# 13.7 数据类型存储要求

> 原文：[`dev.mysql.com/doc/refman/8.0/en/storage-requirements.html`](https://dev.mysql.com/doc/refman/8.0/en/storage-requirements.html)

+   InnoDB 表存储要求

+   NDB 表存储要求

+   数值类型存储要求

+   日期和时间类型存储要求

+   字符串类型存储要求

+   空间类型存储要求

+   JSON 存储要求

磁盘上表数据的存储要求取决于几个因素。不同的存储引擎表示数据类型并以不同方式存储原始数据。表数据可能会被压缩，无论是针对列还是整个行，这会使得计算表或列的存储要求变得复杂。

尽管在磁盘上存储布局存在差异，但内部 MySQL API 用于通信和交换关于表行的信息的数据结构是一致的，适用于所有存储引擎。

本节包括 MySQL 支持的每种数据类型的存储要求的指南和信息，包括对使用固定大小表示数据类型的存储引擎的内部格式和大小的描述。信息按类别或存储引擎列出。

表的内部表示最大行大小为 65,535 字节，即使存储引擎能够支持更大的行也是如此。这个数字不包括`BLOB`或`TEXT`列，这些列只对这个大小贡献了 9 到 12 个字节。对于`BLOB`和`TEXT`数据，信息存储在内存的不同区域中，而不是行缓冲区。不同的存储引擎根据它们用于处理相应类型的方法以不同的方式处理这些数据的分配和存储。有关更多信息，请参见第十八章，*替代存储引擎*和第 10.4.7 节，“表列计数和行大小限制”。

### InnoDB 表存储要求

有关`InnoDB`表的存储要求，请参见第 17.10 节“InnoDB 行格式”。

### NDB 表存储要求

重要提示

`NDB`表使用 4 字节对齐；所有`NDB`数据存储都是 4 字节的倍数。因此，在`NDB`表中，通常需要 15 字节的列值需要 16 字节。例如，在`NDB`表中，`TINYINT`、`SMALLINT`、`MEDIUMINT`和`INTEGER`（`INT`）列类型每个记录需要 4 字节的存储空间，这是由于对齐因素。

每个`BIT(*M*)`列占用*M*位的存储空间。虽然单个`BIT`列不是 4 字节对齐，但是`NDB`每行为`BIT`列的前 1-32 位保留 4 字节（32 位），然后为第 33-64 位保留另外 4 字节，依此类推。

虽然`NULL`本身不需要任何存储空间，但是如果表定义包含允许`NULL`的列，`NDB`每行将保留 4 个字节，最多 32 个`NULL`列。（如果 NDB Cluster 表定义中包含超过 32 个`NULL`列，最多 64 个`NULL`列，则每行将保留 8 个字节。）

每个使用`NDB`存储引擎的表都需要一个主键；如果您没有定义主键，`NDB`将创建一个“隐藏”主键。这个隐藏主键每个表记录消耗 31-35 字节。

您可以使用 **ndb_size.pl** Perl 脚本来估算`NDB`的存储需求。它连接到当前的 MySQL（而不是 NDB Cluster）数据库，并创建一个关于如果该数据库使用`NDB`存储引擎将需要多少空间的报告。有关更多信息，请参见 第 25.5.28 节“ndb_size.pl — NDBCLUSTER Size Requirement Estimator”。

### 数值类型存储需求

| 数据类型 | 所需存储空间 |
| --- | --- |
| `TINYINT` | 1 字节 |
| `SMALLINT` | 2 字节 |
| `MEDIUMINT` | 3 字节 |
| `INT`, `INTEGER` | 4 字节 |
| `BIGINT` | 8 字节 |
| `FLOAT(*`p`*)` | 如果 0 <= *`p`* <= 24，则为 4 字节，如果 25 <= *`p`* <= 53，则为 8 字节 |
| `FLOAT` | 4 字节 |
| `DOUBLE [PRECISION]`, `REAL` | 8 字节 |
| `DECIMAL(*`M`*,*`D`*)`, `NUMERIC(*`M`*,*`D`*)` | 变化；参见下面的讨论 |
| `BIT(*`M`*)` | 大约(*`M`*+7)/8 字节 |
| 数据类型 | 所需存储空间 |

`DECIMAL`（以及`NUMERIC`列使用一种二进制格式表示，将九个十进制（十进制）数字打包成四个字节。每个值的整数部分和小数部分的存储是分开确定的。每个九位数字的倍数需要四个字节，“剩余”数字需要四个字节的一部分。多余数字所需的存储空间由下表给出。

| 剩余数字 | 字节数 |
| --- | --- |
| 0 | 0 |
| 1 | 1 |
| 2 | 1 |
| 3 | 2 |
| 4 | 2 |
| 5 | 3 |
| 6 | 3 |
| 7 | 4 |
| 8 | 4 |

### 日期和时间类型存储需求

对于 `TIME`、`DATETIME` 和 `TIMESTAMP` 列，MySQL 5.6.4 之前创建的表所需的存储空间与从 5.6.4 开始创建的表不同。这是因为 5.6.4 版本的更改允许这些类型具有分数部分，这需要从 0 到 3 个字节。

| 数据类型 | MySQL 5.6.4 之前所需存储空间 | MySQL 5.6.4 及以后所需存储空间 |
| --- | --- | --- |
| `YEAR` | 1 字节 | 1 字节 |
| `DATE` | 3 字节 | 3 字节 |
| `TIME` | 3 字节 | 3 字节 + 分数秒存储 |
| `DATETIME` | 8 字节 | 5 字节 + 分数秒存储 |
| `TIMESTAMP` | 4 字节 | 4 字节 + 分数秒存储 |

截至 MySQL 5.6.4 版本，`YEAR` 和 `DATE` 的存储方式保持不变。然而，`TIME`、`DATETIME` 和 `TIMESTAMP` 的表示方式有所不同。`DATETIME` 被更有效地打包，非分数部分只需 5 个字节，而不是 8 个字节，而且所有三部分都有一个分数部分，根据存储值的分数秒精度，需要从 0 到 3 个字节。

| 分数秒精度 | 所需存储空间 |
| --- | --- |
| 0 | 0 字节 |
| 1, 2 | 1 字节 |
| 3, 4 | 2 字节 |
| 5, 6 | 3 字节 |

例如，`TIME(0)`、`TIME(2)`、`TIME(4)` 和 `TIME(6)` 分别使用 3、4、5 和 6 个字节。`TIME` 和 `TIME(0)` 是等效的，需要相同的存储空间。

有关时间值的内部表示的详细信息，请参阅 MySQL Internals: Important Algorithms and Structures。

### 字符串类型存储要求

在下表中，*`M`*代表非二进制字符串类型的声明列长度（以字符计）和二进制字符串类型的字节数。*`L`*代表给定字符串值的实际字节长度。

| 数据类型 | 所需存储空间 |
| --- | --- |
| `CHAR(*`M`*)` | InnoDB 行格式的紧凑系列优化了变长字符集的存储。请参阅 COMPACT 行格式存储特性。否则，*`M`* × *`w`*字节，`<= *`M`* <=` 255，其中*`w`*是字符集中最大长度字符所需的字节数。 |
| `BINARY(*`M`*)` | *`M`*字节，0 `<= *`M`* <=` 255 |
| `VARCHAR(*`M`*)`, `VARBINARY(*`M`*)` | 如果列值需要 0 − 255 字节，则为*`L`* + 1 字节，如果值可能需要超过 255 字节，则为*`L`* + 2 字节 |
| `TINYBLOB`, `TINYTEXT` | *`L`* + 1 字节，其中*`L`* < 2⁸ |
| `BLOB`, `TEXT` | *`L`* + 2 字节，其中*`L`* < 2¹⁶ |
| `MEDIUMBLOB`, `MEDIUMTEXT` | *`L`* + 3 字节，其中*`L`* < 2²⁴ |
| `LONGBLOB`, `LONGTEXT` | *`L`* + 4 字节，其中*`L`* < 2³² |
| `ENUM('*`value1`*','*`value2`*',...)` | 1 或 2 字节，取决于枚举值的数量（最多 65,535 个值） |
| `SET('*`value1`*','*`value2`*',...)` | 1、2、3、4 或 8 字节，取决于集合成员的数量（最多 64 个成员） |

变长字符串类型使用长度前缀加数据进行存储。长度前缀根据数据类型需要占用一到四个字节不等，前缀的值为*`L`*（字符串的字节长度）。例如，存储`MEDIUMTEXT`值需要*`L`*字节来存储值，再加上三个字节来存储值的长度。

要计算存储特定`CHAR`、`VARCHAR`或`TEXT`列值所需的字节数，必须考虑用于该列的字符集以及值是否包含多字节字符。特别是在使用 UTF-8 Unicode 字符集时，必须记住并非所有字符使用相同数量的字节。`utf8mb3`和`utf8mb4`字符集分别可以每个字符需要最多三个和四个字节。有关不同类别`utf8mb3`或`utf8mb4`字符所使用的存储的详细信息，请参见第 12.9 节“Unicode 支持”。

`VARCHAR`、`VARBINARY`、`BLOB` 和 `TEXT` 类型是可变长度类型。对于每种类型，存储需求取决于以下因素：

+   列值的实际长度

+   列的最大可能长度

+   列使用的字符集，因为某些字符集包含多字节字符

例如，`VARCHAR(255)` 列可以容纳最大长度为 255 个字符的字符串。假设该列使用 `latin1` 字符集（每个字符一个字节），实际所需存储空间是字符串的长度（*`L`*），再加上一个字节来记录字符串的长度。对于字符串 `'abcd'`，*`L`* 为 4，存储需求为五个字节。如果相同列改为使用 `ucs2` 双字节字符集，则存储需求为 10 个字节：`'abcd'` 的长度为八个字节，列需要两个字节来存储长度，因为最大长度大于 255（最多 510 个字节）。

可存储在 `VARCHAR` 或 `VARBINARY` 列中的有效最大 *字节数* 受限于 65,535 字节的最大行大小，该大小在所有列之间共享。对于存储多字节字符的 `VARCHAR` 列，有效最大 *字符数* 较少。例如，`utf8mb4` 字符可能每个字符需要最多四个字节，因此使用 `utf8mb4` 字符集的 `VARCHAR` 列最多可以声明为 16,383 个字符。参见 第 10.4.7 节，“表列数和行大小的限制”。

`InnoDB` 将长度大于或等于 768 个字节的固定长度字段编码为可变长度字段，可以存储在页外。例如，如果 `CHAR(255)` 列的字符集的最大字节长度大于 3，比如 `utf8mb4`，则可以超过 768 个字节。

`NDB` 存储引擎支持可变宽度列。这意味着在 NDB Cluster 表中，`VARCHAR` 列需要与任何其他存储引擎相同的存储空间，唯一的例外是这些值是 4 字节对齐的。因此，在使用 `latin1` 字符集的 `VARCHAR(50)` 列中存储的字符串 `'abcd'` 需要 8 字节（而不是在 `MyISAM` 表中相同列值的 5 字节）。

`TEXT`, `BLOB` 和 `JSON` 列在 `NDB` 存储引擎中实现方式不同，其中列中的每一行由两个独立部分组成。其中一个是固定大小的（`TEXT` 和 `BLOB` 为 256 字节，`JSON` 为 4000 字节），实际上存储在原始表中。另一个部分包含超过 256 字节的任何数据，存储在隐藏的 blob 部分表中。第二个表中行的大小由列的确切类型确定，如下表所示：

| 类型 | Blob 部分大小 |
| --- | --- |
| `BLOB`, `TEXT` | 2000 |
| `MEDIUMBLOB`, `MEDIUMTEXT` | 4000 |
| `LONGBLOB`, `LONGTEXT` | 13948 |
| `JSON` | 8100 |

这意味着如果 *`size`* <= 256（其中 *`size`* 表示行的大小），则 `TEXT` 列的大小为 256；否则，大小为 256 + *`size`* + (2000 × (*`size`* − 256) % 2000)。

`NDB` 不会为 `TINYBLOB` 或 `TINYTEXT` 列值单独存储 blob 部分。

可以使用 `NDB_COLUMN` 在创建或更改父表时在列注释中将 `NDB` blob 列的 blob 部分大小增加到最大值 13948。在 NDB 8.0.30 及更高版本中，还可以使用 `NDB_TABLE` 在列注释中设置 `TEXT`、`BLOB` 或 `JSON` 列的内联大小。有关更多信息，请参见 NDB_COLUMN 选项。

`ENUM` 对象的大小由不同枚举值的数量确定。对于最多有 255 个可能值的枚举，使用一个字节。对于具有 256 到 65,535 个可能值的枚举，使用两个字节。请参见 第 13.3.5 节，“ENUM 类型”。

`SET` 对象的大小由不同集合成员的数量确定。如果集合大小为 *`N`*，则对象占用 `(*`N`*+7)/8` 字节，向上取整为 1、2、3、4 或 8 字节。`SET` 最多可以有 64 个成员。请参见 第 13.3.6 节，“SET 类型”。

### 空间类型存储要求

MySQL 使用 4 个字节来存储几何值的 SRID，后跟值的 WKB 表示。`LENGTH()` 函数返回存储值所需的字节空间。

有关空间值的 WKB 和内部存储格式的描述，请参阅第 13.4.3 节，“支持的空间数据格式”。

### JSON 存储需求

一般来说，`JSON` 列的存储需求大致与 `LONGBLOB` 或 `LONGTEXT` 列相同；也就是说，JSON 文档所占用的空间大致与存储在这些类型列中的文档的字符串表示相同。然而，由于存储在 JSON 文档中的各个值的二进制编码，包括用于查找的元数据和字典，会带来一些额外开销。例如，存储在 JSON 文档中的字符串需要额外的 4 到 10 字节的存储空间，取决于字符串的长度以及存储它的对象或数组的大小。

此外，MySQL 对存储在 `JSON` 列中的任何 JSON 文档的大小施加了限制，使其不能大于 `max_allowed_packet` 的值。
