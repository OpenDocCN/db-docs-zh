# 26.1 MySQL 中分区的概述

> 译文：[`dev.mysql.com/doc/refman/8.0/en/partitioning-overview.html`](https://dev.mysql.com/doc/refman/8.0/en/partitioning-overview.html)

本节提供了 MySQL 8.0 中分区的概念概述。

有关分区限制和功能限制的信息，请参见 第 26.6 节，“分区的限制和限制”。

SQL 标准在数据存储的物理方面并没有提供太多指导。SQL 语言本身旨在独立于其所使用的模式、表、行或列的任何数据结构或媒体而工作。尽管如此，大多数先进的数据库管理系统已经发展出一些确定特定数据存储的物理位置的方法，涉及文件系统、硬件甚至两者。在 MySQL 中，`InnoDB` 存储引擎长期以来一直支持表空间的概念（参见 第 17.6.3 节，“表空间”），即使在引入分区之前，MySQL 服务器也可以配置为使用不同的物理目录来存储不同的数据库（参见 第 10.12.2 节，“使用符号链接”，了解如何实现）。

分区通过使您能够根据您基本上可以根据需要设置的规则将个别表的部分分布到文件系统中，进一步发展了这一概念。实际上，表的不同部分以不同位置的单独表的形式存储。用户选择的数据划分规则称为分区函数，在 MySQL 中可以是模数、简单匹配一组范围或值列表、内部哈希函数或线性哈希函数。该函数根据用户指定的分区类型进行选择，并将用户提供的表达式的值作为其参数。该表达式可以是列值、作用于一个或多个列值的函数，或一个或多个列值的集合，具体取决于所使用的分区类型。

对于 `RANGE`、`LIST` 和 [`LINEAR`] `HASH` 分区，分区列的值将传递给分区函数，该函数返回表示应将该特定记录存储在哪个分区中的整数值。该函数必须是非常量且非随机的。它不能包含任何查询，但可以使用在 MySQL 中有效的 SQL 表达式，只要该表达式返回 `NULL` 或整数 *`intval`*，使得

```sql
-MAXVALUE <= *intval* <= MAXVALUE
```

（`MAXVALUE` 用于表示所讨论整数类型的最小上界。`-MAXVALUE` 表示最大下界。）

对于[`LINEAR`] `KEY`、`RANGE COLUMNS`和`LIST COLUMNS`分区，分区表达式由一个或多个列的列表组成。

对于[`LINEAR`] `KEY`分区，分区函数由 MySQL 提供。

有关允许的分区列类型和分区函数的更多信息，请参见第 26.2 节“分区类型”，以及提供分区语法描述和其他示例的第 15.1.20 节“CREATE TABLE 语句”。有关分区函数的限制信息，请参见第 26.6.3 节“与函数相关的分区限制”。

这被称为水平分区，即表的不同行可以分配给不同的物理分区。MySQL 8.0 不支持垂直分区，即表的不同列分配给不同的物理分区。目前没有计划将垂直分区引入 MySQL 中。

要创建分区表，必须使用支持它们的存储引擎。在 MySQL 8.0 中，同一分区表的所有分区必须使用相同的存储引擎。但是，没有任何阻止您在同一 MySQL 服务器上或甚至在同一数据库中为不同的分区表使用不同的存储引擎。

在 MySQL 8.0 中，仅支持分区的存储引擎是`InnoDB`和`NDB`。不能与不支持分区的存储引擎一起使用分区；这些包括`MyISAM`、`MERGE`、`CSV`和`FEDERATED`存储引擎。

使用`NDB`进行`KEY`或`LINEAR KEY`分区是可能的，但不支持使用其他类型的用户定义分区的表使用此存储引擎。此外，使用用户定义分区的`NDB`表必须具有显式主键，并且表的分区表达式中引用的任何列必须是主键的一部分。但是，如果在用于创建或修改用户分区的`NDB`表的`PARTITION BY KEY`或`PARTITION BY LINEAR KEY`子句中未列出任何列，则不需要该表具有显式主键。有关更多信息，请参见第 25.2.7.1 节“NDB Cluster 中的 SQL 语法不兼容”。

创建分区表时，默认使用与创建任何其他表时相同的存储引擎；要覆盖此行为，只需像为非分区表一样使用`[STORAGE] ENGINE`选项即可。目标存储引擎必须提供本机分区支持，否则语句将失败。需要记住，在`CREATE TABLE`语句中使用任何分区选项之前，需要将`[STORAGE] ENGINE`（以及其他表选项）列在*之前*。此示例显示了如何创建一个表，该表按哈希分区为 6 个分区，并使用`InnoDB`存储引擎（不管`default_storage_engine`的值是什么）：

```sql
CREATE TABLE ti (id INT, amount DECIMAL(7,2), tr_date DATE)
    ENGINE=INNODB
    PARTITION BY HASH( MONTH(tr_date) )
    PARTITIONS 6;
```

每个`PARTITION`子句可以包括一个`[STORAGE] ENGINE`选项，但在 MySQL 8.0 中，这没有任何效果。

除非另有说明，在本讨论中的其余示例假定`default_storage_engine`为`InnoDB`。

重要提示

分区适用于表的所有数据和索引；您不能仅对数据进行分区而不对索引进行分区，反之亦然，也不能仅对表的一部分进行分区。

每个分区的数据和索引可以使用`DATA DIRECTORY`和`INDEX DIRECTORY`选项分配到特定目录，这些选项是用于创建分区表的`CREATE TABLE`语句的`PARTITION`子句。

仅支持`InnoDB`表的各个分区和子分区的`DATA DIRECTORY`选项。截至 MySQL 8.0.21，`DATA DIRECTORY`子句中指定的目录必须为`InnoDB`所知。有关更多信息，请参阅使用 DATA DIRECTORY 子句。

表的分区表达式中使用的所有列必须是表可能具有的每个唯一键的一部分，包括任何主键。这意味着通过以下 SQL 语句创建的这样一个表不能进行分区：

```sql
CREATE TABLE tnp (
    id INT NOT NULL AUTO_INCREMENT,
    ref BIGINT NOT NULL,
    name VARCHAR(255),
    PRIMARY KEY pk (id),
    UNIQUE KEY uk (name)
);
```

因为`pk`和`uk`键没有共同的列，所以没有列可用于分区表达式。在这种情况下的可能解决方法包括将`name`列添加到表的主键中，将`id`列添加到`uk`中，或者简单地完全删除唯一键。有关更多信息，请参阅第 26.6.1 节，“分区键、主键和唯一键”。

此外，`MAX_ROWS`和`MIN_ROWS`可用于确定每个分区中可以存储的最大和最小行数。有关这些选项的更多信息，请参阅第 26.3 节“分区管理”。

`MAX_ROWS`选项还可用于创建具有额外分区的 NDB Cluster 表，从而允许更大的哈希索引存储。有关`DataMemory`数据节点配置参数的文档，以及更多信息，请参阅第 25.2.2 节“NDB Cluster 节点、节点组、片段副本和分区”。

分区的一些优点列在这里：

+   分区使得可以在一个表中存储比单个磁盘或文件系统分区能够容纳的更多数据。

+   数据如果失去了其用处，通常可以通过删除仅包含该数据的分区（或分区）来轻松地从分区表中删除。相反，通过为存储特定数据添加一个或多个新分区，在某些情况下可以极大地促进添加新数据的过程。

+   由于满足给定`WHERE`子句的数据只能存储在一个或多个分区中，因此某些查询可以在很大程度上进行优化，自动排除搜索中的任何剩余分区。由于分区表创建后可以更改分区，因此您可以重新组织数据以增强在设置分区方案时可能未经常使用的频繁查询。排除非匹配分区（以及它们包含的任何行）的能力通常被称为分区修剪。有关更多信息，请参阅第 26.4 节“分区修剪”。

    此外，MySQL 支持对查询进行显式分区选择。例如，`SELECT * FROM t PARTITION (p0,p1) WHERE c < 5` 仅选择与`WHERE`条件匹配的`p0`和`p1`分区中的行。在这种情况下，MySQL 不会检查表`t`的其他分区；当您已经知道要检查哪个分区或哪些分区时，这可以极大地加快查询速度。分区选择也支持数据修改语句`DELETE`、`INSERT`、`REPLACE`、`UPDATE`和`LOAD DATA`、`LOAD XML`。有关这些语句的更多信息和示例，请参阅这些语句的描述。
