> 原文：[`dev.mysql.com/doc/refman/8.0/en/replication-sbr-rbr.html`](https://dev.mysql.com/doc/refman/8.0/en/replication-sbr-rbr.html)

#### 19.2.1.1 基于语句和基于行的复制的优缺点

每种二进制日志格式都有其优缺点。对于大多数用户来说，混合复制格式应该提供最佳的数据完整性和性能组合。然而，如果您想在执行某些任务时利用基于语句或基于行的复制格式的特定功能，您可以使用本节中提供的信息，该信息提供了它们相对优缺点的摘要，以确定哪种最适合您的需求。

+   基于语句的复制的优点

+   基于语句的复制的缺点

+   基于行的复制的优点

+   基于行的复制的缺点

##### 基于语句的复制的优点

+   已验证的技术。

+   写入日志文件的数据较少。当更新或删除影响许多行时，这导致日志文件所需的存储空间*大大*减少。这也意味着可以更快地进行备份和恢复操作。

+   日志文件包含所有进行任何更改的语句，因此可以用于审计数据库。

##### 基于语句的复制的缺点

+   **不适用于基于语句的不安全语句。** 并非所有修改数据的语句（例如`INSERT` `DELETE`, `UPDATE`, 和 `REPLACE` 语句）都可以使用基于语句的复制进行复制。任何非确定性行为在使用基于语句的复制时很难复制。此类数据修改语言（DML）语句的示例包括以下内容：

    +   依赖于不确定性的可加载函数或存储程序的语句，因为这些函数或存储程序返回的值取决于除提供给它的参数之外的因素。 （然而，基于行的复制只是复制函数或存储程序返回的值，因此其对表行和数据的影响在源和副本上是相同的。）有关更多信息，请参见第 19.5.1.16 节，“调用特性的复制”。

    +   使用 `LIMIT` 子句而没有 `ORDER BY` 的 `DELETE` 和 `UPDATE` 语句是不确定的。参见 Section 19.5.1.18, “Replication and LIMIT”.

    +   锁定读取语句（`SELECT ... FOR UPDATE` 和 `SELECT ... FOR SHARE`）使用 `NOWAIT` 或 `SKIP LOCKED` 选项。参见 Locking Read Concurrency with NOWAIT and SKIP LOCKED.

    +   确定性可加载函数必须在副本上应用。

    +   使用以下任何函数的语句无法使用基于语句的复制正确复制：

        +   `LOAD_FILE()`

        +   `UUID()`, `UUID_SHORT()`

        +   `USER()`

        +   `FOUND_ROWS()`

        +   `SYSDATE()`（除非源和副本都使用 `--sysdate-is-now` 选项启动）

        +   `GET_LOCK()`

        +   `IS_FREE_LOCK()`

        +   `IS_USED_LOCK()`

        +   `MASTER_POS_WAIT()`

        +   `RAND()`

        +   `RELEASE_LOCK()`

        +   `SOURCE_POS_WAIT()`

        +   `SLEEP()`

        +   `VERSION()`

        然而，所有其他函数都可以使用基于语句的复制正确复制，包括 `NOW()` 等等。

        更多信息，请参见 Section 19.5.1.14, “Replication and System Functions”.

    无法使用基于语句的复制正确复制的语句将记录警告，如下所示：

    ```sql
    [Warning] Statement is not safe to log in statement format.
    ```

    在这种情况下，客户端也会收到类似的警告。客户端可以使用 `SHOW WARNINGS` 显示它。

+   `INSERT ... SELECT` 需要比基于行的复制更多的行级锁。

+   `UPDATE` 语句需要进行表扫描（因为 `WHERE` 子句中未使用索引），必须锁定比基于行的复制更多的行。

+   对于`InnoDB`：使用`AUTO_INCREMENT`的`INSERT`语句会阻塞其他不冲突的`INSERT`语句。

+   对于复杂语句，必须在副本上评估和执行语句，然后更新或插入行。使用基于行的复制，副本只需修改受影响的行，而不执行完整语句。

+   如果在副本上评估时出现错误，特别是在执行复杂语句时，基于语句的复制可能会随着时间逐渐增加受影响行的错误边界。请参见第 19.5.1.29 节，“复制期间的副本错误”。

+   存储函数执行与调用语句相同的`NOW()`值。但是，存储过程不是这样的。

+   确定性可加载函数必须应用于副本。

+   表定义在源和副本上必须（几乎）完全相同。有关更多信息，请参见第 19.5.1.9 节，“源和副本上具有不同表定义的复制”。

+   从 MySQL 8.0.22 开始，从 MySQL 授予表中读取数据（通过连接列表或子查询）但不修改它们的 DML 操作将作为非锁定读取执行，并因此不适用于基于语句的复制。有关更多信息，请参见授予表并发性。

##### 行级复制的优势

+   所有更改都可以复制。这是最安全的复制形式。

    注意

    更新`mysql`系统模式中的信息的语句，例如`GRANT`、`REVOKE`以及触发器、存储过程（包括存储过程）和视图的操作，都使用基于语句的复制复制到副本。

    对于诸如`CREATE TABLE ... SELECT`之类的语句，从表定义生成`CREATE`语句，并使用基于语句的格式进行复制，而行插入则使用基于行的格式进行复制。

+   源上需要更少的行锁，从而实现更高的并发性，适用于以下类型的语句：

    +   `INSERT ... SELECT`

    +   带有`AUTO_INCREMENT`的`INSERT`语句

    +   带有不使用键或不更改大部分检查行的`WHERE`子句的`UPDATE`或`DELETE`语句。

+   在复制品上，对于任何`INSERT`、`UPDATE`或`DELETE`语句，需要更少的行锁。

##### 基于行的复制的缺点

+   RBR 可以生成更多必须记录的数据。要复制一个 DML 语句（例如`UPDATE`或`DELETE`语句），基于语句的复制仅将语句写入二进制日志。相比之下，基于行的复制将每个更改的行写入二进制日志。如果语句更改了许多行，基于行的复制可能会向二进制日志写入大量数据；即使对语句进行了回滚也是如此。这还意味着制作和恢复备份可能需要更多时间。此外，为了写入数据，二进制日志的锁定时间更长，这可能会导致并发问题。使用`binlog_row_image=minimal`可以大大减少这种劣势。

+   生成大型`BLOB`值的确定性可加载函数在基于行的复制中复制所需的时间比基于语句的复制长。这是因为记录了`BLOB`列值，而不是生成数据的语句。

+   在复制品上，您无法看到从源接收并执行的语句。但是，您可以使用**mysqlbinlog**和选项`--base64-output=DECODE-ROWS`以及`--verbose`查看哪些数据发生了变化。

    或者，使用`binlog_rows_query_log_events`变量，如果启用，则在使用`-vv`选项时，向**mysqlbinlog**输出中添加一个`Rows_query`事件与语句。

+   对于使用`MyISAM`存储引擎的表，在将它们作为基于行的事件应用到二进制日志时，对于`INSERT`语句，复制品上需要更强的锁定，而不是将它们作为语句应用。这意味着在使用基于行的复制时，不支持对`MyISAM`表的并发插入。
