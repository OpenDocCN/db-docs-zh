> 原文：[`dev.mysql.com/doc/refman/8.0/en/memory-use.html`](https://dev.mysql.com/doc/refman/8.0/en/memory-use.html)

#### 10.12.3.1 MySQL 如何使用内存

MySQL 分配缓冲区和缓存以提高数据库操作的性能。默认配置旨在允许 MySQL 服务器在具有大约 512MB RAM 的虚拟机上启动。您可以通过增加某些与缓存和缓冲区相关的系统变量的值来提高 MySQL 的性能。您还可以修改默认配置以在内存有限的系统上运行 MySQL。

以下列表描述了 MySQL 使用内存的一些方式。在适用的情况下，引用了相关的系统变量。一些项目是存储引擎或特定功能。

+   `InnoDB`缓冲池是一个保存用于表、索引和其他辅助缓冲区的缓存`InnoDB`数据的内存区域。为了提高高容量读操作的效率，缓冲池被划分为页，这些页可能可以容纳多行。为了提高缓存管理的效率，缓冲池被实现为页的链表；很少使用的数据会根据 Lru 算法的变体从缓存中淘汰。更多信息，请参见第 17.5.1 节，“缓冲池”。

    缓冲池的大小对系统性能很重要：

    +   `InnoDB`在服务器启动时为整个缓冲池分配内存，使用`malloc()`操作。`innodb_buffer_pool_size`系统变量定义了缓冲池的大小。通常，推荐的`innodb_buffer_pool_size`值为系统内存的 50 到 75%。`innodb_buffer_pool_size`可以在服务器运行时动态配置。更多信息，请参见第 17.8.3.1 节，“配置 InnoDB 缓冲池大小”。

    +   在具有大量内存的系统上，可以通过将缓冲池划分为多个缓冲池实例来提高并发性。`innodb_buffer_pool_instances`系统变量定义了缓冲池实例的数量。

    +   过小的缓冲池可能会导致过多的翻转，因为页面从缓冲池刷新出来，只是在短时间后再次需要。

    +   过大的缓冲池可能会导致由于内存竞争而发生交换。

+   存储引擎接口使优化器能够提供关于要用于估计可能读取多行的扫描的记录缓冲区大小的信息。缓冲区大小可以根据估计的大小变化。`InnoDB`使用这种可变大小的缓冲能力来利用行预取，并减少锁定和 B 树导航的开销。

+   所有线程共享`MyISAM`关键缓冲区。`key_buffer_size`系统变量确定其大小。

    对于每个`MyISAM`表，服务器打开一次索引文件；对于每个同时运行访问该表的线程，数据文件会被打开一次。对于每个并发线程，都会分配一个表结构，每个列的列结构，以及大小为`3 * *`N`*`的缓冲区（其中*`N`*是最大行长度，不包括`BLOB`列）。一个`BLOB`列需要五到八个字节加上`BLOB`数据的长度。`MyISAM`存储引擎为内部使用维护了一个额外的行缓冲区。

+   `myisam_use_mmap`系统变量可以设置为 1，以启用所有`MyISAM`表的内存映射。

+   如果一个内部内存临时表变得太大（根据`tmp_table_size`和`max_heap_table_size`系统变量确定），MySQL 会自动将表从内存转换为磁盘格式。从 MySQL 8.0.16 开始，磁盘临时表总是使用`InnoDB`存储引擎。（以前，用于此目的的存储引擎是由`internal_tmp_disk_storage_engine`系统变量确定的，该变量不再受支持。）您可以按照第 10.4.4 节，“MySQL 中的内部临时表使用”中描述的方式增加临时表的大小。

    对于使用`CREATE TABLE`显式创建的`MEMORY`表，只有`max_heap_table_size`系统变量确定表可以增长多大，而且不会转换为磁盘格式。

+   MySQL 性能模式是一个用于监视 MySQL 服务器在低级别执行的功能。性能模式动态地逐步分配内存，根据实际服务器负载来调整内存使用，而不是在服务器启动期间分配所需内存。一旦分配了内存，直到服务器重新启动之前都不会释放。更多信息，请参阅第 29.17 节，“性能模式内存分配模型”。

+   服务器用于管理客户端连接的每个线程都需要一些特定于线程的空间。以下列表指示了这些空间以及控制它们大小的系统变量：

    +   一个堆栈（`thread_stack`）

    +   一个连接缓冲区（`net_buffer_length`）

    +   一个结果缓冲区（`net_buffer_length`)

    连接缓冲区和结果缓冲区的初始大小均为`net_buffer_length`字节，但根据需要动态扩大至`max_allowed_packet`字节。每个 SQL 语句执行完毕后，结果缓冲区会缩小至`net_buffer_length`字节。在语句运行时，当前语句字符串的副本也会被分配。

    每个连接线程使用内存来计算语句摘要。服务器为每个会话分配`max_digest_length`字节。请参阅第 29.10 节，“性能模式语句摘要和采样”。

+   所有线程共享相同的基本内存。

+   当不再需要一个线程时，分配给它的内存会被释放并返回给系统，除非线程重新进入线程缓存。在这种情况下，内存仍然保持分配状态。

+   每个执行表的顺序扫描的请求都会分配一个读取缓冲区。`read_buffer_size`系统变量确定了缓冲区的大小。

+   在以任意顺序读取行（例如，遵循排序）时，可能会分配一个随机读取缓冲区以避免磁盘查找。`read_rnd_buffer_size`系统变量确定了���冲区的大小。

+   所有连接都在单次执行中执行，大多数连接甚至可以在不使用临时表的情况下完成。大多数临时表都是基于内存的哈希表。具有大行长度（计算为所有列长度之和）或包含`BLOB`列的临时表存储在磁盘上。

+   大多数执行排序操作的请求会分配一个排序缓冲区，并根据结果集大小分配零到两个临时文件。请参阅 Section B.3.3.5, “Where MySQL Stores Temporary Files”。

+   几乎所有的解析和计算都是在线程本地和可重用的内存池中完成的。对于小项目，不需要额外的内存开销，从而避免了常规的缓慢内存分配和释放。只有对于异常大的字符串才会分配内存。

+   对于每个具有`BLOB`列的表，缓冲区会动态扩大以读取更大的`BLOB`值。如果扫描一个表，缓冲区会增长到最大的`BLOB`值的大小。

+   MySQL 需要为表缓存分配内存和描述符。所有正在使用的表的处理程序结构保存在表缓存中，并按照“先进先出”（FIFO）的方式进行管理。`table_open_cache`系统变量定义了初始表缓存大小；请参阅 Section 10.4.3.1, “How MySQL Opens and Closes Tables”。

    MySQL 还需要为表定义缓存分配内存。`table_definition_cache`系统变量定义了可以存储在表定义缓存中的表定义数量。如果使用大量表，可以创建一个大的表定义缓存以加快表的打开速度。表定义缓存占用的空间较小，不使用文件描述符，与表缓存不同。

+   一个`FLUSH TABLES`语句或**mysqladmin flush-tables**命令会立即关闭所有未使用的表，并标记所有正在使用的表在当前执行线程完成时关闭。这有效地释放了大部分正在使用的内存。`FLUSH TABLES`在所有表关闭后才会返回。

+   服务器会因为`GRANT`、`CREATE USER`、`CREATE SERVER`和`INSTALL PLUGIN`语句而在内存中缓存信息。这些内存不会被相应的`REVOKE`、`DROP USER`、`DROP SERVER`和`UNINSTALL PLUGIN`语句释放，因此对于执行许多导致缓存的语句实例的服务器，除非使用`FLUSH PRIVILEGES`释放，否则缓存内存使用量会增加。

+   在复制拓扑中，以下设置会影响内存使用，并可以根据需要进行调整：

    +   复制源上的`max_allowed_packet`系统变量限制源发送给其复制品进行处理的最大消息大小。此设置默认为 64M。

    +   多线程复制品上的`replica_pending_jobs_size_max`（从 MySQL 8.0.26 开始）或 MySQL 8.0.26 之前的`slave_pending_jobs_size_max`系统变量设置用于保存等待处理消息的最大内存量。此设置默认为 128M。只有在需要时才分配内存，但如果您的复制拓扑有时处理大事务，则可能会使用它。这是一个软限制，可以处理更大的事务。

    +   复制源或复制品上的`rpl_read_size`系统变量控制从二进制日志文件和中继日志文件中读取的最小数据量（以字节为单位）。默认值为 8192 字节。为从二进制日志和中继日志文件中读取数据的每个线程分配了与此值大小相同的缓冲区，包括源上的转储线程和复制品上的协调器线程。

    +   `binlog_transaction_dependency_history_size`系统变量限制保存在内存中的行哈希数量。

    +   `max_binlog_cache_size`系统变量指定单个事务的内存使用上限。

    +   `max_binlog_stmt_cache_size`系统变量指定语句缓存的内存使用上限。

**ps** 和其他系统状态程序可能会报告说**mysqld**使用了大量内存。这可能是由于不同内存地址上的线程堆栈导致的。例如，Solaris 版本的 **ps** 将堆栈之间未使用的内存计算为已使用内存。要验证这一点，请使用 `swap -s` 检查可用交换空间。我们使用了几种内存泄漏检测工具来测试**mysqld**（包括商业和开源的），因此不应该有内存泄漏。
