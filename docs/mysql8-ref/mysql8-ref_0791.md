# 14.3 表达式求值中的类型转换

> 原文：[`dev.mysql.com/doc/refman/8.0/en/type-conversion.html`](https://dev.mysql.com/doc/refman/8.0/en/type-conversion.html)

当使用具有不同类型操作数的运算符时，会发生类型转换以使操作数兼容。一些转换会隐式发生。例如，MySQL 会根据需要自动将字符串转换为数字，反之亦然。

```sql
mysql> SELECT 1+'1';
 -> 2
mysql> SELECT CONCAT(2,' test');
 -> '2 test'
```

也可以使用`CAST()`函数将数字显式转换为字符串。使用`CONCAT()`函数时会隐式进行转换，因为它期望字符串参数。

```sql
mysql> SELECT 38.8, CAST(38.8 AS CHAR);
 -> 38.8, '38.8'
mysql> SELECT 38.8, CONCAT(38.8);
 -> 38.8, '38.8'
```

请参阅本节后面有关隐式数字到字符串转换的字符集信息，以及适用于`CREATE TABLE ... SELECT`语句的修改规则。

以下规则描述了比较操作的转换方式：

+   如果一个或两个参数为`NULL`，则比较的结果为`NULL`，除了`NULL`安全的`<=>`等于比较运算符。对于`NULL <=> NULL`，结果为真。不需要转换。

+   如果比较操作中的两个参数都是字符串，则将它们作为字符串进行比较。

+   如果两个参数都是整数，则将它们作为整数进行比较。

+   如果十六进制值与数字进行比较，则将其视为二进制字符串。

+   如果其中一个参数是`TIMESTAMP`或`DATETIME`列，另一个参数是常量，则在执行比较之前将常量转换为时间戳。这样做是为了更符合 ODBC 标准。但对于`IN()`的参数不会执行此操作。为了安全起见，在进行比较时，始终使用完整的日期、日期或时间字符串。例如，当使用`BETWEEN`与日期或时间值时，使用`CAST()`将值显式转换为所需的数据类型以获得最佳结果。

    来自表或表的单行子查询不被视为常量。例如，如果子查询返回一个整数用于与`DATETIME`值进行比较，则比较将作为两个整数进行。整数不会转换为时间值。要将操作数作为`DATETIME`值进行比较，请使用`CAST()`将子查询值显式转换为`DATETIME`。

+   如果其中一个参数是十进制值，则比较取决于另一个参数。如果另一个参数是十进制或整数值，则将参数作为十进制值进行比较，如果另一个参数是浮点值，则将参数作为浮点值进行比较。

+   在所有其他情况下，参数将作为浮点（双精度）数进行比较。例如，字符串和数字操作数的比较将作为浮点数的比较进行。

有关从一种时间类型转换为另一种时间类型的值的转换信息，请参见第 13.2.8 节，“日期和时间类型之间的转换”。

JSON 值的比较分为两个级别。第一级别的比较基于比较值的 JSON 类型。如果类型不同，则比较结果仅由具有更高优先级的类型确定。如果两个值具有相同的 JSON 类型，则使用特定于类型的规则进行第二级别的比较。对于 JSON 和非 JSON 值的比较，将非 JSON 值转换为 JSON，然后将值作为 JSON 值进行比较。有关详细信息，请参见 JSON 值的比较和排序。

以下示例说明了将字符串转换为数字进行比较操作：

```sql
mysql> SELECT 1 > '6x';
 -> 0
mysql> SELECT 7 > '6x';
 -> 1
mysql> SELECT 0 > 'x6';
 -> 0
mysql> SELECT 0 = 'x6';
 -> 1
```

对于字符串列与数字的比较，MySQL 无法使用列上的索引快速查找值。如果*`str_col`*是一个带索引的字符串列，在执行以下语句中进行查找时，索引将无法使用：

```sql
SELECT * FROM *tbl_name* WHERE *str_col*=1;
```

这是因为有许多不同的字符串可能转换为值`1`，比如`'1'`，`' 1'`或`'1a'`。

浮点数和大整数类型的比较是近似的，因为在比较之前整数被转换为双精度浮点数，而双精度浮点数无法精确表示所有 64 位整数。例如，整数值 2⁵³ + 1 无法表示为浮点数，在浮点比较之前会被四舍五入为 2⁵³或 2⁵³ + 2，具体取决于平台。

仅以以下比较中的第一个比较相等的值，但两个比较都返回 true（1）：

```sql
mysql> SELECT '9223372036854775807' = 9223372036854775807;
 -> 1
mysql> SELECT '9223372036854775807' = 9223372036854775806;
 -> 1
```

当从字符串到浮点数和从整数到浮点数的转换发生时，它们不一定以相同的方式发生。整数可能由 CPU 转换为浮点数，而字符串则通过涉及浮点数乘法的操作逐位转换。此外，结果可能受到诸如计算机架构、编译器版本或优化级别等因素的影响。避免此类问题的一种方法是使用`CAST()`以便值不会隐式转换为浮点数：

```sql
mysql> SELECT CAST('9223372036854775807' AS UNSIGNED) = 9223372036854775806;
 -> 0
```

有关浮点比较的更多信息，请参见第 B.3.4.8 节，“浮点值的问题”。

服务器包含`dtoa`，一个转换库，提供了在字符串或`DECIMAL` - DECIMAL, NUMERIC")值和近似值（`FLOAT` - FLOAT, DOUBLE")/`DOUBLE` - FLOAT, DOUBLE")）之间改进转换的基础：

+   跨平台的一致转换结果，消除了 Unix 与 Windows 转换差异，例如。

+   在以前结果未提供足够精度的情况下准确表示值，例如接近 IEEE 极限的值。

+   将数字转换为具有最佳可能精度的字符串格式。`dtoa`的精度始终与标准 C 库函数相同或更好。

由于此库产生的转换在某些情况下与非`dtoa`结果不同，因此存在应用程序不兼容的潜在可能性，这些应用程序依赖于以前的结果。例如，依赖于以前转换的特定精确结果的应用程序可能需要调整以适应额外的精度。

`dtoa`库提供了以下属性的转换。*`D`* 表示具有`DECIMAL` - DECIMAL, NUMERIC")或字符串表示的值，*`F`* 表示本机二进制（IEEE）格式的浮点数。

+   *`F`* -> *`D`* 转换是以最佳可能精度进行的，返回 *`D`* 作为最短字符串，当读回并按 IEEE 指定的本机二进制格式四舍五入到最接近的值时，会产生 *`F`*。

+   *`D`* -> *`F`* 转换是这样进行的，使得 *`F`* 是输入十进制字符串 *`D`* 最接近的本机二进制数。

这些属性意味着 *`F`* -> *`D`* -> *`F`* 转换是无损失的，除非 *`F`* 是 `-inf`，`+inf` 或 `NaN`。后三个值不受支持，因为 SQL 标准将它们定义为`FLOAT` - FLOAT, DOUBLE")或`DOUBLE` - FLOAT, DOUBLE")的无效值。

对于 *`D`* -> *`F`* -> *`D`* 转换，无损失的一个充分条件是 *`D`* 使用 15 位或更少的精度，不是非规格化值，也不是 `-inf`，`+inf` 或 `NaN`。在某些情况下，即使 *`D`* 的精度超过 15 位，转换也是无损失的，但并非总是如此。

将数值或时间值隐式转换为字符串会产生一个具有由`character_set_connection`和`collation_connection`系统变量确定的字符集和排序规则的值。（这些变量通常使用`SET NAMES`设置。有关连接字符集的信息，请参见第 12.4 节，“连接字符集和排序规则”。）

这意味着这样的转换会产生一个字符（非二进制）字符串（一个`CHAR`、`VARCHAR`或`LONGTEXT`值），除非连接字符集设置为`binary`。在这种情况下，转换结果是一个二进制字符串（一个`BINARY`、`VARBINARY`或`LONGBLOB`值）。

对于整数表达式，关于表达式*评估*的前述备注在表达式*赋值*方面有所不同；例如，在这样的语句中：

```sql
CREATE TABLE t SELECT *integer_expr*;
```

在这种情况下，由表达式生成的列中的表具有`INT` - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT")或`BIGINT` - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT")类型，具体取决于整数表达式的长度。如果表达式的最大长度不适合`INT` - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT")，则改用`BIGINT` - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT")。长度取自`SELECT`结果集元数据的`max_length`值（参见 C API 基本数据结构）。这意味着您可以通过使用足够长的表达式来强制使用`BIGINT` - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT")而不是`INT` - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT")：

```sql
CREATE TABLE t SELECT 000000000000000000000;
```
