# 15.5.1 准备语句

> 原文：[`dev.mysql.com/doc/refman/8.0/en/prepare.html`](https://dev.mysql.com/doc/refman/8.0/en/prepare.html)

```sql
PREPARE *stmt_name* FROM *preparable_stmt*
```

`PREPARE`语句准备一个 SQL 语句，并分配一个名称*`stmt_name`*，以便以后引用该语句。准备好的语句通过`EXECUTE`执行，并通过`DEALLOCATE PREPARE`释放。有关示例，请参见第 15.5 节，“准备语句”。

语句名称不区分大小写。*`preparable_stmt`*可以是字符串文字或包含 SQL 语句文本的用户变量。文本必须表示单个语句，而不是多个语句。在语句内部，`?`字符可用作参数标记，指示稍后在执行时要将数据值绑定到查询的位置。`?`字符不应该被引号括起，即使您打算将它们绑定到字符串值。参数标记只能用于数据值应出现的地方，而不能用于 SQL 关键字、标识符等。

如果具有给定名称的准备语句已经存在，则在准备新语句之前会隐式释放它。这意味着如果新语句包含错误且无法准备，则会返回错误，并且不存在具有给定名称的语句。

准备语句的范围是创建它的会话，这有几个含义：

+   在一个会话中创建的准备语句对其他会话不可用。

+   当会话结束时，无论是正常结束还是异常结束，其准备的语句都不再存在。如果启用了自动重新连接，则客户端不会收到连接丢失的通知。因此，客户端可能希望禁用自动重新连接。请参见自动重新连接控制。

+   在存储程序中创建的准备语句在程序执行完成后继续存在，并且可以在程序外部稍后执行。

+   在存储程序上下文中准备的语句不能引用存储过程或函数参数或局部变量，因为它们在程序结束时超出范围，如果稍后在程序外执行该语句，则将无法使用。作为解决方法，可以引用会话范围的用户定义变量，参见第 11.4 节，“用户定义变量”。

从 MySQL 8.0.22 开始，用于准备语句的参数在语句首次准备时确定其类型，并且在为该准备语句调用`EXECUTE`时保留此类型（除非语句被重新准备，如本节后面所述）。确定参数类型的规则如下：

+   作为二元算术运算符的操作数的参数具有与另一个操作数相同的数据类型。

+   如果二元算术运算符的两个操作数都是参数，则参数的类型由运算符的上下文决定。

+   如果参数是一元算术运算符的操作数，则参数的类型由运算符的上下文决定。

+   如果算术运算符没有类型确定的上下文，则涉及的任何参数的派生类型为`DOUBLE PRECISION`。例如，当参数是`SELECT`列表中的顶层节点时，或者当它是比较运算符的一部分时，就会发生这种情况。

+   作为字符串运算符的操作数的参数具有与其他操作数的聚合类型相同的派生类型。如果运算符的所有操作数都是参数，则派生类型为`VARCHAR`；其排序规则由`collation_connection`的值确定。

+   作为时间运算符的操作数具有类型`DATETIME`，如果运算符返回`DATETIME`，则操作数的类型为`TIME`，如果运算符返回`TIME`，则操作数的类型为`DATE`，如果运算符返回`DATE`。

+   二元比较运算符的操作数具有与比较的另一个操作数相同的派生类型。

+   作为`BETWEEN`等三元比较运算符的操作数的参数具有与其他操作数的聚合类型相同的派生类型。

+   如果比较运算符的所有操作数都是参数，则它们每个的派生类型都是`VARCHAR`，其排序规则由`collation_connection`的值确定。

+   作为`CASE`、`COALESCE`、`IF`、`IFNULL`或`NULLIF`的输出操作数之一的参数具有与运算符的其他输出操作数的聚合类型相同的派生类型。

+   如果任何`CASE`、`COALESCE`、`IF`、`IFNULL`或`NULLIF`的所有输出操作数都是参数，或它们都是`NULL`，则参数的类型由运算符的上下文决定。

+   如果参数是任何`CASE`、`COALESCE()`、`IF`或`IFNULL`的操作数，并且没有类型确定的上下文，则涉及的每个参数的派生类型都是`VARCHAR`，其排序规则由`collation_connection`的值确定。

+   作为`CAST()`的操作数的参数具有与`CAST()`指定的类型相同的类型。

+   如果参数是不是`INSERT`语句的一部分的`SELECT`列表的直接成员，则参数的派生类型是`VARCHAR`，其排序规则由`collation_connection`的值确定。

+   如果参数是`INSERT`](insert.html "15.2.7 INSERT Statement")语句的一部分的`SELECT`列表的直接成员，则参数的派生类型是将参数插入的相应列的类型。

+   如果参数用作`UPDATE`语句的`SET`子句中的赋值的源，或者用作`INSERT`语句的`ON DUPLICATE KEY UPDATE`子句中的赋值的源，则参数的派生类型是由`SET`或`ON DUPLICATE KEY UPDATE`子句更新的相应列的类型。

+   如果参数是函数的参数，则派生类型取决于函数的返回类型。

对于实际类型和派生类型的某些组合，会触发语句的自动重新准备，以确保与 MySQL 先前版本更紧密的兼容性。如果以下任一条件为真，则不会发生重新准备：

+   使用`NULL`作为实际参数值。

+   参数是`CAST()`的操作数。（相反，会尝试将其转换为派生类型，如果转换失败则引发异常。）

+   参数是字符串。（在这种情况下，会执行隐式的`CAST(? AS *`derived_type`*)`。）

+   参数的派生类型和实际类型都是`INTEGER`，并且符号相同。

+   参数的派生类型是`DECIMAL`，实际类型是`DECIMAL`或`INTEGER`。

+   派生类型是`DOUBLE`，实际类型是任何数值类型。

+   派生类型和实际类型都是字符串类型。

+   如果派生类型是时间型，实际类型也是时间型。*异常情况*：派生类型是`TIME`，实际类型不是`TIME`；派生类型是`DATE`，实际类型不是`DATE`。

+   派生类型是时间型，实际类型是数值型。

对于除上述情况之外的情况，语句将重新准备，并使用实际参数类型而不是派生参数类型。

这些规则也适用于准备语句中引用的用户变量。

在准备语句中为给定参数或用户变量使用不同的数据类型，导致语句需要重新准备。这样效率较低；也可能导致参数（或变量）的实际类型变化，从而导致后续执行准备语句时结果不一致。因此，建议在重新执行准备语句时为给定参数使用相同的数据类型。
