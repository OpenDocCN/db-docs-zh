# 10.4.1 优化数据大小

> 原文：[`dev.mysql.com/doc/refman/8.0/en/data-size.html`](https://dev.mysql.com/doc/refman/8.0/en/data-size.html)

设计表格以最小化它们在磁盘上的空间占用。通过减少写入和从磁盘读取的数据量，可以实现巨大的改进。较小的表通常在查询执行期间主动处理其内容时需要较少的主内存。对表数据的任何空间减少也会导致更小的索引，可以更快地处理。

MySQL 支持许多不同的存储引擎（表类型）和行格式。对于每个表，您可以决定使用哪种存储和索引方法。为您的应用程序选择适当的表格格式可以带来很大的性能提升。请参阅第十七章，*InnoDB 存储引擎*和第十八章，*替代存储引擎*。

您可以通过使用以下列出的技术获得表的更好性能并最小化存储空间：

+   表列

+   行格式

+   索引

+   连接

+   规范化

#### 表列

+   使用可能的最有效（最小）数据类型。MySQL 有许多专门的类型可以节省磁盘空间和内存。例如，尽可能使用较小的整数类型以获得更小的表。`MEDIUMINT`通常比`INT`更好，因为`MEDIUMINT`列使用的空间少 25%。

+   如果可能，声明列为`NOT NULL`。这样可以通过更好地使用索引和消除测试每个值是否为`NULL`的开销来加快 SQL 操作。您还可以节省一些存储空间，每列一个比特。如果您确实需要在表中使用`NULL`值，请使用它们。只需避免允许每列都有`NULL`值的默认设置。

#### 行格式

+   `InnoDB`表默认使用`DYNAMIC`行格式创建。要使用除`DYNAMIC`之外的行格式，请配置`innodb_default_row_format`，或在`CREATE TABLE`或`ALTER TABLE`语句中明确指定`ROW_FORMAT`选项。

    紧凑系列行格式，包括`COMPACT`、`DYNAMIC`和`COMPRESSED`，减少了行存储空间，但增加了某些操作的 CPU 使用。如果您的工作负载受到缓存命中率和磁盘速度的限制，那么它可能会更快。如果是受 CPU 速度限制的罕见情况，那么它可能会更慢。

    当使用变长字符集（如`utf8mb3`或`utf8mb4`）时，紧凑系列行格式还优化了`CHAR`列的存储。使用`ROW_FORMAT=REDUNDANT`时，`CHAR(*N*)`占用*`N`* × 字符集的最大字节长度。许多语言主要使用单字节的`utf8mb3`或`utf8mb4`字符，因此固定存储长度通常会浪费空间。使用紧凑系列行格式，`InnoDB`为这些列分配一个变量存储量，范围从*`N`*到*`N`* × 字符集的最大字节长度，通过去除尾随空格。最小存储长度为*`N`*字节，以便在典型情况下进行原地更新。有关更多信息，请参阅第 17.10 节，“InnoDB 行格式”。

+   为了通过以压缩形式存储表数据来进一步减少空间，创建`InnoDB`表时指定`ROW_FORMAT=COMPRESSED`，或在现有的`MyISAM`表上运行**myisampack**命令。(`InnoDB`压缩表是可读写的，而`MyISAM`压缩表是只读的。)

+   对于`MyISAM`表，如果没有任何变长列（`VARCHAR`, `TEXT`, 或 `BLOB`列），则使用固定大小的行格式。这样做速度更快，但可能会浪费一些空间。请参阅第 18.2.3 节，“MyISAM 表存储格式”。您可以通过使用`CREATE TABLE`选项`ROW_FORMAT=FIXED`来提示希望拥有固定长度行，即使您有`VARCHAR`列。

#### 索引

+   表的主索引应尽可能短。这样可以轻松高效地识别每一行。对于`InnoDB`表，主键列在每个次要索引条目中都会重复，因此如果有许多次要索引，则较短的主键可以节省大量空间。

+   只创建需要改善查询性能的索引。索引对检索很有用，但会减慢插入和更新操作。如果你主要通过在多个列上搜索来访问表，那么为它们创建一个单一的复合索引，而不是为每个列单独创建索引。索引的第一部分应该是最常用的列。如果你在从表中选择时总是使用许多列，那么索引中的第一列应该是具有最多重复项的列，以获得更好的索引压缩。

+   如果一个长字符串列很可能在前几个字符上有唯一的前缀，最好只对这个前缀建立索引，使用 MySQL 支持在列的最左边部分创建索引（参见 Section 15.1.15, “CREATE INDEX Statement”）。较短的索引更快，不仅因为它们需要更少的磁盘空间，而且因为它们在索引缓存中提供更多的命中，从而减少磁盘查找。参见 Section 7.1.1, “Configuring the Server”。

#### 连接

+   在某些情况下，将经常扫描的表拆分为两个部分可能是有益的。特别是如果它是一个动态格式的表，并且可以使用一个较小的静态格式表来在扫描表时找到相关行。

+   声明在不同表中具有相同信息的列具有相同的数据类型，以加快基于相应列的连接速度。

+   保持列名简单，这样你可以在不同表中使用相同的名称并简化连接查询。例如，在名为`customer`的表中，使用`name`作为列名，而不是`customer_name`。为了使你的名称在其他 SQL 服务器上可移植，考虑将它们保持在 18 个字符以下。

#### 规范化

+   通常情况下，尽量保持所有数据非冗余（遵循数据库理论中所谓的第三范式）。不要重复冗长的数值，如姓名和地址，给它们分配唯一的 ID，根据需要在多个较小的表中重复这些 ID，并通过在连接子句中引用 ID 来在查询中连接这些表。

+   如果速度比磁盘空间和保持多个数据副本的维护成本更重要，例如在商业智能场景中，你分析来自大表的所有数据，你可以放松规范化规则，复制信息或创建摘要表以获得更快的速度。
