> 原文：[`dev.mysql.com/doc/refman/8.0/en/innodb-compression-internals.html`](https://dev.mysql.com/doc/refman/8.0/en/innodb-compression-internals.html)

#### 17.9.1.5 InnoDB 表的压缩工作原理

本节描述了 InnoDB 表的压缩的一些内部实现细节。这里提供的信息可能有助于性能调优，但对于基本的压缩使用并非必须了解。

##### 压缩算法

一些操作系统在文件系统级别实现了压缩。文件通常被分成固定大小的块，这些块被压缩成可变大小的块，这很容易导致碎片化。每次修改块内的内容时，整个块都会在写入磁盘之前重新压缩。这些特性使得这种压缩技术不适合在更新密集型数据库系统中使用。

MySQL 借助著名的[zlib 库](http://www.zlib.net/)实现了压缩，该库实现了 LZ77 压缩算法。这种压缩算法成熟、稳健，并且在 CPU 利用率和数据大小减少方面非常高效。该算法是“无损”的，因此始终可以从压缩形式重构原始未压缩数据。LZ77 压缩通过查找在待压缩数据中重复的数据序列来工作。数据中的值模式决定了它的压缩效果，但典型的用户数据通常可以压缩 50%或更多。

与应用程序执行的压缩或其他一些数据库管理系统的压缩功能不同，InnoDB 压缩同时适用于用户数据和索引。在许多情况下，索引可以占据总数据库大小的 40-50%甚至更多，因此这种差异是显著的。当压缩对数据集有效时，InnoDB 数据文件的大小（每表一个文件表空间或通用表空间 `.ibd`文件）为未压缩大小的 25%至 50%甚至更小。根据工作负载的不同，这种较小的数据库可以进一步减少 I/O，提高吞吐量，以较小的 CPU 利用率成本。您可以通过修改`innodb_compression_level`配置选项来调整压缩级别和 CPU 开销之间的平衡。

##### InnoDB 数据存储和压缩

InnoDB 表中的所有用户数据都存储在包含 B 树索引（聚簇索引）的页面中。在其他一些数据库系统中，这种类型的索引被称为“索引组织表”。索引节点中的每一行包含（用户指定或系统生成的）主键的值和表的所有其他列的值。

InnoDB 表中的二级索引也是 B 树，包含值对：索引键和指向聚簇索引中行的指针。该指针实际上是表的主键值，用于访问聚簇索引，如果需要除索引键和主键之外的列。二级索引记录必须始终适合单个 B 树页面。

B 树节点（包括聚簇索引和二级索引）的压缩处理与用于存储长 `VARCHAR`、`BLOB` 或 `TEXT` 列的溢出页的压缩处理不同，如下节所述。

##### B 树页面的压缩

由于 B 树页面经常更新，因此需要特殊处理。重要的是要尽量减少 B 树节点分裂的次数，以及尽量减少解压缩和重新压缩它们的内容的需求。

MySQL 使用的一种技术是在未压缩形式的 B 树节点中维护一些系统信息，从而方便某些原地更新。例如，这允许行被标记为删除并删除，而无需进行任何压缩操作。

另外，MySQL 尝试在更改索引页面时避免不必要的解压缩和重新压缩。在每个 B 树页面中，系统保留一个未压缩的“修改日志”来记录对页面所做的更改。小记录的更新和插入可以写入此修改日志，而无需完全重建整个页面。

当修改日志的空间用尽时，InnoDB 解压缩页面，应用更改并重新压缩页面。如果重新压缩失败（称为压缩失败的情况），则 B 树节点将被分裂，并重复该过程，直到更新或插入成功。

为了避免在写密集型工作负载中频繁出现压缩失败，例如 OLTP 应用程序，MySQL 有时会在页面中保留一些空间（填充），以便修改日志更快地填满，并在仍有足够空间避免分割页面时重新压缩页面。每个页面中留下的填充空间量因系统跟踪页面分割频率而异。在频繁向压缩表写入的繁忙服务器上，您可以调整`innodb_compression_failure_threshold_pct`和`innodb_compression_pad_pct_max`配置选项来微调此机制。

通常，MySQL 要求 InnoDB 表中的每个 B 树页面至少能容纳两条记录。对于压缩表，此要求已经放宽。B 树节点的叶子页面（无论是主键还是辅助索引）只需要容纳一条记录，但该记录必须以未压缩形式适合于每页修改日志。如果`innodb_strict_mode`为`ON`，MySQL 在`CREATE TABLE`或`CREATE INDEX`期间检查最大行大小。如果行不适合，将发出以下错误消息：`ERROR HY000: Too big row`。

如果在`innodb_strict_mode`为 OFF 时创建表，并且随后的`INSERT`或`UPDATE`语句尝试创建一个在压缩页面大小内不适合的索引条目，则操作将失败，并显示`ERROR 42000: Row size too large`。（此错误消息不会指定记录过大的索引，也不会提及索引记录的长度或特定索引页面上的最大记录大小。）要解决此问题，请使用`ALTER TABLE`重建表，并选择更大的压缩页面大小（`KEY_BLOCK_SIZE`），缩短任何列前缀索引，或完全禁用压缩，使用`ROW_FORMAT=DYNAMIC`或`ROW_FORMAT=COMPACT`。

`innodb_strict_mode`不适用于通用表空间，通用表空间也支持压缩表。通用表空间的表空间管理规则严格执行，与`innodb_strict_mode`独立执行。有关更多信息，请参见第 15.1.21 节，“CREATE TABLESPACE Statement”。

##### 压缩 BLOB、VARCHAR 和 TEXT 列

在 InnoDB 表中，不是主键的`BLOB`、`VARCHAR`和`TEXT`列可能存储在单独分配的溢出页上。我们将这些列称为页外列。它们的值存储在溢出页的单链表上。

对于使用`ROW_FORMAT=DYNAMIC`或`ROW_FORMAT=COMPRESSED`创建的表，根据它们的长度和整行的长度，`BLOB`、`TEXT`或`VARCHAR`列的值可能完全存储在页外。对于存储在页外的列，聚集索引记录仅包含指向溢出页的 20 字节指针，每列一个。是否存储任何列在页外取决于页大小和整行的总大小。当整行长度过长无法完全适应聚集索引页时，MySQL 会选择最长的列进行页外存储，直到整行适应聚集索引页。如上所述，如果一行无法适应压缩页，将会出现错误。

注意

对于使用`ROW_FORMAT=DYNAMIC`或`ROW_FORMAT=COMPRESSED`创建的表，长度小于或等于 40 字节的`TEXT`和`BLOB`列始终存储在内部。

使用`ROW_FORMAT=REDUNDANT`和`ROW_FORMAT=COMPACT`的表将`BLOB`、`VARCHAR`和`TEXT`列的前 768 字节存储在聚集索引记录中，以及主键。768 字节前缀后跟一个指向包含列其余部分值的溢出页的 20 字节指针。

当表处于`COMPRESSED`格式时，写入溢出页的所有数据都会被压缩“原样”；也就是说，MySQL 会对整个数据项应用 zlib 压缩算法。除数据外，压缩的溢出页包含一个未压缩的页头和页尾，其中包括页校验和指向下一个溢出页的链接，等等。因此，如果数据高度可压缩，通常情况下文本数据会获得非常显著的存储节省，对于较长的`BLOB`、`TEXT`或`VARCHAR`列。图像数据，如`JPEG`，通常已经被压缩，因此将其存储在压缩表中并不会带来太大好处；双重压缩可能会浪费 CPU 周期而几乎不节省空间。

溢出页与其他页的大小相同。存储在页外的包含十列的行占用十个溢出页，即使列的总长度只有 8K 字节。在未压缩的表中，十个未压缩的溢出页占用 160K 字节。在具有 8K 页大小的压缩表中，它们只占用 80K 字节。因此，对于具有长列值的表，通常更有效使用压缩表格式。

对于 file-per-table 表空间，使用 16K 压缩页大小可以减少`BLOB`、`VARCHAR`或`TEXT`列的存储和 I/O 成本，因为这些数据通常压缩效果良好，可能需要较少的溢出页，即使 B 树节点本身占用的页数与未压缩形式相同。通用表空间不支持 16K 压缩页大小（`KEY_BLOCK_SIZE`）。有关更多信息，请参见 Section 17.6.3.3，“通用表空间”。

##### 压缩和 InnoDB 缓冲池

在压缩的`InnoDB`表中，每个压缩页（无论是 1K、2K、4K 还是 8K）对应于一个 16K 字节的未压缩页（如果设置了`innodb_page_size`，则大小可能更小）。要访问页中的数据，MySQL 从磁盘读取压缩页（如果尚未在缓冲池中），然后将页解压缩为其原始形式。本节描述了`InnoDB`在处理压缩表的页时如何管理缓冲池。

为了最小化 I/O 并减少解压缩页的需求，有时缓冲池同时包含数据库页的压缩和未压缩形式。为了为其他所需的数据库页腾出空间，MySQL 可以从缓冲池中驱逐一个未压缩页，同时保留压缩页在内存中。或者，如果某个页已经有一段时间没有被访问，该页的压缩形式可能会被写入磁盘，以释放其他数据的空间。因此，在任何给定时间，缓冲池可能同时包含页的压缩和未压缩形式，或仅包含页的压缩形式，或两者都不包含。

MySQL 使用最近最少使用（LRU）列表跟踪要保留在内存中的页面和要驱逐的页面，以便热（频繁访问）数据倾向于保留在内存中。当访问压缩表时，MySQL 使用自适应 LRU 算法在内存中实现压缩和未压缩页面的适当平衡。这种自适应算法对系统是否以 I/O 绑定或 CPU 绑定方式运行敏感。目标是在 CPU 繁忙时避免花费过多的处理时间解压页面，并在 CPU 有空闲周期可以用于解压已经在内存中的压缩页面时避免做过多的 I/O。当系统处于 I/O 绑定状态时，该算法更倾向于驱逐页面的未压缩副本而不是两者，以便为其他磁盘页面腾出更多的内存空间。当系统处于 CPU 绑定状态时，MySQL 更倾向于同时驱逐压缩和未压缩页面，以便更多的内存用于“热”页面，并减少仅以压缩形式在内存中解压数据的需求。

##### 压缩和 InnoDB 重做日志文件

在将压缩页写入数据文件之前，MySQL 会将页面的副本写入重做日志（如果自上次写入数据库以来已重新压缩）。这样做是为了确保即使在`zlib`库升级并且该更改引入与压缩数据不兼容的问题的极少数情况下，重做日志也可以用于崩溃恢复。因此，在使用压缩时，可以预期日志文件的大小会增加，或者需要更频繁的检查点。日志文件大小或检查点频率的增加量取决于压缩页被修改的次数，这些修改需要重新组织和重新压缩。

要在每个表的表空间中创建一个压缩表，必须启用`innodb_file_per_table`。在创建一个压缩表时，不依赖于`innodb_file_per_table`设置在一般表空间中。有关更多信息，请参见第 17.6.3.3 节，“一般表空间”。
