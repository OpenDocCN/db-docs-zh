# 29.9 性能模式表用于当前和历史事件

> 原文：[`dev.mysql.com/doc/refman/8.0/en/performance-schema-event-tables.html`](https://dev.mysql.com/doc/refman/8.0/en/performance-schema-event-tables.html)

对于等待、阶段、语句和事务事件，性能模式可以监视和存储当前事件。此外，当事件结束时，性能模式可以将它们存储在历史表中。对于每种事件类型，性能模式使用三个表来存储当前和历史事件。这些表的名称采用以下形式，其中*`xxx`*表示事件类型（`waits`、`stages`、`statements`、`transactions`）：

+   `events_*`xxx`*_current`： “当前事件”表为每个线程存储当前监视的事件（每个线程一行）。

+   `events_*`xxx`*_history`： “最近历史”表存储每个线程中已结束的最新事件（每个线程最多一定数量的行）。

+   `events_*`xxx`*_history_long`： “长历史”表存储全局结束的最新事件（跨所有线程，每个表最多一定数量的行）。

每种事件类型的`_current`表每个线程包含一行，因此没有用于配置其最大大小的系统变量。性能模式自动调整历史表的大小，或者可以在服务器启动时使用特定于表的系统变量显式配置大小，如在描述各个历史表的部分中所示。典型的自动调整值为`_history`表每个线程 10 行，`_history_long`表总共 10,000 行。

对于每种事件类型，`_current`、`_history`和`_history_long`表具有相同的列。`_current`和`_history`表具有相同的索引。`_history_long`表没有索引。

`_current`表显示服务器当前正在发生的情况。当当前事件结束时，它将从其`_current`表中移除。

`_history`和`_history_long`表显示最近发生的事件。当历史表变满时，旧事件将被丢弃，新事件将被添加。行从`_history`和`_history_long`表中以不同的方式过期，因为这些表有不同的用途：

+   `_history`用于独立于全局服务器负载调查单个线程。

+   `_history_long`用于全局调查服务器，而不是每个线程。

两种历史表之间的区别与数据保留政策有关。当事件首次出现时，两个表包含相同的数据。然而，随着时间的推移，每个表中的数据会以不同的方式过期，因此在每个表中可能会保留更长或更短的时间：

+   对于`_history`，当表对于给定线程包含最大数量的行时，当为该线程添加新行时，最旧的线程行将被丢弃。

+   对于`_history_long`，当表变满时，无论哪个线程生成了这两行，当添加新行时，最老的行都会被丢弃。

当一个线程结束时，它的所有行都会从`_history`表中丢弃，但不会从`_history_long`表中丢弃。

以下示例说明了如何向这两种类型的历史表中添加和丢弃事件的差异。这些原则同样适用于所有事件类型。该示例基于以下假设：

+   性能模式被配置为在`_history`表中保留每个线程的 10 行，在`_history_long`表中总共保留 10,000 行。

+   线程 A 每秒生成 1 个事件。

    线程 B 每秒生成 100 个事件。

+   没有其他线程在运行。

执行 5 秒后：

+   A 和 B 分别生成了 5 和 500 个事件。

+   `_history`包含了 A 的 5 行和 B 的 10 行。因为每个线程的存储限制为 10 行，所以对于 A 没有丢弃行，而对于 B 已经丢弃了 490 行。

+   `_history_long`包含了 A 的 5 行和 B 的 500 行。因为表的最大行数为 10,000 行，所以对于任何一个线程都没有丢弃行。

执行 5 分钟（300 秒）后：

+   A 和 B 分别生成了 300 和 30,000 个事件。

+   `_history`包含了 A 的 10 行和 B 的 10 行。因为每个线程的存储限制为 10 行，对于 A 已经丢弃了 290 行，而对于 B 已经丢弃了 29,990 行。A 的行包含了 10 秒前的数据，而 B 的行只包含了 0.1 秒前的数据。

+   `_history_long`包含了 10,000 行。因为 A 和 B 一起每秒生成 101 个事件，所以表中的数据大约是 10,000/101 = 99 秒前的数据，其中 B 的行数大约是 A 的 100 倍。
