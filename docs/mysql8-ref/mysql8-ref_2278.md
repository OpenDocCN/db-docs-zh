# A.5 MySQL 8.0 FAQ: Triggers

> 原文：[`dev.mysql.com/doc/refman/8.0/en/faqs-triggers.html`](https://dev.mysql.com/doc/refman/8.0/en/faqs-triggers.html)

A.5.1\. 我在哪里可以找到 MySQL 8.0 触发器的文档？

A.5.2\. 是否有关于 MySQL 触发器的讨论论坛？

A.5.3\. MySQL 8.0 是否具有语句级触发器还是行级触发器？

A.5.4\. 是否有任何默认触发器？

A.5.5\. MySQL 中的触发器是如何管理的？

A.5.6\. 是否有一种方法可以查看给定数据库中的所有触发器？

A.5.7\. 触发器存储在哪里？

A.5.8\. 触发器是否可以调用存储过程？

A.5.9\. 触发器是否可以访问表？

A.5.10\. 一个表是否可以有多个具有相同触发器事件和操作时间的触发器？

A.5.11\. 触发器是否可以更新远程服务器上的表？

A.5.12\. 触发器是否与复制一起工作？

A.5.13\. 如何通过触发器在源上执行的操作传递到副本上？

| **A.5.1.** | 我在哪里可以找到 MySQL 8.0 触发器的文档？ |
| --- | --- |
|  | 参见 Section 27.3, “Using Triggers”。 |
| **A.5.2.** | 是否有关于 MySQL 触发器的讨论论坛？ |
|  | 是的。可在 [`forums.mysql.com/list.php?99`](https://forums.mysql.com/list.php?99) 找到。 |
| **A.5.3.** | MySQL 8.0 是否具有语句级触发器还是行级触发器？ |
|  | 在 MySQL 8.0 中，所有触发器都是`FOR EACH ROW`；也就是说，触发器会在每插入、更新或删除的行上被激活。MySQL 8.0 不支持使用`FOR EACH STATEMENT`的触发器。 |
| **A.5.4.** | 是否有任何默认触发器？ |
|  | 并非明确。MySQL 对于一些特定的`TIMESTAMP`列，以及使用`AUTO_INCREMENT`定义的列有特殊行为。 |
| **A.5.5.** | MySQL 中的触发器是如何管理的？ |
|  | 在 MySQL 8.0 中，可以使用`CREATE TRIGGER`语句创建触发器，并使用`DROP TRIGGER`删除触发器。有关这些语句的更多信息，请参见第 15.1.22 节，“CREATE TRIGGER Statement”和第 15.1.34 节，“DROP TRIGGER Statement”。可以通过查询`INFORMATION_SCHEMA.TRIGGERS`表来获取有关触发器的信息。请参见第 28.3.45 节，“INFORMATION_SCHEMA TRIGGERS Table”。 |
| **A.5.6.** | 有没有办法查看给定数据库中的所有触发器？ |

|  | 是的。您可以使用对`INFORMATION_SCHEMA.TRIGGERS`表的查询来获取在数据库`dbname`上定义的所有触发器的列表，例如下面显示的查询：

```sql
SELECT TRIGGER_NAME, EVENT_MANIPULATION, EVENT_OBJECT_TABLE, ACTION_STATEMENT
    FROM INFORMATION_SCHEMA.TRIGGERS
    WHERE TRIGGER_SCHEMA='*dbname*';
```

有关此表格的更多信息，请参见第 28.3.45 节，“INFORMATION_SCHEMA TRIGGERS Table”。您还可以使用`SHOW TRIGGERS`语句，该语句专用于 MySQL。请参见第 15.7.7.40 节，“SHOW TRIGGERS Statement”。 |

| **A.5.7.** | 触发器存储在哪里？ |
| --- | --- |
|  | 触发器存储在`mysql.triggers`系统表中，该表是数据字典的一部分。 |
| **A.5.8.** | 触发器可以调用存储过程吗��� |
|  | 是的。 |
| **A.5.9.** | 触发器可以访问表吗？ |
|  | 触发器可以访问其自己表中的旧数据和新数据。触发器还可以影响其他表，但不允许修改已被调用函数或触发器的语句正在使用（读取或写入）的表。 |
| **A.5.10.** | 表格可以具有具有相同触发事件和操作时间的多个触发器吗？ |
|  | 在 MySQL 8.0 中，可以为给定表定义具有相同触发事件和操作时间的多个触发器。例如，您可以为表定义两个`BEFORE UPDATE`触发器。默认情况下，具有相同触发事件和操作时间的触发器按创建顺序激活。要影响触发器顺序，请在`FOR EACH ROW`之后指定一个子句，指示`FOLLOWS`或`PRECEDES`以及具有相同触发事件和操作时间的现有触发器的名称。使用`FOLLOWS`，新触发器在现有触发器之后激活。使用`PRECEDES`，新触发器在现有触发器之前激活。 |
| **A.5.11.** | 触发器是否可以更新远程服务器上的表？ |
|  | 是的。可以使用 `FEDERATED` 存储引擎更新远程服务器上的表（参见 第 18.8 节，“FEDERATED 存储引擎”）。 |
| **A.5.12.** | 触发器与复制一起工作吗？ |
|  | 是的。然而，它们的工作方式取决于您是使用 MySQL 的“经典”基于语句还是基于行的复制格式。当使用基于语句的复制时，在复制品上执行触发器是由在源上执行的语句执行的（并复制到复制品）。当使用基于行的复制时，由于在源上运行然后复制到复制品的语句，触发器不会在复制品上执行。相反，当使用基于行的复制时，源上执行触发器引起的更改会应用于复制品。有关更多信息，请参见 第 19.5.1.36 节，“复制和触发器”。 |
| **A.5.13.** | 通过源上的触发器执行的操作如何复制到复制品？ |

|  | 再次，这取决于您是使用基于语句还是基于行的复制。**基于语句的复制。** 首先，源上存在的触发器必须在复制品服务器上重新创建。完成此操作后，复制流程就像参与复制的任何其他标准 DML 语句一样工作。例如，考虑一个具有在复制源服务器上存在的 `AFTER` 插入触发器的 `EMP` 表。在复制品服务器上也存在相同的 `EMP` 表和 `AFTER` 插入触发器。复制流程将是：

1.  向 `EMP` 进行了 `INSERT` 语句。

1.  `EMP` 上的 `AFTER` 触发器被激活。

1.  `INSERT` 语句被写入二进制日志。

1.  复制品捡起 `INSERT` 语句到 `EMP` 并执行它。

1.  复制品上存在的 `EMP` 上的 `AFTER` 触发器被激活。

**基于行的复制。** 当您使用基于行的复制时，源上执行触发器引起的更改会应用到副本上。然而，在基于行的复制下，触发器本身实际上不会在副本上执行。这是因为，如果源和副本都应用了源上的更改，并且触发这些更改的触发器在副本上也被应用，那么这些更改实际上会在副本上应用两次，导致源和副本上的数据不同。在大多数情况下，基于行和基于语句的复制的结果是相同的。然而，如果您在源和副本上使用不同的触发器，则无法使用基于行的复制。（这是因为基于行的格式将在源上执行的触发器引起的更改复制到副本上，而不是导致触发器执行的语句，副本上对应的触发器也不会被执行。）相反，导致这些触发器被执行的任何语句必须使用基于语句的复制进行复制。有关更多信息，请参见 Section 19.5.1.36, “Replication and Triggers”. |
