# 8.2.6 访问控制，阶段 1：连接验证

> 原文：[`dev.mysql.com/doc/refman/8.0/en/connection-access.html`](https://dev.mysql.com/doc/refman/8.0/en/connection-access.html)

当你尝试连接到 MySQL 服务器时，服务器根据以下条件接受或拒绝连接：

+   你的身份以及是否可以通过提供适当的凭证来验证。

+   你的帐户是锁定还是解锁的。

服务器首先检查凭证，然后检查帐户锁定状态。任一步骤失败都会导致服务器完全拒绝您的访问。否则，服务器接受连接，然后进入阶段 2 并等待请求。

服务器使用`user`表中的列执行身份和凭证检查，仅当满足以下条件时才接受连接：

+   客户端主机名和用户名与某个`user`表行中的`Host`和`User`列匹配。有关允许的`Host`和`User`值的规则，请参见 Section 8.2.4, “Specifying Account Names”。

+   客户端提供行中指定的凭证（例如，密码），如`authentication_string`列所示。凭证使用`plugin`列中命名的身份验证插件进行解释。

+   该行指示帐户未锁定。锁定状态记录在`account_locked`列中，其值必须为`'N'`。可以使用`CREATE USER`或`ALTER USER`语句设置或更改帐户锁定。

你的身份基于两个信息：

+   你的 MySQL 用户名。

+   你连接的客户端主机。

如果`User`列的值非空，则传入连接中的用户名必须完全匹配。如果`User`值为空，则匹配任何用户名。如果与传入连接匹配的`user`表行具有空白用户名，则该用户被视为没有名称的匿名用户，而不是客户端实际指定的用户名。这意味着在连接期间（即在阶段 2 期间）使用空白用户名进行所有进一步的访问检查。

`authentication_string`列可以为空。这不是通配符，也不意味着任何密码都匹配。这意味着用户必须在不指定密码的情况下连接。验证客户端的插件实现的身份验证方法可能会或可能不会使用`authentication_string`列中的密码。在这种情况下，可能还会使用外部密码来对 MySQL 服务器进行身份验证。

存储在`user`表的`authentication_string`列中的非空密码值已加密。MySQL 不会将密码以明文形式存储供任何人查看。相反，尝试连接的用户提供的密码会被加密（使用帐户认证插件实现的密码哈希方法）。然后，在检查密码是否正确的连接过程中使用加密密码。这样做时，加密密码永远不会通过连接传输。参见 Section 8.2.1, “Account User Names and Passwords”。

从 MySQL 服务器的角度来看，加密密码是*真实*密码，因此您不应该向任何人提供访问权限。特别是*不要向非管理员用户提供对`mysql`系统数据库中表的读取权限*。

以下表格显示了`user`表中各种`User`和`Host`值的组合如何应用于传入连接。

| `User`值 | `Host`值 | 允许的连接 |
| --- | --- | --- |
| `'fred'` | `'h1.example.net'` | `fred`，从`h1.example.net`连接 |
| `''` | `'h1.example.net'` | 任何用户，从`h1.example.net`连接 |
| `'fred'` | `'%'` | `fred`，从任何主机连接 |
| `''` | `'%'` | 任何用户，从任何主机连接 |
| `'fred'` | `'%.example.net'` | `fred`，从`example.net`域中的任何主机连接 |
| `'fred'` | `'x.example.%'` | `fred`，从`x.example.net`，`x.example.com`，`x.example.edu`等连接；这可能没有用处 |
| `'fred'` | `'198.51.100.177'` | `fred`，从具有 IP 地址`198.51.100.177`的主机连接 |
| `'fred'` | `'198.51.100.%'` | `fred`，从`198.51.100`类 C 子网中的任何主机连接 |
| `'fred'` | `'198.51.100.0/255.255.255.0'` | 与前一个示例相同 |

客户端主机名和用户名可能与`user`表中的多行匹配。前面的示例集演示了这一点：所示的几个条目与`fred`通过`h1.example.net`的连接匹配。

当存在多个匹配项时，服务器必须确定使用哪个。它解决此问题如下：

+   每当服务器将`user`表读入内存时，它会对行进行排序。

+   当客户端尝试连接时，服务器按顺序查看行。

+   服务器使用与客户端主机名和用户名匹配的第一行。

服务器使用排序规则，首先按最具体的`Host`值对行进行排序：

+   字面 IP 地址和主机名是最具体的。

+   在 MySQL 8.0.23 之前，字面 IP 地址的特异性不受其是否具有网络掩码的影响，因此`198.51.100.13`和`198.51.100.0/255.255.255.0`被视为同等特异性。从 MySQL 8.0.23 开始，主机部分带有 IP 地址的帐户具有以下特异性顺序：

    +   具有 IP 地址作为主机部分的帐户：

        ```sql
        CREATE USER '*user_name*'@'127.0.0.1';
        CREATE USER '*user_name*'@'198.51.100.44';
        ```

    +   具有使用 CIDR 表示法给定 IP 地址作为主机部分的帐户：

        ```sql
        CREATE USER '*user_name*'@'192.0.2.21/8';
        CREATE USER '*user_name*'@'198.51.100.44/16';
        ```

    +   具有给定子网掩码的 IP 地址作为主机部分的帐户：

        ```sql
        CREATE USER '*user_name*'@'192.0.2.0/255.255.255.0';
        CREATE USER '*user_name*'@'198.51.0.0/255.255.0.0';
        ```

+   模式`'%'`表示“任何主机”，是最不具体的。

+   空字符串`''`也表示“任何主机”，但在`'%'`之后排序。

非 TCP（套接字文件、命名管道和共享内存）连接被视为本地连接，并且如果存在这样的帐户，则与`localhost`的主机部分匹配，否则与匹配`localhost`的通配符主机部分匹配（例如，`local%`，`l%`，`%`）。

将`'%'`视为等同于`localhost`的处理在 MySQL 8.0.35 中已弃用，您应该期望这种行为在将来的 MySQL 版本中被移除。

具有相同`Host`值的行按照最具体的`User`值首先排序。空白的`User`值表示“任何用户”，是最不具体的，因此对于具有相同`Host`值的行，非匿名用户排在匿名用户之前。

对于具有同等特定`Host`和`User`值的行，顺序是不确定的。

要了解这是如何工作的，假设`user`表如下所示：

```sql
+-----------+----------+-
| Host      | User     | ...
+-----------+----------+-
| %         | root     | ...
| %         | jeffrey  | ...
| localhost | root     | ...
| localhost |          | ...
+-----------+----------+-
```

当服务器将表读入内存时，使用刚才描述的规则对行进行排序。排序后的结果如下所示：

```sql
+-----------+----------+-
| Host      | User     | ...
+-----------+----------+-
| localhost | root     | ...
| localhost |          | ...
| %         | jeffrey  | ...
| %         | root     | ...
+-----------+----------+-
```

当客户端尝试连接时，服务器会浏览排序后的行，并使用找到的第一个匹配项。对于由`jeffrey`从`localhost`连接的连接，表中的两行匹配：具有`Host`和`User`值为`'localhost'`和`''`的行，以及具有值为`'%'`和`'jeffrey'`的行。`'localhost'`行在排序顺序中首先出现，因此服务器使用该行。

这里是另一个例子。假设`user`表如下所示：

```sql
+----------------+----------+-
| Host           | User     | ...
+----------------+----------+-
| %              | jeffrey  | ...
| h1.example.net |          | ...
+----------------+----------+-
```

排序后的表如下所示：

```sql
+----------------+----------+-
| Host           | User     | ...
+----------------+----------+-
| h1.example.net |          | ...
| %              | jeffrey  | ...
+----------------+----------+-
```

第一行匹配来自`h1.example.net`的任何用户的连接，而第二行匹配来自任何主机的`jeffrey`的连接。

注意

一个常见的误解是认为，对于给定的用户名，当服务器尝试找到连接匹配时，所有明确命名该用户的行都会首先使用。这是不正确的。前面的例子说明了这一点，其中来自`h1.example.net`的`jeffrey`的连接首先匹配的不是包含`'jeffrey'`作为`User`列值的行，而是没有用户名的行。结果，`jeffrey`被认证为匿名用户，即使他在连接时指定了用户名。

如果您能够连接到服务器，但您的权限不符合您的期望，那么您可能正在以其他帐户进行身份验证。要找出服务器用于对您进行身份验证的帐户，请使用`CURRENT_USER()`函数。 (参见第 14.15 节，“信息函数”.) 它以`*`user_name`*@*`host_name`*`格式返回一个值，指示匹配的`user`表行中的`User`和`Host`值。假设`jeffrey`连接并发出以下查询：

```sql
mysql> SELECT CURRENT_USER();
+----------------+
| CURRENT_USER() |
+----------------+
| @localhost     |
+----------------+
```

这里显示的结果表明，匹配的`user`表行具有空白的`User`列值。换句话说，服务器将`jeffrey`视为匿名用户。

诊断身份验证问题的另一种方法是打印出`user`表，并手动按照顺序排列，以查看第一个匹配是在哪里进行的。
