> 译文：[`dev.mysql.com/doc/refman/8.0/en/replication-gtids-failover.html`](https://dev.mysql.com/doc/refman/8.0/en/replication-gtids-failover.html)

#### 19.1.3.5 使用 GTIDs 进行故障切换和扩展

在使用带有全局事务标识符（GTIDs）的 MySQL 复制时，有许多技术可用于为新副本提供数据，然后用于扩展，必要时提升为源以进行故障切换。本节描述以下技术：

+   简单复制

+   将数据和事务复制到副本

+   注入空事务

+   排除具有 gtid_purged 的事务

+   恢复 GTID 模式副本

全局事务标识符被添加到 MySQL 复制中，目的是简化复制数据流的管理以及特定情况下的故障切换活动。每个标识符唯一标识一组二进制日志事件，这些事件一起构成一个事务。GTIDs 在应用对数据库的更改中起着关键作用：服务器会自动跳过任何具有服务器识别为其之前已处理过的标识符的事务。这种行为对于自动复制定位和正确的故障切换至关重要。

标识符与构成给定事务的事件集之间的映射被记录在二进制日志中。当为新服务器提供来自另一个现有服务器的数据时，这会带来一些挑战。为了在新服务器上复制标识符集，需要将标识符从旧服务器复制到新服务器，并保留标识符与实际事件之间的关系。这对于恢复一个立即可用作故障切换或切换源的副本是必要的。

**简单复制。** 在新服务器上复制所有标识符和事务的最简单方法是将新服务器制作为具有完整执行历史记录的源的副本，并在两个服务器上启用全局事务标识符。有关更多信息，请参见 Section 19.1.3.4, “使用 GTIDs 设置复制”。

一旦复制开始，新服务器会从源服务器复制整个二进制日志，从而获取所有关于所有 GTIDs 的信息。

这种方法简单而有效，但需要副本从源读取二进制日志；新副本有时可能需要相对较长的时间才能赶上源，因此此方法不适用于快速故障转移或从备份中恢复。本节解释了如何通过将二进制日志文件复制到新服务器来避免从源获取所有执行历史记录。

**将数据和事务复制到副本。** 当源服务器之前处理了大量事务时，执行整个事务历史记录可能会耗时，这在设置新副本时可能会成为一个主要瓶颈。为了消除这一要求，可以将源服务器包含的数据集、二进制日志和全局事务信息的快照导入到新副本中。快照被拍摄的服务器可以是源服务器或其副本之一，但必须确保服务器在复制数据之前已处理了所有必需的事务。

有几种这种方法的变体，其区别在于从二进制日志中转移数据转储和事务到副本的方式，如下所述：

数据集

1.  在源服务器上使用**mysqldump**创建一个转储文件。设置**mysqldump**选项`--master-data`（默认值为 1）以包含带有二进制日志信息的`CHANGE REPLICATION SOURCE TO` | `CHANGE MASTER TO`语句。将`--set-gtid-purged`选项设置为`AUTO`（默认）或`ON`，以在转储中包含有关已执行事务的信息。然后使用**mysql**客户端在目标服务器上导入转储文件。

1.  或者，使用原始数据文件在源服务器上创建数据快照，然后将这些文件复制到目标服务器，按照第 19.1.2.5 节，“选择数据快照方法”中的说明进行操作。如果使用`InnoDB`表，可以使用 MySQL Enterprise Backup 组件中的**mysqlbackup**命令生成一致的快照。该命令记录了与快照对应的日志名称和偏移量，以便在副本上使用。MySQL Enterprise Backup 是 MySQL Enterprise 订阅的一部分，是一款商业产品。详细信息请参见第 32.1 节，“MySQL Enterprise Backup 概述”。

1.  或者，停止源服务器和目标服务器，将源数据目录的内容复制到新副本的数据目录，然后重新启动副本。如果使用此方法，副本必须配置为基于 GTID 的复制，换句话说，使用 `gtid_mode=ON`。有关此方法的说明和重要信息，请参见 第 19.1.2.8 节“将副本添加到复制环境”。

事务历史

如果源服务器在其二进制日志中具有完整的事务历史记录（即，GTID 集 `@@GLOBAL.gtid_purged` 为空），则可以使用这些方法。

1.  使用 **mysqlbinlog** 将源服务器的二进制日志导入新副本，使用 `--read-from-remote-server`、`--read-from-remote-source` 和 `--read-from-remote-master` 选项。

1.  或者，将源服务器的二进制日志文件复制到副本。您可以使用 **mysqlbinlog** 从副本中复制，使用 `--read-from-remote-server` 和 `--raw` 选项。这些可以通过使用 **mysqlbinlog** `>` `*`file`*`（不使用 `--raw` 选项）将二进制日志文件导出到 SQL 文件，然后将这些文件传递给 **mysql** 客户端进行处理。确保所有二进制日志文件都使用单个 **mysql** 进程处理，而不是多个连接。例如：

    ```sql
    $> mysqlbinlog copied-binlog.000001 copied-binlog.000002 | mysql -u root -p
    ```

    有关更多信息，请参见 第 6.6.9.3 节“使用 mysqlbinlog 备份二进制日志文件”。

这种方法的优势在于几乎立即可以获得新服务器；只有在重放快照或转储文件时提交的交易才需要从现有源获取。这意味着副本的可用性并非即时，但只需要相对较短的时间即可使副本赶上这些少量剩余交易。

预先复制二进制日志到目标服务器通常比实时从源读取整个事务执行历史要快。然而，当需要时，将这些文件移动到目标可能并不总是可行，由于大小或其他考虑。本节讨论的用于为新副本配置的另外两种方法使用其他方式将有关事务的信息传输到新副本。

**注入空事务。** 源的全局`gtid_executed`变量包含在源上执行的所有事务的集合。在拍摄快照以为新服务器配置时，您可以在拍摄快照的服务器上记录`gtid_executed`的内容，而不是复制二进制日志。在将新服务器添加到复制链之前，只需为源的`gtid_executed`中包含的每个事务标识符在新服务器上提交一个空事务，就像这样：

```sql
SET GTID_NEXT='aaa-bbb-ccc-ddd:N';

BEGIN;
COMMIT;

SET GTID_NEXT='AUTOMATIC';
```

一旦所有事务标识符都通过使用空事务重新建立，您必须刷新并清除副本的二进制日志，如下所示，其中*`N`*是当前二进制日志文件名的非零后缀：

```sql
FLUSH LOGS;
PURGE BINARY LOGS TO 'source-bin.00000*N*';
```

您应该这样做，以防止该服务器在以后被提升为源时通过虚假事务淹没复制流。（`FLUSH LOGS`语句强制创建一个新的二进制日志文件；`PURGE BINARY LOGS`清除空事务，但保留它们的标识符。）

这种方法创建了一个本质上是快照的服务器，但随着其二进制日志历史与复制流的收敛（即，与源或源的收敛），它能够成为一个源。这种结果在效果上类似于使用剩余的配置方法获得的效果，我们将在接下来的几段中讨论。

**排除具有 gtid_purged 的事务。** 源的全局`gtid_purged` 变量包含已从源的二进制日志中清除的所有事务的集合。与之前讨论的方法一样（参见注入空事务），您可以记录从快照被取得的服务器上的`gtid_executed` 的值（而不是将二进制日志复制到新服务器）。与以前的方法不同，无需提交空事务（或发出`PURGE BINARY LOGS`）；相反，您可以根据从备份或快照被取得的服务器上的`gtid_executed` 的值，在复制品上直接设置`gtid_purged`。

与使用空事务的方法一样，此方法创建了一个在功能上是快照的服务器，但随着其二进制日志历史与源和其他复制品的收敛，它可以成为一个源。

**恢复 GTID 模式的复制品。** 在遇到错误的基于 GTID 的复制设置中恢复复制品时，注入空事务可能无法解决问题，因为事件没有 GTID。

使用 **mysqlbinlog** 查找下一个事务，这可能是事件后下一个日志文件中的第一个事务。复制直到该事务的`COMMIT`，确保包括`SET @@SESSION.gtid_next`。即使您不使用基于行的复制，也可以在命令行客户端中运行二进制日志行事件。

停止复制品并运行您复制的事务。**mysqlbinlog** 输出将分隔符设置为`/*!*/;`，因此将其设置回去：

```sql
mysql> DELIMITER ;
```

自动从正确位置重新启动复制：

```sql
mysql> SET GTID_NEXT=automatic;
mysql> RESET SLAVE;
mysql> START SLAVE;
Or from MySQL 8.0.22:
mysql> SET GTID_NEXT=automatic;
mysql> RESET REPLICA;
mysql> START REPLICA;
```
