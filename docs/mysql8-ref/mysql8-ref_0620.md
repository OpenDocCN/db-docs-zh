# 10.11.2 表锁定问题

> 原文：[`dev.mysql.com/doc/refman/8.0/en/table-locking.html`](https://dev.mysql.com/doc/refman/8.0/en/table-locking.html)

`InnoDB`表使用行级锁定，以便多个会话和应用程序可以同时从同一表中读取和写入，而不必等待或产生不一致的结果。对于这种存储引擎，避免使用`LOCK TABLES`语句，因为它不提供任何额外的保护，而是降低并发性。自动的行级锁定使这些表适用于您最繁忙的数据库和最重要的数据，同时简化应用程序逻辑，因为您不需要锁定和解锁表。因此，`InnoDB`存储引擎是 MySQL 的默认存储引擎。

MySQL 对所有存储引擎使用表锁定（而不是页面、行或列锁定），除了`InnoDB`。锁定操作本身没有太多开销。但由于一次只能有一个会话写入表，对于这些其他存储引擎的最佳性能，主要用于经常查询但很少插入或更新的表。

+   支持 InnoDB 的性能考虑

+   锁定性能问题的解决方法

#### 支持 InnoDB 的性能考虑

在选择是使用`InnoDB`还是其他存储引擎创建表时，请记住表锁定的以下缺点：

+   表锁定使许多会话可以同时从表中读取，但如果会话想要写入表，则必须首先获得独占访问，这意味着它可能必须等待其他会话先完成对表的操作。在更新期间，所有其他想要访问此特定表的会话必须等待更新完成。

+   当会话因磁盘已满而等待时，表锁定会导致问题，需要在会话继续之前释放空间。在这种情况下，所有想要访问问题表的会话也会进入等待状态，直到更多的磁盘空间可用。

+   运行时间较长的`SELECT`语句会阻止其他会话在此期间更新表，使其他会话看起来缓慢或无响应。当会话等待独占访问表以进行更新时，发出`SELECT`语句的其他会话排队等待，即使对于只读会话也会降低并发性。

#### 锁定性能问题的解决方法

以下项目描述了一些避免或减少由表锁定引起的争用的方法：

+   考虑将表切换到`InnoDB`存储引擎，可以在设置期间使用`CREATE TABLE ... ENGINE=INNODB`，或者对现有表使用`ALTER TABLE ... ENGINE=INNODB`。有关此存储引擎的更多详细信息，请参见第十七章，*InnoDB 存储引擎*。

+   优化`SELECT`语句以使其运行更快，从而使其锁定表的时间更短。您可能需要创建一些汇总表来实现这一点。

+   使用带有`--low-priority-updates`启动**mysqld**。对于仅使用表级锁定的存储引擎（如`MyISAM`、`MEMORY`和`MERGE`），这会使所有更新（修改）表的语句比`SELECT`语句具有较低的优先级。在这种情况下，前述情景中的第二个`SELECT`语句将在`UPDATE`语句之���执行，并且不会等待第一个`SELECT`语句完成。

+   要指定在特定连接中发出的所有更新都应以低优先级执行，请将`low_priority_updates`服务器系统变量设置为 1。

+   要给特定的`INSERT`、`UPDATE`或`DELETE`语句降低优先级，请使用`LOW_PRIORITY`属性。

+   要给特定的`SELECT`语句提高优先级，请使用`HIGH_PRIORITY`属性。请参见第 15.2.13 节，“SELECT 语句”。

+   使用较低值的`max_write_lock_count`系统变量启动**mysqld**，以强制 MySQL 在特定数量的写锁定表之后（例如，对于插入操作）暂时提升所有等待表的`SELECT`语句的优先级。这允许在一定数量的写锁之后进行读锁定。

+   如果您在混合使用`SELECT`和`DELETE`语句时遇到问题，`DELETE`的`LIMIT`选项可能会有所帮助。请参见第 15.2.2 节，“DELETE 语句”。

+   在`SELECT`语句中使用`SQL_BUFFER_RESULT`可以帮助缩短表锁定的持续时间。请参见第 15.2.13 节，“SELECT 语句”。

+   将表内容拆分为单独的表可能会有所帮助，允许查询针对一个表中的列运行，而更新则限制在另一个表中的列。

+   您可以更改`mysys/thr_lock.c`中的锁定代码以使用单个队列。在这种情况下，写锁和读锁将具有相同的优先级，这可能有助于某些应用程序。
