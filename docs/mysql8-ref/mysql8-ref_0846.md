# 14.17.3 搜索 JSON 值的函数

> 原文：[`dev.mysql.com/doc/refman/8.0/en/json-search-functions.html`](https://dev.mysql.com/doc/refman/8.0/en/json-search-functions.html)

本节中的函数执行 JSON 值的搜索或比较操作，以从中提取数据，报告数据是否存在于其中的位置，或报告数据在其中的路径。此外，`MEMBER OF()` 运算符也在此处记录。

+   [`JSON_CONTAINS(*`target`*, *`candidate`*[, *`path`*])`](json-search-functions.html#function_json-contains)

    通过返回 1 或 0 指示给定的*`candidate`* JSON 文档是否包含在*`target`* JSON 文档中，或者 - 如果提供了*`path`*参数 - 候选是否在目标中的特定路径中找到。如果任何参数为`NULL`，或者路径参数未标识目标文档的某个部分，则返回`NULL`。如果*`target`*或*`candidate`*不是有效的 JSON 文档，或者*`path`*参数不是有效的路径表达式或包含`*`或`**`通配符，则会发生错误。

    若要仅检查路径上是否存在任何数据，请改用`JSON_CONTAINS_PATH()`。

    以下规则定义包含：

    +   如果且仅如果候选标量包含在目标标量中，则它们是可比较且相等。如果两个标量值具有相同的`JSON_TYPE()`类型，则它们是可比较的，但`INTEGER`和`DECIMAL`类型的值也可以相互比较。

    +   如果且仅如果候选数组中的每个元素包含在目标数组的某个元素中，则候选数组包含在目标数组中。

    +   如果且仅如果候选非数组包含在目标数组中，则候选包含在目标的某个元素中。

    +   如果且仅如果候选对象包含在目标对象中，则对于候选中的每个键，目标中都有一个同名键，并且与候选键关联的值包含在与目标键关联的值中。

    否则，候选值不包含在目标文档中。

    从 MySQL 8.0.17 开始，在`InnoDB`表上使用`JSON_CONTAINS()`的查询可以通过多值索引进行优化；有关更多信息，请参见多值索引。

    ```sql
    mysql> SET @j = '{"a": 1, "b": 2, "c": {"d": 4}}';
    mysql> SET @j2 = '1';
    mysql> SELECT JSON_CONTAINS(@j, @j2, '$.a');
    +-------------------------------+
    | JSON_CONTAINS(@j, @j2, '$.a') |
    +-------------------------------+
    |                             1 |
    +-------------------------------+
    mysql> SELECT JSON_CONTAINS(@j, @j2, '$.b');
    +-------------------------------+
    | JSON_CONTAINS(@j, @j2, '$.b') |
    +-------------------------------+
    |                             0 |
    +-------------------------------+

    mysql> SET @j2 = '{"d": 4}';
    mysql> SELECT JSON_CONTAINS(@j, @j2, '$.a');
    +-------------------------------+
    | JSON_CONTAINS(@j, @j2, '$.a') |
    +-------------------------------+
    |                             0 |
    +-------------------------------+
    mysql> SELECT JSON_CONTAINS(@j, @j2, '$.c');
    +-------------------------------+
    | JSON_CONTAINS(@j, @j2, '$.c') |
    +-------------------------------+
    |                             1 |
    +-------------------------------+
    ```

+   [`JSON_CONTAINS_PATH(*`json_doc`*, *`one_or_all`*, *`path`*[, *`path`*] ...)`](json-search-functions.html#function_json-contains-path)

    返回 0 或 1 以指示 JSON 文档是否包含给定路径或路径上的数据。如果任何参数为`NULL`，则返回`NULL`。如果*`json_doc`*参数不是有效的 JSON 文档，任何*`path`*参数不是有效的路径表达式，或者*`one_or_all`*不是`'one'`或`'all'`，则会发生错误。

    要检查路径上的特定值，请改用`JSON_CONTAINS()`。

    如果文档中不存在指定路径，则返回值为 0。否则，返回值取决于*`one_or_all`*参数：

    +   `'one'`：如果至少有一个路径存在于文档中，则为 1，否则为 0。

    +   `'all'`：如果所有路径都存在于文档中，则为 1，否则为 0。

    ```sql
    mysql> SET @j = '{"a": 1, "b": 2, "c": {"d": 4}}';
    mysql> SELECT JSON_CONTAINS_PATH(@j, 'one', '$.a', '$.e');
    +---------------------------------------------+
    | JSON_CONTAINS_PATH(@j, 'one', '$.a', '$.e') |
    +---------------------------------------------+
    |                                           1 |
    +---------------------------------------------+
    mysql> SELECT JSON_CONTAINS_PATH(@j, 'all', '$.a', '$.e');
    +---------------------------------------------+
    | JSON_CONTAINS_PATH(@j, 'all', '$.a', '$.e') |
    +---------------------------------------------+
    |                                           0 |
    +---------------------------------------------+
    mysql> SELECT JSON_CONTAINS_PATH(@j, 'one', '$.c.d');
    +----------------------------------------+
    | JSON_CONTAINS_PATH(@j, 'one', '$.c.d') |
    +----------------------------------------+
    |                                      1 |
    +----------------------------------------+
    mysql> SELECT JSON_CONTAINS_PATH(@j, 'one', '$.a.d');
    +----------------------------------------+
    | JSON_CONTAINS_PATH(@j, 'one', '$.a.d') |
    +----------------------------------------+
    |                                      0 |
    +----------------------------------------+
    ```

+   [`JSON_EXTRACT(*`json_doc`*, *`path`*[, *`path`*] ...)`](json-search-functions.html#function_json-extract)

    从 JSON 文档中返回数据，选取由*`path`*参数匹配的部分。如果任何参数为`NULL`或没有路径定位到文档中的值，则返回`NULL`。如果*`json_doc`*参数不是有效的 JSON 文档，或任何*`path`*参数不是有效的路径表达式，则会发生错误。

    返回值由*`path`*参数匹配的所有值组成。如果这些参数可能返回多个值，则匹配的值会自动包装为数组，顺序与产生它们的路径对应。否则，返回值为单个匹配值。

    ```sql
    mysql> SELECT JSON_EXTRACT('[10, 20, [30, 40]]', '$[1]');
    +--------------------------------------------+
    | JSON_EXTRACT('[10, 20, [30, 40]]', '$[1]') |
    +--------------------------------------------+
    | 20                                         |
    +--------------------------------------------+
    mysql> SELECT JSON_EXTRACT('[10, 20, [30, 40]]', '$[1]', '$[0]');
    +----------------------------------------------------+
    | JSON_EXTRACT('[10, 20, [30, 40]]', '$[1]', '$[0]') |
    +----------------------------------------------------+
    | [20, 10]                                           |
    +----------------------------------------------------+
    mysql> SELECT JSON_EXTRACT('[10, 20, [30, 40]]', '$[2][*]');
    +-----------------------------------------------+
    | JSON_EXTRACT('[10, 20, [30, 40]]', '$[2][*]') |
    +-----------------------------------------------+
    | [30, 40]                                      |
    +-----------------------------------------------+
    ```

    MySQL 支持`->`运算符作为此函数的简写，用于左侧是`JSON`列标识符（而不是表达式），右侧是要在列中匹配的 JSON 路径的 2 个参数。

+   `*`column`*->*`path`*`

    当与两个参数一起使用时，`->`运算符在左侧是列标识符，在右侧是针对 JSON 文档（列值）进行评估的 JSON 路径（字符串文字）时，充当`JSON_EXTRACT()`函数的别名。您可以在 SQL 语句中的任何列引用出现的地方使用这样的表达式。

    此处显示的两个`SELECT`语句产生相同的输出：

    ```sql
    mysql> SELECT c, JSON_EXTRACT(c, "$.id"), g
         > FROM jemp
         > WHERE JSON_EXTRACT(c, "$.id") > 1
         > ORDER BY JSON_EXTRACT(c, "$.name");
    +-------------------------------+-----------+------+
    | c                             | c->"$.id" | g    |
    +-------------------------------+-----------+------+
    | {"id": "3", "name": "Barney"} | "3"       |    3 |
    | {"id": "4", "name": "Betty"}  | "4"       |    4 |
    | {"id": "2", "name": "Wilma"}  | "2"       |    2 |
    +-------------------------------+-----------+------+
    3 rows in set (0.00 sec)

    mysql> SELECT c, c->"$.id", g
         > FROM jemp
         > WHERE c->"$.id" > 1
         > ORDER BY c->"$.name";
    +-------------------------------+-----------+------+
    | c                             | c->"$.id" | g    |
    +-------------------------------+-----------+------+
    | {"id": "3", "name": "Barney"} | "3"       |    3 |
    | {"id": "4", "name": "Betty"}  | "4"       |    4 |
    | {"id": "2", "name": "Wilma"}  | "2"       |    2 |
    +-------------------------------+-----------+------+
    3 rows in set (0.00 sec)
    ```

    此功能不仅限于`SELECT`，如下所示：

    ```sql
    mysql> ALTER TABLE jemp ADD COLUMN n INT;
    Query OK, 0 rows affected (0.68 sec)
    Records: 0  Duplicates: 0  Warnings: 0

    mysql> UPDATE jemp SET n=1 WHERE c->"$.id" = "4";
    Query OK, 1 row affected (0.04 sec)
    Rows matched: 1  Changed: 1  Warnings: 0

    mysql> SELECT c, c->"$.id", g, n
         > FROM jemp
         > WHERE JSON_EXTRACT(c, "$.id") > 1
         > ORDER BY c->"$.name";
    +-------------------------------+-----------+------+------+
    | c                             | c->"$.id" | g    | n    |
    +-------------------------------+-----------+------+------+
    | {"id": "3", "name": "Barney"} | "3"       |    3 | NULL |
    | {"id": "4", "name": "Betty"}  | "4"       |    4 |    1 |
    | {"id": "2", "name": "Wilma"}  | "2"       |    2 | NULL |
    +-------------------------------+-----------+------+------+
    3 rows in set (0.00 sec)

    mysql> DELETE FROM jemp WHERE c->"$.id" = "4";
    Query OK, 1 row affected (0.04 sec)

    mysql> SELECT c, c->"$.id", g, n
         > FROM jemp
         > WHERE JSON_EXTRACT(c, "$.id") > 1
         > ORDER BY c->"$.name";
    +-------------------------------+-----------+------+------+
    | c                             | c->"$.id" | g    | n    |
    +-------------------------------+-----------+------+------+
    | {"id": "3", "name": "Barney"} | "3"       |    3 | NULL |
    | {"id": "2", "name": "Wilma"}  | "2"       |    2 | NULL |
    +-------------------------------+-----------+------+------+
    2 rows in set (0.00 sec)
    ```

    (参见为 JSON 列索引创建生成列的索引，用于创建和填充刚刚显示的表的语句。)

    这也适用于 JSON 数组值，如下所示：

    ```sql
    mysql> CREATE TABLE tj10 (a JSON, b INT);
    Query OK, 0 rows affected (0.26 sec)

    mysql> INSERT INTO tj10
         > VALUES ("[3,10,5,17,44]", 33), ("[3,10,5,17,[22,44,66]]", 0);
    Query OK, 1 row affected (0.04 sec)

    mysql> SELECT a->"$[4]" FROM tj10;
    +--------------+
    | a->"$[4]"    |
    +--------------+
    | 44           |
    | [22, 44, 66] |
    +--------------+
    2 rows in set (0.00 sec)

    mysql> SELECT * FROM tj10 WHERE a->"$[0]" = 3;
    +------------------------------+------+
    | a                            | b    |
    +------------------------------+------+
    | [3, 10, 5, 17, 44]           |   33 |
    | [3, 10, 5, 17, [22, 44, 66]] |    0 |
    +------------------------------+------+
    2 rows in set (0.00 sec)
    ```

    支持嵌套数组。如果在目标 JSON 文档中找不到匹配的键，则使用`->`的表达式将评估为`NULL`，如下所示：

    ```sql
    mysql> SELECT * FROM tj10 WHERE a->"$[4][1]" IS NOT NULL;
    +------------------------------+------+
    | a                            | b    |
    +------------------------------+------+
    | [3, 10, 5, 17, [22, 44, 66]] |    0 |
    +------------------------------+------+

    mysql> SELECT a->"$[4][1]" FROM tj10;
    +--------------+
    | a->"$[4][1]" |
    +--------------+
    | NULL         |
    | 44           |
    +--------------+
    2 rows in set (0.00 sec)
    ```

    这与使用`JSON_EXTRACT()`时看到的情况相同：

    ```sql
    mysql> SELECT JSON_EXTRACT(a, "$[4][1]") FROM tj10;
    +----------------------------+
    | JSON_EXTRACT(a, "$[4][1]") |
    +----------------------------+
    | NULL                       |
    | 44                         |
    +----------------------------+
    2 rows in set (0.00 sec)
    ```

+   `*`column`*->>*`path`*`

    这是一个改进的去引号提取运算符。而`->`运算符仅仅提取一个值，`->>`运算符除此之外还去除提取结果的引号。换句话说，给定一个`JSON`列值*`column`*和一个路径表达式*`path`*（一个字符串文字），以下三个表达式返回相同的值：

    +   `JSON_UNQUOTE(` `JSON_EXTRACT(*`column`*, *`path`*) )`

    +   `JSON_UNQUOTE(*`column`*` `->` `*`path`*)`

    +   `*`column`*->>*`path`*`

    `->>`运算符可以在任何允许使用`JSON_UNQUOTE(JSON_EXTRACT())`的地方使用。这包括（但不限于）`SELECT`列表、`WHERE`和`HAVING`子句，以及`ORDER BY`和`GROUP BY`子句。

    接下来的几个语句演示了一些`->>`运算符与**mysql**客户端中其他表达式的等价性：

    ```sql
    mysql> SELECT * FROM jemp WHERE g > 2;
    +-------------------------------+------+
    | c                             | g    |
    +-------------------------------+------+
    | {"id": "3", "name": "Barney"} |    3 |
    | {"id": "4", "name": "Betty"}  |    4 |
    +-------------------------------+------+
    2 rows in set (0.01 sec)

    mysql> SELECT c->'$.name' AS name
     ->     FROM jemp WHERE g > 2;
    +----------+
    | name     |
    +----------+
    | "Barney" |
    | "Betty"  |
    +----------+
    2 rows in set (0.00 sec)

    mysql> SELECT JSON_UNQUOTE(c->'$.name') AS name
     ->     FROM jemp WHERE g > 2;
    +--------+
    | name   |
    +--------+
    | Barney |
    | Betty  |
    +--------+
    2 rows in set (0.00 sec)

    mysql> SELECT c->>'$.name' AS name
     ->     FROM jemp WHERE g > 2;
    +--------+
    | name   |
    +--------+
    | Barney |
    | Betty  |
    +--------+
    2 rows in set (0.00 sec)
    ```

    请参阅为 JSON 列提供索引的生成列索引，了解在刚刚展示的示例集中用于创建和填充`jemp`表的 SQL 语句。

    该运算符也可以与 JSON 数组一起使用，如下所示：

    ```sql
    mysql> CREATE TABLE tj10 (a JSON, b INT);
    Query OK, 0 rows affected (0.26 sec)

    mysql> INSERT INTO tj10 VALUES
     ->     ('[3,10,5,"x",44]', 33),
     ->     ('[3,10,5,17,[22,"y",66]]', 0);
    Query OK, 2 rows affected (0.04 sec)
    Records: 2  Duplicates: 0  Warnings: 0

    mysql> SELECT a->"$[3]", a->"$[4][1]" FROM tj10;
    +-----------+--------------+
    | a->"$[3]" | a->"$[4][1]" |
    +-----------+--------------+
    | "x"       | NULL         |
    | 17        | "y"          |
    +-----------+--------------+
    2 rows in set (0.00 sec)

    mysql> SELECT a->>"$[3]", a->>"$[4][1]" FROM tj10;
    +------------+---------------+
    | a->>"$[3]" | a->>"$[4][1]" |
    +------------+---------------+
    | x          | NULL          |
    | 17         | y             |
    +------------+---------------+
    2 rows in set (0.00 sec)
    ```

    与`->`类似，`->>`运算符在`EXPLAIN`输出中总是展开的，如下例所示：

    ```sql
    mysql> EXPLAIN SELECT c->>'$.name' AS name
     ->     FROM jemp WHERE g > 2\G
    *************************** 1\. row ***************************
               id: 1
      select_type: SIMPLE
            table: jemp
       partitions: NULL
             type: range
    possible_keys: i
              key: i
          key_len: 5
              ref: NULL
             rows: 2
         filtered: 100.00
            Extra: Using where 1 row in set, 1 warning (0.00 sec)

    mysql> SHOW WARNINGS\G
    *************************** 1\. row ***************************
      Level: Note
       Code: 1003
    Message: /* select#1 */ select
    json_unquote(json_extract(`jtest`.`jemp`.`c`,'$.name')) AS `name` from
    `jtest`.`jemp` where (`jtest`.`jemp`.`g` > 2) 1 row in set (0.00 sec)
    ```

    这类似于 MySQL 在相同情况下展开`->`运算符的方式。

+   [`JSON_KEYS(*`json_doc`*[, *`path`*])`](json-search-functions.html#function_json-keys)

    将 JSON 对象的顶级值的键作为 JSON 数组返回，或者如果给定了*`path`*参数，则从所选路径返回顶级键。如果任何参数为`NULL`，*`json_doc`*参数不是对象，或者如果给定了*`path`*，则无法定位对象，则返回`NULL`。如果*`json_doc`*参数不是有效的 JSON 文档，或者*`path`*参数不是有效的路径表达式或包含`*`或`**`通配符，则会发生错误。

    如果所选对象为空，则结果数组为空。如果顶层值有嵌套的子对象，则返回值不包括这些子对象的键。

    ```sql
    mysql> SELECT JSON_KEYS('{"a": 1, "b": {"c": 30}}');
    +---------------------------------------+
    | JSON_KEYS('{"a": 1, "b": {"c": 30}}') |
    +---------------------------------------+
    | ["a", "b"]                            |
    +---------------------------------------+
    mysql> SELECT JSON_KEYS('{"a": 1, "b": {"c": 30}}', '$.b');
    +----------------------------------------------+
    | JSON_KEYS('{"a": 1, "b": {"c": 30}}', '$.b') |
    +----------------------------------------------+
    | ["c"]                                        |
    +----------------------------------------------+
    ```

+   `JSON_OVERLAPS(*`json_doc1`*, *`json_doc2`*)`

    比较两个 JSON 文档。如果两个文档有任何键值对或数组元素相同，则返回 true（1）。如果两个参数都是标量，函数执行简单的相等性测试。如果任一参数为`NULL`，函数返回`NULL`。

    此函数作为 `JSON_CONTAINS()` 的对应函数，要求搜索的数组中的所有元素都存在于搜索的数组中。因此，`JSON_CONTAINS()` 对搜索键执行 `AND` 操作，而 `JSON_OVERLAPS()` 执行 `OR` 操作。

    在 `WHERE` 子句中使用 `JSON_OVERLAPS()` 查询 `InnoDB` 表的 JSON 列可以使用多值索引进行优化。多值索引 提供了详细信息和示例。

    在比较两个数组时，如果它们共享一个或多个数组元素，则 `JSON_OVERLAPS()` 返回真，否则返回假：

    ```sql
    mysql> SELECT JSON_OVERLAPS("[1,3,5,7]", "[2,5,7]");
    +---------------------------------------+
    | JSON_OVERLAPS("[1,3,5,7]", "[2,5,7]") |
    +---------------------------------------+
    |                                     1 |
    +---------------------------------------+
    1 row in set (0.00 sec)

    mysql> SELECT JSON_OVERLAPS("[1,3,5,7]", "[2,6,7]");
    +---------------------------------------+
    | JSON_OVERLAPS("[1,3,5,7]", "[2,6,7]") |
    +---------------------------------------+
    |                                     1 |
    +---------------------------------------+
    1 row in set (0.00 sec)

    mysql> SELECT JSON_OVERLAPS("[1,3,5,7]", "[2,6,8]");
    +---------------------------------------+
    | JSON_OVERLAPS("[1,3,5,7]", "[2,6,8]") |
    +---------------------------------------+
    |                                     0 |
    +---------------------------------------+
    1 row in set (0.00 sec)
    ```

    部分匹配被视为无匹配，如下所示：

    ```sql
    mysql> SELECT JSON_OVERLAPS('[[1,2],[3,4],5]', '[1,[2,3],[4,5]]');
    +-----------------------------------------------------+
    | JSON_OVERLAPS('[[1,2],[3,4],5]', '[1,[2,3],[4,5]]') |
    +-----------------------------------------------------+
    |                                                   0 |
    +-----------------------------------------------------+
    1 row in set (0.00 sec)
    ```

    在比较对象时，如果它们至少有一个键值对相同，则结果为真。

    ```sql
    mysql> SELECT JSON_OVERLAPS('{"a":1,"b":10,"d":10}', '{"c":1,"e":10,"f":1,"d":10}');
    +-----------------------------------------------------------------------+
    | JSON_OVERLAPS('{"a":1,"b":10,"d":10}', '{"c":1,"e":10,"f":1,"d":10}') |
    +-----------------------------------------------------------------------+
    |                                                                     1 |
    +-----------------------------------------------------------------------+
    1 row in set (0.00 sec)

    mysql> SELECT JSON_OVERLAPS('{"a":1,"b":10,"d":10}', '{"a":5,"e":10,"f":1,"d":20}');
    +-----------------------------------------------------------------------+
    | JSON_OVERLAPS('{"a":1,"b":10,"d":10}', '{"a":5,"e":10,"f":1,"d":20}') |
    +-----------------------------------------------------------------------+
    |                                                                     0 |
    +-----------------------------------------------------------------------+
    1 row in set (0.00 sec)
    ```

    如果两个标量用作函数的参数，`JSON_OVERLAPS()` 执行简单的相等性测试：

    ```sql
    mysql> SELECT JSON_OVERLAPS('5', '5');
    +-------------------------+
    | JSON_OVERLAPS('5', '5') |
    +-------------------------+
    |                       1 |
    +-------------------------+
    1 row in set (0.00 sec)

    mysql> SELECT JSON_OVERLAPS('5', '6');
    +-------------------------+
    | JSON_OVERLAPS('5', '6') |
    +-------------------------+
    |                       0 |
    +-------------------------+
    1 row in set (0.00 sec)
    ```

    在将标量与数组进行比较时，`JSON_OVERLAPS()` 会尝试将标量视为数组元素。在此示例中，第二个参数 `6` 被解释为 `[6]`，如下所示：

    ```sql
    mysql> SELECT JSON_OVERLAPS('[4,5,6,7]', '6');
    +---------------------------------+
    | JSON_OVERLAPS('[4,5,6,7]', '6') |
    +---------------------------------+
    |                               1 |
    +---------------------------------+
    1 row in set (0.00 sec)
    ```

    函数不执行类型转换：

    ```sql
    mysql> SELECT JSON_OVERLAPS('[4,5,"6",7]', '6');
    +-----------------------------------+
    | JSON_OVERLAPS('[4,5,"6",7]', '6') |
    +-----------------------------------+
    |                                 0 |
    +-----------------------------------+
    1 row in set (0.00 sec)

    mysql> SELECT JSON_OVERLAPS('[4,5,6,7]', '"6"');
    +-----------------------------------+
    | JSON_OVERLAPS('[4,5,6,7]', '"6"') |
    +-----------------------------------+
    |                                 0 |
    +-----------------------------------+
    1 row in set (0.00 sec)
    ```

    `JSON_OVERLAPS()` 在 MySQL 8.0.17 中添加。

+   [`JSON_SEARCH(*`json_doc`*, *`one_or_all`*, *`search_str`*[, *`escape_char`*[, *`path`*] ...])`](json-search-functions.html#function_json-search)

    返回 JSON 文档中给定字符串的路径。如果 *`json_doc`*、*`search_str`* 或 *`path`* 参数中有任何一个为 `NULL`；文档中不存在 *`path`*；或未找到 *`search_str`*，则返回 `NULL`。如果 *`json_doc`* 参数不是有效的 JSON 文档，任何 *`path`* 参数不是有效的路径表达式，*`one_or_all`* 不是 `'one'` 或 `'all'`，或 *`escape_char`* 不是常量表达式，则会出现错误。

    *`one_or_all`* 参数影响搜索如下：

    +   `'one'`：在第一个匹配后搜索终止并返回一个路径字符串。未定义哪个匹配被视为第一个。

    +   `'all'`：搜索返回所有匹配的路径字符串，以确保不包含重复路径。如果有多个字符串，它们将自动包装为数组。数组元素的顺序是未定义的。

    在 *`search_str`* 搜索字符串参数中，`%` 和 `_` 字符的工作方式与 `LIKE` 运算符相同：`%` 匹配任意数量的字符（包括零个字符），`_` 精确匹配一个字符。

    要在搜索字符串中指定字面上的 `%` 或 `_` 字符，请在其前面加上转义字符。如果 *`escape_char`* 参数缺失或为 `NULL`，则默认为 `\`。否则，*`escape_char`* 必须是一个空的或一个字符的常量。

    有关匹配和转义字符行为的更多信息，请参阅第 14.8.1 节，“字符串比较函数和运算符”中`LIKE`的描述。关于转义字符处理，与`LIKE`行为的不同之处在于，`JSON_SEARCH()`的转义字符必须在编译时评估为常量，而不仅仅在执行时。例如，如果在准备语句中使用`JSON_SEARCH()`，并且使用`?`参数提供了*`escape_char`*参数，则参数值可能在执行时是常量，但在编译时不是。

    *`search_str`*和*`path`*始终被解释为 utf8mb4 字符串，而不管它们的实际编码如何。这是一个已知问题，在 MySQL 8.0.24 中已修复（Bug #32449181）。

    ```sql
    mysql> SET @j = '["abc", [{"k": "10"}, "def"], {"x":"abc"}, {"y":"bcd"}]';

    mysql> SELECT JSON_SEARCH(@j, 'one', 'abc');
    +-------------------------------+
    | JSON_SEARCH(@j, 'one', 'abc') |
    +-------------------------------+
    | "$[0]"                        |
    +-------------------------------+

    mysql> SELECT JSON_SEARCH(@j, 'all', 'abc');
    +-------------------------------+
    | JSON_SEARCH(@j, 'all', 'abc') |
    +-------------------------------+
    | ["$[0]", "$[2].x"]            |
    +-------------------------------+

    mysql> SELECT JSON_SEARCH(@j, 'all', 'ghi');
    +-------------------------------+
    | JSON_SEARCH(@j, 'all', 'ghi') |
    +-------------------------------+
    | NULL                          |
    +-------------------------------+

    mysql> SELECT JSON_SEARCH(@j, 'all', '10');
    +------------------------------+
    | JSON_SEARCH(@j, 'all', '10') |
    +------------------------------+
    | "$[1][0].k"                  |
    +------------------------------+

    mysql> SELECT JSON_SEARCH(@j, 'all', '10', NULL, '$');
    +-----------------------------------------+
    | JSON_SEARCH(@j, 'all', '10', NULL, '$') |
    +-----------------------------------------+
    | "$[1][0].k"                             |
    +-----------------------------------------+

    mysql> SELECT JSON_SEARCH(@j, 'all', '10', NULL, '$[*]');
    +--------------------------------------------+
    | JSON_SEARCH(@j, 'all', '10', NULL, '$[*]') |
    +--------------------------------------------+
    | "$[1][0].k"                                |
    +--------------------------------------------+

    mysql> SELECT JSON_SEARCH(@j, 'all', '10', NULL, '$**.k');
    +---------------------------------------------+
    | JSON_SEARCH(@j, 'all', '10', NULL, '$**.k') |
    +---------------------------------------------+
    | "$[1][0].k"                                 |
    +---------------------------------------------+

    mysql> SELECT JSON_SEARCH(@j, 'all', '10', NULL, '$[*][0].k');
    +-------------------------------------------------+
    | JSON_SEARCH(@j, 'all', '10', NULL, '$[*][0].k') |
    +-------------------------------------------------+
    | "$[1][0].k"                                     |
    +-------------------------------------------------+

    mysql> SELECT JSON_SEARCH(@j, 'all', '10', NULL, '$[1]');
    +--------------------------------------------+
    | JSON_SEARCH(@j, 'all', '10', NULL, '$[1]') |
    +--------------------------------------------+
    | "$[1][0].k"                                |
    +--------------------------------------------+

    mysql> SELECT JSON_SEARCH(@j, 'all', '10', NULL, '$[1][0]');
    +-----------------------------------------------+
    | JSON_SEARCH(@j, 'all', '10', NULL, '$[1][0]') |
    +-----------------------------------------------+
    | "$[1][0].k"                                   |
    +-----------------------------------------------+

    mysql> SELECT JSON_SEARCH(@j, 'all', 'abc', NULL, '$[2]');
    +---------------------------------------------+
    | JSON_SEARCH(@j, 'all', 'abc', NULL, '$[2]') |
    +---------------------------------------------+
    | "$[2].x"                                    |
    +---------------------------------------------+

    mysql> SELECT JSON_SEARCH(@j, 'all', '%a%');
    +-------------------------------+
    | JSON_SEARCH(@j, 'all', '%a%') |
    +-------------------------------+
    | ["$[0]", "$[2].x"]            |
    +-------------------------------+

    mysql> SELECT JSON_SEARCH(@j, 'all', '%b%');
    +-------------------------------+
    | JSON_SEARCH(@j, 'all', '%b%') |
    +-------------------------------+
    | ["$[0]", "$[2].x", "$[3].y"]  |
    +-------------------------------+

    mysql> SELECT JSON_SEARCH(@j, 'all', '%b%', NULL, '$[0]');
    +---------------------------------------------+
    | JSON_SEARCH(@j, 'all', '%b%', NULL, '$[0]') |
    +---------------------------------------------+
    | "$[0]"                                      |
    +---------------------------------------------+

    mysql> SELECT JSON_SEARCH(@j, 'all', '%b%', NULL, '$[2]');
    +---------------------------------------------+
    | JSON_SEARCH(@j, 'all', '%b%', NULL, '$[2]') |
    +---------------------------------------------+
    | "$[2].x"                                    |
    +---------------------------------------------+

    mysql> SELECT JSON_SEARCH(@j, 'all', '%b%', NULL, '$[1]');
    +---------------------------------------------+
    | JSON_SEARCH(@j, 'all', '%b%', NULL, '$[1]') |
    +---------------------------------------------+
    | NULL                                        |
    +---------------------------------------------+

    mysql> SELECT JSON_SEARCH(@j, 'all', '%b%', '', '$[1]');
    +-------------------------------------------+
    | JSON_SEARCH(@j, 'all', '%b%', '', '$[1]') |
    +-------------------------------------------+
    | NULL                                      |
    +-------------------------------------------+

    mysql> SELECT JSON_SEARCH(@j, 'all', '%b%', '', '$[3]');
    +-------------------------------------------+
    | JSON_SEARCH(@j, 'all', '%b%', '', '$[3]') |
    +-------------------------------------------+
    | "$[3].y"                                  |
    +-------------------------------------------+
    ```

    有关 MySQL 支持的 JSON 路径语法的更多信息，包括控制通配符`*`和`**`的规则，请参阅 JSON 路径语法。

+   `JSON_VALUE(*`json_doc`*, *`path`*)`

    从指定文档中给定路径提取值，并返回提取的值，可选择将其转换为所需类型。完整的语法如下所示：

    ```sql
    JSON_VALUE(*json_doc*, *path* [RETURNING *type*] [*on_empty*] [*on_error*])

    *on_empty*:
        {NULL | ERROR | DEFAULT *value*} ON EMPTY

    *on_error*:
        {NULL | ERROR | DEFAULT *value*} ON ERROR
    ```

    *`json_doc`*是一个有效的 JSON 文档。如果为`NULL`，函数将返回`NULL`。

    *`path`*是指向文档中位置的 JSON 路径。这必须是一个字符串文字值。

    *`type`*是以下数据类型之一：

    +   `FLOAT`

    +   `DOUBLE`

    +   `DECIMAL`

    +   `SIGNED`

    +   `UNSIGNED`

    +   `DATE`

    +   `TIME`

    +   `DATETIME`

    +   `YEAR`（MySQL 8.0.22 及更高版本）

        不支持一位或两位数字的`YEAR`值。

    +   `CHAR`

    +   `JSON`

    刚列出的类型与`CAST()`函数支持的（非数组）类型相同。

    如果没有由 `RETURNING` 子句指定，`JSON_VALUE()` 函数的返回类型为 `VARCHAR(512)`。当没有为返回类型指定字符集时，`JSON_VALUE()` 使用带有二进制排序规则的 `utf8mb4`；如果指定 `utf8mb4` 作为结果的字符集，则服务器使用此字符集的默认排序规则，这是不区分大小写的。

    当指定路径处的数据由 JSON 空字面量组成或解析为 JSON 空字面量时，该函数返回 SQL `NULL`。

    *`on_empty`*，如果指定，确定了当在给定路径找不到数据时 `JSON_VALUE()` 的行为；此子句可以取以下值：

    +   `NULL ON EMPTY`: 函数返回 `NULL`；这是默认的 `ON EMPTY` 行为。

    +   `DEFAULT *`value`* ON EMPTY`: 返回提供的 *`value`*。该值的类型必须与返回类型匹配。

    +   `ERROR ON EMPTY`: 函数抛出错误。

    如果使用，*`on_error`* 可以取以下值，当发生错误时会有相应的结果，如下所列：

    +   `NULL ON ERROR`: `JSON_VALUE()` 返回 `NULL`；如果没有使用 `ON ERROR` 子句，则这是默认行为。

    +   `DEFAULT *`value`* ON ERROR`: 这是返回的值；其值必须与返回类型匹配。

    +   `ERROR ON ERROR`: 抛出错误。

    如果使用 `ON EMPTY`，必须在任何 `ON ERROR` 子句之前。指定错误的顺序会导致语法错误。

    **错误处理。** 一般来说，`JSON_VALUE()` 处理错误如下：

    +   所有 JSON 输入（文档和路径）都会被检查其有效性。如果其中任何部分无效，则会抛出 SQL 错误，而不会触发 `ON ERROR` 子句。

    +   当发生以下事件之一时触发 `ON ERROR`：

        +   尝试提取对象或数组，例如由解析为 JSON 文档中多个位置的路径导致的对象或数组

        +   转换错误，例如尝试将 `'asdf'` 转换为 `UNSIGNED` 值

        +   值的截断

    +   即使指定了 `NULL ON ERROR` 或 `DEFAULT ... ON ERROR`，转换错误始终会触发警告。

    +   当源 JSON 文档（*`expr`*）在指定位置（*`path`*）不包含数据时，会触发 `ON EMPTY` 子句。

    `JSON_VALUE()` 在 MySQL 8.0.21 中引入。

    **示例。** 这里展示了两个简单的示例：

    ```sql
    mysql> SELECT JSON_VALUE('{"fname": "Joe", "lname": "Palmer"}', '$.fname');
    +--------------------------------------------------------------+
    | JSON_VALUE('{"fname": "Joe", "lname": "Palmer"}', '$.fname') |
    +--------------------------------------------------------------+
    | Joe                                                          |
    +--------------------------------------------------------------+

    mysql> SELECT JSON_VALUE('{"item": "shoes", "price": "49.95"}', '$.price'
     -> RETURNING DECIMAL(4,2)) AS price;
    +-------+
    | price |
    +-------+
    | 49.95 |
    +-------+
    ```

    语句 `SELECT JSON_VALUE(*`json_doc`*, *`path`* RETURNING *`type`*)` 等同于以下语句：

    ```sql
    SELECT CAST(
        JSON_UNQUOTE( JSON_EXTRACT(*json_doc*, *path*) )
        AS *type*
    );
    ```

    `JSON_VALUE()` 简化了在 JSON 列上创建索引的过程，因为在许多情况下不需要创建一个生成列，然后在生成列上创建索引。您可以在创建具有 `JSON` 列的表 `t1` 时，通过在使用 `JSON_VALUE()` 操作该列（使用与该列中值匹配的路径）的表达式上创建索引来实现这一点，如下所示：

    ```sql
    CREATE TABLE t1(
        j JSON,
        INDEX i1 ( (JSON_VALUE(j, '$.id' RETURNING UNSIGNED)) )
    );
    ```

    以下`EXPLAIN`输出显示，针对`t1`的查询在`WHERE`子句中使用索引表达式，使用了创建的索引：

    ```sql
    mysql> EXPLAIN SELECT * FROM t1
     ->     WHERE JSON_VALUE(j, '$.id' RETURNING UNSIGNED) = 123\G
    *************************** 1\. row ***************************
               id: 1
      select_type: SIMPLE
            table: t1
       partitions: NULL
             type: ref
    possible_keys: i1
              key: i1
          key_len: 9
              ref: const
             rows: 1
         filtered: 100.00
            Extra: NULL
    ```

    这实现了与在生成列上创建具有索引的表`t2`（请参见为 JSON 列提供索引的生成列索引）几乎相同的效果，如下所示：

    ```sql
    CREATE TABLE t2 (
        j JSON,
        g INT GENERATED ALWAYS AS (j->"$.id"),
        INDEX i1 (g)
    );
    ```

    针对这个表的查询的`EXPLAIN`输出，引用生成的列，显示索引的使用方式与针对表`t1`的先前查询相同：

    ```sql
    mysql> EXPLAIN SELECT * FROM t2 WHERE g  = 123\G
    *************************** 1\. row ***************************
               id: 1
      select_type: SIMPLE
            table: t2
       partitions: NULL
             type: ref
    possible_keys: i1
              key: i1
          key_len: 5
              ref: const
             rows: 1
         filtered: 100.00
            Extra: NULL
    ```

    有关在生成列上使用索引对 JSON 列进行间接索引的信息，请参见为 JSON 列提供索引的生成列索引。

+   `*`value`* MEMBER OF(*`json_array`*)`

    如果*`value`*是*`json_array`*的元素，则返回 true（1），否则返回 false（0）。*`value`*必须是标量或 JSON 文档；如果它是标量，运算符会尝试将其视为 JSON 数组的元素。如果*`value`*或*`json_array`*是*`NULL`*，函数将返回*`NULL`*。

    在`WHERE`子句中对`InnoDB`表的 JSON 列使用`MEMBER OF()`查询可以通过使用多值索引进行优化。有关详细信息和示例，请参见多值索引。

    简单标量被视为数组值，如下所示：

    ```sql
    mysql> SELECT 17 MEMBER OF('[23, "abc", 17, "ab", 10]');
    +-------------------------------------------+
    | 17 MEMBER OF('[23, "abc", 17, "ab", 10]') |
    +-------------------------------------------+
    |                                         1 |
    +-------------------------------------------+
    1 row in set (0.00 sec)

    mysql> SELECT 'ab' MEMBER OF('[23, "abc", 17, "ab", 10]');
    +---------------------------------------------+
    | 'ab' MEMBER OF('[23, "abc", 17, "ab", 10]') |
    +---------------------------------------------+
    |                                           1 |
    +---------------------------------------------+
    1 row in set (0.00 sec)
    ```

    部分匹配数组元素值不匹配：

    ```sql
    mysql> SELECT 7 MEMBER OF('[23, "abc", 17, "ab", 10]');
    +------------------------------------------+
    | 7 MEMBER OF('[23, "abc", 17, "ab", 10]') |
    +------------------------------------------+
    |                                        0 |
    +------------------------------------------+
    1 row in set (0.00 sec)
    ```

    ```sql
    mysql> SELECT 'a' MEMBER OF('[23, "abc", 17, "ab", 10]');
    +--------------------------------------------+
    | 'a' MEMBER OF('[23, "abc", 17, "ab", 10]') |
    +--------------------------------------------+
    |                                          0 |
    +--------------------------------------------+
    1 row in set (0.00 sec)
    ```

    不执行到字符串类型的转换：

    ```sql
    mysql> SELECT
     -> 17 MEMBER OF('[23, "abc", "17", "ab", 10]'),
     -> "17" MEMBER OF('[23, "abc", 17, "ab", 10]')\G
    *************************** 1\. row ***************************
    17 MEMBER OF('[23, "abc", "17", "ab", 10]'): 0
    "17" MEMBER OF('[23, "abc", 17, "ab", 10]'): 0 1 row in set (0.00 sec)
    ```

    要使用这个运算符与一个本身是数组的值，必须将其显式转换为 JSON 数组。您可以使用`CAST(... AS JSON)`来实现这一点：

    ```sql
    mysql> SELECT CAST('[4,5]' AS JSON) MEMBER OF('[[3,4],[4,5]]');
    +--------------------------------------------------+
    | CAST('[4,5]' AS JSON) MEMBER OF('[[3,4],[4,5]]') |
    +--------------------------------------------------+
    |                                                1 |
    +--------------------------------------------------+
    1 row in set (0.00 sec)
    ```

    还可以使用`JSON_ARRAY()`函数执行必要的转换，如下所示：

    ```sql
    mysql> SELECT JSON_ARRAY(4,5) MEMBER OF('[[3,4],[4,5]]');
    +--------------------------------------------+
    | JSON_ARRAY(4,5) MEMBER OF('[[3,4],[4,5]]') |
    +--------------------------------------------+
    |                                          1 |
    +--------------------------------------------+
    1 row in set (0.00 sec)
    ```

    任何用作要测试的值或出现在目标数组中的 JSON 对象必须使用`CAST(... AS JSON)`或`JSON_OBJECT()`强制转换为正确的类型。此外，包含 JSON 对象的目标数组必须使用`JSON_ARRAY`进行转换。下面的语句序列演示了这一点：

    ```sql
    mysql> SET @a = CAST('{"a":1}' AS JSON);
    Query OK, 0 rows affected (0.00 sec)

    mysql> SET @b = JSON_OBJECT("b", 2);
    Query OK, 0 rows affected (0.00 sec)

    mysql> SET @c = JSON_ARRAY(17, @b, "abc", @a, 23);
    Query OK, 0 rows affected (0.00 sec)

    mysql> SELECT @a MEMBER OF(@c), @b MEMBER OF(@c);
    +------------------+------------------+
    | @a MEMBER OF(@c) | @b MEMBER OF(@c) |
    +------------------+------------------+
    |                1 |                1 |
    +------------------+------------------+
    1 row in set (0.00 sec)
    ```

    `MEMBER OF()`运算符在 MySQL 8.0.17 中添加。
