# 10.3.1 MySQL 如何使用索引

> 原文：[`dev.mysql.com/doc/refman/8.0/en/mysql-indexes.html`](https://dev.mysql.com/doc/refman/8.0/en/mysql-indexes.html)

索引用于快速查找具有特定列值的行。没有索引，MySQL 必须从第一行开始，然后读取整个表以找到相关行。表越大，成本越高。如果表中有涉及的列的索引，MySQL 可以快速确定在数据文件中要查找的位置，而无需查看所有数据。这比顺序读取每一行要快得多。

大多数 MySQL 索引（`PRIMARY KEY`、`UNIQUE`、`INDEX`和`FULLTEXT`）存储在 B-trees 中。例外情况：空间数据类型的索引使用 R-trees；`MEMORY`表还支持 hash 索引；`InnoDB`对`FULLTEXT`索引使用倒排列表。

一般来说，索引的使用如下所述。哈希索引（用于`MEMORY`表中）的特性在第 10.3.9 节“B-Tree 和 Hash 索引的比较”中描述。

MySQL 在以下操作中使用索引：

+   快速查找与`WHERE`子句匹配的行。

+   要消除考虑的行。如果存在多个索引选择，MySQL 通常使用找到最少行数（最具选择性的索引）的索引。

+   如果表具有多列索引，则优化器可以使用索引的任何最左前缀来查找行。例如，如果在`(col1, col2, col3)`上有一个三列索引，则可以在`(col1)`、`(col1, col2)`和`(col1, col2, col3)`上进行索引搜索。有关更多信息，请参见第 10.3.6 节“多列索引”。

+   在执行连接时从其他表中检索行。如果声明为相同类型和大小的列，MySQL 可以更有效地使用列上的索引。在这种情况下，如果它们声明为相同大小，则`VARCHAR`和`CHAR`被视为相同。例如，`VARCHAR(10)`和`CHAR(10)`是相同大小，但`VARCHAR(10)`和`CHAR(15)`不是。

    对于非二进制字符串列之间的比较，两列应使用相同的字符集。例如，将`utf8mb4`列与`latin1`列进行比较会排除索引的使用。

    比较不同类型的列（例如将字符串列与时间或数字列进行比较）可能会阻止使用索引，如果值不能直接进行比较而需要转换。对于数字列中的给定值，例如`1`，它可能与字符串列中的任意数量的值相等，例如`'1'`，`' 1'`，`'00001'`或`'01.e1'`。这排除了对字符串列使用任何索引。

+   要查找特定索引列*`key_col`*的`MIN()`或`MAX()`值。这是通过预处理器进行优化的，它会检查您是否在索引中使用了`WHERE *`key_part_N`* = *`constant`*`，其中*`key_col`*之前的所有关键部分。在这种情况下，MySQL 对每个`MIN()`或`MAX()`表达式进行单个关键查找，并将其替换为常量。如果所有表达式都被常量替换，查询将立即返回。例如：

    ```sql
    SELECT MIN(*key_part2*),MAX(*key_part2*)
      FROM *tbl_name* WHERE *key_part1*=10;
    ```

+   要对表进行排序或分组，如果排序或分组是在可用索引的最左前缀上完成的（例如，`ORDER BY *`key_part1`*, *`key_part2`*`）。如果所有关键部分后面都跟着`DESC`，则按相反顺序读取关键字。 （或者，如果索引是降序索引，则按正向顺序读取关键字。）请参见 Section 10.2.1.16，“ORDER BY Optimization”，Section 10.2.1.17，“GROUP BY Optimization”和 Section 10.3.13，“Descending Indexes”。

+   在某些情况下，可以优化查询以在不查看数据行的情况下检索值。（为查询提供所有必要结果的索引称为覆盖索引。）如果查询仅使用了某个索引中包含的列，那么所选值可以从索引树中检索以提高速度：

    ```sql
    SELECT *key_part3* FROM *tbl_name*
      WHERE *key_part1*=1
    ```

对于小表或大表的查询，其中报表查询处理大部分或全部行，索引不那么重要。当查询需要访问大部分行时，顺序读取比通过索引逐个查找更快。顺序读取最小化磁盘寻址，即使查询不需要所有行。有关详细信息，请参见 Section 10.2.1.23，“Avoiding Full Table Scans”。
