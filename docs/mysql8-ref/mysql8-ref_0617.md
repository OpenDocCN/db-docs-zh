# 10.10.3 预处理语句和存储程序的缓存

> 原文：[`dev.mysql.com/doc/refman/8.0/en/statement-caching.html`](https://dev.mysql.com/doc/refman/8.0/en/statement-caching.html)

对于客户端可能在会话期间多次执行的某些语句，服务器会将语句转换为内部结构并缓存该结构以在执行期间使用。缓存使服务器能够更高效地执行，因为它避免了在会话期间再次需要语句时重新转换语句的开销。对这些语句进行转换和缓存：

+   预处理语句，无论是在 SQL 级别（使用`PREPARE`语句）处理的还是使用二进制客户端/服务器协议（使用`mysql_stmt_prepare()` C API 函数）处理的。`max_prepared_stmt_count`系统变量控制服务器缓存的语句总数。（所有会话中预处理语句数量的总和。）

+   存储程序（存储过程和函数、触发器和事件）。在这种情况下，服务器会转换并缓存整个程序体。`stored_program_cache`系统变量指示服务器每个会话缓存的存储程序的大致数量。

服务器在每个会话基础上维护预处理语句和存储程序的缓存。为一个会话缓存的语句对其他会话不可访问。当会话结束时，服务器会丢弃为其缓存的任何语句。

当服务器使用缓存的内部语句结构时，必须注意结构不会过时。对象的元数据更改可能会导致语句使用的对象的当前定义与内部语句结构中表示的定义不匹配。元数据更改会发生在 DDL 语句中，比如创建、删除、修改、重命名或截断表，或者分析、优化或修复表。表内容的更改（例如，使用`INSERT`或`UPDATE`）不会更改元数据，也不会更改`SELECT`语句。

这里是问题的示例。假设客户端准备了这个语句：

```sql
PREPARE s1 FROM 'SELECT * FROM t1';
```

`SELECT *`在内部结构中扩展为表中的列列表。如果使用`ALTER TABLE`修改表中的列集，那么预处理语句就会过时。如果服务器在客户端下次执行`s1`时没有检测到这个更改，预处理语句将返回不正确的结果。

为了避免由于预处理语句引用的表或视图的元数据更改而引起的问题，服务器会检测这些更改，并在下次执行时自动重新准备该语句。也就是说，服务器会重新解析该语句并重建内部结构。在引用的表或视图从表定义缓存中刷新时，也会重新解析，无论是隐式地为新条目腾出缓存空间，还是显式地由于`FLUSH TABLES`。

类似地，如果存储程序使用的对象发生更改，服务器会重新解析程序中受影响的语句。

服务器还会检测表达式中对象的元数据更改。这些对象可能被存储程序特定语句使用，例如`DECLARE CURSOR`或流程控制语句，如`IF`，`CASE`和`RETURN`。

为了避免重新解析整个存储程序，服务器仅在需要时重新解析程序中受影响的语句或表达式。例如：

+   假设表或视图的元数据发生更改。程序中访问该表或视图的`SELECT *`将重新解析，但不会重新解析不访问该表或视图的`SELECT *`。

+   当语句受到影响时，服务器会尽可能部分重新解析它。考虑这个`CASE`语句：

    ```sql
    CASE *case_expr*
      WHEN *when_expr1* ...
      WHEN *when_expr2* ...
      WHEN *when_expr3* ...
      ...
    END CASE
    ```

    如果元数据更改仅影响`WHEN *`when_expr3`*`，那么该表达式将被重新解析。*`case_expr`*和其他`WHEN`表达式不会被重新解析。

重新解析使用了最初转换为内部形式时生效的默认数据库和 SQL 模式。

服务器尝试重新解析最多三次。如果所有尝试都失败，则会发生错误。

重新解析是自动的，但在发生时，会降低预处理语句和存储程序的性能。

对于预处理语句，`Com_stmt_reprepare`状态变量跟踪重新准备的次数。
