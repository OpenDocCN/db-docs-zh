> 译文：[`dev.mysql.com/doc/refman/8.0/en/replication-rbr-safe-unsafe.html`](https://dev.mysql.com/doc/refman/8.0/en/replication-rbr-safe-unsafe.html)

#### 19.2.1.3 二进制日志中安全和不安全语句的确定

在 MySQL 复制中，一个语句的“安全性”指的是该语句及其效果是否可以使用基于语句的格式正确复制。如果这对于该语句是正确的，我们将该语句称为安全的；否则，我们将其称为不安全的。

通常情况下，如果一个语句是确定性的，那么它就是安全的；如果不是，则是不安全的。然而，某些非确定性函数*不*被视为不安全（请参见非确定性函数不被视为不安全，本节后面的内容）。此外，使用浮点数数学函数结果的语句——这些函数是依赖于硬件的——总是被视为不安全（请参见第 19.5.1.12 节，“复制和浮点值”）。

**安全和不安全语句的处理。** 一个语句的处理方式取决于该语句是否被视为安全，并且与二进制日志格式有关（即，`binlog_format`的当前值）。

+   在使用基于行的日志记录时，对于安全和不安全的语句没有区别对待。

+   在使用混合格式日志记录时，被标记为不安全的语句将使用基于行的格式记录；被视为安全的语句将使用基于语句的格式记录。

+   在使用基于语句的日志记录时，被标记为不安全的语句会生成相应的警告。安全的语句会正常记录。

每个被标记为不安全的语句都会生成一个警告。如果在源端执行了大量这样的语句，这可能导致错误日志文件过大。为了防止这种情况发生，MySQL 有一个警告抑制机制。每当在任何 50 秒内生成的最近 50 个`ER_BINLOG_UNSAFE_STATEMENT`警告超过 50 次时，警告抑制就会被启用。一旦激活，这将导致这类警告不会被写入错误日志；相反，对于每 50 个这种类型的警告，错误日志中会写入一个注释`最后一个警告在最近的*`N`*秒内重复了*`S`*次`。只要最近的 50 个这样的警告在 50 秒内或更短的时间内发出，这将继续进行；一旦速率降低到低于此阈值，警告将再次正常记录。警告抑制对于决定基于语句的日志记录中语句的安全性，以及如何将警告发送给客户端没有影响。MySQL 客户端仍然会为每个这样的语句接收一个警告。

更多信息，请参见 Section 19.2.1, “Replication Formats”。

**被视为不安全的语句。** 具有以下特征的语句被视为不安全：

+   **包含可能在副本上返回不同值的系统函数的语句。** 这些函数包括`FOUND_ROWS()`, `GET_LOCK()`, `IS_FREE_LOCK()`, `IS_USED_LOCK()`, `LOAD_FILE()`, `MASTER_POS_WAIT()`, `RAND()`, `RELEASE_LOCK()`, `ROW_COUNT()`, `SESSION_USER()`, `SLEEP()`, `SOURCE_POS_WAIT()`, `SYSDATE()`, `SYSTEM_USER()`, `USER()`, `UUID()`, 和 `UUID_SHORT()`。

    **非确定性函数不被视为不安全。** 尽管这些函数不是确定性的，但在记录和复制的目的上被视为安全：`CONNECTION_ID()`, `CURDATE()`, `CURRENT_DATE()`, `CURRENT_TIME()`, `CURRENT_TIMESTAMP()`, `CURTIME()`,, `LAST_INSERT_ID()`, `LOCALTIME()`, `LOCALTIMESTAMP()`, `NOW()`, `UNIX_TIMESTAMP()`, `UTC_DATE()`, `UTC_TIME()`, 和 `UTC_TIMESTAMP()`。

    更多信息，请参见 Section 19.5.1.14, “Replication and System Functions”。

+   **系统变量的引用。** 大多数系统变量在基于语句的格式下无法正确复制。参见 Section 19.5.1.39, “复制和变量”。特殊情况请参见 Section 7.4.4.3, “混合二进制日志格式”。

+   **可加载函数。** 由于我们无法控制可加载函数的操作，因此必须假定它执行不安全的语句。

+   **全文插件。** 此插件在不同的 MySQL 服务器上可能表现不同；因此，依赖于它的语句可能会产生不同的结果。因此，在 MySQL 中，所有依赖全文插件的语句都被视为不安全。

+   **触发器或存储过程更新具有 AUTO_INCREMENT 列的表。** 这是不安全的，因为更新行的顺序可能在源和副本上不同。

    此外，对具有包含不是此复合键的第一列的 AUTO_INCREMENT 列的复合主键的表进行`INSERT`是不安全的。

    更多信息，请参见 Section 19.5.1.1, “复制和 AUTO_INCREMENT”。

+   **对具有多个主键或唯一键的表执行 INSERT ... ON DUPLICATE KEY UPDATE 语句。** 当针对包含多个主键或唯一键的表执行此语句时，此语句被视为不安全，因为存储引擎检查键的顺序是不确定的，MySQL 服务器更新的行取决于此顺序。

    对于具有多个唯一或主键的表进行`INSERT ... ON DUPLICATE KEY UPDATE`语句在基于语句的复制中被标记为不安全。 (Bug #11765650, Bug #58637)

+   **使用 LIMIT 进行更新。** 检索行的顺序未指定，因此被视为不安全。参见 Section 19.5.1.18, “复制和 LIMIT”。

+   **访问或引用日志表。** 系统日志表的内容可能在源和副本之间不同。

+   **事务操作后的非事务操作。** 在事务中，允许任何非事务读取或写入在任何事务读取或写入之后执行被视为不安全。

    更多信息，请参见 Section 19.5.1.35, “复制和事务”。

+   **访问或引用自记录表。** 对自记录表的所有读取和写入都被视为不安全。在事务中，对自记录表的读取或写入后的任何语句也被视为不安全。

+   **LOAD DATA 语句。** `LOAD DATA`被视为不安全，当`binlog_format=MIXED`时，该语句以基于行的格式记录。当`binlog_format=STATEMENT`时，`LOAD DATA`不会生成警告，与其他不安全语句不同。

+   **XA 事务。** 如果在源端并行提交的两个 XA 事务在副本上以相反顺序准备，那么在基于语句的复制中可能会出现无法安全解决的锁定依赖关系，并且可能导致副本上的复制失败并发生死锁。当`binlog_format=STATEMENT`时，XA 事务内的 DML 语句被标记为不安全并生成警告。当`binlog_format=MIXED`或`binlog_format=ROW`时，XA 事务内的 DML 语句使用基于行的复制记录，并且潜在问题不存在。

+   **`DEFAULT`子句指的是一个不确定性函数。** 如果表达式的默认值指向一个不确定性函数，任何导致表达式被评估的语句对于基于语句的复制都是不安全的。这包括诸如`INSERT`、`UPDATE`和`ALTER TABLE`等语句。与大多数其他不安全语句不同，这类语句在基于行的格式中无法安全复制。当`binlog_format`设置为`STATEMENT`时，该语句被记录并执行，但会在错误日志中写入警告消息。当`binlog_format`设置为`MIXED`或`ROW`时，该语句不会被执行，并且会在错误日志中写入错误消息。有关显式默认值处理的更多信息，请参见 MySQL 8.0.13 中的显式默认值处理。

更多信息，请参见第 19.5.1 节，“复制功能和问题”。
