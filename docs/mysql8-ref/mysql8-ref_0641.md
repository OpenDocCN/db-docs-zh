# 10.14.3 常规线程状态

> 原文：[`dev.mysql.com/doc/refman/8.0/en/general-thread-states.html`](https://dev.mysql.com/doc/refman/8.0/en/general-thread-states.html)

以下列表描述了与一般查询处理相关的线程`State`值，而���是更专业的活动，如复制。其中许多仅用于在服务器中查找错误。

+   `创建后`

    当线程创建表（包括内部临时表）时，会发生这种情况，在创建表的函数结束时。即使由于某些错误而无法创建表，也会使用此状态。

+   `修改表`

    服务器正在执行原地`ALTER TABLE`的过程中。

+   `分析中`

    线程正在计算`MyISAM`表的键分布（例如，对于`ANALYZE TABLE`）。

+   `检查权限`

    线程正在检查服务器是否具有执行该语句所需的权限。

+   `检查表`

    线程正在执行表检查操作。

+   `清理中`

    线程已处理完一个命令，并准备释放内存并重置某些状态变量。

+   `关闭表`

    线程正在将更改的表数据刷新到磁盘并关闭已使用的表。这应该是一个快速操作。如果不是，请验证您的磁盘没有满，并且磁盘没有被大量使用。

+   `提交更改表到存储引擎`

    服务器已完成一个原地`ALTER TABLE`并正在提交结果。

+   `将 HEAP 转换为磁盘`

    线程正在将内部临时表从`MEMORY`表转换为磁盘上的表。

+   `复制到临时表`

    线程正在处理一个`ALTER TABLE`语句。此状态发生在具有新结构的表已创建但在将行复制到其中之前。

    对于处于此状态的线程，性能模式可用于获取有关复制操作进度的信息。请参阅第 29.12.5 节，“性能模式阶段事件表”。

+   `复制到组表`

    如果语句具有不同的`ORDER BY`和`GROUP BY`标准，则按组排序行并复制到临时表。

+   `复制到临时表`

    服务器正在将数据复制到内存中的临时表。

+   `复制到磁盘上的临时表`

    服务器正在将数据复制到磁盘上的临时表。临时结果集变得太大（请参阅第 10.4.4 节，“MySQL 中的内部临时表使用”）。因此，线程正在将临时表从内存转换为基于磁盘的格式以节省内存。

+   `创建索引`

    线程正在为`MyISAM`表处理`ALTER TABLE ... ENABLE KEYS`。

+   `创建排序索引`

    线程正在处理使用内部临时表解析的`SELECT`。

+   `创建表`

    线程正在创建表。这包括创建临时表。

+   `创建临时表`

    线程正在内存或磁盘上创建临时表。如果表是在内存中创建的，但后来转换为磁盘表，那么在该操作期间的状态是`复制到磁盘上的临时表`。

+   `从主表中删除`

    服务器正在执行多表删除的第一部分。仅从第一个表中删除，并保存列和偏移量以用于从其他（参考）表中删除。

+   `从参考表中删除`

    服务器正在执行多表删除的第二部分，并从其他表中删除匹配的行。

+   `discard_or_import_tablespace`

    线程正在处理`ALTER TABLE ... DISCARD TABLESPACE`或`ALTER TABLE ... IMPORT TABLESPACE`语句。

+   `end`

    在执行`ALTER TABLE`、`CREATE VIEW`、`DELETE`、`INSERT`、`SELECT`或`UPDATE`语句的清理之前发生。

    对于`end`状态，可能正在进行以下操作：

    +   将事件写入二进制日志

    +   释放内存缓冲区，包括 blob

+   `执行中`

    线程已开始执行语句。

+   `执行 init_command`

    线程正在执行`init_command`系统变量值中的语句。

+   `释放项目`

    线程已执行命令。通常在此状态之后是`清理`。

+   `FULLTEXT 初始化`

    服务器正在准备执行自然语言全文搜索。

+   `初始化`

    在执行`ALTER TABLE`、`DELETE`、`INSERT`、`SELECT`或`UPDATE`语句的初始化之前发生。服务器在此状态下采取的操作包括刷新二进制日志和`InnoDB`日志。

+   `已终止`

    有人向线程发送了`KILL`语句，并且线程应该在下次检查终止标志时中止。在 MySQL 的每个主要循环中检查该标志，但在某些情况下，线程可能仍需要一段时间才能终止。如果线程被其他线程锁定，那么终止将在其他线程释放锁定时立即生效。

+   `锁定系统表`

    线程正在尝试锁定系统表（例如，时区或日志表）。

+   `记录慢查询`

    线程正在将语句写入慢查询日志。

+   `登录`

    连接线程的初始状态，直到客户端成功验证。

+   `管理键`

    服务器正在启用或禁用表索引。

+   `打开系统表`

    线程正在尝试打开一个系统表（例如，时区或日志表）。

+   `打开表`

    线程正在尝试打开一个表。这应该是一个非常快速的过程，除非有什么阻止打开。例如，一个`ALTER TABLE`或`LOCK TABLE`语句可能会阻止打开一个表，直到语句执行完毕。还值得检查您的`table_open_cache`��是否足够大。

    对于系统表，使用`打开系统表`状态。

+   `优化`

    服务器正在为查询执行初始优化。

+   `准备中`

    这种状态发生在查询优化期间。

+   `准备修改表`

    服务器正在准备执行一个原地`ALTER TABLE`。

+   `清除旧的中继日志`

    线程正在删除不需要的中继日志文件。

+   `查询结束`

    这种状态发生在处理查询之后但在`释放项目`状态之前。

+   `从客户端接收`

    服务器正在从客户端读取一个数据包。

+   `移除重复项`

    查询使用`SELECT DISTINCT`的方式使得 MySQL 无法在早期阶段优化去除重复操作。因此，MySQL 需要额外的阶段在将结果发送给客户端之前去除所有重复行。

+   `移除临时表`

    线程在处理`SELECT`语句后正在移除内部临时表。如果没有创建临时表，则不使用此状态。

+   `重命名`

    线程正在重命名一个表。

+   `重命名结果表`

    线程正在处理一个`ALTER TABLE`语句，已创建新表，并正在将其重命名以替换原始表。

+   `重新打开表`

    线程为表获取了锁，但在获取锁后注意到底层表结构发生了变化。它已释放锁，关闭表，并尝试重新打开它。

+   `排序修复`

    修复代码正在使用排序来创建索引。

+   `修复完成`

    线程已完成对`MyISAM`表的多线程修复。

+   `使用键缓存进行修复`

    修复代码正在通过键缓存逐个创建键。这比`排序修复`要慢得多。

+   `回滚`

    线程正在回滚一个事务。

+   `保存状态`

    对于`MyISAM`表操作，如修复或分析，线程正在将新表状态保存到`.MYI`文件头。状态包括诸如行数、`AUTO_INCREMENT`计数器和键分布等信息。

+   `搜索要更新的行`

    线程在更新之前执行第一阶段以查找所有匹配的行。如果`UPDATE`正在更改用于查找相关行的索引，则必须执行此操作。

+   `发送数据`

    *MySQL 8.0.17 之前*：线程正在读取和处理`SELECT`语句的行，并将数据发送给客户端。因为在此状态下发生的操作往往执行大量的磁盘访问（读取），所以通常是给定查询的生命周期中运行时间最长的状态。*MySQL 8.0.17 及更高版本*：此状态不再单独指示，而是包含在`执行`状态中。

+   `发送给客户端`

    服务器正在向客户端写入数据包。

+   `设置`

    线程正在开始一个`ALTER TABLE`操作。

+   `为分组排序`

    线程正在进行排序以满足`GROUP BY`。

+   `为订单排序`

    线程正在进行排序以满足`ORDER BY`。

+   `排序索引`

    线程正在为更高效地访问`MyISAM`表优化操作中的索引页面进行排序。

+   `排序结果`

    对于`SELECT`语句，这类似于`创建排序索引`，但适用于非临时表。

+   `开始`

    语句执行开始时的第一阶段。

+   `统计`

    服务器正在计算统计信息以制定查询执行计划。如果线程在此状态下长时间停留，服务器可能正在执行其他工作而受到磁盘限制。

+   `系统锁`

    线程已调用`mysql_lock_tables()`，并且线程状态尚未更新。这是一个非常普遍的状态，可能出现的原因很多。

    例如，线程将请求或正在等待表格的内部或外部系统锁。这可能发生在`InnoDB`在执行`LOCK TABLES`期间等待表级锁时。如果此状态是由于对外部锁的请求而引起的，并且您没有使用访问相同`MyISAM`表的多个**mysqld**服务器，您可以使用`--skip-external-locking`选项禁用外部系统锁。但是，默认情况下已禁用外部锁定，因此这个选项可能没有效果。对于`SHOW PROFILE`，此状态表示线程正在请求锁（而不是等待锁）。

    对于系统表，使用`锁定系统表`状态。

+   `更新`

    线程正在准备开始更新表格。

+   `更新中`

    线程正在搜索要更新的行并更新它们。

+   `更新主表`

    服务器正在执行多表更新的第一部分。它只更新第一个表，并保存列和偏移量以用于更新其他（参考）表。

+   `更新参考表`

    服务器正在执行多表更新的第二部分，并更新其他表中匹配的行。

+   `用户锁`

    该线程将请求或正在等待使用`GET_LOCK()`函数请求的咨询锁。对于`SHOW PROFILE`，此状态表示线程正在请求锁（而不是等待锁）。

+   `用户休眠`

    该线程已调用`SLEEP()`函数。

+   `等待提交锁`

    `FLUSH TABLES WITH READ LOCK`正在等待提交锁。

+   `等待处理程序提交`

    该线程正在等待事务提交，而不是查询处理的其他部分。

+   `等待表`

    线程收到通知，表的基础结构已更改，需要重新打开表以获取新结构。但是，为了重新打开表，必须等到所有其他线程关闭了相关表。

    如果另一个线程在相关表上使用了`FLUSH TABLES`或以下语句之一：`FLUSH TABLES *`tbl_name`*`，`ALTER TABLE`，`RENAME TABLE`，`REPAIR TABLE`，`ANALYZE TABLE`或`OPTIMIZE TABLE`，则会发生此通知。

+   `等待表刷新`

    该线程正在执行`FLUSH TABLES`并正在等待所有线程关闭其表，或者该线程收到通知，表的基础结构已更改，需要重新打开表以获取新结构。但是，为了重新打开表，必须等到所有其他线程关闭了相关表。

    如果另一个线程在相关表上使用了`FLUSH TABLES`或以下语句之一：`FLUSH TABLES *`tbl_name`*`，`ALTER TABLE`，`RENAME TABLE`，`REPAIR TABLE`，`ANALYZE TABLE`或`OPTIMIZE TABLE`，则会发生此通知。

+   `等待 *`lock_type`* 锁`

    服务器正在等待获取`THR_LOCK`锁或来自元数据锁定子系统的锁，其中*`lock_type`*表示锁的类型。

    此状态表示等待`THR_LOCK`：

    +   `等待表级锁`

    这些状态表示正在等待元数据锁：

    +   `等待事件元数据锁`

    +   `等待全局读锁`

    +   `等待模式元数据锁`

    +   `等待存储函数元数据锁`

    +   `等待存储过程元数据锁`

    +   `等待表元数据锁`

    +   `等待触发器元数据锁`

    有关表锁指示器的信息，请参见第 10.11.1 节，“内部锁定方法”。有关元数据锁定的信息，请参见第 10.11.4 节，“元数据锁定”。要查看哪些锁正在阻止锁请求，请使用第 29.12.13 节，“性能模式锁定表”中描述的性能模式锁定表。

+   `等待条件`

    一种通用状态，线程正在等待条件变为真。没有可用的具体状态信息。

+   `写入网络`

    服务器正在向网络写入数据包。
