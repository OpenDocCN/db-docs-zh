# 13.5 JSON 数据类型

> 原文：[`dev.mysql.com/doc/refman/8.0/en/json.html`](https://dev.mysql.com/doc/refman/8.0/en/json.html)

+   创建 JSON 值

+   JSON 值的规范化、合并和自动包装

+   搜索和修改 JSON 值

+   JSON 路径语法

+   JSON 值的比较和排序

+   JSON 和非 JSON 值之间的转换

+   JSON 值的聚合

MySQL 支持由[RFC 7159](https://tools.ietf.org/html/rfc7159)定义的本机`JSON`数据类型，可实现对 JSON（JavaScript 对象表示）文档中数据的高效访问。`JSON`数据类型相对于在字符串列中存储 JSON 格式字符串具有以下优势：

+   存储在`JSON`列中的 JSON 文档的自动验证。无效文档会产生错误。

+   优化的存储格式。存储在`JSON`列中的 JSON 文档会转换为内部格式，以便快速读取文档元素。当服务器后续必须从此二进制格式中读取存储的 JSON 值时，无需从文本表示中解析值。二进制格式被设计为使服务器能够直接通过键或数组索引查找子对象或嵌套值，而无需在文档中读取它们之前或之后的所有值。

MySQL 8.0 还支持[RFC 7396](https://tools.ietf.org/html/rfc7396)中定义的*JSON 合并补丁*格式，使用`JSON_MERGE_PATCH()`函数。请参阅此函数的描述，以及 JSON 值的规范化、合并和自动包装，获取示例和更多信息。

注意

本讨论中使用单调字体的`JSON`表示特定的 JSON 数据类型，`JSON`使用常规字体表示一般的 JSON 数据。

存储 `JSON` 文档所需的空间大致与 `LONGBLOB` 或 `LONGTEXT` 相同；有关更多信息，请参见 第 13.7 节，“数据类型存储要求”。重要的是要记住，存储在 `JSON` 列中的任何 JSON 文档的大小受限于 `max_allowed_packet` 系统变量的值。（当服务器在内存中内部操作 JSON 值时，它可以比这个值更大；限制适用于服务器存储它时。）您可以使用 `JSON_STORAGE_SIZE()` 函数获取存储 JSON 文档所需空间的量；请注意，对于 `JSON` 列，存储大小——因此此函数返回的值——是在对其执行的任何部分更新之前使用的列的大小（请参见本节后面关于 JSON 部分更新优化的讨论）。

在 MySQL 8.0.13 之前，`JSON` 列不能有非`NULL`默认值。

除了 `JSON` 数据类型外，还提供了一组 SQL 函数，用于对 JSON 值进行操作，如创建、操作和搜索。以下讨论展示了这些操作的示例。有关各个函数的详细信息，请参见 第 14.17 节，“JSON 函数”。

还提供了一组用于操作 GeoJSON 值的空间函数。请参见 第 14.16.11 节，“空间 GeoJSON 函数”。

`JSON` 列，就像其他二进制类型的列一样，不能直接索引；相反，您可以在生成的列上创建索引，从 `JSON` 列中提取标量值。有关详细示例，请参见 在生成的列上创建索引以提供 JSON 列索引。

MySQL 优化器还会查找与匹配 JSON 表达式的虚拟列上的兼容索引。

在 MySQL 8.0.17 及更高版本中，`InnoDB` 存储引擎支持对 JSON 数组进行多值索引。请参见 多值索引。

MySQL NDB Cluster 8.0 支持 `JSON` 列和 MySQL JSON 函数，包括在从 `JSON` 列生成的列上创建索引，作为无法对 `JSON` 列进行索引的解决方法。每个 `NDB` 表支持最多 3 个 `JSON` 列。

### JSON 值的部分更新

在 MySQL 8.0 中，优化器可以对`JSON`列执行部分、原地更新，而不是删除旧文档并将新文档完全写入列。此优化可用于满足以下条件的更新：

+   正在更新的列被声明为`JSON`。

+   `UPDATE`语句使用三个函数中的任何一个`JSON_SET()`, `JSON_REPLACE()`, 或 `JSON_REMOVE()`来更新列。不能像直接赋值列值（例如，`UPDATE mytable SET jcol = '{"a": 10, "b": 25}'`）这样进行部分更新。

    在单个`UPDATE`语句中更新多个`JSON`列可以通过这种方式进行优化；MySQL 可以仅对使用刚才列出的三个函数更新值的列进行部分更新。

+   输入列和目标列必须是同一列；不能像`UPDATE mytable SET jcol1 = JSON_SET(jcol2, '$.a', 100)`这样进行部分更新。

    更新可以使用前一项中列出的任何函数的嵌套调用，以任何组合，只要输入和目标列是相同的。

+   所有更改都用新值替换现有数组或对象值，并且不向父对象或数组添加任何新元素。

+   被替换的值必须至少和替换值一样大。换句话说，新值不能比旧值更大。

    当之前的部分更新留下足够空间容纳更大值时，可能会有一个例外。您可以使用函数`JSON_STORAGE_FREE()`查看通过对`JSON`列进行任何部分更新而释放了多少空间。

可以使用紧凑格式将这种部分更新写入二进制日志，以节省空间；可以通过将`binlog_row_value_options`系统变量设置为`PARTIAL_JSON`来启用此功能。

重要的是要区分表中存储的`JSON`列值的部分更新与将行的部分更新写入二进制日志。当前面列表中的最后两个条件中的任一条件（或两者）不满足但其他条件满足时，可以将`JSON`列的完整更新记录为部分更新。

参见`binlog_row_value_options`的描述。

接下来的几节提供有关创建和操作 JSON 值的基本信息。

### 创建 JSON 值

JSON 数组包含由逗号分隔并在`[`和`]`字符内包围的值列表：

```sql
["abc", 10, null, true, false]
```

JSON 对象包含一组由逗号分隔并在`{`和`}`字符内封装的键值对：

```sql
{"k1": "value", "k2": 10}
```

正如示例所示，JSON 数组和对象可以包含作为字符串或数字的标量值，JSON null 字面值，或 JSON 布尔 true 或 false 字面值。JSON 对象中的键必须是字符串。也允许使用时间（日期、时间或日期时间）标量值：

```sql
["12:18:29.000000", "2015-07-29", "2015-07-29 12:18:29.000000"]
```

JSON 数组元素和 JSON 对象键值内允许嵌套：

```sql
[99, {"id": "HK500", "cost": 75.99}, ["hot", "cold"]]
{"k1": "value", "k2": [10, 20]}
```

您还可以通过 MySQL 提供的许多用于此目的的函数（请参阅第 14.17.2 节，“创建 JSON 值的函数”）以及通过将其他类型的值转换为`JSON`类型使用`CAST(*`value`* AS JSON)`（请参阅在 JSON 和非 JSON 值之间转换）来获取 JSON 值。接下来的几段描述了 MySQL 如何处理提供的 JSON 值作为输入。

在 MySQL 中，JSON 值被写为字符串。MySQL 解析任何在需要 JSON 值的上下文中使用的字符串，并在其无效为 JSON 时产生错误。这些上下文包括将值插入具有`JSON`数据类型的列中以及将参数传递给期望 JSON 值的函数（通常在 MySQL JSON 函数文档中显示为*`json_doc`*或*`json_val`*），如以下示例所示：

+   尝试将值插入`JSON`列成功，如果该值是有效的 JSON 值，则失败，如果不是则失败：

    ```sql
    mysql> CREATE TABLE t1 (jdoc JSON);
    Query OK, 0 rows affected (0.20 sec)

    mysql> INSERT INTO t1 VALUES('{"key1": "value1", "key2": "value2"}');
    Query OK, 1 row affected (0.01 sec)

    mysql> INSERT INTO t1 VALUES('1, 2,');
    ERROR 3140 (22032) at line 2: Invalid JSON text:
    "Invalid value." at position 6 in value (or column) '[1, 2,'.
    ```

    在这种错误消息中，“在位置*`N`*处”表示基于 0 的位置，但应该被视为值中实际问题发生位置的粗略指示。

+   [`JSON_TYPE()`函数期望一个 JSON 参数并尝试将其解析为 JSON 值。如果有效则返回该值的 JSON 类型，否则产生错误：

    ```sql
    mysql> SELECT JSON_TYPE('["a", "b", 1]');
    +----------------------------+
    | JSON_TYPE('["a", "b", 1]') |
    +----------------------------+
    | ARRAY                      |
    +----------------------------+

    mysql> SELECT JSON_TYPE('"hello"');
    +----------------------+
    | JSON_TYPE('"hello"') |
    +----------------------+
    | STRING               |
    +----------------------+

    mysql> SELECT JSON_TYPE('hello');
    ERROR 3146 (22032): Invalid data type for JSON data in argument 1
    to function json_type; a JSON string or JSON type is required.
    ```

MySQL 处理在 JSON 上下文中使用的字符串时，使用`utf8mb4`字符集和`utf8mb4_bin`排序规则。其他字符集中的字符串会根据需要转换为`utf8mb4`。（对于`ascii`或`utf8mb3`字符集中的字符串，不需要转换，因为`ascii`和`utf8mb3`是`utf8mb4`的子集。）

作为使用文字字符串编写 JSON 值的替代方法，存在用于从组件元素组合 JSON 值的函数。`JSON_ARRAY()`接受一个（可能为空）值列表，并返回包含这些值的 JSON 数组：

```sql
mysql> SELECT JSON_ARRAY('a', 1, NOW());
+----------------------------------------+
| JSON_ARRAY('a', 1, NOW())              |
+----------------------------------------+
| ["a", 1, "2015-07-27 09:43:47.000000"] |
+----------------------------------------+
```

`JSON_OBJECT()`接受一个（可能为空）键值对列表，并返回包含这些对的 JSON 对象：

```sql
mysql> SELECT JSON_OBJECT('key1', 1, 'key2', 'abc');
+---------------------------------------+
| JSON_OBJECT('key1', 1, 'key2', 'abc') |
+---------------------------------------+
| {"key1": 1, "key2": "abc"}            |
+---------------------------------------+
```

`JSON_MERGE_PRESERVE()`接受两个或多个 JSON 文档并返回合并的结果：

```sql
mysql> SELECT JSON_MERGE_PRESERVE('["a", 1]', '{"key": "value"}');
+-----------------------------------------------------+
| JSON_MERGE_PRESERVE('["a", 1]', '{"key": "value"}') |
+-----------------------------------------------------+
| ["a", 1, {"key": "value"}]                          |
+-----------------------------------------------------+
1 row in set (0.00 sec)
```

关于合并规则的信息，请参见 JSON 值的规范化、合并和自动包装。

（MySQL 8.0.3 及更高版本还支持`JSON_MERGE_PATCH()`，其行为略有不同。有关这两个函数之间差异的信息，请参见 JSON_MERGE_PATCH()与 JSON_MERGE_PRESERVE()的比较 compared with JSON_MERGE_PRESERVE()")。）

JSON 值可以分配给用户定义的变量：

```sql
mysql> SET @j = JSON_OBJECT('key', 'value');
mysql> SELECT @j;
+------------------+
| @j               |
+------------------+
| {"key": "value"} |
+------------------+
```

然而，用户定义的变量不能是`JSON`数据类型，因此，尽管前面示例中的`@j`看起来像一个 JSON 值，并且具有与 JSON 值相同的字符集和校对规则，但它*不*具有`JSON`数据类型。相反，当分配给变量时，`JSON_OBJECT()`的结果会被转换为字符串。

通过转换 JSON 值生成的字符串具有`utf8mb4`字符集和`utf8mb4_bin`校对规则：

```sql
mysql> SELECT CHARSET(@j), COLLATION(@j);
+-------------+---------------+
| CHARSET(@j) | COLLATION(@j) |
+-------------+---------------+
| utf8mb4     | utf8mb4_bin   |
+-------------+---------------+
```

因为`utf8mb4_bin`是一个二进制校对规则，所以 JSON 值的比较是区分大小写的。

```sql
mysql> SELECT JSON_ARRAY('x') = JSON_ARRAY('X');
+-----------------------------------+
| JSON_ARRAY('x') = JSON_ARRAY('X') |
+-----------------------------------+
|                                 0 |
+-----------------------------------+
```

区分大小写也适用于 JSON 的`null`、`true`和`false`字面量，它们必须始终以小写形式编写：

```sql
mysql> SELECT JSON_VALID('null'), JSON_VALID('Null'), JSON_VALID('NULL');
+--------------------+--------------------+--------------------+
| JSON_VALID('null') | JSON_VALID('Null') | JSON_VALID('NULL') |
+--------------------+--------------------+--------------------+
|                  1 |                  0 |                  0 |
+--------------------+--------------------+--------------------+

mysql> SELECT CAST('null' AS JSON);
+----------------------+
| CAST('null' AS JSON) |
+----------------------+
| null                 |
+----------------------+
1 row in set (0.00 sec)

mysql> SELECT CAST('NULL' AS JSON);
ERROR 3141 (22032): Invalid JSON text in argument 1 to function cast_as_json:
"Invalid value." at position 0 in 'NULL'.
```

JSON 字面量的大小写敏感性与 SQL 的`NULL`、`TRUE`和`FALSE`字面量的大小写敏感性不同，后者可以以任何大小写形式编写：

```sql
mysql> SELECT ISNULL(null), ISNULL(Null), ISNULL(NULL);
+--------------+--------------+--------------+
| ISNULL(null) | ISNULL(Null) | ISNULL(NULL) |
+--------------+--------------+--------------+
|            1 |            1 |            1 |
+--------------+--------------+--------------+
```

有时可能需要或希望将引号字符（`"`或`'`）插入 JSON 文档中。假设为此示例，您想要插入一些包含表示关于 MySQL 的一些事实的句子的 JSON 对象，每个句子都与适当的关键字配对，插入到使用下面显示的 SQL 语句创建的表中：

```sql
mysql> CREATE TABLE facts (sentence JSON);
```

在这些关键字-句子对中，有这样一个：

```sql
mascot: The MySQL mascot is a dolphin named "Sakila".
```

将此作为 JSON 对象插入`facts`表中的一种方法是使用 MySQL 的`JSON_OBJECT()`函数。在这种情况下，必须使用反斜杠转义每个引号字符，如下所示：

```sql
mysql> INSERT INTO facts VALUES
     >   (JSON_OBJECT("mascot", "Our mascot is a dolphin named \"Sakila\"."));
```

如果将值作为 JSON 对象字面量插入，则不能以相同方式工作，在这种情况下，必须使用双反斜杠转义序列，就像这样：

```sql
mysql> INSERT INTO facts VALUES
     >   ('{"mascot": "Our mascot is a dolphin named \\"Sakila\\"."}');
```

使用双反斜杠可以阻止 MySQL 执行转义序列处理，而是导致将字符串字面量传递给存储引擎进行处理。在刚刚展示的任一方式中插入 JSON 对象后，可以通过简单的`SELECT`查看 JSON 列值中存在反斜杠，就像这样：

```sql
mysql> SELECT sentence FROM facts;
+---------------------------------------------------------+
| sentence                                                |
+---------------------------------------------------------+
| {"mascot": "Our mascot is a dolphin named \"Sakila\"."} |
+---------------------------------------------------------+
```

要查找使用`mascot`作为关键字的特定句子，可以使用列路径运算符`->`，如下所示：

```sql
mysql> SELECT col->"$.mascot" FROM qtest;
+---------------------------------------------+
| col->"$.mascot"                             |
+---------------------------------------------+
| "Our mascot is a dolphin named \"Sakila\"." |
+---------------------------------------------+
1 row in set (0.00 sec)
```

这会保留反斜杠，以及周围的引号。要使用`mascot`作为键显示所需的值，但不包括周围的引号或任何转义字符，请使用内联路径运算符`->>`，如下所示：

```sql
mysql> SELECT sentence->>"$.mascot" FROM facts;
+-----------------------------------------+
| sentence->>"$.mascot"                   |
+-----------------------------------------+
| Our mascot is a dolphin named "Sakila". |
+-----------------------------------------+
```

注意

如果启用了`NO_BACKSLASH_ESCAPES`服务器 SQL 模式，则前面的示例不会按照所示方式工作。如果设置了此模式，则可以使用单个反斜杠而不是双反斜杠来插入 JSON 对象文字，并且反斜杠会被保留。如果在执行插入时使用`JSON_OBJECT()`函数并设置了此模式，则必须交替使用单引号和双引号，如下所示：

```sql
mysql> INSERT INTO facts VALUES
     > (JSON_OBJECT('mascot', 'Our mascot is a dolphin named "Sakila".'));
```

有关此模式对 JSON 值中转义字符的影响的更多信息，请参阅`JSON_UNQUOTE()`函数的描述。

### JSON 值的规范化、合并和自动包装

当解析字符串并发现其为有效的 JSON 文档时，也会进行规范化。这意味着具有与后面在文档中找到的重复键的成员，从左到右阅读，将被丢弃。以下`JSON_OBJECT()`调用生成的对象值仅包含第二个`key1`元素，因为该键名在值中较早出现，如下所示：

```sql
mysql> SELECT JSON_OBJECT('key1', 1, 'key2', 'abc', 'key1', 'def');
+------------------------------------------------------+
| JSON_OBJECT('key1', 1, 'key2', 'abc', 'key1', 'def') |
+------------------------------------------------------+
| {"key1": "def", "key2": "abc"}                       |
+------------------------------------------------------+
```

当值插入 JSON 列时也会执行规范化，如下所示：

```sql
mysql> CREATE TABLE t1 (c1 JSON);

mysql> INSERT INTO t1 VALUES
     >     ('{"x": 17, "x": "red"}'),
     >     ('{"x": 17, "x": "red", "x": [3, 5, 7]}');

mysql> SELECT c1 FROM t1;
+------------------+
| c1               |
+------------------+
| {"x": "red"}     |
| {"x": [3, 5, 7]} |
+------------------+
```

这种“最后一个重复键胜出”的行为是由[RFC 7159](https://tools.ietf.org/html/rfc7159)建议的，并且大多数 JavaScript 解析器都实现了这种行为。（Bug #86866，Bug #26369555）

在 MySQL 8.0.3 之前的版本中，具有与文档中较早找到的键重复的成员将被丢弃。以下`JSON_OBJECT()`调用生成的对象值不包含第二个`key1`元素，因为该键名在值中较早出现：

```sql
mysql> SELECT JSON_OBJECT('key1', 1, 'key2', 'abc', 'key1', 'def');
+------------------------------------------------------+
| JSON_OBJECT('key1', 1, 'key2', 'abc', 'key1', 'def') |
+------------------------------------------------------+
| {"key1": 1, "key2": "abc"}                           |
+------------------------------------------------------+
```

在 MySQL 8.0.3 之前，插入 JSON 列时也执行了这种“第一个重复键胜出”的规范化。

```sql
mysql> CREATE TABLE t1 (c1 JSON);

mysql> INSERT INTO t1 VALUES
     >     ('{"x": 17, "x": "red"}'),
     >     ('{"x": 17, "x": "red", "x": [3, 5, 7]}');

mysql> SELECT c1 FROM t1;
+-----------+
| c1        |
+-----------+
| {"x": 17} |
| {"x": 17} |
+-----------+
```

MySQL 还会丢弃原始 JSON 文档中键、值或元素之间的额外空格，并在显示时在每个逗号（`,`）或冒号（`:`）后留下（或在必要时插入）一个空格。这样做是为了增强可读性。

生成 JSON 值的 MySQL 函数（请参阅第 14.17.2 节，“创建 JSON 值的函数”）始终返回规范化值。

为了使查找更有效率，MySQL 还对 JSON 对象的键进行排序。*您应该注意，此排序的结果可能会发生变化，并且不能保证在不同版本之间保持一致*。

#### 合并 JSON 值

MySQL 8.0.3（以及更高版本）支持两种合并算法，由函数`JSON_MERGE_PRESERVE()`和`JSON_MERGE_PATCH()`实现。它们在处理重复键时有所不同：`JSON_MERGE_PRESERVE()`保留重复键的值，而`JSON_MERGE_PATCH()`丢弃除最后一个值之外的所有值。接下来的几段将解释这两个函数如何处理不同组合的 JSON 文档（即对象和数组）的合并。

注意

`JSON_MERGE_PRESERVE()`与 MySQL 先前版本中的`JSON_MERGE()`函数相同（在 MySQL 8.0.3 中更名）。`JSON_MERGE()`在 MySQL 8.0 中仍作为`JSON_MERGE_PRESERVE()`的别名受支持，但已被弃用，并可能在将来的版本中被移除。

**合并数组。** 在合并多个数组的上下文中，这些数组会合并为一个单一的数组。`JSON_MERGE_PRESERVE()`通过将后面命名的数组连接到第一个数组的末尾来实现这一点。`JSON_MERGE_PATCH()`将每个参数视为由单个元素组成的数组（因此其索引为 0），然后应用“最后重复键获胜”的逻辑，仅选择最后一个参数。您可以通过此查询比较所示的结果：

```sql
mysql> SELECT
 ->   JSON_MERGE_PRESERVE('[1, 2]', '["a", "b", "c"]', '[true, false]') AS Preserve,
 ->   JSON_MERGE_PATCH('[1, 2]', '["a", "b", "c"]', '[true, false]') AS Patch\G
*************************** 1\. row ***************************
Preserve: [1, 2, "a", "b", "c", true, false]
   Patch: [true, false]
```

多个对象合并后产生一个单一对象。`JSON_MERGE_PRESERVE()`通过将具有相同键的多个对象的所有唯一值组合为一个数组来处理这些对象；然后该数组被用作结果中该键的值。`JSON_MERGE_PATCH()`丢弃发现重复键的值，从左到右工作，因此结果仅包含该键的最后一个值。以下查询说明了对重复键`a`的结果差异：

```sql
mysql> SELECT
 ->   JSON_MERGE_PRESERVE('{"a": 1, "b": 2}', '{"c": 3, "a": 4}', '{"c": 5, "d": 3}') AS Preserve,
 ->   JSON_MERGE_PATCH('{"a": 3, "b": 2}', '{"c": 3, "a": 4}', '{"c": 5, "d": 3}') AS Patch\G
*************************** 1\. row ***************************
Preserve: {"a": [1, 4], "b": 2, "c": [3, 5], "d": 3}
   Patch: {"a": 4, "b": 2, "c": 5, "d": 3}
```

在需要数组值的上下文中使用非数组值时，会自动包装：该值会被`[`和`]`字符包围以转换为数组。在下面的语句中，每个参数都被自动包装为一个数组（`[1]`，`[2]`）。然后这些数组被合并为一个单一的结果数组；与前两种情况一样，`JSON_MERGE_PRESERVE()`会合并具有相同键的值，而`JSON_MERGE_PATCH()`会丢弃所有重复键的值，除了最后一个，如下所示：

```sql
mysql> SELECT
 ->   JSON_MERGE_PRESERVE('1', '2') AS Preserve,
 ->   JSON_MERGE_PATCH('1', '2') AS Patch\G
*************************** 1\. row ***************************
Preserve: [1, 2]
   Patch: 2
```

数组和对象值通过将对象自动包装为数组并根据合并函数的选择（`JSON_MERGE_PRESERVE()`或`JSON_MERGE_PATCH()`）合并数组中的值或“最后重复键获胜”来进行合并，如本例所示：

```sql
mysql> SELECT
 ->   JSON_MERGE_PRESERVE('[10, 20]', '{"a": "x", "b": "y"}') AS Preserve,
 ->   JSON_MERGE_PATCH('[10, 20]', '{"a": "x", "b": "y"}') AS Patch\G
*************************** 1\. row ***************************
Preserve: [10, 20, {"a": "x", "b": "y"}]
   Patch: {"a": "x", "b": "y"}
```

### 搜索和修改 JSON 值

JSON 路径表达式选择 JSON 文档中的值。

路径表达式在提取或修改 JSON 文档的部分的函数中非常有用，用于指定在文档中的哪个位置操作。例如，以下查询从 JSON 文档中提取具有`name`键的成员的值：

```sql
mysql> SELECT JSON_EXTRACT('{"id": 14, "name": "Aztalan"}', '$.name');
+---------------------------------------------------------+
| JSON_EXTRACT('{"id": 14, "name": "Aztalan"}', '$.name') |
+---------------------------------------------------------+
| "Aztalan"                                               |
+---------------------------------------------------------+
```

路径语法使用一个前导`$`字符来表示正在考虑的 JSON 文档，可选地跟随指示逐渐更具体部分的选择器：

+   一个点后跟一个键名命名对象中具有给定键的成员。如果不带引号的键名在路径表达式中不合法（例如，包含空格），则必须在双引号内指定键名。

+   `[*`N`*]`附加到选择数组的*`path`*上，命名数组中位置为*`N`*的值。数组位置是从零开始的整数。如果*`path`*没有选择一个数组值，*`path`*[0]会评估为与*`path`*相同的值：

    ```sql
    mysql> SELECT JSON_SET('"x"', '$[0]', 'a');
    +------------------------------+
    | JSON_SET('"x"', '$[0]', 'a') |
    +------------------------------+
    | "a"                          |
    +------------------------------+
    1 row in set (0.00 sec)
    ```

+   `[*`M`* to *`N`*]`指定从位置*`M`*开始，到位置*`N`*结束的数组值的子集或范围。

    `last`被支持作为最右边数组元素的索引的同义词。也支持数组元素的相对寻址。如果*`path`*没有选择一个数组值，*`path`*[last]会评估为与*`path`*相同的值，如本节后面所示（参见最右边数组元素）。

+   路径可以包含`*`或`**`通配符：

    +   `.[*]`评估为 JSON 对象中所有成员的值。

    +   `[*]`评估为 JSON 数组中所有元素的值。

    +   `*`prefix`****`suffix`*`评估为所有以指定前缀开头并以指定后缀结尾的路径。

+   一个在文档中不存在的路径（评估为不存在的数据）会评估为`NULL`。

让`$`指代这个具有三个元素的 JSON 数组：

```sql
[3, {"a": [5, 6], "b": 10}, [99, 100]]
```

然后：

+   `$[0]`评估为`3`。

+   `$[1]`评估为`{"a": [5, 6], "b": 10}`。

+   `$[2]`评估为`[99, 100]`。

+   `$[3]`评估为`NULL`（它指代第四个数组元素，但不存在）。

因为`$[1]`和`$[2]`评估为非标量值，它们可以作为更具体路径表达式的基础，选择嵌套值。例如：

+   `$[1].a`评估为`[5, 6]`。

+   `$[1].a[1]`评估为`6`。

+   `$[1].b`评估为`10`。

+   `$[2][0]`评估为`99`。

如前所述，命名键的路径组件在路径表达式中不合法时必须加引号。让`$`指代这个值：

```sql
{"a fish": "shark", "a bird": "sparrow"}
```

两个键都包含空格，必须加引号：

+   `$."a fish"`评估为`shark`。

+   `$."a bird"`评估为`sparrow`。

使用通配符的路径会评估为一个可以包含多个值的数组：

```sql
mysql> SELECT JSON_EXTRACT('{"a": 1, "b": 2, "c": [3, 4, 5]}', '$.*');
+---------------------------------------------------------+
| JSON_EXTRACT('{"a": 1, "b": 2, "c": [3, 4, 5]}', '$.*') |
+---------------------------------------------------------+
| [1, 2, [3, 4, 5]]                                       |
+---------------------------------------------------------+
mysql> SELECT JSON_EXTRACT('{"a": 1, "b": 2, "c": [3, 4, 5]}', '$.c[*]');
+------------------------------------------------------------+
| JSON_EXTRACT('{"a": 1, "b": 2, "c": [3, 4, 5]}', '$.c[*]') |
+------------------------------------------------------------+
| [3, 4, 5]                                                  |
+------------------------------------------------------------+
```

在下面的例子中，路径`$**.b`评估为多个路径（`$.a.b`和`$.c.b`）并产生匹配路径值的数组：

```sql
mysql> SELECT JSON_EXTRACT('{"a": {"b": 1}, "c": {"b": 2}}', '$**.b');
+---------------------------------------------------------+
| JSON_EXTRACT('{"a": {"b": 1}, "c": {"b": 2}}', '$**.b') |
+---------------------------------------------------------+
| [1, 2]                                                  |
+---------------------------------------------------------+
```

**来自 JSON 数组的范围。** 您可以使用`to`关键字与范围一起指定 JSON 数组的子集。例如，`$[1 to 3]`包括数组的第二、第三和第四个元素，如下所示：

```sql
mysql> SELECT JSON_EXTRACT('[1, 2, 3, 4, 5]', '$[1 to 3]');
+----------------------------------------------+
| JSON_EXTRACT('[1, 2, 3, 4, 5]', '$[1 to 3]') |
+----------------------------------------------+
| [2, 3, 4]                                    |
+----------------------------------------------+
1 row in set (0.00 sec)
```

语法是`*`M`* to *`N`*`，其中*`M`*和*`N`*分别是 JSON 数组中一系列元素的第一个和最后一个索引。*`N`*必须大于*`M`*；*`M`*必须大于或等于 0。数组元素从 0 开始索引。

您可以在支持通配符的上下文中使用范围。

**最右侧的数组元素。** `last`关键字可用作数组中最后一个元素的索引的同义词。形式为`last - *`N`*`的表达式可用于相对寻址，以及在范围定义中，如下所示：

```sql
mysql> SELECT JSON_EXTRACT('[1, 2, 3, 4, 5]', '$[last-3 to last-1]');
+--------------------------------------------------------+
| JSON_EXTRACT('[1, 2, 3, 4, 5]', '$[last-3 to last-1]') |
+--------------------------------------------------------+
| [2, 3, 4]                                              |
+--------------------------------------------------------+
1 row in set (0.01 sec)
```

如果路径针对的值不是数组，则评估的结果与将该值包装在单元素数组中的结果相同：

```sql
mysql> SELECT JSON_REPLACE('"Sakila"', '$[last]', 10);
+-----------------------------------------+
| JSON_REPLACE('"Sakila"', '$[last]', 10) |
+-----------------------------------------+
| 10                                      |
+-----------------------------------------+
1 row in set (0.00 sec)
```

您可以使用`*`column`*->*`path`*`作为 JSON 列标识符和 JSON 路径表达式的同义词，用于`JSON_EXTRACT(*`column`*, *`path`*)`。有关更多信息，请参见第 14.17.3 节，“搜索 JSON 值的函数”。另请参见为提供 JSON 列索引而对生成列进行索引。

一些函数接受现有的 JSON 文档，在某种方式上对其进行修改，并返回结果修改后的文档。路径表达式指示在文档中何处进行更改。例如，`JSON_SET()`、`JSON_INSERT()`和`JSON_REPLACE()`函数分别接受一个 JSON 文档，以及一个或多个描述在何处修改文档以及要使用的值的路径-值对。这些函数在处理文档中的现有值和不存在的值方面有所不同。

考虑这个文档：

```sql
mysql> SET @j = '["a", {"b": [true, false]}, [10, 20]]';
```

`JSON_SET()`替换存在的路径的值，并为不存在的路径添加值：

```sql
mysql> SELECT JSON_SET(@j, '$[1].b[0]', 1, '$[2][2]', 2);
+--------------------------------------------+
| JSON_SET(@j, '$[1].b[0]', 1, '$[2][2]', 2) |
+--------------------------------------------+
| ["a", {"b": [1, false]}, [10, 20, 2]]      |
+--------------------------------------------+
```

在这种情况下，路径`$[1].b[0]`选择了一个现有值（`true`），该值将被路径参数后面的值（`1`）替换。路径`$[2][2]`不存在，因此将值（`2`）添加到由`$[2]`选择的值中。

`JSON_INSERT()`添加新值，但不替换现有值：

```sql
mysql> SELECT JSON_INSERT(@j, '$[1].b[0]', 1, '$[2][2]', 2);
+-----------------------------------------------+
| JSON_INSERT(@j, '$[1].b[0]', 1, '$[2][2]', 2) |
+-----------------------------------------------+
| ["a", {"b": [true, false]}, [10, 20, 2]]      |
+-----------------------------------------------+
```

`JSON_REPLACE()`替换现有值并忽略新值：

```sql
mysql> SELECT JSON_REPLACE(@j, '$[1].b[0]', 1, '$[2][2]', 2);
+------------------------------------------------+
| JSON_REPLACE(@j, '$[1].b[0]', 1, '$[2][2]', 2) |
+------------------------------------------------+
| ["a", {"b": [1, false]}, [10, 20]]             |
+------------------------------------------------+
```

路径-值对从左到右进行评估。通过评估一个对产生的文档成为下一个对要评估的新值。

`JSON_REMOVE()`接受一个 JSON 文档和一个或多个指定要从文档中移除的值的路径。返回值是原始文档减去由文档内存在的路径选择的值：

```sql
mysql> SELECT JSON_REMOVE(@j, '$[2]', '$[1].b[1]', '$[1].b[1]');
+---------------------------------------------------+
| JSON_REMOVE(@j, '$[2]', '$[1].b[1]', '$[1].b[1]') |
+---------------------------------------------------+
| ["a", {"b": [true]}]                              |
+---------------------------------------------------+
```

这些路径具有以下效果：

+   `$[2]`匹配`[10, 20]`并将其移除。

+   第一个实例`$[1].b[1]`匹配`b`元素中的`false`并将其移除。

+   第二个实例`$[1].b[1]`匹配不到任何内容：该元素已被移除，路径不再存在，也不产生任何效果。

### JSON 路径语法

MySQL 支持的许多 JSON 函数在本手册的其他地方有描述（请参见第 14.17 节，“JSON 函数”，在*ECMAScript 语言规范*中）。路径表达式和 JSON 文本应使用`ascii`，`utf8mb3`或`utf8mb4`字符集进行编码。其他字符编码将被隐式强制转换为`utf8mb4`。完整的语法如下所示：

```sql
*pathExpression*:
    *scope*[(*pathLeg*)*]

*pathLeg*:
    *member* | *arrayLocation* | *doubleAsterisk*

*member*:
    *period* ( *keyName* | *asterisk* )

*arrayLocation*:
    *leftBracket* ( *nonNegativeInteger* | *asterisk* ) *rightBracket*

*keyName*:
    *ESIdentifier* | *doubleQuotedString*

*doubleAsterisk*:
    '**'

*period*:
    '.'

*asterisk*:
    '*'

*leftBracket*:
    '['

*rightBracket*:
    ']'
```

正如前面所述，在 MySQL 中，路径的范围始终是操作的文档，表示为`$`。您可以在 JSON 路径表达式中使用`'$'`作为文档的同义词。

注意

一些实现支持 JSON 路径范围的列引用；MySQL 8.0 不支持这些功能。

通配符`*`和`**`标记的使用如下：

+   `.*`代表对象中所有成员的值。

+   `[*]`代表数组中所有单元格的值。

+   `[*`前缀`*]***`后缀`*`代表以*`前缀`*开头并以*`后缀`*结尾的所有路径。*`前缀`*是可选的，而*`后缀`*是必需的；换句话说，路径不能以`**`结尾。

    另外，路径中不能包含序列`***`。

有关路径语法示例，请参阅各种接受路径作为参数的 JSON 函数的描述，例如`JSON_CONTAINS_PATH()`，`JSON_SET()`和`JSON_REPLACE()`。有关包含`*`和`**`通配符的示例，请参阅`JSON_SEARCH()`函数的描述。

MySQL 8.0 还支持使用`to`关键字对 JSON 数组的子集进行范围表示（例如`$[2 to 10]`），以及使用`last`关键字作为数组最右侧元素的同义词。有关更多信息和示例，请参见搜索和修改 JSON 值。

### JSON 值的比较和排序

可以使用`=`、`<`、`<=`、`>`、`>=`、`<>`、`!=`和`<=>`运算符来比较 JSON 值。

尚不支持以下比较运算符和函数与 JSON 值一起使用：

+   `BETWEEN`

+   `IN()`

+   `GREATEST()`

+   `LEAST()`

对于刚刚列出的比较运算符和函数的解决方法是将 JSON 值转换为本机 MySQL 数值或字符串数据类型，以便它们具有一致的非 JSON 标量类型。

JSON 值的比较分为两个级别。第一级别的比较基于所比较值的 JSON 类型。如果类型不同，则比较结果仅由具有更高优先级的类型确定。如果两个值具有相同的 JSON 类型，则使用特定于类型的规则进行第二级别的比较。

下面的列表显示了 JSON 类型的优先级，从最高优先级到最低优先级。（类型名称是由`JSON_TYPE()`函数返回的。）在同一行上显示的类型具有相同的优先级。任何具有列表中较早 JSON 类型的值都比具有列表中较晚 JSON 类型的值大。

```sql
BLOB
BIT
OPAQUE
DATETIME
TIME
DATE
BOOLEAN
ARRAY
OBJECT
STRING
INTEGER, DOUBLE
NULL
```

对于具有相同优先级的 JSON 值，比较规则是特定于类型的：

+   `BLOB`

    比较两个值的前*`N`*字节，其中*`N`*是较短值中的字节数。如果两个值的前*`N`*字节相同，则较短值在较长值之前排序。

+   `BIT`

    与`BLOB`相同的规则。

+   `OPAQUE`

    与`BLOB`相同的规则。`OPAQUE`值是未分类为其他类型的值。

+   `DATETIME`

    代表较早时间点的值在代表较晚时间点的值之前。如果两个值最初分别来自 MySQL 的`DATETIME`和`TIMESTAMP`类型，则如果它们表示相同的时间点，则它们相等。

+   `TIME`

    两个时间值中较小的一个在较大的一个之前排序。

+   `DATE`

    较早日期在较近日期之前。

+   `ARRAY`

    如果两个 JSON 数组具有相同的长度，并且数组中对应位置的值相等，则它们是相等的。

    如果数组不相等，则它们的顺序由第一个出现差异的位置的元素确定。在该位置上值较小的数组被排在前面。如果较短数组的所有值都等于较长数组中对应的值，则较短数组被排在前面。

    例子：

    ```sql
    [] < ["a"] < ["ab"] < ["ab", "cd", "ef"] < ["ab", "ef"]
    ```

+   `BOOLEAN`

    JSON 中的 false 文字小于 JSON 中的 true 文字。

+   `OBJECT`

    如果两个 JSON 对象具有相同的键集，并且每个键在两个对象中具有相同的值，则它们是相等的。

    例子：

    ```sql
    {"a": 1, "b": 2} = {"b": 2, "a": 1}
    ```

    两个不相等的对象的顺序是未指定的，但是确定的。

+   `STRING`

    字符串在比较时按照两个字符串的`utf8mb4`表示的前*`N`*个字节的词法顺序排序，其中*`N`*是较短字符串的长度。如果两个字符串的前*`N`*个字节相同，则较短的字符串被认为比较长的字符串小。

    例子：

    ```sql
    "a" < "ab" < "b" < "bc"
    ```

    这种排序等同于具有`utf8mb4_bin`排序规则的 SQL 字符串的排序。因为`utf8mb4_bin`有一个二进制排序规则，所以 JSON 值的比较是区分大小写的：

    ```sql
    "A" < "a"
    ```

+   `INTEGER`，`DOUBLE`

    JSON 值可以包含精确值和近似值数字。有关这些类型数字的一般讨论，请参见第 11.1.2 节，“数字文字”。

    讨论了比较本机 MySQL 数值类型的规则在第 14.3 节，“表达式求值中的类型转换”中，但是比较 JSON 值中的数字的规则略有不同：

    +   在比较使用本机 MySQL `INT` - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT") 和 `DOUBLE` - FLOAT, DOUBLE") 数值类型的两列时，已知所有比较涉及整数和双精度数，因此整数被转换为双精度以用于所有行。也就是说，精确值数字被转换为近似值数字。

    +   另一方面，如果查询比较包含数字的两个 JSON 列，无法事先知道数字是整数还是双精度。为了在所有行中提供最一致的行为，MySQL 将近似值数字转换为精确值数字。结果的排序是一致的，并且对于精确值数字不会丢失精度。例如，给定标量 9223372036854775805、9223372036854775806、9223372036854775807 和 9.223372036854776e18，顺序如下：

        ```sql
        9223372036854775805 < 9223372036854775806 < 9223372036854775807
        < 9.223372036854776e18 = 9223372036854776000 < 9223372036854776001
        ```

    如果 JSON 比较使用非 JSON 数值比较规则，可能会导致不一致的排序。通常的 MySQL 数值比较规则产生以下排序：

    +   整数比较：

        ```sql
        9223372036854775805 < 9223372036854775806 < 9223372036854775807
        ```

        (未定义为 9.223372036854776e18)

    +   双精度比较：

        ```sql
        9223372036854775805 = 9223372036854775806 = 9223372036854775807 = 9.223372036854776e18
        ```

任何 JSON 值与 SQL `NULL` 的比较结果为`UNKNOWN`。

对于 JSON 和非 JSON 值的比较，根据以下表中的规则将非 JSON 值转换为 JSON，然后按照先前描述的方式进行比较。

### 在 JSON 值和非 JSON 值之间转换

以下表格总结了 MySQL 在 JSON 值和其他类型值之间转换时遵循的规则：

**表 13.3 JSON 转换规则**

| 其他类型 | CAST(other type AS JSON) | CAST(JSON AS other type) |
| --- | --- | --- |
| JSON | 无变化 | 无变化 |
| utf8 字符类型（`utf8mb4`，`utf8mb3`，`ascii`） | 字符串被解析为 JSON 值。 | JSON 值被序列化为`utf8mb4`字符串。 |
| 其他字符类型 | 其他字符编码会隐式转换为`utf8mb4`，并按照该字符类型描述的方式处理。 | JSON 值被序列化为`utf8mb4`字符串，然后转换为其他字符编码。结果可能无意义。 |
| `NULL` | 结果为 JSON 类型的`NULL`值。 | 不适用。 |
| 几何类型 | 几何值通过调用 `ST_AsGeoJSON()` 转换为 JSON 文档。 | 非法操作。解决方法：将 `CAST(*`json_val`* AS CHAR)` 的结果传递给 `ST_GeomFromGeoJSON()`。 |
| 所有其他类型 | 结果为由单个标量值组成的 JSON 文档。 | 如果 JSON 文档由目标类型的单个标量值组成且该标量值可以转换为目标类型，则成功。否则，返回`NULL`并产生警告。 |

对于 JSON 值，`ORDER BY` 和 `GROUP BY` 遵循以下原则：

+   标量 JSON 值的排序使用与前述讨论相同的规则。

+   对于升序排序，SQL `NULL` 排在所有 JSON 值之前，包括 JSON 的 null 字面量；对于降序排序，SQL `NULL` 排在所有 JSON 值之后，包括 JSON 的 null 字面量。

+   JSON 值的排序键受 `max_sort_length` 系统变量的值限制，因此仅在首个 `max_sort_length` 字节之后有差异的键将被视为相等。

+   非标量值的排序目前不受支持，会出现警告。

对于排序，将 JSON 标量转换为其他本机 MySQL 类型可能是有益的。例如，如果名为`jdoc`的列包含具有由`id`键和非负值组成的成员的 JSON 对象，则使用此表达式按`id`值排序：

```sql
ORDER BY CAST(JSON_EXTRACT(jdoc, '$.id') AS UNSIGNED)
```

如果存在一个生成的列被定义为使用与`ORDER BY`相同的表达式，MySQL 优化器会识别并考虑在查询执行计划中使用该索引。参见 Section 10.3.11, “生成列索引的优化器使用”。

### JSON 值的聚合

对于 JSON 值的聚合，SQL `NULL` 值会被忽略，就像其他数据类型一样。非`NULL` 值会被转换为数值类型并进行聚合，除了 `MIN()`, `MAX()`, 和 `GROUP_CONCAT()`。对于 JSON 值转换为数字应该会产生有意义的结果，尽管（取决于值）可能会发生截断和精度丢失。其他 JSON 值的转换为数字可能不会产生有意义的结果。
