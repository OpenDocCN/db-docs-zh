> 原文：[`dev.mysql.com/doc/refman/8.0/en/replication-features-differing-tables.html`](https://dev.mysql.com/doc/refman/8.0/en/replication-features-differing-tables.html)

#### 19.5.1.9 源表和副本表定义不同的复制

源表和目标表的复制不必完全相同。源表可以比副本表的副本具有更多或更少的列。此外，源表和副本的对应表列可以使用不同的数据类型，但必须满足一定条件。

注意

不支持不同分区的表之间的复制。参见 Section 19.5.1.24, “复制和分区”。

在所有源表和目标表定义不完全相同的情况下，数据库和表名必须在源表和副本上相同。在以下两个部分中讨论了其他条件，并给出了示例。

##### 19.5.1.9.1 源表或副本表中有更多列的复制

可以将表从源复制到副本，使得源表和副本表的列数不同，但必须满足以下条件：

+   两个表共有的列必须在源表和副本上以相同顺序定义。（即使两个表具有相同数量的列也是如此。）

+   两个表共有的列必须在任何额外列之前定义。

    这意味着在副本上执行`ALTER TABLE`语句，向表中插入一个新列，该列位于两个表共有的列范围内，会导致复制失败，如下例所示：

    假设表`t`在源和副本上存在，并由以下`CREATE TABLE`语句定义：

    ```sql
    CREATE TABLE t (
        c1 INT,
        c2 INT,
        c3 INT
    );
    ```

    假设在副本上执行了以下`ALTER TABLE`语句：

    ```sql
    ALTER TABLE t ADD COLUMN cnew1 INT AFTER c3;
    ```

    之前的`ALTER TABLE`在副本上是允许的，因为表`t`的两个版本中共有的列`c1`、`c2`和`c3`在任何不同的列之前都保持在一起。

    然而，在副本上执行以下`ALTER TABLE`语句会导致复制中断：

    ```sql
    ALTER TABLE t ADD COLUMN cnew2 INT AFTER c2;
    ```

    在副本上执行刚刚显示的`ALTER TABLE`语句后，复制失败，因为新列`cnew2`位于`t`两个版本共有的列之间。

+   在列更多的表版本中，每个“额外”列必须有一个默认值。

    列的默认值由多种因素决定，包括其类型、是否使用`DEFAULT`选项定义、是否声明为`NULL`，以及创建时服务器 SQL 模式的有效性；更多信息，请参见第 13.6 节，“数据类型默认值”）。

此外，当副本表比源表具有更多列时，两个表中共有的每一列必须在两个表中使用相同的数据类型。

**示例。** 以下示例说明了一些有效和无效的表定义：

**源表中有更多列。** 以下表定义是有效的，并且可以正确复制：

```sql
source> CREATE TABLE t1 (c1 INT, c2 INT, c3 INT);
replica>  CREATE TABLE t1 (c1 INT, c2 INT);
```

下表定义会引发错误，因为两个版本表共有的列的定义在副本表上的顺序与源表上的顺序不同：

```sql
source> CREATE TABLE t1 (c1 INT, c2 INT, c3 INT);
replica>  CREATE TABLE t1 (c2 INT, c1 INT);
```

下表定义也会引发错误，因为源表中额外列的定义出现在两个版本共有的列定义之前：

```sql
source> CREATE TABLE t1 (c3 INT, c1 INT, c2 INT);
replica>  CREATE TABLE t1 (c1 INT, c2 INT);
```

**副本表中有更多列。** 以下表定义是有效的，并且可以正确复制：

```sql
source> CREATE TABLE t1 (c1 INT, c2 INT);
replica>  CREATE TABLE t1 (c1 INT, c2 INT, c3 INT);
```

下列定义会引发错误，因为两个版本表共有的列在源表和副本表上的定义顺序不同：

```sql
source> CREATE TABLE t1 (c1 INT, c2 INT);
replica>  CREATE TABLE t1 (c2 INT, c1 INT, c3 INT);
```

下表定义也会引发错误，因为副本版本表中额外列的定义出现在两个版本共有的列定义之前：

```sql
source> CREATE TABLE t1 (c1 INT, c2 INT);
replica>  CREATE TABLE t1 (c3 INT, c1 INT, c2 INT);
```

下表定义失败，因为副本版本表比源版本表多了额外列，并且两个版本的表对于共有列`c2`使用了不同的数据类型：

```sql
source> CREATE TABLE t1 (c1 INT, c2 BIGINT);
replica>  CREATE TABLE t1 (c1 INT, c2 INT, c3 INT);
```

##### 19.5.1.9.2 具有不同数据类型的列的复制

源表和副本表中相应的列的副本应该具有相同的数据类型。然而，并不总是严格执行这一规定，只要满足一定条件即可。

通常可以从具有特定数据类型的列复制到具有相同类型和大小或宽度的另一列，如适用，或更大的列。例如，可以从`CHAR(10)`列复制到另一个`CHAR(10)`列，或者从`CHAR(10)`列复制到`CHAR(25)`列而不会出现问题。在某些情况下，还可以从源表中具有一种数据类型的列复制到副本中具有不同数据类型的列；当源表中列的数据类型提升为副本中相同大小或更大的类型时，这称为属性提升。

属性提升可用于基于语句和基于行的复制，并且不依赖于源或副本使用的存储引擎。但是，日志格式的选择确实会影响允许的类型转换；具体内容将在本节后面讨论。

重要提示

无论您使用基于语句还是基于行的复制，如果希望使用属性提升，则副本表的副本不能包含比源表的副本更多的列。

**基于语句的复制。** 在使用基于语句的复制时，一个简单的经验法则是，“如果在源上运行的语句也可以在副本上成功执行，则它也应该成功复制”。换句话说，如果语句使用与副本上给定列类型兼容的值，则可以复制该语句。例如，您可以将适合`TINYINT`列的任何值插入到`BIGINT`列中；因此，即使您将副本表中的`TINYINT`列的类型更改为`BIGINT`，任何成功插入该列的源上的插入也应该在副本上成功，因为不可能有一个合法的`TINYINT`值大到足以超过`BIGINT`列。

**基于行的复制：属性提升和降级。** 基于行的复制支持较小数据类型和较大类型之间的属性提升和降级。还可以指定是否允许对降级列值进行有损（截断）或无损转换，如本节后面所述。

**有损和无损转换。** 在目标类型无法表示要插入的值的情况下，必须决定如何处理转换。如果我们允许转换但截断（或以其他方式修改）源值以在目标列中实现“适合”，我们进行的是所谓的有损转换。不需要截断或类似修改以使源列值适合目标列的转换是无损转换。

**类型转换模式。** 系统变量`replica_type_conversions`（从 MySQL 8.0.26 开始）或`slave_type_conversions`（在 MySQL 8.0.26 之前）的全局值控制副本上使用的类型转换模式。此变量接受以下列表中的一组值，描述了每种模式对副本的类型转换行为的影响：

ALL_LOSSY

在此模式下，允许会导致信息丢失的类型转换。

这并不意味着允许非损失转换，仅表示只允许需要损失转换或根本不需要转换的情况；例如，仅启用*此*模式允许将`INT`列转换为`TINYINT`（损失转换），但不允许将`TINYINT`列转换为`INT`列（非损失）。在这种情况下尝试后者的转换会导致副本停止并显示错误。

ALL_NON_LOSSY

此模式允许不需要截断或其他特殊处理源值的转换；也就是说，它允许目标类型的范围比源类型更宽的转换。

设置此模式不影响是否允许有损转换；这由`ALL_LOSSY`模式控制。如果只设置了`ALL_NON_LOSSY`，但没有设置`ALL_LOSSY`，那么尝试进行可能导致数据丢失的转换（例如`INT`到`TINYINT`，或`CHAR(25)`到`VARCHAR(20)`）会导致副本停止并显示错误。

ALL_LOSSY,ALL_NON_LOSSY

当设置此模式时，允许所有支持的类型转换，无论它们是否是有损转换。

ALL_SIGNED

将提升的整数类型视为有符号值（默认行为）。

ALL_UNSIGNED

将提升的整数类型视为无符号值。

ALL_SIGNED,ALL_UNSIGNED

尽可能将提升的整数类型视为有符号，否则视为无符号。

[*空*]

当未设置`replica_type_conversions`或`slave_type_conversions`时，不允许进行属性提升或降级；这意味着源表和目标表中的所有列必须是相同类型。

这是默认模式。

当整数类型被提升时，其符号性不会被保留。默认情况下，副本将所有这些值视为有符号的。您可以使用`ALL_SIGNED`、`ALL_UNSIGNED`或两者来控制此行为。`ALL_SIGNED`告诉副本将所有提升的整数类型视为有符号；`ALL_UNSIGNED`指示将其视为无符号。如果同时指定两者，副本将尽可能将值视为有符号，否则将视为无符号；它们列出的顺序并不重要。如果至少没有使用`ALL_LOSSY`或`ALL_NONLOSSY`中的一个，那么`ALL_SIGNED`和`ALL_UNSIGNED`都不会产生任何效果。

更改类型转换模式需要使用新的`replica_type_conversions`或`slave_type_conversions`设置重新启动副本。

**支持的转换。** 支持不同但相似数据类型之间的转换列在以下列表中：

+   在任何整数类型`TINYINT`，`SMALLINT`，`MEDIUMINT`，`INT`和`BIGINT`之间。

    这包括这些类型的有符号和无符号版本之间的转换。

    通过将源值截断为目标列允许的最大（或最小）值来进行有损转换。为了确保从无符号到有符号类型的非有损转换，目标列必须足够大，以容纳源列中的值范围。例如，您可以将`TINYINT UNSIGNED`非有损地降级为`SMALLINT`，但不能降级为`TINYINT`。

+   在任何十进制类型`DECIMAL`，`FLOAT`，`DOUBLE`和`NUMERIC`之间。

    `FLOAT`到`DOUBLE`是非有损转换；`DOUBLE`到`FLOAT`只能以有损方式处理。从`DECIMAL(*`M`*,*`D`*)`到`DECIMAL(*`M'`*,*`D'`*)`的转换，其中`*`D'`* >= *`D`*`和`(*`M'`*-*`D'`*) >= (*`M`*-*`D`*`)是非有损的；对于任何`*`M'`* < *`M`*`，`*`D'`* < *`D`*`，或两者都是的情况，只能进行有损转换。

    对于任何十进制类型，如果要存储的值无法适应目标类型，则根据文档中其他地方定义的服务器舍入规则将该值向下舍入。有关十进制类型的此类操作的详细信息，请参见第 14.24.4 节，“舍入行为”。

+   在任何字符串类型`CHAR`，`VARCHAR`和`TEXT`之间，包括不同宽度之间的转换。

    将`CHAR`，`VARCHAR`或`TEXT`转换为大小相同或更大的`CHAR`，`VARCHAR`或`TEXT`列永远不会有损。有损转换通过在副本上仅插入字符串的前*`N`*个字符来处理，其中*`N`*是目标列的宽度。

    重要提示

    不支持在使用不同字符集的列之间进行复制。

+   任意二进制数据类型`BINARY`，`VARBINARY`和`BLOB`之间的转换，包括不同宽度之间的转换。

    将`BINARY`，`VARBINARY`或`BLOB`转换为相同大小或更大的`BINARY`，`VARBINARY`或`BLOB`列永远不会有损失。有损转换通过仅在副本上插入字符串的前*`N`*字节来处理，其中*`N`*是目标列的宽度。

+   任意两个不同大小的`BIT`列之间。

    当将来自`BIT(*`M`*)`列的值插入到`BIT(*`M'`*)`列中，其中`*`M'`* > *`M`*`时，`BIT(*`M'`*)`列的最高有效位被清除（设置为零），而`BIT(*`M`*)`值的*`M`*位被设置为`BIT(*`M'`*)`列的最低有效位。

    当将来自源`BIT(*`M`*)`列的值插入到目标`BIT(*`M'`*)`列中，其中`*`M'`* < *`M`*`时，`BIT(*`M'`*)`列被赋予最大可能的值；换句话说，目标列被赋予“全置位”值。

类型转换不在前述列表中的类型是不允许的。
