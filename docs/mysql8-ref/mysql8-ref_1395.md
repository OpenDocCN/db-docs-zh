> 原文：[`dev.mysql.com/doc/refman/8.0/en/replication-rules-examples.html`](https://dev.mysql.com/doc/refman/8.0/en/replication-rules-examples.html)

#### 19.2.5.3 复制过滤选项之间的交互

如果您同时使用数据库级和表级复制过滤选项，副本首先根据数据库选项接受或忽略事件，然后根据表选项评估所有这些选项允许的事件。这有时可能导致看起来反直觉的结果。还要注意，结果会根据操作是使用基于语句还是基于行的二进制日志格式而变化。如果您希望确保您的复制过滤器始终以相同的方式运行，独立于二进制日志格式，这在使用混合二进制日志格式时尤为重要，请遵循本主题中的指导。

复制过滤选项的效果在不同的二进制日志格式之间有所不同，这是因为数据库名称的识别方式不同。在基于语句的格式中，DML 语句是基于当前数据库处理的，由`USE`语句指定。在基于行的格式中，DML 语句是基于修改表所在的数据库处理的。DDL 语句始终基于当前数据库进行过滤，由`USE`语句指定，而不受二进制日志格式的影响。

涉及多个表的操作也可能会因二进制日志格式的不同而受到复制过滤选项的影响。需要注意的操作包括涉及多表`UPDATE`语句的事务、触发器、级联外键、更新多个表的存储函数以及调用更新一个或多个表的存储函数的 DML 语句。如果这些操作同时更新被过滤进和被过滤出的表，结果可能会随着二进制日志格式的不同而变化。

如果您需要确保您的复制过滤器在不同的二进制日志格式下都能一致地运行，特别是如果您正在使用混合二进制日志格式（`binlog_format=MIXED`），请仅使用表级复制过滤选项，不要使用数据库级复制过滤选项。此外，不要使用同时更新被过滤进和被过滤出表的多表 DML 语句。

如果您需要同时使用数据库级和表级复制过滤器，并希望它们尽可能一致地运行，请选择以下策略之一：

1.  如果您使用基于行的二进制日志格式（`binlog_format=ROW`），对于 DDL 语句，依赖`USE`语句设置数据库，不要指定数据库名称。您可以考虑更改为基于行的二进制日志格式以提高与复制过滤的一致性。有关更改二进制日志格式适用的条件，请参见 Section 7.4.4.2, “Setting The Binary Log Format”。

1.  如果您使用基于语句或混合二进制日志格式（`binlog_format=STATEMENT`或`MIXED`），对于 DML 和 DDL 语句，依赖`USE`语句，不要使用数据库名称。此外，不要使用同时更新过滤进和过滤出表的多表 DML 语句。

**示例 19.7 一个`--replicate-ignore-db`选项和一个`--replicate-do-table`选项**

在复制源服务器上，发出以下语句：

```sql
USE db1;
CREATE TABLE t2 LIKE t1;
INSERT INTO db2.t3 VALUES (1);
```

副本设置了以下复制过滤选项：

```sql
replicate-ignore-db = db1
replicate-do-table = db2.t3
```

DDL 语句`CREATE TABLE`在`db1`中创建表，如前述`USE`语句指定。副本根据其`--replicate-ignore-db = db1`选项过滤掉此语句，因为`db1`是当前数据库。无论复制源服务器上的二进制日志格式如何，结果都是相同的。然而，DML `INSERT`语句的结果取决于二进制日志格式：

+   如果源服务器上使用基于行的二进制日志格式（`binlog_format=ROW`），副本使用表存在的数据库`db2`评估`INSERT`操作。首先评估数据库级选项`--replicate-ignore-db = db1`，因此不适用。表级选项`--replicate-do-table = db2.t3`适用，因此副本将更改应用于表`t3`。

+   如果源端使用基于语句的二进制日志格式（`binlog_format=STATEMENT`），那么复制端将使用由`USE`语句设置为`db1`且未更改的默认数据库来评估`INSERT`操作。根据其数据库级别的`--replicate-ignore-db = db1`选项，因此它会忽略该操作，不会将更改应用于表`t3`。表级别的选项`--replicate-do-table = db2.t3`不会被检查，因为该语句已经匹配了一个数据库级别的选项并被忽略。

如果在复制端需要`--replicate-ignore-db = db1`选项，并且在源端使用基于语句（或混合）的二进制日志格式也是必要的，可以通过在`INSERT`语句中省略数据库名称并依赖于`USE`语句来使结果保持一致，如下所示：

```sql
USE db1;
CREATE TABLE t2 LIKE t1;
USE db2;
INSERT INTO t3 VALUES (1);
```

在这种情况下，复制端始终基于数据库`db2`评估`INSERT`语句。无论操作是以语句为基础还是以行为基础的二进制格式记录，结果都是一样的。
