> 原文：[`dev.mysql.com/doc/refman/8.0/en/audit-log-logging-configuration.html`](https://dev.mysql.com/doc/refman/8.0/en/audit-log-logging-configuration.html)

#### 8.4.5.5 配置审计日志特性

本节描述了如何配置审计日志特性，例如审计日志插件写入事件的文件、写入事件的格式、是否启用日志文件压缩和加密以及空间管理。

+   审计日志文件命名约定

+   选择审计日志文件格式

+   启用审计日志刷新任务

+   为异常检测添加查询统计信息

+   压缩审计日志文件

+   加密审计日志文件

+   手动解压和解密审计日志文件

+   MySQL 8.0.17 之前的审计日志文件加密

+   审计日志文件空间管理

+   审计日志编写策略

注意

此处描述的加密功能适用于 MySQL 8.0.17，除了比较当前加密功能与以前更有限功能的部分之外；请参阅 MySQL 8.0.17 之前的审计日志文件加密。

有关影响审计日志的函数和系统变量的额外信息，请参阅审计日志函数和审计日志选项和变量。

审计日志插件还可以根据事件内容或事件来源的帐户控制写入审计日志文件的审计事件。请参阅第 8.4.5.7 节，“审计日志过滤”。

##### 审计日志文件命名约定

要配置审计日志文件名，请在服务器启动时设置`audit_log_file`系统变量。默认名称是服务器数据目录中的`audit.log`。为了最佳安全性，将审计日志写入仅对 MySQL 服务器和有合法查看日志原因的用户可访问的目录。

该插件将`audit_log_file`值解释为由可选的前导目录名、基本名称和可选后缀组成。如果启用了压缩或加密，则有效文件名（实际用于创建日志文件的名称）与配置文件名不同，因为它具有额外的后缀：

+   如果启用了压缩，插件会添加一个后缀为`.gz`。

+   如果启用了加密，插件会添加一个后缀为`.*`pwd_id`*.enc`，其中`pwd_id`指示用于日志文件操作的加密密码。审计日志插件将加密密码存储在密钥环中；请参阅加密审计日志文件。

有效的审计日志文件名是通过将适用的压缩和加密后缀添加到配置文件名中得到的名称。例如，如果配置的`audit_log_file`值为`audit.log`，则有效文件名是以下表中显示的值之一。

| 启用功能 | 有效文件名 |
| --- | --- |
| 无压缩或加密 | `audit.log` |
| 压缩 | `audit.log.gz` |
| 加密 | `audit.log.*`pwd_id`*.enc` |
| 压缩，加密 | `audit.log.gz.*`pwd_id`*.enc` |

`pwd_id`指示用于加密或解密文件的密码的 ID。`pwd_id`格式为`pwd_timestamp-seq`，其中：

+   `pwd_timestamp`是一个以`*`YYYYMMDD`*T*`hhmmss`*`格式表示的 UTC 值，指示密码创建的时间。

+   `seq`是一个序列号。序列号从 1 开始，对于具有相同`pwd_timestamp`值的密码递增。

以下是一些示例`pwd_id`密码 ID 值：

```sql
20190403T142359-1
20190403T142400-1
20190403T142400-2
```

为了构建用于在密钥环中存储密码的相应密钥环 ID，审计日志插件将`pwd_id`值的前缀添加为`audit_log-`。对于刚刚显示的示例密码 ID，相应的密钥环 ID 是：

```sql
audit_log-20190403T142359-1
audit_log-20190403T142400-1
audit_log-20190403T142400-2
```

当前由审计日志插件用于加密的密码的 ID 是具有最大`pwd_timestamp`值的密码。如果多个密码具有该`pwd_timestamp`值，则当前密码 ID 是具有最大序列号的密码。例如，在前面的密码 ID 集合中，有两个具有最大时间戳`20190403T142400`，因此当前密码 ID 是具有最大序列号（`2`）的密码。

审计日志插件根据有效的审计日志文件名在初始化和终止期间执行某些操作：

+   在初始化期间，插件会检查是否已存在具有审计日志文件名的文件，并在有时重命名它。（在这种情况下，插件假定之前的服务器调用以审计日志插件运行而异常退出。）然后插件会写入一个新的空审计日志文件。

+   在终止期间，插件会重命名审计日志文件。

+   文件重命名（无论是在插件初始化还是终止期间）都遵循自动基于大小的日志文件轮换的通常规则；请参阅手动审计日志文件轮换（MySQL 8.0.31 之前）。

##### 选择审计日志文件格式

要配置审计日志文件格式，请在服务器启动时设置`audit_log_format`系统变量。这些格式可用：

+   `NEW`：新式 XML 格式。这是默认值。

+   `OLD`：旧式 XML 格式。

+   `JSON`：JSON 格式。将审计日志写入 JSON 数组。只有此格式支持可选的查询时间和大小统计信息，这些信息从 MySQL 8.0.30 开始提供。

有关每种格式的详细信息，请参阅第 8.4.5.4 节，“审计日志文件格式”。

##### 启用审计日志刷新任务

从 MySQL 8.0.34 开始，MySQL 企业审计提供了设置刷新间隔以自动处理内存缓存的功能。使用`audit_log_flush_interval_seconds`系统变量配置的刷新任务默认值为零，这意味着未安排运行任务。

当任务配置为运行时（值为非零），MySQL 企业审计尝试在其初始化时调用 scheduler 组件，并配置其内存缓存的定期定期刷新：

+   如果审计日志找不到调度程序注册服务的实现，则不会安排刷新并继续加载。

+   审计日志实现了`dynamic_loader_services_loaded_notification`服务，并监听`mysql_scheduler`的新注册，以便审计日志可以将其计划任务注册到新加载的调度程序中。

+   审计日志仅注册到加载的第一个调度程序实现中。

类似地，MySQL 企业审计在其去初始化时调用`scheduler`组件，并取消其已计划的定期刷新。它保持对调度程序注册服务的活动引用，直到计划任务被注销，确保在有活动计划任务时无法卸载`scheduler`组件。执行调度程序及其任务的所有结果都写入服务器错误日志。

要安排审计日志刷新任务：

1.  确认`scheduler`组件已加载并启用。该组件默认启用（`ON`）（参见`component_scheduler.enabled`）。

    ```sql
    SELECT * FROM mysql.components;
    +--------------+--------------------+----------------------------+
    | component_id | component_group_id | component_urn              |
    +--------------+--------------------+----------------------------+
    |            1 |                  1 | file://component_scheduler |
    +--------------+--------------------+----------------------------+
    ```

1.  如果尚未安装`audit_log`插件，请安装它（参见 Section 8.4.5.2, “Installing or Uninstalling MySQL Enterprise Audit”）。

1.  使用`audit_log_flush_interval_seconds`启动服务器，并将值设置为大于 59 的数字。该值的上限因平台而异。例如，要配置刷新任务每两分钟重复一次：

    ```sql
    $> mysqld --audit_log_flush_interval_seconds=120
    ```

    更多信息，请参阅`audit_log_flush_interval_seconds`系统变量。

##### 添加用于异常值检测的查询统计信息

在 MySQL 8.0.30 及更高版本中，您可以通过可选数据字段扩展 JSON 格式的日志文件，以显示查询时间、发送和接收的字节数、返回给客户端的行数以及检查的行数。对于符合条件的查询，此数据在慢查询日志中可用，并且在审计日志的上下文中，类似地有助于检测活动分析的异常值。只有当审计日志处于 JSON 格式（`audit_log_format=JSON`）时，扩展数据字段才能添加，这不是默认设置。

查询统计信息通过您设置的组件服务传递到审计日志，作为审计日志过滤函数。这些服务分别命名为`mysql_audit_print_service_longlong_data_source`和`mysql_audit_print_service_double_data_source`。您可以为每个输出项选择任一数据类型。对于查询时间，`longlong`以微秒输出值，而`double`以秒输出值。

您可以使用`audit_log_filter_set_filter()`审计日志函数将查询统计信息添加为 JSON 过滤语法的`service`元素，如下所示：

```sql
SELECT audit_log_filter_set_filter('QueryStatistics',  
                                   '{ "filter": { "class": { "name": "general", "event": { "name": "status", "print" : '
                                   '{ "service": { "implementation": "mysql_server", "tag": "query_statistics", "element": [ '
                                   '{ "name": "query_time",     "type": "double" }, '
                                   '{ "name": "bytes_sent",     "type": "longlong" }, '
                                   '{ "name": "bytes_received", "type": "longlong" }, '
                                   '{ "name": "rows_sent",      "type": "longlong" }, '
                                   '{ "name": "rows_examined",  "type": "longlong" } ] } } } } } }');
```

要填充`bytes_sent`和`bytes_received`字段，系统变量`log_slow_extra`必须设置为`ON`。如果系统��量值为`OFF`，则这些字段的日志文件中将写入空值。

如果您想停止收集查询统计信息，请使用`audit_log_filter_set_filter()`审计日志函数来移除过滤器，例如：

```sql
SELECT audit_log_filter_remove_filter('QueryStatistics');
```

##### 压缩审计日志文件

可以为任何日志格式启用审计日志文件压缩。

要配置审计日志文件压缩，请在服务器启动时设置`audit_log_compression`系统变量。允许的值为`NONE`（无压缩；默认值）和`GZIP`（GNU Zip 压缩）。

如果同时启用了压缩和加密，则压缩会在加密之前发生。要手动恢复原始文件，首先解密，然后解压缩。请参阅手动解压缩和解密审计日志文件。

##### 加密审计日志文件

可以为任何日志格式启用审计日志文件加密。加密基于用户定义的密码（除了审计日志插件生成的初始密码）。要使用此功能，必须启用 MySQL 密钥环，因为审计日志使用它进行密码存储。可以使用任何密钥环组件或插件；有关说明，请参阅第 8.4.4 节，“MySQL 密钥环”。

要配置审计日志文件加密，请在服务器启动时设置`audit_log_encryption`系统变量。允许的值为`NONE`（无加密；默认）和`AES`（AES-256-CBC 密码加密）。

要在运行时设置或获取加密密码，请使用这些审计日志函数：

+   要设置当前的加密密码，请调用`audit_log_encryption_password_set()`。此函数将新密码存储在密钥环中。如果启用了加密，它还会执行一个日志文件旋转操作，重命名当前日志文件，并开始一个新的使用密码加密的日志文件。文件重命名遵循自动基于大小的日志文件旋转的通常规则；请参阅手动审计日志文件旋转（MySQL 8.0.31 之前）。

    如果`audit_log_password_history_keep_days`系统变量不为零，则调用`audit_log_encryption_password_set()`也会导致旧的存档审计日志加密密码过期。有关审计日志密码历史的信息，包括密码存档和过期，请参阅该变量的描述。

+   要获取当前的加密密码，请调用不带参数的`audit_log_encryption_password_get()`。要通过 ID 获取密码，请传递一个指定当前密码或存档密码的密钥环 ID 的参数。

    要确定存在哪些审计日志密钥环 ID，请查询性能模式`keyring_keys`表：

    ```sql
    mysql> SELECT KEY_ID FROM performance_schema.keyring_keys
           WHERE KEY_ID LIKE 'audit_log%'
           ORDER BY KEY_ID;
    +-----------------------------+
    | KEY_ID                      |
    +-----------------------------+
    | audit_log-20190415T152248-1 |
    | audit_log-20190415T153507-1 |
    | audit_log-20190416T125122-1 |
    | audit_log-20190416T141608-1 |
    +-----------------------------+
    ```

有关审计日志加密函数的其他信息，请参阅审计日志函数。

当审计日志插件初始化时，如果发现日志文件加密已启用，则会检查密钥环是否包含审计日志加密密码。如果没有，则插件会自动生成一个随机初始加密密码并将其存储在密钥环中。要查找此密码，请调用`audit_log_encryption_password_get()`。

如果同时启用了压缩和加密，则压缩会在加密之前发生。要手动恢复原始文件，请先解密，然后解压缩。请参阅手动解压缩和解密审计日志文件。

##### 手动解压缩和解密审计日志文件

审计日志文件可以使用标准工具进行解压缩和解密。这应该仅针对已关闭（已归档）且不再使用的日志文件进行，而不是当前审计日志插件正在写入的日志文件。您可以通过审计日志插件将时间戳添加到基本名称后的文件名中来识别已归档的日志文件。

在本讨论中，假设`audit_log_file`设置为`audit.log`。在这种情况下，已归档的审计日志文件具有以下表中显示的名称之一。

| 启用功能 | 已归档文件名 |
| --- | --- |
| 无压缩或加密 | `audit.*`timestamp`*.log` |
| 压缩 | `audit.*`timestamp`*.log.gz` |
| 加密 | `audit.*`timestamp`*.log.*`pwd_id`*.enc` |
| 压缩，加密 | `audit.*`timestamp`*.log.gz.*`pwd_id`*.enc` |

如审计日志文件命名约定所述，*`pwd_id`*格式为*`pwd_timestamp-seq`*。因此，已归档的加密日志文件的名称实际上包含两个时间戳。第一个时间戳表示文件旋转时间，第二个时间戳表示加密密码创建时间。

考虑以下一组已归档的加密日志文件名称：

```sql
audit.20190410T205827.log.20190403T185337-1.enc
audit.20190410T210243.log.20190403T185337-1.enc
audit.20190415T145309.log.20190414T223342-1.enc
audit.20190415T151322.log.20190414T223342-2.enc
```

每个文件名都有一个唯一的旋转时间戳。相比之下，密码时间戳不是唯一的：

+   前两个文件具有相同的密码 ID 和序列号（`20190403T185337-1`）。它们具有相同的加密密码。

+   后两个文件具有相同的密码 ID（`20190414T223342`），但不同的序列号（`1`，`2`）。这些文件具有不同的加密密码。

要手动解压缩压缩的日志文件，请使用**gunzip**，**gzip -d**或等效命令。例如：

```sql
gunzip -c audit.*timestamp*.log.gz > audit.*timestamp*.log
```

要手动解密加密的日志文件，请使用**openssl**命令。例如：

```sql
openssl enc -d -aes-256-cbc -pass pass:*password* -md sha256
    -in audit.*timestamp*.log.*pwd_id*.enc
    -out audit.*timestamp*.log
```

要执行该命令，你必须获取*`password`*，即加密密码。为此，请使用`audit_log_encryption_password_get()`。例如，如果审计日志文件名为`audit.20190415T151322.log.20190414T223342-2.enc`，密码 ID 为`20190414T223342-2`，密钥环 ID 为`audit-log-20190414T223342-2`。像这样检索密钥环密码：

```sql
SELECT audit_log_encryption_password_get('audit-log-20190414T223342-2');
```

如果审计日志既启用了压缩又启用了加密，压缩会在加密之前发生。在这种情况下，文件名会添加`.gz`和`.*`pwd_id`*.enc`后缀，对应这些操作发生的顺序。要手动恢复原始文件，请按相反顺��执行操作。也就是说，首先解密文件，然后解压缩：

```sql
openssl enc -d -aes-256-cbc -pass pass:*password* -md sha256
    -in audit.*timestamp*.log.gz.*pwd_id*.enc
    -out audit.*timestamp*.log.gz
gunzip -c audit.*timestamp*.log.gz > audit.*timestamp*.log
```

##### MySQL 8.0.17 之前的审计日志文件加密

本节介绍了 MySQL 8.0.17 之前和之后审计日志文件加密功能的差异，这是在实现密码历史记录（包括密码归档和过期）时的情况。还指出了审计日志插件如何处理从低于 8.0.17 版本升级到 MySQL 8.0.17 或更高版本的情况。

| 功能 | 在 MySQL 8.0.17 之前 | 截至 MySQL 8.0.17 |
| --- | --- | --- |
| 密码数量 | 仅单个密码 | 允许多个密码 |
| 加密日志文件名称 | `.enc` 后缀 | `.*`pwd_id`*.enc` 后缀 |
| 密码密钥环 ID | `audit_log` | `audit_log-*`pwd_id`*` |
| 密码历史记录 | 否 | 是 |

在 MySQL 8.0.17 之前，没有密码历史记录，因此设置新密码会使旧密码无法访问，导致 MySQL 企业审计无法读取用旧密码加密的日志文件。如果你预期需要手动解密这些文件，你必须保留以前的密码记录。

如果在从低版本升级到 MySQL 8.0.17 或更高版本时启用了审计日志文件加密，则审计日志插件执行以下升级操作：

+   在插件初始化期间，插件会检查具有`audit_log`密钥环 ID 的加密密码。如果找到一个，插件会使用`audit_log-*`pwd_id`*`格式中的密钥环 ID 复制密码，并将其用作当前的加密密码。（有关*`pwd_id`*语法的详细信息，请参阅审计日志文件命名约定.）

+   现有加密的日志文件具有后缀`.enc`。插件不会将这些重命名为后缀为`.*`pwd_id`*.enc`，但只要具有`audit_log` ID 的密钥保留在密钥环中，就可以读取它们。

+   当密码清理发生时，如果插件过期任何具有`audit_log-*`pwd_id`*`格式的密钥环 ID 的密码，它也会过期具有`audit_log`密钥环 ID 的密码（如果存在）。此时，具有后缀`.enc`而不是`.*`pwd_id`*.enc`的加密日志文件变得无法被插件读取，因此可以假定你不再需要它们。

##### 审计日志文件的空间管理

审计日志文件有可能变得非常庞大，占用大量磁盘空间。如果您正在收集自 MySQL 8.0.30 起可用的可选查询时间和大小统计信息，则会增加空间要求。查询统计仅支持 JSON 格式。

为管理使用的空间，采用以下方法：

+   日志文件轮换。这涉及通过重命名当前日志文件来轮换它，然后使用原始名称打开一个新的当前日志文件。轮换可以手动执行，也可以配置为自动执行。

+   如果启用了自动轮换，则对已轮换的 JSON 格式日志文件进行修剪。修剪可以基于日志文件的年龄（自 MySQL 8.0.24 起），或组合日志文件大小（自 MySQL 8.0.26 起）进行。

要配置审计日志文件空间管理，请使用以下系统变量：

+   如果`audit_log_rotate_on_size`为 0（默认值），则禁用自动日志文件轮换。

    +   除非手动执行，否则不会发生轮换。

    +   要轮换当前文件，请使用以下方法之一：

        +   在 MySQL 8.0.31 之前，手动重命名文件，然后启用`audit_log_flush`来关闭它，并使用原始名称打开一个新的当前日志文件。此文件轮换方法和`audit_log_flush`变量在 MySQL 8.0.31 中已弃用。

            使用此文件轮换方法，不会发生对已轮换的 JSON 格式日志文件进行修剪；`audit_log_max_size`和`audit_log_prune_seconds`不起作用。

        +   从 MySQL 8.0.31 开始，运行`SELECT audit_log_rotate();`来重命名文件，并使用原始名称打开一个新的审计日志文件。

            使用此文件轮换方法，如果`audit_log_max_size`或`audit_log_prune_seconds`的值大于 0，则会对已轮换的 JSON 格式日志文件进行修剪。

        参见手动审计日志文件轮换（MySQL 8.0.31 之前）。

+   如果`audit_log_rotate_on_size`大于 0，则启用自动审计日志文件轮换：

    +   当对当前日志文件进行写入导致其大小超过`audit_log_rotate_on_size`值时，以及在某些其他条件下，会自动进行轮换；参见自动审计日志文件轮换。当自动轮换发生时，审计日志插件会重命名当前日志文件，并使用原始名称打开一个新的当前日志文件。

    +   如果`audit_log_max_size`或`audit_log_prune_seconds`的值大于 0，则会对旋转的 JSON 格式日志文件进行修剪。

    +   `audit_log_flush`没有效果。

注意

对于 JSON 格式的日志文件，在运行时更改`audit_log_format_unix_timestamp`系统变量的值时也会发生旋转。然而，这并不是为了空间管理目的，而是为了使给定的 JSON 格式日志文件中的所有记录要么包含`time`字段，要么不包含。

注意

旋转（重命名）的日志文件不会自动删除。例如，基于大小的日志文件旋转，重命名的日志文件具有唯一名称并且会无限累积。它们不会在名称序列的末尾旋转。为避免过度使用空间：

+   从 MySQL 8.0.24 开始（针对 JSON 格式日志文件）：按照审计日志文件修剪中描述的方式启用日志文件修剪。

+   否则（对于非 JSON 文件，或者在 MySQL 8.0.24 之前的所有日志格式）：定期删除旧文件，必要时首先备份它们。如果备份的日志文件已加密，还需将相应的加密密码备份到安全位置，以便以后解密文件时使用。

以下部分详细描述了日志文件旋转和修剪。

+   手动审计日志文件旋转（MySQL 8.0.31 之前）

+   手动审计日志文件旋转（从 MySQL 8.0.31 开始）

+   自动审计日志文件旋转

+   审计日志文件修剪

###### 手动审计日志文件旋转（MySQL 8.0.31 之前）

注意

从 MySQL 8.0.31 开始，`audit_log_flush`变量和这种审计日志文件旋转方法已被弃用；预计在未来的 MySQL 版本中将不再支持。

如果`audit_log_rotate_on_size`为 0（默认值），除非手动执行，否则不会发生日志轮换。在这种情况下，当`audit_log_flush`值从禁用更改为启用时，审计日志插件会关闭并重新打开日志文件。日志文件重命名必须在服务器外部完成。假设日志文件名为`audit.log`，并且您希望保留最近的三个日志文件，循环使用名称`audit.log.1`到`audit.log.3`。在 Unix 上，执行以下手动旋转：

1.  从命令行，重命名当前的日志文件：

    ```sql
    mv audit.log.2 audit.log.3
    mv audit.log.1 audit.log.2
    mv audit.log audit.log.1
    ```

    此策略会覆盖当前的`audit.log.3`内容，限制已归档的日志文件的数量和它们使用的空间。

1.  此时，插件仍在写入当前的日志文件，该文件已重命名为`audit.log.1`。连接到服务器并刷新日志文件，以便插件关闭它并重新打开一个新的`audit.log`文件：

    ```sql
    SET GLOBAL audit_log_flush = ON;
    ```

    `audit_log_flush`是特殊的，其值保持为`OFF`，因此您无需在再次启用它以执行另一个刷新之前显式禁用它。

注意

如果启用了压缩或加密功能，则日志文件名包括表示已启用功能的后缀，以及如果启用了加密则包括密码 ID。如果文件名包括密码 ID，请确保在手动重命名任何文件时保留 ID，以便确定用于解密操作的密码。

注意

对于 JSON 格式日志记录，手动重命名审计日志文件会使它们对于日志读取功能不可用，因为审计日志插件无法再确定它们是日志文件序列的一部分（参见第 8.4.5.6 节，“读取审计日志文件”）。考虑设置`audit_log_rotate_on_size`大于 0 以使用基于大小的轮换。

###### 手动审计日志文件旋转（从 MySQL 8.0.31 开始）

如果`audit_log_rotate_on_size`为 0（默认值），除非手动执行，否则不会发生日志轮换。

要手动旋转审计日志文件，请运行`SELECT audit_log_rotate();`以重命名当前的审计日志文件并打开一个新的审计日志文件。文件将根据审计日志文件命名约定中描述的约定进行重命名。

使用`audit_log_rotate()`函数需要`AUDIT_ADMIN`特权。

管理已归档的日志文件（已重命名的文件）的数量和它们使用的空间是一个手动任务，涉及从文件系统中删除不再需要的已归档审计日志文件。

使用`audit_log_rotate()`函数重命名的审计日志文件的内容可以通过`audit_log_read()`函数读取。

###### 自动审计日志文件旋转

如果`audit_log_rotate_on_size`大于 0，则设置`audit_log_flush`无效。相反，每当对当前日志文件的写入导致其大小超过`audit_log_rotate_on_size`值时，审计日志插件会自动重命名当前日志文件，并使用原始名称打开一个新的当前日志文件。

在以下情况下也会自动基于大小进行旋转：

+   在插件初始化期间，如果具有审计日志文件名的文件已经存在（参见审计日志文件命名约定）。

+   在插件终止期间。

+   当调用`audit_log_encryption_password_set()`函数设置加密密码时，如果启用了加密。（如果禁用加密，则不会发生旋转。）

插件通过在基本名称后插入时间戳来重命名原始文件。例如，如果文件名为`audit.log`，插件将将其重命名为类似`audit.20210115T140633.log`的值。时间戳是`*`YYYYMMDD`*T*`hhmmss`*`格式的 UTC 值。对于 XML 日志记录，时间戳表示旋转时间。对于 JSON 日志记录，时间戳是写入文件的最后一个事件的时间。

如果日志文件已加密，则原始文件名已包含指示加密密码创建时间的时间戳（请参见审计日志文件命名约定）。在这种情况下，旋转后的文件名包含两个时间戳。例如，名为`audit.log.20210110T130749-1.enc`的加密日志文件将重命名为类似`audit.20210115T140633.log.20210110T130749-1.enc`的值。

###### 审计日志文件修剪

如果启用了自动日志文件旋转，则审计日志插件支持对旋转的 JSON 格式审计日志文件进行修剪。要使用此功能：

+   将`audit_log_format`设置为`JSON`。（此外，还考虑更改`audit_log_file`;请参见选择审计日志文件格式。）

+   将`audit_log_rotate_on_size`设置为大于 0，以指定自动日志文件旋转发生的字节大小。

+   默认情况下，不会对自动旋转的 JSON 格式日志文件进行修剪。要启用修剪，请将以下系统变量之一设置为大于 0 的值：

    +   将`audit_log_max_size`设置为大于 0，以指定旋转日志文件的组合大小上限，超过该大小的文件将被修剪。`audit_log_max_size`自 MySQL 8.0.26 版本起可用。

    +   将`audit_log_prune_seconds`设置为大于 0，以指定旋转日志文件在多少秒后将被修剪。`audit_log_prune_seconds`自 MySQL 8.0.24 版本起可用。

    非零值的`audit_log_max_size`优先于非零值的`audit_log_prune_seconds`。如果两者在插件初始化时都设置为大于 0，则会向服务器错误日志写入警告。如果客户端在运行时都设置为大于 0，则会向客户端返回警告。

    注意

    写入错误日志的警告被写入为注释，这些是信息消息。为确保这些消息出现在错误日志中并且不被丢弃，请确保错误日志的详细程度足以包含信息消息。例如，如果您正在使用基于优先级的日志过滤，如第 7.4.2.5 节，“基于优先级的错误日志过滤（log_filter_internal）”中所述，将`log_error_verbosity`系统变量设置为 3。

如果启用了 JSON 格式日志文件的修剪，则会按以下方式进行：

+   当自动旋转发生时；有关发生此情况的条件，请参阅自动审计日志文件旋转。

+   当全局`audit_log_max_size`或`audit_log_prune_seconds`系统变量���运行时设置时。

对于基于组合旋转日志文件大小进行修剪，如果组合大小大于`audit_log_max_size`指定的限制，则审计日志插件将删除最旧的文件，直到它们的组合大小不超过限制。

对于基于旋转日志文件年龄进行修剪，修剪点是当前时间减去`audit_log_prune_seconds`的值。在旋转的 JSON 格式日志文件中，每个文件名的时间戳部分表示写入文件的最后一个事件的时间戳。审计日志插件使用文件名时间戳来确定哪些文件仅包含早于修剪点的事件，并将其删除。

##### 撰写审计日志策略

审计日志插件可以使用多种策略进行日志写入。无论采用哪种策略，记录都是尽力而为的，没有一致性的保证。

要指定写入策略，请在服务器启动时设置 `audit_log_strategy` 系统变量。默认情况下，策略值为 `ASYNCHRONOUS`，插件会异步记录到缓冲区，如果缓冲区已满则等待。可以告诉插件不要等待 (`PERFORMANCE`) 或使用文件系统缓存同步记录 (`SEMISYNCHRONOUS`)，或者在每次写入请求后强制输出使用 `sync()` 调用 (`SYNCHRONOUS`)。

对于异步写入策略，`audit_log_buffer_size` 系统变量是以字节为单位的缓冲区大小。在服务器启动时设置此变量以更改缓冲区大小。插件使用一个单一的缓冲区，在初始化时分配并在终止时移除。插件不会为非异步写入策略分配此缓冲区。

异步记录策略具有以下特点：

+   对服务器性能和可扩展性的影响最小。

+   阻塞生成审计事件的线程的时间尽可能短；即分配缓冲区的时间加上将事件复制到缓冲区的时间。

+   输出到缓冲区。一个单独的线程处理从缓冲区到日志文件的写入。

使用异步记录时，如果在写入文件时出现问题或插件未能干净地关闭（例如，在服务器主机意外退出的情况下），日志文件的完整性可能会受到影响。为了降低这种风险，请将 `audit_log_strategy` 设置为使用同步记录。

`PERFORMANCE` 策略的一个缺点是当缓冲区已满时会丢弃事件。对于负载较重的服务器，审计日志可能会丢失事件。
