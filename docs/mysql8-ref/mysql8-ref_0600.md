# 10.8.5 估计查询性能

> 原文：[`dev.mysql.com/doc/refman/8.0/en/estimating-performance.html`](https://dev.mysql.com/doc/refman/8.0/en/estimating-performance.html)

在大多数情况下，您可以通过计算磁盘寻道次数来估计查询性能。对于小表，您通常可以在一个磁盘寻道中找到一行（因为索引可能已缓存）。对于更大的表，您可以估计使用 B 树索引，您需要这么多次寻道才能找到一行：`log(*`row_count`*) / log(*`index_block_length`* / 3 * 2 / (*`index_length`* + *`data_pointer_length`*)) + 1`。

在 MySQL 中，索引块通常为 1,024 字节，数据指针通常为四个字节。对于一个具有 500,000 行的表，关键值长度为三个字节（`MEDIUMINT` - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT")的大小），该公式指示 `log(500,000)/log(1024/3*2/(3+4)) + 1` = `4` 次寻道。

这个索引需要存储大约 500,000 * 7 * 3/2 = 5.2MB 的空间（假设典型索引缓冲填充比为 2/3），所以你可能已经将大部分索引存储在内存中，因此只需要一两次读取数据来找到行。

然而，对于写入操作，您需要四个寻道请求来找到新索引值的放置位置，并通常需要两次寻道来更新索引并写入行。

前面的讨论并不意味着您的应用性能会随着 log *`N`* 而缓慢下降。只要一切都被操作系统或 MySQL 服务器缓存，随着表变得更大，事情只会变得稍微慢一点。当数据变得太大无法缓存时，事情开始变得慢得多，直到您的应用程序仅受磁盘寻道的限制（这些寻道按 log *`N`* 增加）。为了避免这种情况，随着数据增长，增加关键缓存大小。对于`MyISAM`表，关键缓存大小由`key_buffer_size`系统变量控制。请参阅第 7.1.1 节，“配置服务器”。
