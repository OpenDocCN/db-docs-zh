# 14.20.1 窗口函数描述

> 原文：[`dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html`](https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html)

本节描述了非聚合窗口函数，对于查询中的每一行，使用与该行相关的行执行计算。大多数聚合函数也可以用作窗口函数；请参见第 14.19.1 节，“聚合函数描述”。

有关窗口函数的使用信息和示例，以及术语的定义，如`OVER`子句、窗口、分区、帧和对等行，请参见第 14.20.2 节，“窗口函数概念和语法”。

**表 14.30 窗口函数**

| 名称 | 描述 |
| --- | --- |
| `CUME_DIST()` | 累积分布值 |
| `DENSE_RANK()` | 分区内当前行的排名，无间隔 |
| `FIRST_VALUE()` | 窗口帧的第一行的参数值 |
| `LAG()` | 分区内滞后于当前行的行的参数值 |
| `LAST_VALUE()` | 窗口帧的最后一行的参数值 |
| `LEAD()` | 分区内领先于当前行的行的参数值 |
| `NTH_VALUE()` | 窗口帧的第 N 行的参数值 |
| `NTILE()` | 当前行在其分区内的桶编号 |
| `PERCENT_RANK()` | 百分比排名值 |
| `RANK()` | 分区内当前行的排名，有间隔 |
| `ROW_NUMBER()` | 当前行在其分区内的编号 |
| 名称 | 描述 |

在以下函数描述中，*`over_clause`*代表`OVER`子句，详见第 14.20.2 节，“窗口函数概念和语法”。一些窗口函数允许使用*`null_treatment`*子句，指定在计算结果时如何处理`NULL`值。此子句是可选的。它是 SQL 标准的一部分，但 MySQL 实现仅允许`RESPECT NULLS`（这也是默认值）。这意味着在计算结果时会考虑`NULL`值。`IGNORE NULLS`被解析，但会产生错误。

+   `CUME_DIST()` *`over_clause`*

    返回值在组内值的累积分布；即，在当前行中窗口排序的窗口分区中小于或等于当前行中值的分区值的百分比。这表示在窗口分区中在当前行之前或与当前行并列的行数除以窗口分区中的总行数。返回值范围从 0 到 1。

    此函数应与 `ORDER BY` 一起使用，以将分区行按所需顺序排序。没有 `ORDER BY`，所有行都是对等的，并且具有值 *`N`*/*`N`* = 1，其中 *`N`* 是分区大小。

    *`over_clause`* 如 第 14.20.2 节，“窗口函数概念和语法” 中所述。

    以下查询显示了 `val` 列中值集合的每行的 `CUME_DIST()` 值，以及类似的 `PERCENT_RANK()` 函数返回的百分比排名值。供参考，查询还使用 `ROW_NUMBER()` 显示行号：

    ```sql
    mysql> SELECT
             val,
             ROW_NUMBER()   OVER w AS 'row_number',
             CUME_DIST()    OVER w AS 'cume_dist',
             PERCENT_RANK() OVER w AS 'percent_rank'
           FROM numbers
           WINDOW w AS (ORDER BY val);
    +------+------------+--------------------+--------------+
    | val  | row_number | cume_dist          | percent_rank |
    +------+------------+--------------------+--------------+
    |    1 |          1 | 0.2222222222222222 |            0 |
    |    1 |          2 | 0.2222222222222222 |            0 |
    |    2 |          3 | 0.3333333333333333 |         0.25 |
    |    3 |          4 | 0.6666666666666666 |        0.375 |
    |    3 |          5 | 0.6666666666666666 |        0.375 |
    |    3 |          6 | 0.6666666666666666 |        0.375 |
    |    4 |          7 | 0.8888888888888888 |         0.75 |
    |    4 |          8 | 0.8888888888888888 |         0.75 |
    |    5 |          9 |                  1 |            1 |
    +------+------------+--------------------+--------------+
    ```

+   `DENSE_RANK()` *`over_clause`*

    返回当前行在其分区内的排名，没有间隔。对等行被视为并列，并获得相同的排名。此函数为对等组分配连续的排名；结果是大小大于一的组不会产生不连续的排名数字。有关示例，请参阅 `RANK()` 函数描述。

    此函数应与 `ORDER BY` 一起使用，以将分区行按所需顺序排序。没有 `ORDER BY`，所有行都是对等的。

    *`over_clause`* 如 第 14.20.2 节，“窗口函数概念和语法” 中所述。

+   `FIRST_VALUE(*`expr`*)` [*`null_treatment`*] *`over_clause`*

    返回窗口帧的第一行中 *`expr`* 的值。

    *`over_clause`* 如 第 14.20.2 节，“窗口函数概念和语法” 中所述。*`null_treatment`* 如章节介绍中所述。

    以下查询演示了 `FIRST_VALUE()`、`LAST_VALUE()` 和两个 `NTH_VALUE()` 的实例：

    ```sql
    mysql> SELECT
             time, subject, val,
             FIRST_VALUE(val)  OVER w AS 'first',
             LAST_VALUE(val)   OVER w AS 'last',
             NTH_VALUE(val, 2) OVER w AS 'second',
             NTH_VALUE(val, 4) OVER w AS 'fourth'
           FROM observations
           WINDOW w AS (PARTITION BY subject ORDER BY time
                        ROWS UNBOUNDED PRECEDING);
    +----------+---------+------+-------+------+--------+--------+
    | time     | subject | val  | first | last | second | fourth |
    +----------+---------+------+-------+------+--------+--------+
    | 07:00:00 | st113   |   10 |    10 |   10 |   NULL |   NULL |
    | 07:15:00 | st113   |    9 |    10 |    9 |      9 |   NULL |
    | 07:30:00 | st113   |   25 |    10 |   25 |      9 |   NULL |
    | 07:45:00 | st113   |   20 |    10 |   20 |      9 |     20 |
    | 07:00:00 | xh458   |    0 |     0 |    0 |   NULL |   NULL |
    | 07:15:00 | xh458   |   10 |     0 |   10 |     10 |   NULL |
    | 07:30:00 | xh458   |    5 |     0 |    5 |     10 |   NULL |
    | 07:45:00 | xh458   |   30 |     0 |   30 |     10 |     30 |
    | 08:00:00 | xh458   |   25 |     0 |   25 |     10 |     30 |
    +----------+---------+------+-------+------+--------+--------+
    ```

    每个函数使用当前帧中的行，根据所示的窗口定义，该帧从第一个分区行延伸到当前行。对于 `NTH_VALUE()` 调用，当前帧并不总是包括请求的行；在这种情况下，返回值为 `NULL`。

+   [`LAG(*`expr`* [, *`N`*[, *`default`*]])`](window-function-descriptions.html#function_lag) [*`null_treatment`*] *`over_clause`*

    返回在其分区内当前行之前*`N`*行的行的*`expr`*的值。如果没有这样的行，则返回值为*`default`*。例如，如果*`N`*为 3，则前三行的返回值为*`default`*。如果*`N`*或*`default`*缺失，则默认值分别为 1 和`NULL`。

    *`N`*必须是一个字面非负整数。如果*`N`*为 0，则为当前行评估*`expr`*。

    从 MySQL 8.0.22 开始，*`N`* 不能为`NULL`。此外，它现在必须是范围在`0`到`2⁶³`之间的整数，包括以下任一形式：

    +   一个无符号整数常量字面值

    +   一个位置参数标记（`?`）

    +   一个用户定义的变量

    +   存储过程中的局部变量

    *`over_clause`* 如第 14.20.2 节，“窗口函数概念和语法”所述。*`null_treatment`* 如章节介绍所述。

    `LAG()`（以及类似的`LEAD()`函数）经常用于计算行之间的差异。以下查询显示了一组按时间排序的观测值，以及每个观测值的`LAG()`和`LEAD()`值，以及当前行与相邻行之间的差异：

    ```sql
    mysql> SELECT
             t, val,
             LAG(val)        OVER w AS 'lag',
             LEAD(val)       OVER w AS 'lead',
             val - LAG(val)  OVER w AS 'lag diff',
             val - LEAD(val) OVER w AS 'lead diff'
           FROM series
           WINDOW w AS (ORDER BY t);
    +----------+------+------+------+----------+-----------+
    | t        | val  | lag  | lead | lag diff | lead diff |
    +----------+------+------+------+----------+-----------+
    | 12:00:00 |  100 | NULL |  125 |     NULL |       -25 |
    | 13:00:00 |  125 |  100 |  132 |       25 |        -7 |
    | 14:00:00 |  132 |  125 |  145 |        7 |       -13 |
    | 15:00:00 |  145 |  132 |  140 |       13 |         5 |
    | 16:00:00 |  140 |  145 |  150 |       -5 |       -10 |
    | 17:00:00 |  150 |  140 |  200 |       10 |       -50 |
    | 18:00:00 |  200 |  150 | NULL |       50 |      NULL |
    +----------+------+------+------+----------+-----------+
    ```

    在示例中，`LAG()`和`LEAD()`调用使用默认的*`N`*和*`default`*值分别为 1 和`NULL`。

    第一行显示了当`LAG()`没有前一行时会发生什么：函数返回*`default`*值（在本例中为`NULL`）。最后一行显示了当`LEAD()`没有下一行时会发生的情况。

    `LAG()`和`LEAD()`还用于计算和而不是差。考虑这个数据集，其中包含斐波那契数列的前几个数字：

    ```sql
    mysql> SELECT n FROM fib ORDER BY n;
    +------+
    | n    |
    +------+
    |    1 |
    |    1 |
    |    2 |
    |    3 |
    |    5 |
    |    8 |
    +------+
    ```

    以下查询显示了与当前行相邻的行的`LAG()`和`LEAD()`值。它还使用这些函数将前一行和后一行的值添加到当前行值中。效果是生成斐波那契数列中的下一个数字，以及其后一个数字：

    ```sql
    mysql> SELECT
             n,
             LAG(n, 1, 0)      OVER w AS 'lag',
             LEAD(n, 1, 0)     OVER w AS 'lead',
             n + LAG(n, 1, 0)  OVER w AS 'next_n',
             n + LEAD(n, 1, 0) OVER w AS 'next_next_n'
           FROM fib
           WINDOW w AS (ORDER BY n);
    +------+------+------+--------+-------------+
    | n    | lag  | lead | next_n | next_next_n |
    +------+------+------+--------+-------------+
    |    1 |    0 |    1 |      1 |           2 |
    |    1 |    1 |    2 |      2 |           3 |
    |    2 |    1 |    3 |      3 |           5 |
    |    3 |    2 |    5 |      5 |           8 |
    |    5 |    3 |    8 |      8 |          13 |
    |    8 |    5 |    0 |     13 |           8 |
    +------+------+------+--------+-------------+
    ```

    生成斐波那契数列的初始集合的一种方法是使用递归公共表达式。有关示例，请参见 Fibonacci Series Generation。

    从 MySQL 8.0.22 开始，您不能在此函数的行参数中使用负值。

+   `LAST_VALUE(*`expr`*)` [*`null_treatment`*] *`over_clause`*

    返回窗口帧的最后一行的*`expr`*的值。

    *`over_clause`*如第 14.20.2 节，“窗口函数概念和语法”中所述。*`null_treatment`*如本节介绍中所述。

    有关示例，请参见`FIRST_VALUE()`函数描述。

+   [`LEAD(*`expr`* [, *`N`*[, *`default`*]])`](window-function-descriptions.html#function_lead) [*`null_treatment`*] *`over_clause`*

    返回在其分区内跟随当前行的第*N*行的*`expr`*的值。如果没有这样的行，则返回值为*`default`*。例如，如果*N*为 3，则最后三行的返回值为*`default`*。如果*N*或*`default`*缺失，则默认值分别为 1 和`NULL`。

    *`N`*必须是一个字面非负整数。如果*N*为 0，则为当前行评估*`expr`*。

    从 MySQL 8.0.22 开始，*`N`*不能为`NULL`。此外，现在它必须是范围为`0`到`2⁶³`（包括）的整数，可以采用以下任何形式：

    +   一个无符号整数常量字面值

    +   一个位置参数标记（`?`）

    +   用户定义变量

    +   存储过程中的局部变量

    *`over_clause`*如第 14.20.2 节，“窗口函数概念和语法”中所述。*`null_treatment`*如本节介绍中所述。

    有关示例，请参见`LAG()`函数描述。

    在 MySQL 8.0.22 及更高版本中，不允许在此函数的行参数中使用负值。

+   `NTH_VALUE(*`expr`*, *`N`*)` [*`from_first_last`*] [*`null_treatment`*] *`over_clause`*

    返回窗口帧的第*N*行的*`expr`*的值。如果没有这样的行，则返回值为`NULL`。

    *`N`*必须是一个字面正整数。

    *`from_first_last`*是 SQL 标准的一部分，但 MySQL 实现仅允许`FROM FIRST`（这也是默认值）。这意味着计算从窗口的第一行开始。`FROM LAST`被解析，但会产生错误。要获得与`FROM LAST`相同的效果（从窗口的最后一行开始计算），请使用`ORDER BY`以相反顺序排序。

    *`over_clause`*如第 14.20.2 节，“窗口函数概念和语法”中描述的那样。*`null_treatment`*如章节介绍中描述的那样。

    有关示例，请参阅`FIRST_VALUE()`函数描述。

    在 MySQL 8.0.22 及更高版本中，您不能将`NULL`用作此函数的行参数。

+   `NTILE(*`N`*)` *`over_clause`*

    将分区分成*`N`*组（桶），为分区中的每行分配其桶号，并返回当前行在其分区中的桶号。例如，如果*`N`*为 4，`NTILE()`将行分成四个桶。如果*`N`*为 100，`NTILE()`将行分成 100 个桶。

    *`N`*必须是一个字面正整数。桶号返回值范围从 1 到*`N`*。

    从 MySQL 8.0.22 开始，*`N`*不能为`NULL`，必须是范围在`0`到`2⁶³`之间的整数，可以采用以下任何形式：

    +   一个无符号整数常量字面值

    +   一个位置参数标记（`?`）

    +   一个用户定义的变量

    +   存储过程中的局部变量

    此函数应与`ORDER BY`一起使用，以将分区行按所需顺序排序。

    *`over_clause`*如第 14.20.2 节，“窗口函数概念和语法”中描述的那样。

    以下查询显示了`val`列中值集合的百分位值，将行分成两组或四组。为了参考，查询还使用`ROW_NUMBER()`显示行号：

    ```sql
    mysql> SELECT
             val,
             ROW_NUMBER() OVER w AS 'row_number',
             NTILE(2)     OVER w AS 'ntile2',
             NTILE(4)     OVER w AS 'ntile4'
           FROM numbers
           WINDOW w AS (ORDER BY val);
    +------+------------+--------+--------+
    | val  | row_number | ntile2 | ntile4 |
    +------+------------+--------+--------+
    |    1 |          1 |      1 |      1 |
    |    1 |          2 |      1 |      1 |
    |    2 |          3 |      1 |      1 |
    |    3 |          4 |      1 |      2 |
    |    3 |          5 |      1 |      2 |
    |    3 |          6 |      2 |      3 |
    |    4 |          7 |      2 |      3 |
    |    4 |          8 |      2 |      4 |
    |    5 |          9 |      2 |      4 |
    +------+------------+--------+--------+
    ```

    从 MySQL 8.0.22 开始，不再允许使用构造`NTILE(NULL)`。

+   `PERCENT_RANK()` *`over_clause`*

    返回小于当前行值的分区值的百分比，不包括最高值。返回值范围从 0 到 1，表示行相对排名，计算公式的结果如下，其中*`rank`*是行排名，*`rows`*是分区行数：

    ```sql
    (*rank* - 1) / (*rows* - 1)
    ```

    此函数应与`ORDER BY`一起使用，以将分区行按所需顺序排序。没有`ORDER BY`，所有行都是同级。

    *`over_clause`*如第 14.20.2 节，“窗口函数概念和语法”中描述的那样。

    有关示例，请参阅`CUME_DIST()`函数描述。

+   `RANK()` *`over_clause`*

    返回当前行在其分区中的排名，带有间隙。同级被视为并列并获得相同的排名。如果存在大于一的同级组，则此函数不会为同级组分配连续的排名；结果是不连续的排名数字。

    此函数应与 `ORDER BY` 一起使用，以将分区行按所需顺序排序。没有 `ORDER BY`，所有行都是对等值。

    *`over_clause`* 如 第 14.20.2 节，“窗口函数概念和语法” 中所述。

    下面的查询展示了 `RANK()` 和 `DENSE_RANK()` 之间的差异。前者生成带有间隔的排名，后者生成没有间隔的排名。该查询显示了 `val` 列中一组值的排名，其中包含一些重复值。`RANK()` 为对等值（重复值）分配相同的排名，下一个更大的值的排名比对等值的数量减一高。`DENSE_RANK()` 也为对等值分配相同的排名，但下一个更大的值的排名比前一个高一。为了参考，该查询还使用 `ROW_NUMBER()` 显示行号：

    ```sql
    mysql> SELECT
             val,
             ROW_NUMBER() OVER w AS 'row_number',
             RANK()       OVER w AS 'rank',
             DENSE_RANK() OVER w AS 'dense_rank'
           FROM numbers
           WINDOW w AS (ORDER BY val);
    +------+------------+------+------------+
    | val  | row_number | rank | dense_rank |
    +------+------------+------+------------+
    |    1 |          1 |    1 |          1 |
    |    1 |          2 |    1 |          1 |
    |    2 |          3 |    3 |          2 |
    |    3 |          4 |    4 |          3 |
    |    3 |          5 |    4 |          3 |
    |    3 |          6 |    4 |          3 |
    |    4 |          7 |    7 |          4 |
    |    4 |          8 |    7 |          4 |
    |    5 |          9 |    9 |          5 |
    +------+------------+------+------------+
    ```

+   `ROW_NUMBER()` *`over_clause`*

    返回当前行在其分区内的编号。行号从 1 开始，到分区行数结束。

    `ORDER BY` 影响编号行的顺序。没有 `ORDER BY`，行编号是不确定的。

    `ROW_NUMBER()` 为对等值分配不同的行号。要为对等值分配相同的值，请使用 `RANK()` 或 `DENSE_RANK()`。有关示例，请参阅 `RANK()` 函数描述。

    *`over_clause`* 如 第 14.20.2 节，“窗口函数概念和语法” 中所述。
