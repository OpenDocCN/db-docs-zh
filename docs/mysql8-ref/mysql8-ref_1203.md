> 原文：[`dev.mysql.com/doc/refman/8.0/en/innodb-performance-midpoint_insertion.html`](https://dev.mysql.com/doc/refman/8.0/en/innodb-performance-midpoint_insertion.html)

#### 17.8.3.3 使缓冲池具有扫描抵抗力

`InnoDB`不使用严格的 LRU 算法，而是使用一种技术来最小化带入缓冲池但从未再次访问的数据量。目标是确保频繁访问的（“热”）页面保留在缓冲池中，即使预读取和全表扫描带入可能或可能不会在之后访问的新块。

新读取的块被插入 LRU 列表的中间。所有新读取的页面默认情况下插入到 LRU 列表尾部的`3/8`位置。当它们在缓冲池中第一次被访问时，页面被移动到列表的前端（最近使用的端）。因此，从未被访问的页面永远不会进入 LRU 列表的前部，比严格的 LRU 方法更快地“老化”。这种安排将 LRU 列表分为两个部分，插入点后面的页面被视为“旧”，是 LRU 驱逐的理想受害者。

有关`InnoDB`缓冲池的内部工作原理和 LRU 算法的具体信息，请参见第 17.5.1 节，“缓冲池”。

您可以控制 LRU 列表中的插入点，并选择`InnoDB`是否将相同的优化应用于通过表或索引扫描带入缓冲池的块。配置参数`innodb_old_blocks_pct`控制 LRU 列表中“旧”块的百分比。`innodb_old_blocks_pct`的默认值为`37`，对应于原始的固定比率 3/8。值范围为`5`（缓冲池中的新页面很快就会老化）到`95`（只有 5%的缓冲池用于热页面，使算法接近熟悉的 LRU 策略）。

通过优化，可以避免缓冲池由于预读取而产生类似的问题，这可以避免由于表格或索引扫描而导致的问题。在这些扫描中，数据页通常会被快速连续访问几次，然后再也不会被访问。配置参数`innodb_old_blocks_time`指定了在第一次访问页面后的时间窗口（以毫秒为单位），在此期间可以访问该页面而无需将其移动到 LRU 列表的前端（最近使用的端）。`innodb_old_blocks_time`的默认值为`1000`。增加此值会使更多的块更有可能从缓冲池中更快地过期。

`innodb_old_blocks_pct`和`innodb_old_blocks_time`都可以在 MySQL 选项文件（`my.cnf`或`my.ini`）中指定，或者使用`SET GLOBAL`语句在运行时更改。在运行时更改值需要具有足够权限设置全局系统变量。请参见 Section 7.1.9.1，“系统变量权限”。

为了帮助您评估设置这些参数的效果，`SHOW ENGINE INNODB STATUS`命令会报告缓冲池的统计信息。详情请参见使用 InnoDB 标准监视器监视缓冲池。

由于这些参数的效果可能根据硬件配置、数据和工作负载的细节而有很大差异，所以在更改这些设置之前，始终要进行基准测试以验证效果，尤其是在任何性能关键或生产环境中。

在混合工作负载中，大部分活动是 OLTP 类型，定期批量报告查询导致大规模扫描时，设置`innodb_old_blocks_time`的值可以帮助保持正常工作负载的工作集在缓冲池中。

当扫描无法完全适应缓冲池的大型表格时，将`innodb_old_blocks_pct`设置为一个较小的值，可以避免只读取一次的数据占用缓冲池的大部分空间。例如，设置`innodb_old_blocks_pct=5`将限制只读取一次的数据占缓冲池的 5%。

当扫描适应内存的小型表格时，在缓冲池内移动页面的开销较小，因此可以将`innodb_old_blocks_pct`保持在默认值，甚至更高，例如`innodb_old_blocks_pct=50`。

`innodb_old_blocks_time`参数的影响比`innodb_old_blocks_pct`参数更难预测，影响相对较小，并且随着工作负载的变化更大。如果调整`innodb_old_blocks_pct`未能带来性能改善，建议进行自己的基准测试以确定最佳值。
