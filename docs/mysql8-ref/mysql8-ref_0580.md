# 10.5.1 优化 InnoDB 表的存储布局

> 原文：[`dev.mysql.com/doc/refman/8.0/en/optimizing-innodb-storage-layout.html`](https://dev.mysql.com/doc/refman/8.0/en/optimizing-innodb-storage-layout.html)

+   一旦你的数据达到稳定大小，或者一个增长中的表增加了几十或几百兆字节，考虑使用`OPTIMIZE TABLE`语句重新组织表并压缩任何浪费的空间。重新组织的表需要更少的磁盘 I/O 来执行全表扫描。这是一种简单的技术，当其他技术如改进索引使用或调整应用程序代码不可行时，可以提高性能。

    `OPTIMIZE TABLE`会复制表的数据部分并重建索引。好处来自于索引内数据的改进打包，以及表空间和磁盘上的碎片减少。好处取决于每个表中的数据。你可能会发现对于某些表有显著的收益，而对于其他表则没有，或者收益会随着时间的推移而减少，直到下次优化表为止。如果表很大或者重建的索引不适合缓冲池，这个操作可能会很慢。在向表中添加大量数据后的第一次运行通常比后续运行慢得多。

+   在`InnoDB`中，拥有一个长的`PRIMARY KEY`（要么是一个具有冗长值的单列，要么是几个列形成的长复合值）会浪费大量磁盘空间。一行的主键值会在指向同一行的所有二级索引记录中重复。 （参见第 17.6.2.1 节，“聚簇索引和二级索引”。）如果你的主键很长，可以创建一个`AUTO_INCREMENT`列作为主键，或者索引长`VARCHAR`列的前缀而不是整个列。

+   使用`VARCHAR`数据类型来存储变长字符串或具有许多`NULL`值的列，而不是使用`CHAR`。`CHAR(*`N`*)`列始终需要*`N`*个字符来存储数据，即使字符串较短或其值为`NULL`。较小的表更适合缓冲池，并减少磁盘 I/O。

    当使用`COMPACT`行格式（默认的`InnoDB`格式）和变长字符集，比如`utf8mb4`或`sjis`时，`CHAR(*`N`*)`列占据可变数量的空间，但至少占用*`N`*字节。

+   对于大表，或包含大量重复文本或数字数据的表，考虑使用`COMPRESSED`行格式。需要更少的磁盘 I/O 将数据带入缓冲池，或执行全表扫描。在做出永久决定之前，通过使用`COMPRESSED`与`COMPACT`行格式来衡量你可以实现的压缩量。
