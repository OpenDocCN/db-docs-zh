> 译文：[`dev.mysql.com/doc/refman/8.0/en/replication-rbr-usage.html`](https://dev.mysql.com/doc/refman/8.0/en/replication-rbr-usage.html)

#### 19.2.1.2 基于行的日志记录和复制的用法

MySQL 使用基于语句的日志记录（SBL）、基于行的日志记录（RBL）或混合格式日志。所使用的二进制日志类型会影响日志的大小和效率。因此，在基于行的复制（RBR）和基于语句的复制（SBR）之间的选择取决于您的应用程序和环境。本节描述了使用基于行格式日志时的已知问题，并描述了在复制中使用它的一些最佳实践。

欲了解更多信息，请参阅第 19.2.1 节，“复制格式”和第 19.2.1.1 节，“基于语句和基于行复制的优缺点”。

有关 NDB 集群复制特定问题的信息（依赖于基于行的复制），请参阅第 25.7.3 节，“NDB 集群复制中的已知问题”。

+   **临时表的基于行日志记录。** 如第 19.5.1.31 节，“复制和临时表”所述，当使用基于行格式或（从 MySQL 8.0.4 开始）混合格式时，临时表不会被复制。有关更多信息，请参阅第 19.2.1.1 节，“基于语句和基于行复制的优缺点”。

    当使用基于行或混合格式时，临时表不会被复制，因为没有必要。此外，由于临时表只能从创建它们的线程中读取，即使使用基于语句的格式，复制它们也很少或几乎没有任何好处。

    即使已创建临时表，您可以在运行时从基于语句切换到基于行的二进制日志格式。然而，在 MySQL 8.0 中，您无法在运行时从基于行或混合格式切换到基于语句的二进制日志格式，因为在先前模式中省略了任何`CREATE TEMPORARY TABLE`语句。

    MySQL 服务器跟踪创建每个临时表时生效的日志记录模式。当给定的客户端会话结束时，服务器会为仍然存在且在使用基于语句的二进制日志记录时创建的每个临时表记录一个`DROP TEMPORARY TABLE IF EXISTS`语句。如果在创建表时使用基于行或混合格式的二进制日志记录，则不会记录`DROP TEMPORARY TABLE IF EXISTS`语句。在 MySQL 8.0.4 和 5.7.25 之前的版本中，无论生效的日志记录模式如何，都会记录`DROP TEMPORARY TABLE IF EXISTS`语句。

    当使用`binlog_format=ROW`时，涉及临时表的非事务性 DML 语句是允许的，只要语句影响的非事务性表都是临时表（Bug #14272672）。

+   **RBL 和非事务性表的同步。** 当影响到许多行时，更改集会被拆分为几个事件；当语句提交时，所有这些事件都将写入二进制日志。在副本上执行时，会对涉及的所有表进行表锁定，然后以批处理模式应用行。根据副本表的引擎使用情况，这可能有效也可能无效。

+   **延迟和二进制日志大小。** RBL 将每行的更改写入二进制日志，因此其大小可能会迅速增加。这可能会显著增加使副本上的更改与源上的更改匹配所需的时间。您应该意识到这种延迟可能对您的应用程序产生影响。

+   **读取二进制日志。** **mysqlbinlog** 使用`BINLOG`语句在二进制日志中显示基于行的事件。该语句将事件显示为一个 base 64 编码的字符串，其含义不明显。当使用`--base64-output=DECODE-ROWS`和`--verbose`选项调用时，**mysqlbinlog**将二进制日志的内容格式化为人类可读的形式。当二进制日志事件以基于行的格式编写，并且您想要读取或从复制或数据库故障中恢复时，您可以使用此命令读取二进制日志的内容。有关更多信息，请参见 Section 6.6.9.2, “mysqlbinlog Row Event Display”。

+   **二进制日志执行错误和副本执行模式。** 使用`slave_exec_mode=IDEMPOTENT`通常仅在 MySQL NDB Cluster 复制中有用，其中`IDEMPOTENT`是默认值。（参见第 25.7.10 节，“NDB Cluster Replication: 双向和循环复制”）。当系统变量`replica_exec_mode`或`slave_exec_mode`为`IDEMPOTENT`时，由于找不到原始行而无法应用来自 RBL 的更改不会触发错误或导致复制失败。这意味着可能不会在副本上应用更新，导致源和副本不再同步。当`replica_exec_mode`或`slave_exec_mode`为`IDEMPOTENT`时，延迟问题和在 RBR 中使用非事务表可能导致源和副本进一步分歧。有关`replica_exec_mode`和`slave_exec_mode`的更多信息，请参见第 7.1.8 节，“服务器系统变量”。

    对于其他情况，将`replica_exec_mode`或`slave_exec_mode`设置为`STRICT`通常足够；这是除`NDB`之外的存储引擎的默认值。

+   **基于服务器 ID 的过滤不受支持。** 您可以通过在`CHANGE REPLICATION SOURCE TO`语句（从 MySQL 8.0.23 开始）或`CHANGE MASTER TO`语句（MySQL 8.0.23 之前）中使用`IGNORE_SERVER_IDS`选项来基于服务器 ID 进行过滤。此选项适用于基于语句和基于行的日志格式，但在设置`GTID_MODE=ON`时已被弃用。另一种在某些副本中过滤更改的方法是使用包含关系`@@server_id <> *`id_value`*`子句的`WHERE`子句与`UPDATE`和`DELETE`语句。例如，`WHERE @@server_id <> 1`。但是，这在基于行的日志记录中无法正常工作。要使用`server_id`系统变量进行语句过滤，请使用基于语句的日志记录。

+   **RBL、非事务表和停止的副本。** 当使用基于行的日志记录时，如果在副本线程更新非事务表时停止副本服务器，副本数据库可能会达到不一致的状态。因此，建议您对使用基于行格式复制的所有表使用事务存储引擎，如`InnoDB`。在关闭副本 MySQL 服务器之前使用`STOP REPLICA`或`STOP REPLICA SQL_THREAD`（在 MySQL 8.0.22 之前，使用`STOP slave`或`STOP SLAVE SQL_THREAD`）有助于防止问题发生，并且无论您使用的是哪种日志格式或存储引擎，都建议始终这样做。
