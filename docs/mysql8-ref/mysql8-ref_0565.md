# 10.3.14 从时间戳列进行索引查找

> 原文：[`dev.mysql.com/doc/refman/8.0/en/timestamp-lookups.html`](https://dev.mysql.com/doc/refman/8.0/en/timestamp-lookups.html)

时间值以 UTC 值的形式存储在`TIMESTAMP`列中，并且插入和检索`TIMESTAMP`列中的值在会话时区和 UTC 之间转换。（这与`CONVERT_TZ()`函数执行的相同类型的转换相同。如果会话时区是 UTC，则实际上没有时区转换。）

由于本地时区更改的惯例，如夏令时（DST），UTC 和非 UTC 时区之间的转换在两个方向上不是一对一的。在另一个时区中，原本不同的 UTC 值可能变得相同。以下示例显示了在非 UTC 时区中变为相同的不同 UTC 值：

```sql
mysql> CREATE TABLE tstable (ts TIMESTAMP);
mysql> SET time_zone = 'UTC'; -- insert UTC values
mysql> INSERT INTO tstable VALUES
       ('2018-10-28 00:30:00'),
       ('2018-10-28 01:30:00');
mysql> SELECT ts FROM tstable;
+---------------------+
| ts                  |
+---------------------+
| 2018-10-28 00:30:00 |
| 2018-10-28 01:30:00 |
+---------------------+
mysql> SET time_zone = 'MET'; -- retrieve non-UTC values
mysql> SELECT ts FROM tstable;
+---------------------+
| ts                  |
+---------------------+
| 2018-10-28 02:30:00 |
| 2018-10-28 02:30:00 |
+---------------------+
```

注意

要使用诸如`'MET'`或`'Europe/Amsterdam'`之类的命名时区，必须正确设置时区表。有关说明，请参见第 7.1.15 节“MySQL 服务器时区支持”。

您可以看到，当转换为`'MET'`时区时，这两个不同的 UTC 值相同。这种现象可能导致对给定的`TIMESTAMP`列查询的不同结果，具体取决于优化器是否使用索引来执行查询。

假设查询使用`WHERE`子句从`ts`列中搜索单个特定值，例如用户提供的时间戳文字：

```sql
SELECT ts FROM tstable
WHERE ts = '*literal*';
```

进一步假设查询在以下条件下执行：

+   会话时区不是 UTC 并且存在夏令时转换。例如：

    ```sql
    SET time_zone = 'MET';
    ```

+   存储在`TIMESTAMP`列中的唯一 UTC 值，在会话时区中由于夏令时转换而不是唯一的。（前面显示的示例说明了这种情况。）

+   查询指定的搜索值在会话时区进入夏令时的那个小时内。

在这些条件下，`WHERE`子句中的比较以不同的方式进行非索引和索引查找，并导致不同的结果：

+   如果没有索引或优化器无法使用索引，则比较将在会话时区中进行。优化器执行表扫描，检索每个`ts`列值，将其从 UTC 转换为会话时区，然后将其与搜索值（也在会话时区中解释）进行比较：

    ```sql
    mysql> SELECT ts FROM tstable
           WHERE ts = '2018-10-28 02:30:00';
    +---------------------+
    | ts                  |
    +---------------------+
    | 2018-10-28 02:30:00 |
    | 2018-10-28 02:30:00 |
    +---------------------+
    ```

    因为存储的`ts`值被转换为会话时区，所以查询可能返回两个时间戳值，这些值在 UTC 值上是不同的，但在会话时区中是相等的：一个值发生在时钟更改之前的 DST 转换时，另一个值发生在 DST 转换之后。

+   如果存在可用的索引，则比较将在 UTC 时间发生。优化器执行索引扫描，首先将搜索值从会话时区转换为 UTC，然后将结果与 UTC 索引条目进行比较：

    ```sql
    mysql> ALTER TABLE tstable ADD INDEX (ts);
    mysql> SELECT ts FROM tstable
           WHERE ts = '2018-10-28 02:30:00';
    +---------------------+
    | ts                  |
    +---------------------+
    | 2018-10-28 02:30:00 |
    +---------------------+
    ```

    在这种情况下，（转换后的）搜索值仅与索引条目匹配，因为存储的不同 UTC 值的索引条目也是不同的，搜索值只能匹配其中一个。

由于非索引和索引查找的优化器操作不同，因此查询在每种情况下产生不同的结果。非索引查找的结果返回所有在会话时区匹配的值。索引查找无法做到这一点：

+   这是在仅知道 UTC 值的存储引擎内执行的。

+   对于映射到相同 UTC 值的两个不同会话时区值，索引查找仅匹配相应的 UTC 索引条目，并仅返回一行。

在前面的讨论中，存储在`tstable`中的数据集恰好由不同的 UTC 值组成。在这种情况下，所示形式的所有使用索引的查询最多匹配一个索引条目。

如果索引不是`UNIQUE`，则表（和索引）可能存储给定 UTC 值的多个实例。例如，`ts`列可能包含多个 UTC 值为`'2018-10-28 00:30:00'`的实例。在这种情况下，使用索引的查询将返回每个实例（在结果集中转换为 MET 值`'2018-10-28 02:30:00'`）。索引使用的查询仍然匹配将转换的搜索值与 UTC 索引条目中的单个值匹配，而不是匹配多个 UTC 值，这些值在会话时区中转换为搜索值。

如果重要的是返回所有在会话时区匹配的`ts`值，则解决方法是使用`IGNORE INDEX`提示来抑制索引的使用：

```sql
mysql> SELECT ts FROM tstable
       IGNORE INDEX (ts)
       WHERE ts = '2018-10-28 02:30:00';
+---------------------+
| ts                  |
+---------------------+
| 2018-10-28 02:30:00 |
| 2018-10-28 02:30:00 |
+---------------------+
```

在其他情况下，例如使用`FROM_UNIXTIME()`和`UNIX_TIMESTAMP()`函数执行的转换中，同样存在双向时区转换的一对多映射问题。请参阅第 14.7 节，“日期和时间函数”。
