# 19.4.2 处理复制品意外停止

> 原文：[`dev.mysql.com/doc/refman/8.0/en/replication-solutions-unexpected-replica-halt.html`](https://dev.mysql.com/doc/refman/8.0/en/replication-solutions-unexpected-replica-halt.html)

为了使复制对服务器的意外停止具有弹性（有时被描述为崩溃安全），必须使复制品能够在停止之前恢复其状态。本节描述了复制过程中复制品意外停止的影响，以及如何配置复制品以获得继续复制的最佳恢复机会。

在复制品意外停止后，重新启动时，复制 SQL 线程必须恢复已执行的事务的信息。恢复所需的信息存储在复制品的应用程序元数据存储库中。从 MySQL 8.0 开始，默认情况下，此存储库以名为`mysql.slave_relay_log_info`的`InnoDB`表的形式创建。通过使用这种事务性存储引擎，信息始终可以在重新启动时恢复。对应用程序元数据存储库的更新与事务一起提交，这意味着记录在该存储库中的复制品进度信息始终与已应用于数据库的内容一致，即使服务器意外停止也是如此。有关应用程序元数据存储库的更多信息，请参见第 19.2.4 节“中继日志和复制元数据存储库”。

DML 事务和原子 DDL 更新也会在`mysql.slave_relay_log_info`表中更新复制品的应用程序元数据存储库的复制位置，并将更改应用于数据库，作为一个原子操作。在所有其他情况下，包括不完全原子的 DDL 语句和不支持原子 DDL 的豁免存储引擎，如果服务器意外停止，`mysql.slave_relay_log_info`表可能会缺少与复制数据相关的更新。在这种情况下，恢复更新是一个手动过程。有关 MySQL 8.0 中原子 DDL 支持的详细信息以及某些语句复制的结果行为，请参见第 15.1.1 节“原子数据定义语句支持”。

复制品从意外停止中恢复的恢复过程取决于复制品的配置。恢复过程的细节受到复制方法的选择、复制品是单线程还是多线程以及相关系统变量设置的影响。恢复过程的总体目标是确定在意外停止发生之前复制品的数据库上已经应用了哪些事务，并检索并应用在意外停止后复制品错过的事务。

+   对于基于 GTID 的复制，恢复过程需要副本已经接收或提交的事务的 GTID。缺失的事务可以通过 GTID 自动定位从源获取，该过程会自动比较源的事务和副本的事务，并识别缺失的事务。

+   对于基于文件位置的复制，恢复过程需要准确的复制 SQL 线程（应用程序）位置，显示在副本上应用的最后一个事务。基于该位置，复制 I/O 线程（接收器）从源的二进制日志中检索应该从该点开始在副本上应用的所有事务。

使用基于 GTID 的复制使得配置复制以应对意外停止变得最容易。GTID 自动定位意味着副本可以可靠地识别和检索缺失的事务，即使应用事务序列中存在间隙。

以下信息提供了适用于不同类型副本的设置组合，以确保在复制控制范围内尽可能实现恢复。

重要提示

复制控制范围之外的一些因素可能会影响复制恢复过程和恢复过程后复制的整体状态。特别是，影响各个存储引擎恢复过程的设置可能导致在副本意外停止时丢失事务，因此这些事务对于复制恢复过程不可用。下面列表中提到的`innodb_flush_log_at_trx_commit=1`设置是使用带有事务的`InnoDB`的复制设置的关键设置。然而，特定于`InnoDB`或其他存储引擎的其他设置，特别是与刷新或同步相关的设置，也可能会产生影响。始终检查并应用您选择的存储引擎关于崩溃安全设置的建议。

在副本上的以下设置组合对于意外停止是最具弹性的：

+   当使用基于 GTID 的复制时（`gtid_mode=ON`），设置`SOURCE_AUTO_POSITION=1` | `MASTER_AUTO_POSITION=1`，这将激活 GTID 自动定位，使连接到源的连接自动识别并检索丢失的事务。可以使用`CHANGE REPLICATION SOURCE TO`语句（从 MySQL 8.0.23 开始）或`CHANGE MASTER TO`语句（MySQL 8.0.23 之前）来设置此选项。如果复制品有多个复制通道，则需要为每个通道单独设置此选项。有关 GTID 自动定位的工作原理的详细信息，请参见第 19.1.3.3 节，“GTID 自动定位”。当使用基于文件位置的复制时，不使用`SOURCE_AUTO_POSITION=1` | `MASTER_AUTO_POSITION=1`，而是使用二进制日志位置或中继日志位置来控制复制开始的位置。

+   从 MySQL 8.0.27 开始，当使用基于 GTID 的复制时（`gtid_mode=ON`），设置`GTID_ONLY=1`，这使得复制品在恢复过程中仅使用 GTID，并停止在复制元数据存储库中持久化二进制日志和中继日志文件名和文件位置。可以使用`CHANGE REPLICATION SOURCE TO`语句来设置此选项。如果复制品有多个复制通道，则需要为每个通道单独设置此选项。使用`GTID_ONLY=1`时，在恢复过程中，将忽略文件位置信息，并使用 GTID 自动跳过来跳过已经提供的事务，而不是识别正确的文件位置。这种策略更有效，前提是您使用`relay_log_purge`的默认设置清除中继日志，这意味着只需要检查一个中继日志文件。

+   设置`sync_relay_log=1`，指示复制接收线程在每个接收的事务写入后将中继日志同步到磁盘。这意味着副本从源二进制日志中读取的当前位置记录（在应用程序元数据存储库中）永远不会超过保存在中继日志中的事务记录。请注意，尽管这个设置是最安全的，但由于涉及磁盘写入的次数较多，因此也是最慢的。当`sync_relay_log > 1`或`sync_relay_log=0`（其中同步由操作系统处理）时，在副本意外停止的情况下，可能存在已提交但尚未同步到磁盘的事务。这些事务可能会导致恢复过程失败，如果正在恢复的副本根据中继日志中的信息（最后一次同步到磁盘）尝试重新检索和应用事务而不是跳过它们。设置`sync_relay_log=1`对于多线程副本尤为重要，如果无法使用中继日志中的信息填补事务序列中的间隙，则恢复过程将失败。对于单线程副本，只有在应用程序元数据存储库中没有相关信息时，恢复过程才需要使用中继日志。

+   设置`innodb_flush_log_at_trx_commit=1`，在每个事务提交之前将`InnoDB`日志同步到磁盘。这个默认设置确保`InnoDB`表和`InnoDB`日志被保存在磁盘上，因此不再需要关于事务的中继日志中的信息。结合设置`sync_relay_log=1`，这个设置进一步确保`InnoDB`表和`InnoDB`日志的内容始终与中继日志的内容一致，以便在意外停止时，清除中继日志文件不会导致副本事务历史中存在无法填补的间隙。

+   设置`relay_log_info_repository = TABLE`，将复制 SQL 线程位置存储在`InnoDB`表`mysql.slave_relay_log_info`中，并与事务提交一起更新，以确保始终准确的记录。这个设置是 MySQL 8.0 的默认设置，`FILE`设置已被弃用。从 MySQL 8.0.23 开始，系统变量本身的使用已被弃用，因此可以省略它并允许其默认值。如果使用了`FILE`设置，这在早期版本中是默认设置，信息将存储在数据目录中的文件中，在事务应用后更新。这会导致与源的同步丢失的风险，具体取决于副本在处理事务的哪个阶段停止，甚至文件本身的损坏。使用设置`relay_log_info_repository = FILE`，无法保证恢复。

+   设置`relay_log_recovery = ON`，在服务器启动后立即启用自动中继日志恢复。这个全局变量默认为`OFF`，在运行时是只读的，但您可以在副本启动时使用`--relay-log-recovery`选项将其设置为`ON`，以应对副本意外停止。请注意，此设置会忽略现有的中继日志文件，以防它们损坏或不一致。中继日志恢复过程会启动一个新的中继日志文件，并从在应用程序元数据存储库中记录的复制 SQL 线程位置开始从源获取事务。副本的正常清理机制会随着时间删除先前的中继日志文件。

对于多线程复制，设置`relay_log_recovery = ON`会自动处理中继日志中已执行的事务序列中的任何不一致和间隙。当使用基于文件位置的复制时，这些间隙可能会发生。（有关更多详细信息，请参见第 19.5.1.34 节，“复制和事务不一致性”。）中继日志恢复过程使用与`START REPLICA UNTIL SQL_AFTER_MTS_GAPS`（或在 MySQL 8.0.22 之前，使用`START SLAVE`而不是`START REPLICA`）语句相同的方法处理间隙。当复制达到一致的无间隙状态时，中继日志恢复过程继续从源头开始获取进一步的事务，从复制 SQL 线程位置开始。当使用基于 GTID 的复制时，从 MySQL 8.0.18 开始，多线程复制首先检查`MASTER_AUTO_POSITION`是否设置为`ON`，如果是，则省略计算应跳过或不跳过的事务的步骤，因此旧的中继日志不需要用于恢复过程。
