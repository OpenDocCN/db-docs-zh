# 14.14 锁定函数

> 原文：[`dev.mysql.com/doc/refman/8.0/en/locking-functions.html`](https://dev.mysql.com/doc/refman/8.0/en/locking-functions.html)

本节描述用于操作用户级别锁的函数。

**表 14.19 锁定函数**

| 名称 | 描述 |
| --- | --- |
| `GET_LOCK()` | 获取命名锁 |
| `IS_FREE_LOCK()` | 命名锁是否空闲 |
| `IS_USED_LOCK()` | 命名锁是否正在使用；如果是，则返回连接标识符 |
| `RELEASE_ALL_LOCKS()` | 释放所有当前命名锁 |
| `RELEASE_LOCK()` | 释放命名锁 |

+   `GET_LOCK(*`str`*,*`timeout`*)`

    尝试使用字符串*`str`*给出的名称以及*`timeout`*秒的超时获取锁。负的*`timeout`*值表示无限超时。该锁是排他的。当一个会话持有锁时，其他会话无法获取相同名称的锁。

    如果成功获取锁，则返回`1`，如果尝试超时（例如，因为另一个客户端先前锁定了名称），则返回`0`，如果发生错误（例如，内存耗尽或线程被**mysqladmin kill**杀死），则返回`NULL`。

    使用`GET_LOCK()`获取的锁通过执行`RELEASE_LOCK()`显式释放，或者在会话终止时（正常或异常）隐式释放。使用`GET_LOCK()`获取的锁在事务提交或回滚时不会释放。

    `GET_LOCK()`是使用元数据锁定（MDL）子系统实现的。可以获取多个同时锁，并且`GET_LOCK()`不会释放任何现有锁。例如，假设您执行以下语句：

    ```sql
    SELECT GET_LOCK('lock1',10);
    SELECT GET_LOCK('lock2',10);
    SELECT RELEASE_LOCK('lock2');
    SELECT RELEASE_LOCK('lock1');
    ```

    第二个`GET_LOCK()`获取第二个锁，两个`RELEASE_LOCK()`调用都返回 1（成功）。

    甚至可以让给定会话为同一名称获取多个锁。其他会话在获取会话释放该名称的所有锁之前无法获取具有该名称的锁。

    使用`GET_LOCK()`获取的具有唯一名称的锁会出现在性能模式`metadata_locks`表中。`OBJECT_TYPE`列显示`USER LEVEL LOCK`，`OBJECT_NAME`列指示锁名称。在为*相同*名称获取多个锁的情况下，只有第一个名称的锁会在`metadata_locks`表中注册一行。对于该名称的后续锁将在锁中递增计数器，但不会获取额外的元数据锁。当名称上的最后一个锁实例被释放时，锁的`metadata_locks`行将被删除。

    获得多个锁的能力意味着客户端之间可能发生死锁。当这种情况发生时，服务器会选择一个调用者，并以`ER_USER_LOCK_DEADLOCK`错误终止其锁获取请求。此错误不会导致事务回滚。

    MySQL 对锁名称的最大长度强制为 64 个字符。

    `GET_LOCK()`可用于实现应用程序锁或模拟记录锁。名称在整个服务器范围内被锁定。如果一个名称在一个会话中被锁定，那么`GET_LOCK()`会阻止另一个会话对具有相同名称的锁发出的任何请求。这使得同意给定锁名称的客户端可以使用该名称执行协作性咨询锁定。但请注意，这也使得不属于协作客户端集的客户端可以锁定一个名称，无论是无意还是故意，从而阻止任何协作客户端锁定该名称。减少这种可能性的一种方法是使用特定于数据库或应用程序的锁名称。例如，使用形式为*`db_name.str`*或*`app_name.str`*的锁名称。

    如果多个客户端正在等待一个锁，它们获取锁的顺序是不确定的。应用程序不应假设客户端按照发出锁请求的顺序获取锁。

    当`binlog_format`设置为`STATEMENT`时，`GET_LOCK()`对基于语句的复制是不安全的。如果在此函数在此情况下使用，将记录一个警告。

    由于`GET_LOCK()`仅在单个**mysqld**上建立锁，因此不适用于 NDB Cluster，后者无法强制执行跨多个 MySQL 服务器的 SQL 锁。有关更多信息，请参见第 25.2.7.10 节，“与多个 NDB Cluster 节点相关的限制”。

    注意

    具有获取多个命名锁的能力，一个语句可以获取大量的锁。例如：

    ```sql
    INSERT INTO ... SELECT GET_LOCK(t1.col_name) FROM t1;
    ```

    这些类型的语句可能会产生某些不良影响。例如，如果语句在中途失败并回滚，则在失败点之前获取的锁仍然存在。如果意图是要求插入的行与获取的锁对应，那么这个意图就无法满足。此外，如果重要的是按特定顺序授予锁，请注意结果集顺序可能会因优化器选择的执行计划而有所不同。因此，最好限制每个语句对单个锁获取调用。

    另一种不同的锁定接口可作为插件服务或一组可加载函数提供。该接口提供锁定命名空间和不同的读写锁，与`GET_LOCK()`及相关函数提供的接口不同。有关详细信息，请参见第 7.6.9.1 节，“锁定服务”。

+   `IS_FREE_LOCK(*`str`*)`

    检查名为*`str`*的锁是否可用（即未被锁定）。如果锁可用（没有人在使用锁），则返回`1`，如果锁正在使用，则返回`0`，如果发生错误（例如参数不正确），则返回`NULL`。

    此函数对基于语句的复制不安全。如果在`binlog_format`设置为`STATEMENT`时使用此函数，将记录警告。

+   `IS_USED_LOCK(*`str`*)`

    检查名为*`str`*的锁是否正在使用（即已锁定）。如果是，则返回持有锁的客户会话的连接标识符。否则，返回`NULL`。

    此函数对基于语句的复制不安全。如果在`binlog_format`设置为`STATEMENT`时使用此函数，将记录警告。

+   `RELEASE_ALL_LOCKS()`

    释放当前会话持有的所有命名锁，并返回释放的锁数（如果没有锁则返回 0）

    此函数对基于语句的复制不安全。如果在`binlog_format`设置为`STATEMENT`时使用此函数，将记录警告。

+   `RELEASE_LOCK(*`str`*)`

    释放由字符串*`str`*命名的锁，该锁是使用`GET_LOCK()`获取的。如果释放了锁，则返回`1`，如果该线程未建立锁（在这种情况下不会释放锁），则返回`0`，如果命名的锁不存在，则返回`NULL`。如果从未通过调用`GET_LOCK()`获取过锁，或者之前已释放锁，则该锁不存在。

    `DO`语句与`RELEASE_LOCK()`一起使用非常方便。请参阅第 15.2.3 节，“DO 语句”。

    当`binlog_format`设置为`STATEMENT`时，此函数对基于语句的复制不安全。如果在此函数中使用`binlog_format`设置为`STATEMENT`时，将记录警告。
