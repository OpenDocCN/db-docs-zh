> 原文：[`dev.mysql.com/doc/refman/8.0/en/multiple-tables.html`](https://dev.mysql.com/doc/refman/8.0/en/multiple-tables.html)

#### 5.3.4.9 使用多个表

`pet`表记录了你拥有的宠物。如果你想记录关于它们的其他信息，比如它们生活中的事件，比如去兽医那里或者生产幼崽的时间，你需要另一个表。这个表应该是什么样子？它需要包含以下信息：

+   宠物名称，以便你知道每个事件涉及哪个动物。

+   一个日期，以便你知道事件发生的时间。

+   一个描述事件的字段。

+   一个事件类型字段，如果你想对事件进行分类。

鉴于这些考虑，`event`表的`CREATE TABLE`语句可能如下所示：

```sql
mysql> CREATE TABLE event (name VARCHAR(20), date DATE,
       type VARCHAR(15), remark VARCHAR(255));
```

与`pet`表一样，最简单的方法是通过创建一个包含以下信息的制表符分隔文本文件来加载初始记录。

| 名称 | 日期 | 类型 | 备注 |
| --- | --- | --- | --- |
| 绒绒 | 1995-05-15 | 分娩 | 4 只小猫，3 只雌性，1 只雄性 |
| 巴菲 | 1993-06-23 | 分娩 | 5 只小狗，2 只雌性，3 只雄性 |
| 巴菲 | 1994-06-19 | 分娩 | 3 只小狗，3 只雌性 |
| 啁啾 | 1999-03-21 | 兽医 | 需要修直喙 |
| 苗条 | 1997-08-03 | 兽医 | 肋骨骨折 |
| 鲍泽 | 1991-10-12 | 狗舍 |  |
| 方格 | 1991-10-12 | 狗舍 |  |
| 方格 | 1998-08-28 | 生日 | 给了他一个新的咬咬玩具 |
| 爪子 | 1998-03-17 | 生日 | 给了他一个新的跳蚤项圈 |
| 威斯勒 | 1998-12-09 | 生日 | 第一个生日 |
| 名称 | 日期 | 类型 | 备注 |

加载记录如下：

```sql
mysql> LOAD DATA LOCAL INFILE 'event.txt' INTO TABLE event;
```

根据你在`pet`表上运行的查询所学到的知识，你应该能够在`event`表中执行检索；原则是相同的。但是`event`表本身何时不足以回答你可能提出的问题？

假设你想找出每只宠物产下幼崽时的年龄。我们之前看到如何从两个日期计算年龄。母亲的产仔日期在`event`表中，但要计算她在那天的年龄，你需要她的出生日期，这个日期存储在`pet`表中。这意味着查询需要两个表：

```sql
mysql> SELECT pet.name,
       TIMESTAMPDIFF(YEAR,birth,date) AS age,
       remark
       FROM pet INNER JOIN event
         ON pet.name = event.name
       WHERE event.type = 'litter';
+--------+------+-----------------------------+
| name   | age  | remark                      |
+--------+------+-----------------------------+
| Fluffy |    2 | 4 kittens, 3 female, 1 male |
| Buffy  |    4 | 5 puppies, 2 female, 3 male |
| Buffy  |    5 | 3 puppies, 3 female         |
+--------+------+-----------------------------+
```

关于这个查询有几点需要注意：

+   `FROM`子句连接了两个表，因为查询需要从两个表中提取信息。

+   当从多个表中合并（连接）信息时，你需要指定如何将一个表中的记录与另一个表中的记录匹配。这很容易，因为它们都有一个`name`列。查询使用`ON`子句根据`name`值匹配两个表中的记录。

    查询使用`INNER JOIN`来合并这两个表。`INNER JOIN`允许只有当两个表都满足`ON`子句中指定的条件时，才能在结果中出现来自任一表的行。在这个例子中，`ON`子句指定`pet`表中的`name`列必须与`event`表中的`name`列匹配。如果一个名字出现在一个表中而在另一个表中没有出现，那么该行不会出现在结果中，因为`ON`子句中的条件不满足。

+   因为`name`列在两个表中都存在，所以在引用该列时必须明确指定是指哪个表。这可以通过在列名前加上表名来实现。

执行连接操作并不一定需要两个不同的表。有时，如果要比较表中的记录与该表中的其他记录，则将表与自身连接是有用的。例如，要找出你的宠物中的配对，你可以将`pet`表与自身连接，以生成相同物种的活体雄性和雌性的候选配对：

```sql
mysql> SELECT p1.name, p1.sex, p2.name, p2.sex, p1.species
       FROM pet AS p1 INNER JOIN pet AS p2
         ON p1.species = p2.species
         AND p1.sex = 'f' AND p1.death IS NULL
         AND p2.sex = 'm' AND p2.death IS NULL;
+--------+------+-------+------+---------+
| name   | sex  | name  | sex  | species |
+--------+------+-------+------+---------+
| Fluffy | f    | Claws | m    | cat     |
| Buffy  | f    | Fang  | m    | dog     |
+--------+------+-------+------+---------+
```

在这个查询中，我们为表名指定别名，以便引用列并清楚地知道每个列引用与哪个表实例相关联。
