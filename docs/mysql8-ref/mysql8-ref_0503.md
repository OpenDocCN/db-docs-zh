# 9.5.2 使用事件位置进行时间点恢复

> 原文：[`dev.mysql.com/doc/refman/8.0/en/point-in-time-recovery-positions.html`](https://dev.mysql.com/doc/refman/8.0/en/point-in-time-recovery-positions.html)

最后一节，第 9.5.1 节，“使用二进制日志进行时间点恢复”，解释了使用二进制日志执行时间点恢复的一般思路。该部分通过示例详细解释了操作。

例如，假设在 2020 年 3 月 11 日 20:06:00 左右执行了一个删除表的 SQL 语句。您可以执行时间点恢复，将服务器恢复到表删除之前的状态。以下是一些实现这一目标的示例步骤：

1.  恢复在感兴趣时间点之前创建的最后一个完整备份（我们的示例中是 2020 年 3 月 11 日 20:06:00 的`t[p]`）。完成后，记录已恢复服务器的二进制日志位置以供以后使用，并重新启动服务器。

    注意

    虽然 InnoDB 在恢复和服务器重新启动后也会显示最后一个恢复的二进制日志位置，但这*不*是获取恢复结束日志位置的可靠方法，因为在显示位置之后可能发生了 DDL 事件和非 InnoDB 更改。您的备份和恢复工具应为您提供用于恢复的最后一个二进制日志位置：例如，如果您正在使用**mysqlbinlog**执行任务，请检查二进制日志重放的停止位置；如果您正在使用 MySQL 企业版备份，则最后一个二进制日志位置已保存在您的备份中。请参阅时间点恢复。

1.  找到与您想要恢复数据库的时间点对应的精确二进制日志事件位置。在我们的示例中，假设我们知道表删除发生的大致时间（`t[p]`），我们可以通过使用**mysqlbinlog**实用程序来检查该时间周围的日志内容，找到日志位置。使用`--start-datetime`和`--stop-datetime`选项来指定围绕`t[p]`的短时间段，然后在输出中查找事件。例如：

    ```sql
    $> mysqlbinlog --start-datetime="2020-03-11 20:05:00" \
                       --stop-datetime="2020-03-11 20:08:00" --verbose \
             /var/lib/mysql/bin.123456 | grep -C 15 "DROP TABLE"

    /*!80014 SET @@session.original_server_version=80019*//*!*/;
    /*!80014 SET @@session.immediate_server_version=80019*//*!*/;
    SET @@SESSION.GTID_NEXT= 'ANONYMOUS'/*!*/;
    # at 232
    #200311 20:06:20 server id 1  end_log_pos 355 CRC32 0x2fc1e5ea 	Query	thread_id=16	exec_time=0	error_code=0
    SET TIMESTAMP=1583971580/*!*/;
    SET @@session.pseudo_thread_id=16/*!*/;
    SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1/*!*/;
    SET @@session.sql_mode=1168113696/*!*/;
    SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/;
    /*!\C utf8mb4 *//*!*/;
    SET @@session.character_set_client=255,@@session.collation_connection=255,@@session.collation_server=255/*!*/;
    SET @@session.lc_time_names=0/*!*/;
    SET @@session.collation_database=DEFAULT/*!*/;
    /*!80011 SET @@session.default_collation_for_utf8mb4=255*//*!*/;
    DROP TABLE `pets`.`cats` /* generated by server */
    /*!*/;
    # at 355
    #200311 20:07:48 server id 1  end_log_pos 434 CRC32 0x123d65df 	Anonymous_GTID	last_committed=1	sequence_number=2	rbr_only=no	original_committed_timestamp=1583971668462467	immediate_commit_timestamp=1583971668462467	transaction_length=473
    # original_commit_timestamp=1583971668462467 (2020-03-11 20:07:48.462467 EDT)
    # immediate_commit_timestamp=1583971668462467 (2020-03-11 20:07:48.462467 EDT)
    /*!80001 SET @@session.original_commit_timestamp=1583971668462467*//*!*/;
    /*!80014 SET @@session.original_server_version=80019*//*!*/;
    /*!80014 SET @@session.immediate_server_version=80019*//*!*/;
    SET @@SESSION.GTID_NEXT= 'ANONYMOUS'/*!*/;
    # at 434
    #200311 20:07:48 server id 1  end_log_pos 828 CRC32 0x57fac9ac 	Query	thread_id=16	exec_time=0	error_code=0	Xid = 217
    use `pets`/*!*/;
    SET TIMESTAMP=1583971668/*!*/;
    /*!80013 SET @@session.sql_require_primary_key=0*//*!*/;
    CREATE TABLE dogs
    ```

    从**mysqlbinlog**的输出中，可以在二进制日志的段中找到`DROP TABLE `pets`.`cats``语句，该语句位于`# at 232`和`# at 355`之间，这意味着该语句发生在日志位置 232 之后，并且在`DROP TABLE`语句之后的位置 355 处。

    注意

    仅使用`--start-datetime`和`--stop-datetime`选项来帮助您找到感兴趣的实际事件位置。不建议使用这两个选项来指定要应用的二进制日志段的范围：使用这些选项时更容易错过二进制日志事件。请改用`--start-position`和`--stop-position`。

1.  将二进制日志文件中的事件应用到服务器上，从您在第 1 步中找到的日志位置开始（假设为 155），直到您在第 2 步中找到的在您感兴趣的时间点之前的位置（即 232）：

    ```sql
    $> mysqlbinlog --start-position=155 --stop-position=232 /var/lib/mysql/bin.123456 \
             | mysql -u root -p
    ```

    该命令从起始位置恢复所有事务，直到停止位置之前。因为**mysqlbinlog**的输出在每个记录的 SQL 语句之前包含`SET TIMESTAMP`语句，恢复的数据和相关的 MySQL 日志反映了事务执行的原始时间。

    您的数据库现在已经恢复到感兴趣的时间点`t[p]`，就在表`pets.cats`被删除之前。

1.  完成了点时间恢复后，如果您还想重新执行您感兴趣的时间点*之后*的所有语句，请再次使用**mysqlbinlog**来将`t[p]`之后的所有事件应用到服务器上。我们在第 2 步中指出，在我们想要跳过的语句之后，日志位于位置 355；我们可以将其用于`--start-position`选项，以便包括位置之后的任何语句：

    ```sql
    $> mysqlbinlog --start-position=355 /var/lib/mysql/bin.123456 \
             | mysql -u root -p
    ```

    您的数据库已经恢复到二进制日志文件中记录的最新语句，但跳过了选定的事件。
