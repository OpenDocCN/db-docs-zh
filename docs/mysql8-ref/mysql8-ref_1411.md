> 原文：[`dev.mysql.com/doc/refman/8.0/en/replication-solutions-backups-read-only.html`](https://dev.mysql.com/doc/refman/8.0/en/replication-solutions-backups-read-only.html)

#### 19.4.1.3 通过将其设置为只读来备份源或复制品

可以通过获取全局读锁并操作 `read_only` 系统变量来改变要备份服务器的只读状态，从而备份复制设置中的源或复制服务器：

1.  将服务器设置为只读，以便仅处理检索并阻止更新。

1.  执行备份。

1.  将服务器改回正常的读写状态。

注意

本节中的说明将要备份的服务器置于安全状态，以便备份方法从服务器获取数据，例如 **mysqldump**（参见 第 6.5.4 节，“mysqldump — 数据库备份程序”）。您不应尝试使用这些说明通过直接复制文件来进行二进制备份，因为服务器可能仍然在内存中缓存修改的数据，尚未刷新到磁盘。

本节中的说明描述了如何为源和复制品执行此操作。对于这里讨论的两种场景，假设您有以下复制设置：

+   一个源服务器 S1

+   一个复制服务器 R1，其源为 S1

+   一个连接到 S1 的客户端 C1

+   一个连接到 R1 的客户端 C2

在任一场景中，获取全局读锁并操作 `read_only` 变量的语句是在要备份的服务器上执行的，不会传播到该服务器的任何副本。

**场景 1：只读源备份**

通过在源 S1 上执行以下语句，将源 S1 置于只读状态：

```sql
mysql> FLUSH TABLES WITH READ LOCK;
mysql> SET GLOBAL read_only = ON;
```

当 S1 处于只读状态时，以下属性为真：

+   由 C1 发送到 S1 的更新请求被阻塞，因为服务器处于只读模式。

+   由 C1 发送到 S1 的查询结果请求成功。

+   在 S1 上进行备份是安全的。

+   在 R1 上进行备份是不安全的。该服务器仍在运行，并且可能正在处理二进制日志或来自客户端 C2 的更新请求。

当 S1 处于只读状态时，执行备份。例如，您可以使用 **mysqldump**。

在 S1 上的备份操作完成后，通过执行以下语句将 S1 恢复到正常运行状态：

```sql
mysql> SET GLOBAL read_only = OFF;
mysql> UNLOCK TABLES;
```

尽管在 S1 上执行备份是安全的（就备份而言），但对性能来说并不是最佳选择，因为 S1 的客户端被阻止执行更新操作。

这种策略适用于在复制设置中备份源，但也可以用于非复制设置中的单个服务器。

**场景 2：只读复制备份**

通过在复制 R1 上执行以下语句，将复制 R1 置于只读状态：

```sql
mysql> FLUSH TABLES WITH READ LOCK;
mysql> SET GLOBAL read_only = ON;
```

当 R1 处于只读状态时，以下属性为真：

+   源 S1 仍在运行，因此在源上进行备份是不安全的。

+   副本 R1 已停止，因此在副本 R1 上进行备份是安全的。

这些属性为一种常见的备份场景提供了基础：让一个副本在一段时间内忙于执行备份不会造成问题，因为它不会影响整个网络，而且系统在备份期间仍在运行。特别是，客户端仍然可以在源服务器上执行更新操作，而备份副本上的备份活动不会对源服务器产生影响。

当 R1 处于只读状态时，执行备份操作。例如，您可以使用**mysqldump**。

完成 R1 上的备份操作后，通过执行以下语句将 R1 恢复到正常运行状态：

```sql
mysql> SET GLOBAL read_only = OFF;
mysql> UNLOCK TABLES;
```

将副本恢复到正常运行状态后，它会通过追赶源的二进制日志中的任何未完成更新再次与源进行同步。
