> 原文：[`dev.mysql.com/doc/refman/8.0/en/converting-tables-to-innodb.html`](https://dev.mysql.com/doc/refman/8.0/en/converting-tables-to-innodb.html)

#### 17.6.1.5 将表从`MyISAM`转换为`InnoDB`

如果您有想要转换为更可靠和可扩展的`InnoDB`的`MyISAM`表，请在转换之前查看以下准则和提示。

注意

在之前的 MySQL 版本中创建的分区`MyISAM`表与 MySQL 8.0 不兼容。这些表必须在升级之前进行准备，可以通过删除分区或将其转换为`InnoDB`来完成。有关更多信息，请参阅 Section 26.6.2, “与存储引擎相关的分区限制”。

+   调整`MyISAM`和`InnoDB`的内存使用

+   处理过长或过短的事务

+   处理死锁

+   存储布局

+   转换现有表

+   克隆表的结构

+   数据转移

+   存储需求

+   定义主键

+   应用性能考虑

+   了解与`InnoDB`表相关的文件

##### 调整`MyISAM`和`InnoDB`的内存使用

当你从`MyISAM`表过渡时，降低`key_buffer_size`配置选项的值，释放不再需要用于缓存结果的内存。增加`innodb_buffer_pool_size`配置选项的值，它扮演着为`InnoDB`表分配缓存内存的类似角色。`InnoDB`缓冲池同时缓存表数据和索引数据，加快查询的查找速度，并将查询结果保留在内存中以便重复使用。有关缓冲池大小配置的指导，请参见第 10.12.3.1 节，“MySQL 如何使用内存”。

##### 处理过长或过短的事务

因为`MyISAM`表不支持事务，你可能没有太关注`autocommit`配置选项以及`COMMIT`和`ROLLBACK`语句。这些关键词对于允许多个会话同时读写`InnoDB`表非常重要，在写入密集型工作负载中提供了可观的可扩展性优势。

当事务打开时，系统会保留事务开始时看到的数据快照，如果系统在一个杂乱的事务持续运行时插入、更新和删除数百万行数据，这可能会导致很大的开销。因此，要注意避免运行时间过长的事务：

+   如果你正在使用一个**mysql**会话进行交互式实验，完成后始终要`COMMIT`（以完成更改）或`ROLLBACK`（以撤消更改）。关闭交互式会话而不是长时间保持打开，以避免意外保持事务长时间打开。

+   确保应用程序中的任何错误处理程序也会`ROLLBACK`未完成的更改或`COMMIT`已完成的更改。

+   `ROLLBACK`是一个相对昂贵的操作，因为`INSERT`、`UPDATE`和`DELETE`操作在`COMMIT`之前被写入`InnoDB`表，预期大多数更改都会成功提交，而回滚是罕见的。在处理大量数据时，避免对大量行进行更改，然后回滚这些更改。

+   当使用一系列`INSERT`语句加载大量数据时，定期`COMMIT`结果，以避免持续数小时的事务。在数据仓库的典型加载操作中，如果出现问题，你会截断表（使用`TRUNCATE TABLE`），然后从头开始，而不是执行`ROLLBACK`。

上述提示可以节省在过长事务期间可能浪费的内存和磁盘空间。当事务比应该更短时，问题在于过多的 I/O。每次`COMMIT`时，MySQL 都会确保每个更改都安全记录到磁盘上，这涉及一些 I/O。

+   对于大多数`InnoDB`表操作，应该使用设置`autocommit=0`。从效率的角度来看，这样可以避免在连续发出大量`INSERT`、`UPDATE`或`DELETE`语句时产生不必要的 I/O。从安全性的角度来看，这允许你发出一个`ROLLBACK`语句，以恢复在**mysql**命令行上犯错或在应用程序的异常处理程序中出现错误的数据。

+   在运行一系列用于生成报告或分析统计数据的查询时，`autocommit=1`适用于`InnoDB`表。在这种情况下，与`COMMIT`或`ROLLBACK`相关的 I/O 惩罚不存在，而`InnoDB`可以自动优化只读工作负载。

+   如果您进行一系列相关更改，请在最后一次使用单个`COMMIT`完成所有更改。例如，如果您将相关信息插入多个表中，请在进行所有更改后执行单个`COMMIT`。或者如果您运行许多连续的`INSERT`语句，请在所有数据加载后执行单个`COMMIT`；如果您正在执行数百万次`INSERT`语句，也许可以通过在每一万或十万条记录后发出一个`COMMIT`来拆分巨大的事务，以避免事务过大。

+   请记住，即使是`SELECT`语句也会开启一个事务，因此在交互式**mysql**会话中运行一些报告或调试查询后，要么执行一个`COMMIT`，要么关闭**mysql**会话。

有关信息，请参阅第 17.7.2.2 节，“自动提交、提交和回滚”。

##### 处理死锁

您可能会在 MySQL 错误日志中看到指向“死锁”的警告消息，或者`SHOW ENGINE INNODB STATUS`的输出。死锁对于`InnoDB`表来说并不是一个严重的问题，通常不需要任何纠正措施。当两个事务开始修改多个表，以不同顺序访问这些表时，它们可能会达到一个状态，其中每个事务都在等待另一个事务，而两者都无法继续。当启用死锁检测（默认情况下），MySQL 会立即检测到这种情况并取消（回滚）“较小”的事务，从而允许另一个事务继续。如果使用`innodb_deadlock_detect`配置选项禁用死锁检测，则`InnoDB`依赖于`innodb_lock_wait_timeout`设置，在死锁发生时回滚事务。

无论哪种方式，您的应用程序都需要错误处理逻辑来重新启动因死锁而被强制取消的事务。当重新发出与之前相同的 SQL 语句时，原始的时间问题不再存在。要么另一个事务已经完成，您的事务可以继续，要么另一个事务仍在进行中，您的事务将等待直到其完成。

如果死锁警告频繁发生，您可能需要审查应用程序代码以以一致的方式重新排序 SQL 操作，或缩短事务。您可以启用`innodb_print_all_deadlocks`选项进行测试，以在 MySQL 错误日志中看到所有死锁警告，而不仅仅是`SHOW ENGINE INNODB STATUS`输出中的最后一个警告。

更多信息，请参见 Section 17.7.5, “Deadlocks in InnoDB”。

##### 存储布局

要从`InnoDB`表中获得最佳性能，您可以调整与存储布局相关的多个参数。

当您转换大型、频繁访问且保存重要数据的`MyISAM`表时，请调查并考虑`innodb_file_per_table`和`innodb_page_size`变量，以及`CREATE TABLE`语句的`ROW_FORMAT`和`KEY_BLOCK_SIZE`子句。

在您的初始实验中，最重要的设置是`innodb_file_per_table`。当启用此设置时（默认情况下），新的`InnoDB`表会隐式地创建在 file-per-table 表空间中。与`InnoDB`系统表空间相比，file-per-table 表空间允许在表被截断或删除时由操作系统回收磁盘空间。File-per-table 表空间还支持 DYNAMIC 和 COMPRESSED 行格式以及相关功能，如表压缩、长变长列的高效离页存储和大索引前缀。更多信息，请参见 Section 17.6.3.2, “File-Per-Table Tablespaces”。

您还可以将`InnoDB`表存储在共享的通用表空间中，支持多个表和所有行格式。更多信息，请参见 Section 17.6.3.3, “General Tablespaces”。

##### 转换现有表

要将非`InnoDB`表转换为使用`InnoDB`，请使用`ALTER TABLE`：

```sql
ALTER TABLE *table_name* ENGINE=InnoDB;
```

##### 复制表的结构

您可以创建一个`InnoDB`表，它是 MyISAM 表的克隆，而不是使用`ALTER TABLE`执行转换，以在切换之前测试旧表和新表并排放置。

创建一个具有相同列和索引定义的空`InnoDB`表。使用`SHOW CREATE TABLE *`table_name`*\G`查看完整的`CREATE TABLE`语句。将`ENGINE`子句更改为`ENGINE=INNODB`。

##### 数据传输

要将大量数据传输到在上一节中创建的空`InnoDB`表中，使用`INSERT INTO *`innodb_table`* SELECT * FROM *`myisam_table`* ORDER BY *`primary_key_columns`*`插入行。

在插入数据后，您还可以为`InnoDB`表创建索引。历史上，为`InnoDB`创建新的辅助索引是一个缓慢的操作，但现在您可以在加载数据后创建索引，而索引创建步骤的开销相对较小。

如果在辅助键上有`UNIQUE`约束，您可以在导入操作期间暂时关闭唯一性检查以加快表导入速度：

```sql
SET unique_checks=0;
*... import operation ...* SET unique_checks=1;
```

对于大表，这样可以节省磁盘 I/O，因为`InnoDB`可以使用其更改缓冲区批量写入辅助索引记录。确保数据不包含重复键。`unique_checks`允许但不要求存储引擎忽略重复键。

为了更好地控制插入过程，您可以分批插入大表：

```sql
INSERT INTO newtable SELECT * FROM oldtable
   WHERE yourkey > *something* AND yourkey <= *somethingelse*;
```

插入所有记录后，您可以重命名表。

在转换大表时，增加`InnoDB`缓冲池的大小以减少磁盘 I/O。通常，推荐的缓冲池大小为系统内存的 50 到 75％。您还可以增加`InnoDB`日志文件的大小。

##### 存储要求

如果您打算在转换过程中在`InnoDB`表中创建多个临时副本，建议您创建文件级表空间中的表，以便在删除表时可以回收磁盘空间。当启用`innodb_file_per_table`配置选项（默认情况下）时，新创建的`InnoDB`表会隐式地创建在文件级表空间中。

无论是直接转换`MyISAM`表还是创建一个克隆的`InnoDB`表，确保在整个过程中有足够的磁盘空间来容纳新旧表。**`InnoDB`表需要比`MyISAM`表更多的磁盘空间。**如果`ALTER TABLE`操作空间不足，它会启动回滚，如果受限于磁盘，这可能需要数小时。对于插入操作，`InnoDB`使用插入缓冲区批量合并次要索引记录到索引中。这样可以节省大量磁盘 I/O。但对于回滚操作，没有使用这样的机制，回滚可能比插入操作慢 30 倍。

在出现无法控制的回滚情况下，如果数据库中没有重要数据，可能建议终止数据库进程，而不是等待数百万次磁盘 I/O 操作完成。有关完整的步骤，请参见第 17.21.3 节，“强制 InnoDB 恢复”。

##### 定义主键

`PRIMARY KEY`子句是影响 MySQL 查询性能和表格及索引空间使用的关键因素。主键在表中唯一标识一行。表中的每一行应该有一个主键值，而且没有两行可以有相同的主键值。

这些是主键的指导原则，后面是更详细的解释。

+   为每个表声明一个`PRIMARY KEY`。通常，这是在查找单行时在`WHERE`子句中引用的最重要的列。

+   在原始的`CREATE TABLE`语句中声明`PRIMARY KEY`子句，而不是通过`ALTER TABLE`语句后期添加。

+   仔细选择列和其数据类型。优先选择数值列而不是字符或字符串列。

+   如果没有其他稳定的、唯一的、非空的、数值列可用，考虑使用自增列。

+   如果对主键列的值是否会发生变化存在任何疑问，自增列也是一个不错的选择。更改主键列的值是一项昂贵的操作，可能涉及表内数据和每个次要索引的重新排列。

考虑为任何尚未拥有主键的表添加主键。根据表的最大预期大小，使用最小的实用数值类型。这可以使每行稍微更紧凑，对于大表可以产生大量的空间节省。如果表具有任何次要索引，则空间节省会成倍增加，因为主键值在每个次要索引条目中重复。除了减少磁盘上的数据大小外，较小的主键还可以让更多的数据适应缓冲池，加快各种操作的速度，并提高并发性。

如果表已经在某个较长的列上有一个主键，比如`VARCHAR`，考虑添加一个新的无符号的`AUTO_INCREMENT`列，并将主键切换到该列，即使该列在查询中没有被引用。这种设计更改可以在次要索引中产生大量的空间节省。您可以将以前的主键列指定为`UNIQUE NOT NULL`，以强制执行与`PRIMARY KEY`子句相同的约束，即防止所有这些列中的重复或空值。

如果您将相关信息分布在多个表中，通常每个表都使用相同的列作为其主键。例如，人事数据库可能有几个表，每个表的主键都是员工编号。销售数据库可能有一些表的主键是客户编号，其他表的主键是订单编号。由于使用主键进行查找非常快速，您可以为这些表构建高效的连接查询。

如果完全省略`PRIMARY KEY`子句，MySQL 会为您创建一个不可见的主键。这是一个 6 字节的值，可能比您需要的要长，从而浪费空间。由于它是隐藏的，您无法在查询中引用它。

##### 应用程序性能考虑

`InnoDB`的可靠性和可扩展性功能需要比等效的`MyISAM`表更多的磁盘存储空间。您可以稍微更改列和索引定义，以获得更好的空间利用率，在处理结果集时减少 I/O 和内存消耗，并制定更好的查询优化计划，以有效利用索引查找。

如果为主键设置了一个数字 ID 列，请使用该值与其他表中的相关值进行交叉引用，特别是对于连接查询。例如，不要接受国家名称作为输入并执行搜索相同名称的查询，而是进行一次查找以确定国家 ID，然后进行其他查询（或单个连接查询）以查找跨多个表的相关信息。而不是将客户或目录项号存储为一串数字，可能使用多个字节，将其转换为数字 ID 以进行存储和查询。一个 4 字节的无符号`INT`列可以索引超过 40 亿个项目（使用十进制中的十亿：1000 百万）。有关不同整数类型的范围，请参见第 13.1.2 节，“整数类型（精确值） - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT”。

##### 理解与 InnoDB 表相关的文件

`InnoDB`文件需要比`MyISAM`文件更多的关注和计划。

+   你不应删除代表`InnoDB`系统表空间的 ibdata 文件。

+   描述了将`InnoDB`表移动或复制到不同服务器的方法在第 17.6.1.4 节，“移动或复制 InnoDB 表”中。
