# 7.1.19 服务器关闭过程

> 原文：[`dev.mysql.com/doc/refman/8.0/en/server-shutdown.html`](https://dev.mysql.com/doc/refman/8.0/en/server-shutdown.html)

服务器关闭过程如下进行：

1.  关闭过程被启动。

    这可以通过多种方式来启动。例如，具有`SHUTDOWN`权限的用户可以执行**mysqladmin shutdown**命令。**mysqladmin**可以在 MySQL 支持的任何平台上使用。还有其他特定于操作系统的关闭启动方法：Unix 上的服务器在接收到`SIGTERM`信号时关闭。在 Windows 上作为服务运行的服务器在服务管理器告知时关闭。

1.  如果需要，服务器会创建一个关闭线程。

    根据关闭是如何启动的，服务器可能会创建一个线程来处理关闭过程。如果关闭是由客户端请求的，将创建一个关闭线程。如果关闭是由接收到`SIGTERM`信号导致的，信号线程可能会自行处理关闭，或者可能会创建一个单独的线程来处理。如果服务器尝试创建关闭线程但无法（例如，内存耗尽），它会发出出现在错误日志中的诊断消息：

    ```sql
    Error: Can't create thread to kill server
    ```

1.  服务器停止接受新连接。

    为了在关闭过程中防止启动新活动，服务器通过关闭通常用于接受连接的网络接口的处理程序来停止接受新的客户端连接：TCP/IP 端口，Unix 套接字文件，Windows 命名管道以及 Windows 上的共享内存。

1.  服务器终止当前活动。

    对于与客户端连接相关的每个线程，服务器会断开与客户端的连接并将线程标记为已终止。线程在注意到自己被标记后会终止。空闲连接的线程会迅速终止。当前正在处理语句的线程会定期检查其状态并需要更长时间才能终止。有关线程终止的更多信息，请参见 Section 15.7.8.4, “KILL Statement”，特别是关于在`MyISAM`表上执行被终止的`REPAIR TABLE`或`OPTIMIZE TABLE`操作的说明。

    对于具有未完成事务的线程，事务将被回滚。如果一个线程正在更新一个非事务表，例如多行`UPDATE`或`INSERT`操作可能会导致表部分更新，因为操作可能在完成之前终止。

    如果服务器是一个复制源服务器，它会像对待其他客户端线程一样对待与当前连接的复制品相关的线程。也就是说，每个线程都被标记为已杀死，并在下次检查其状态时退出。

    如果服务器是一个复制服务器，在标记客户端线程为已杀死之前，它会停止复制 I/O 和 SQL 线程（如果它们是活动的）。SQL 线程被允许完成当前的语句（以避免引起复制问题），然后停止。如果此时 SQL 线程正在事务中，服务器会等到当前的复制事件组（如果有的话）执行完毕，或者直到用户发出`KILL QUERY`或`KILL CONNECTION`语句。另请参阅第 15.4.2.9 节，“STOP SLAVE Statement”。由于非事务性语句无法回滚，为了保证崩溃安全的复制，只能使用事务性表。

    注意

    为了保证复制品的崩溃安全性，必须使用`--relay-log-recovery`参数运行复制品。

    另请参阅第 19.2.4 节，“中继日志和复制元数据存储库”。

1.  服务器关闭或关闭存储引擎。

    在此阶段，服务器刷新表缓存并关闭所有打开的表。

    每个存储引擎执行其管理的表所需的任何操作。`InnoDB`将其缓冲池刷新到磁盘（除非`innodb_fast_shutdown`为 2），将当前 LSN 写入表空间，并终止其自己的内部线程。`MyISAM`刷新任何待处理的表的索引写入。

1.  服务器退出。

为了向管理进程提供信息，服务器返回以下列表中描述的退出代码之一。括号中的短语指示 systemd 对代码的响应动作，对于使用 systemd 管理服务器的平台。 

+   0 = 成功的终止（未重启）

+   1 = 不成功的终止（未重启）

+   2 = 不成功的终止（已重启）
