# 10.11.1 内部锁定方法

> 原文：[`dev.mysql.com/doc/refman/8.0/en/internal-locking.html`](https://dev.mysql.com/doc/refman/8.0/en/internal-locking.html)

本节讨论内部锁定；即 MySQL 服务器内部执行的锁定，以管理多个会话对表内容的争用。这种类型的锁定是内部的，因为它完全由服务器执行，不涉及其他程序。有关其他程序在 MySQL 文件上执行的锁定，请参见第 10.11.5 节，“外部锁定”。

+   行级锁定

+   表级锁定

+   选择锁定类型

#### 行级锁定

MySQL 对`InnoDB`表使用行级锁定，以支持多个会话同时写入访问，使其适用于多用户、高并发和 OLTP 应用程序。

为了避免在单个`InnoDB`表上执行多个并发写操作时发生死锁，在事务开始时通过为预计修改的每组行发出`SELECT ... FOR UPDATE`语句来获取必要的锁，即使数据更改语句在事务后面执行。如果事务修改或锁定多个表，请在每个事务内以相同顺序发出适用的语句。死锁会影响性能而不是表示严重错误，因为`InnoDB`默认会自动检测死锁条件并回滚受影响的事务之一。

在高并发系统中，死锁检测可能导致许多线程等待相同锁时出现减速。有时，禁用死锁检测并依赖于`innodb_lock_wait_timeout`设置在死锁发生时回滚事务可能更有效。可以使用`innodb_deadlock_detect`配置选项禁用死锁检测。

行级锁定的优势：

+   当不同会话访问不同行时，减少锁冲突。

+   回滚更少的更改。

+   可以长时间锁定单个行。

#### 表级锁定

MySQL 对`MyISAM`、`MEMORY`和`MERGE`表使用表级锁定，每次只允许一个会话更新这些表。这种锁定级别使这些存储引擎更适合只读、读多或单用户应用程序。

这些存储引擎通过在查询开始时一次性请求所有所需的锁并始终以相同顺序锁定表来避免死锁。这种权衡是这种策略降低了并发性；其他想要修改表的会话必须等到当前数据更改语句完成。

表级锁定的优点：

+   需要相对较少的内存（行锁定需要每行或每组行锁定的内存）

+   在大部分表上使用时速度很快，因为只涉及一个锁。

+   如果经常在大部分数据上执行`GROUP BY`操作或必须频繁扫描整个表，则速度很快。

MySQL 授予表写锁如下：

1.  如果表上没有锁，请在其上放置写锁。

1.  否则，将锁请求放入写锁队列。

MySQL 授予表读锁如下：

1.  如果表上没有写锁，请在其上放置读锁。

1.  否则，将锁请求放入读锁队列。

表更新比表检索具有更高的优先级。因此，当释放锁时，锁将提供给写锁队列中的请求，然后提供给读锁队列中的请求。这确保了即使表上有大量`SELECT`活动，对表的更新也不会“饿死”。但是，如果对表进行了许多更新，`SELECT`语句将等待直到没有更多更新。

有关修改读写优先级的信息，请参见第 10.11.2 节，“表锁问题”。

您可以通过检查`Table_locks_immediate`和`Table_locks_waited`状态变量来分析系统上的表锁争用情况，这些变量分别表示请求表锁可以立即授予的次数以及必须等待的次数：

```sql
mysql> SHOW STATUS LIKE 'Table%';
+-----------------------+---------+
| Variable_name         | Value   |
+-----------------------+---------+
| Table_locks_immediate | 1151552 |
| Table_locks_waited    | 15324   |
+-----------------------+---------+
```

Performance Schema 锁表还提供了锁定信息。请参见第 29.12.13 节，“Performance Schema 锁表”。

`MyISAM` 存储引擎支持并发插入以减少对给定表的读取者和写入者之间的争用：如果 `MyISAM` 表在数据文件中间没有空闲块，则行始终插入到数据文件的末尾。在这种情况下，您可以在不锁定的情况下自由混合并发 `INSERT` 和 `SELECT` 语句用于 `MyISAM` 表。也就是说，您可以在其他客户端从中读取时向 `MyISAM` 表插入行。空洞可能是由于从表中间删除或更新行而导致的。如果有空洞，则并发插入将被禁用，但在所有空洞填满新数据后会自动重新启用。要控制此行为，请使用 `concurrent_insert` 系统变量。参见 Section 10.11.3, “Concurrent Inserts”。

如果您使用 `LOCK TABLES` 明确获取表锁，则可以请求 `READ LOCAL` 锁而不是 `READ` 锁，以便其他会话在您锁定表时执行并发插入。

当无法进行并发插入时，要在表 `t1` 上执行许多 `INSERT` 和 `SELECT` 操作，您可以将行插入临时表 `temp_t1`，然后使用临时表中的行更新真实表：

```sql
mysql> LOCK TABLES t1 WRITE, temp_t1 WRITE;
mysql> INSERT INTO t1 SELECT * FROM temp_t1;
mysql> DELETE FROM temp_t1;
mysql> UNLOCK TABLES;
```

#### 选择锁定类型

通常，在以下情况下，表锁优于行级锁：

+   表的大多数语句是读取操作。

+   表的语句是读取和写入的混合，其中写入是更新或删除单行，可以通过一个键读取获取：

    ```sql
    UPDATE *tbl_name* SET *column*=*value* WHERE *unique_key_col*=*key_value*;
    DELETE FROM *tbl_name* WHERE *unique_key_col*=*key_value*;
    ```

+   `SELECT` 与并发 `INSERT` 语句结合，以及很少的 `UPDATE` 或 `DELETE` 语句。

+   对整个表进行许多扫描或 `GROUP BY` 操作，没有任何写入者。

使用更高级别的锁，您可以更容易地通过支持不同类型的锁来调整应用程序，因为与行级锁相比，锁开销更小。

除了行级锁之外的选项：

+   版本控制（例如 MySQL 中用于并发插入的方式），在同一时间可能有一个写入者和多个读取者。这意味着数据库或表支持根据访问开始时间而为数据提供不同视图。其他常见术语包括“时间旅行”，“写时复制”或“按需复制”。

+   在许多情况下，按需复制比行级锁更优越。然而，在最坏的情况下，它可能比使用普通锁占用更多内存。

+   你可以使用应用程序级别的锁，而不是使用行级别的锁，比如 MySQL 中提供的`GET_LOCK()`和`RELEASE_LOCK()`。这些是咨询性锁，所以只能与相互合作的应用程序一起使用。参见第 14.14 节，“锁定函数”。
