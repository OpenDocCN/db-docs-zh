> 原文：[`dev.mysql.com/doc/refman/8.0/en/group-replication-understanding-consistency-guarantees.html`](https://dev.mysql.com/doc/refman/8.0/en/group-replication-understanding-consistency-guarantees.html)

#### 20.5.3.1 理解事务一致性保证

就分布式一致性保证而言，无论是在正常操作还是故障修复操作中，Group Replication 一直是一个最终一致性系统。这意味着一旦传入流量减慢或停止，所有组成员都具有相同的数据内容。与系统一致性相关的事件可以分为控制操作，无论是手动操作还是由故障自动触发；和数据流操作。

对于 Group Replication，可以根据一致性评估的控制操作包括：

+   成员加入或离开，这在 Group Replication 的 Section 20.5.4, “分布式恢复” 和写保护中有所涵盖。

+   网络故障，这由围栏模式涵盖。

+   在单主组中，主故障切换，也可以是由 `group_replication_set_as_primary()` 触发的操作。

##### 一致性保证和主故障切换

在单主组中，在次级节点被提升为主节点的主故障切换事件中，新的主节点可以立即对应用流量开放，无论复制积压数据有多大，或者可以限制访问直到积压数据被应用。

第一种方法是，在主故障后，组尽可能快地确保稳定的组成员资格，通过选举新的主节点，然后立即允许数据访问，同时仍在应用旧主节点的任何可能的积压数据。确保了写一致性，但在新的主节点应用积压数据时，读取可能暂时检索到陈旧数据。例如，如果客户端 C1 在旧主节点故障前刚写入 `A=2 WHERE A=1`，当客户端 C1 重新连接到新的主节点时，它可能读取到 `A=1`，直到新的主节点应用其积压数据并赶上旧主节点离开组的状态。

第二种选择是，在主故障后，系统确保稳定的组成员资格，并像第一种选择一样选举新的主节点，但在这种情况下，组等待新的主节点应用所有积压数据，然后才允许数据访问。这确保了在先前描述的情况下，当客户端 C1 重新连接到新的主节点时，它读取 `A=2`。然而，这样做的代价是，故障切换所需的时间与积压数据的大小成正比，在正确配置的组上应该很小。

在 MySQL 8.0.14 之前，没有办法配置故障切换策略，默认情况下可用性最大化，如第一种方法所述。在运行 MySQL 8.0.14 及更高版本的成员组中，您可以使用`group_replication_consistency`变量配置主故障切换期间成员提供的事务一致性保证级别。请参阅一致性对主选举的影响。

##### 数据流操作

数据流与组一致性保证相关，因为读取和写入操作在组中执行，特别是当这些操作分布在所有成员之间时。数据流操作适用于组复制的两种模式：单主和多主，但为了更清晰地解释，本文仅限于单主模式。将传入的读取或写入事务分割到单主组成员的常规方式是将写入路由到主节点，并将读取均匀分布到从节点。由于组应该表现为单个实体，因此可以合理地期望主节点上的写入立即在从节点上可用。虽然组复制是使用实现 Paxos 算法的组通信系统（GCS）协议编写的，但组复制的某些部分是异步的，这意味着数据会异步应用到从节点。这意味着客户端 C2 可以在主节点上写入`B=2 WHERE B=1`，立即连接到从节点并读取`B=1`。这是因为从节点仍在应用积压数据，并且尚未应用主节点应用的事务。

##### 事务同步点

您可以根据希望在组中同步事务的时间点配置组的一致性保证。为了帮助您理解概念，本节将简化跨组同步事务的时间点为读取操作时或写入操作时。如果在读取时同步数据，则当前客户端会等待直到给定时间点，即所有先前的更新事务都已应用，然后才能开始执行。使用这种方法，只有此会话受到影响，所有其他并发数据操作不受影响。

如果在写入时同步数据，则写入会话会等待直到所有从节点写入其数据。组复制使用写入的总顺序，因此这意味着等待这个和所有在从节点队列中的先前写入被应用。因此，当使用此同步点时，写入会话等待所有从节点队列被应用。

任何替代方案都确保在描述的客户端 C2 的情况下，即使立即连接到辅助服务器，也始终读取`B=2`。每种替代方案都有其优点和缺点，这些直接与你的系统工作负载相关。以下示例描述了不同类型的工作负载，并建议哪种同步点是适当的。

想象以下情况：

+   你希望负载均衡你的读取操作，而不需要在从哪个服务器读取时部署额外的限制，以避免读取过时数据，组写入比组读取要少得多。

+   如果你有一个主要是只读数据的组，你希望读写事务在提交后到处都被应用，这样后续的读取都是在包含最新写入的最新数据上进行的。这确保你不必为每个只读事务支付同步成本，而只需为读写事务支付。

在这些情况下，你应该选择在写入时进行同步。

想象以下情况：

+   你希望负载均衡你的读取操作，而不需要在从哪个服务器读取时部署额外的限制，以避免读取过时数据，组写入比组读取要常见得多。

+   你希望你的工作负载中的特定事务始终从组中读取最新数据，例如每当敏感数据更新时（例如文件的凭据或类似数据），你希望强制读取检索到最新值。

在这些情况下，你应该选择在读取时进行同步。
