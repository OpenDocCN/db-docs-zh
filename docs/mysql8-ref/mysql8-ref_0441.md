> 原文：[`dev.mysql.com/doc/refman/8.0/en/audit-log-file-reading.html`](https://dev.mysql.com/doc/refman/8.0/en/audit-log-file-reading.html)

#### 8.4.5.6 读取审计日志文件

审计日志插件支持提供 SQL 接口以读取 JSON 格式审计日志文件的函数。（此功能不适用于其他格式的日志文件。）

当审计日志插件初始化并配置为 JSON 记录时，它使用包含当前审计日志文件的目录作为搜索可读取审计日志文件的位置。插件从`audit_log_file`系统变量的值中确定文件位置、基本名称和后缀，然后查找与以下模式匹配的文件，其中`[...]`表示可选文件名部分：

```sql
*basename*[.*timestamp*].*suffix*[.gz][[.*pwd_id*].enc]
```

如果文件名以`.enc`结尾，则文件已加密，读取其未加密内容需要从密钥环获取解密密码。审计日志插件确定解密密码的密钥环 ID 如下：

+   如果`.enc`之前是*`pwd_id`*，密钥环 ID 是`audit_log-*`pwd_id`*`。

+   如果`.enc`之前不是*`pwd_id`*，则文件具有在实施审计日志加密密码历史之前的旧名称。密钥环 ID 是`audit_log`。

有关加密审计日志文件的更多信息，请参阅加密审计日志文件。

插件会忽略那些被手动重命名且不符合模式的文件，以及使用密码加密但密钥环中不再存在密码的文件。插件会打开每个剩余的候选文件，验证文件是否实际包含`JSON`审计事件，并使用每个文件的第一个事件的时间戳对文件进行排序。结果是一系列文件，可以通过日志读取函数进行访问：

+   `audit_log_read()` 从审计日志中读取事件或关闭读取过程。

+   `audit_log_read_bookmark()` 返回最近写入的审计日志事件的书签。此书签适合传递给`audit_log_read()`以指示从何处开始读取。

`audit_log_read()` 接受一个可选的`JSON`字符串参数，成功调用任一函数后返回的结果是一个`JSON`字符串。

要使用函数读取审计日志，请遵循以下原则：

+   调用`audit_log_read()` 从给定位置或当前位置开始读取事件，或关闭读取：

    +   要初始化审核日志读取序列，请传递指示开始位置的参数。一种方法是传递由`audit_log_read_bookmark()`返回的书签：

        ```sql
        SELECT audit_log_read(audit_log_read_bookmark());
        ```

    +   要从序列中的当前位置继续读取，请调用`audit_log_read()`而不指定位置：

        ```sql
        SELECT audit_log_read();
        ```

    +   要显式关闭读取序列，请传递一个`JSON` `null`参数：

        ```sql
        SELECT audit_log_read('null');
        ```

        不需要显式关闭读取。当会话结束或通过调用带有指示开始位置参数的`audit_log_read()`来初始化新的读取序列时，读取会在隐式关闭。

+   成功调用`audit_log_read()`读取事件将返回一个包含审核事件数组的`JSON`字符串：

    +   如果返回数组的最终值不是`JSON` `null`值，则在刚刚读取的事件后还有更多事件，并且可以再次调用`audit_log_read()`来读取更多事件。

    +   如果返回数组的最终值是`JSON` `null`值，则当前读取序列中没有更多事件可读取。

    每个非`null`数组元素都表示为`JSON`哈希。例如：

    ```sql
    [
      {
        "timestamp": "2020-05-18 13:39:33", "id": 0,
        "class": "connection", "event": "connect",
        ...
      },
      {
        "timestamp": "2020-05-18 13:39:33", "id": 1,
        "class": "general", "event": "status",
        ...
      },
      {
        "timestamp": "2020-05-18 13:39:33", "id": 2,
        "class": "connection", "event": "disconnect",
        ...
      },
      null
    ]
    ```

    有关 JSON 格式审核事件内容的更多信息，请参阅 JSON 审计日志文件格式。

+   未指定位置的`audit_log_read()`调用在以下任何条件下都会产生错误：

    +   通过向`audit_log_read()`传递位置参数来初始化读取序列。

    +   当前读取序列中没有更多事件可读取；也就是说，`audit_log_read()`先前返回了以`JSON` `null`值结尾的数组。

    +   通过向`audit_log_read()`传递一个`JSON` `null`值，最近的读取序列已被关闭。

    要在这些条件下读取事件，需要首先通过调用带有指定位置参数的`audit_log_read()`来初始化读取序列。

要指定传递给`audit_log_read()`的位置，请包含指示从何处开始读取的参数。例如，传递一个书签，这是一个包含`timestamp`和`id`元素的`JSON`哈希，用于唯一标识特定事件。以下是通过调用`audit_log_read_bookmark()`函数获得的示例书签：

```sql
mysql> SELECT audit_log_read_bookmark();
+-------------------------------------------------+
| audit_log_read_bookmark()                       |
+-------------------------------------------------+
| { "timestamp": "2020-05-18 21:03:44", "id": 0 } |
+-------------------------------------------------+
```

将当前书签传递给`audit_log_read()`会初始化从书签位置开始的事件读取：

```sql
mysql> SELECT audit_log_read(audit_log_read_bookmark());
+-----------------------------------------------------------------------+
| audit_log_read(audit_log_read_bookmark())                             |
+-----------------------------------------------------------------------+
|  {"timestamp":"2020-05-18 22:41:24","id":0,"class":"connection", ... |
+-----------------------------------------------------------------------+
```

传递给[`audit_log_read()`的参数是可选的。如果存在，则可以是`JSON` `null`值以关闭读取序列，或者是`JSON`哈希。

在传递给`audit_log_read()`的哈希参数中，项目是可选的，用于控制读取操作的方面，例如开始读取的位置或要读取的事件数量。以下项目是重要的（其他项目将被忽略）：

+   `start`：要读取的第一个事件在审计日志中的位置。位置以时间戳给出，并且读取从时间戳值之后或同时发生的第一个事件开始。`start`项目具有以下格式，其中*`value`*是一个文字时间戳值：

    ```sql
    "start": { "timestamp": "*value*" }
    ```

    `start`项目自 MySQL 8.0.22 起允许使用。

+   `timestamp`，`id`：读取的第一个事件在审计日志中的位置。`timestamp`和`id`项目一起构成一个书签，唯一标识特定事件。如果`audit_log_read()`参数包括任一项目，则必须同时包括两者才能完全指定位置，否则会出现错误。

+   `max_array_length`：从日志中读取的最大事件数。如果省略此项目，默认情况下是读取到日志末尾或直到读取缓冲区已满为止。

要指定传递给`audit_log_read()`的起始位置，请传递一个包含`start`项目或由`timestamp`和`id`项目组成的书签的哈希参数。如果哈希参数同时包括`start`项目和书签，则会出现错误。

如果哈希参数未指定起始位置，则从当前位置继续读取。

如果时间戳值不包含时间部分，则假定时间部分为`00:00:00`。

`audit_log_read()`接受的示例参数：

+   从给定时间戳之后或同时发生的第一个事件开始读取事件：

    ```sql
    audit_log_read('{ "start": { "timestamp": "2020-05-24 12:30:00" } }')
    ```

+   类似于前一个示例，但最多读取 3 个事件：

    ```sql
    audit_log_read('{ "start": { "timestamp": "2020-05-24 12:30:00" }, "max_array_length": 3 }')
    ```

+   从`2020-05-24 00:00:00`之后或同时发生的第一个事件开始读取事件（时间戳不包含时间部分，因此假定为`00:00:00`）：

    ```sql
    audit_log_read('{ "start": { "timestamp": "2020-05-24" } }')
    ```

+   从具有确切时间戳和事件 ID 的事件开始读取事件：

    ```sql
    audit_log_read('{ "timestamp": "2020-05-24 12:30:00", "id": 0 }')
    ```

+   与前一个示例类似，但最多读取 3 个事件：

    ```sql
    audit_log_read('{ "timestamp": "2020-05-24 12:30:00", "id": 0, "max_array_length": 3 }')
    ```

+   从读取序列的当前位置读取事件：

    ```sql
    audit_log_read()
    ```

+   从当前位置开始读取最多 5 个事件：

    ```sql
    audit_log_read('{ "max_array_length": 5 }')
    ```

+   关闭当前读取序列：

    ```sql
    audit_log_read('null')
    ```

从任一日志读取函数返回的`JSON`字符串可以根据需要进行操作。假设调用以获取书签产生此值：

```sql
mysql> SET @mark := audit_log_read_bookmark();
mysql> SELECT @mark;
+-------------------------------------------------+
| @mark                                           |
+-------------------------------------------------+
| { "timestamp": "2020-05-18 16:10:28", "id": 2 } |
+-------------------------------------------------+
```

使用该参数调用`audit_log_read()`可以返回多个事件。要限制`audit_log_read()`最多读取 *`N`* 个事件，请向字符串添加一个具有该值的 `max_array_length` 项。例如，要读取单个事件，请修改字符串如下：

```sql
mysql> SET @mark := JSON_SET(@mark, '$.max_array_length', 1);
mysql> SELECT @mark;
+----------------------------------------------------------------------+
| @mark                                                                |
+----------------------------------------------------------------------+
| {"id": 2, "timestamp": "2020-05-18 16:10:28", "max_array_length": 1} |
+----------------------------------------------------------------------+
```

修改后的字���串，当传递给`audit_log_read()`时，将产生一个包含最多一个事件的结果，无论有多少事件可用。

在 MySQL 8.0.19 之前，审计日志函数返回的字符串返回值是二进制字符串。要将二进制字符串用于需要非二进制字符串的函数（例如操作`JSON`值的函数），请将其转换为非二进制字符串。例如，在将书签传递给`JSON_SET()`之前，将其转换为`utf8mb4`如下：

```sql
SET @mark = CONVERT(@mark USING utf8mb4);
```

该语句即使对于 MySQL 8.0.19 及更高版本也可以使用；对于这些版本，它基本上是一个无操作，并且是无害的。

如果从**mysql**客户端内调用审计日志函数，则根据`--binary-as-hex`的值，二进制字符串结果将以十六进制表示。有关该选项的更多信息，请参见 Section 6.5.1, “mysql — The MySQL Command-Line Client”。

要限制`audit_log_read()`读取的字节数量，请设置`audit_log_read_buffer_size`系统变量。从 MySQL 8.0.12 开始，此变量默认为 32KB，并且可以在运行时设置。每个客户端应适当设置其对`audit_log_read()`的使用的会话值`audit_log_read_buffer_size`。

每次调用`audit_log_read()`都会返回尽可能多的可用事件，适合缓冲区大小。不适合缓冲区大小的事件将被跳过并生成警告。考虑这种行为时，应考虑以下因素来评估应用程序的适当缓冲区大小：

+   在调用`audit_log_read()`和每次调用返回的事件数量之间存在权衡：

    +   使用更小的缓冲区大小，调用会返回更少的事件，因此需要更多的调用。

    +   使用更大的缓冲区大小，调用会返回更多事件，因此需要更少的调用。

+   使用较小的缓冲区大小，例如默认大小为 32KB，事件超过缓冲区大小并因此被跳过的可能性更大。

在 MySQL 8.0.12 之前，`audit_log_read_buffer_size`默认为 1MB，影响所有客户端，只能在服务器启动时更改。

有关审计日志读取函数的更多信息，请参见 Audit Log Functions。
