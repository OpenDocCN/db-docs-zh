> 原文：[`dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html`](https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html)

#### 17.6.1.6 InnoDB 中的 AUTO_INCREMENT 处理

`InnoDB`提供了可配置的锁定机制，可以显著提高向带有`AUTO_INCREMENT`列的表添加行的 SQL 语句的可伸缩性和性能。要在`InnoDB`表中使用`AUTO_INCREMENT`机制，必须将`AUTO_INCREMENT`列定义为某个索引的第一列或唯一列，以便可以对表执行相当于索引的`SELECT MAX(*ai_col*)`查找以获取最大列值。索引不需要是`PRIMARY KEY`或`UNIQUE`，但为了避免`AUTO_INCREMENT`列中的重复值，建议使用这些索引类型。

本节描述了`AUTO_INCREMENT`锁定模式，不同`AUTO_INCREMENT`锁定模式设置的使用影响以及`InnoDB`如何初始化`AUTO_INCREMENT`计数器。

+   InnoDB AUTO_INCREMENT 锁定模式

+   InnoDB AUTO_INCREMENT 锁定模式使用影响

+   InnoDB AUTO_INCREMENT 计数器初始化

+   注释

##### InnoDB AUTO_INCREMENT 锁定模式

本节描述了用于生成自增值的`AUTO_INCREMENT`锁定模式，以及每种锁定模式如何影响复制。`auto-increment`锁定模式是在启动时使用`innodb_autoinc_lock_mode`变量进行配置的。

在描述`innodb_autoinc_lock_mode`设置时使用以下术语：

+   “`INSERT`-like”语句

    所有在表中生成新行的语句，包括`INSERT`，`INSERT ... SELECT`，`REPLACE`，`REPLACE ... SELECT`和`LOAD DATA`。包括“simple-inserts”，“bulk-inserts”和“mixed-mode”插入。

+   “简单插入”

    可以在初始处理语句时提前确定要插入的行数的语句。这包括没有嵌套子查询的单行和多行`INSERT`和`REPLACE`语句，但不包括`INSERT ... ON DUPLICATE KEY UPDATE`。

+   “批量插入”

    无法提前确定要插入的行数（和所需的自动递增值数量）的语句。这包括`INSERT ... SELECT`、`REPLACE ... SELECT`和`LOAD DATA`语句，但不包括普通的`INSERT`。`InnoDB`在处理每一行时逐个为`AUTO_INCREMENT`列分配新值。

+   “混合模式插入”

    这些是指定一些（但不是所有）新行的自动递增值的“简单插入”语句。以下是一个示例，其中`c1`是表`t1`的一个`AUTO_INCREMENT`列：

    ```sql
    INSERT INTO t1 (c1,c2) VALUES (1,'a'), (NULL,'b'), (5,'c'), (NULL,'d');
    ```

    另一种“混合模式插入”是`INSERT ... ON DUPLICATE KEY UPDATE`，在最坏的情况下实际上是一个`INSERT`后跟一个`UPDATE`，其中在更新阶段可能会或可能不会使用`AUTO_INCREMENT`列的分配值。

`innodb_autoinc_lock_mode`变量有三种可能的设置。这些设置分别为 0、1 或 2，分别为“传统”、“连续”或“交错”锁定模式。从 MySQL 8.0 开始，交错锁定模式（`innodb_autoinc_lock_mode=2`）是默认设置。在 MySQL 8.0 之前，连续锁定模式是默认设置（`innodb_autoinc_lock_mode=1`）。

MySQL 8.0 中交错锁定模式的默认设置反映了从基于语句的复制到基于行的复制作为默认复制类型的更改。基于语句的复制需要连续的自动递增锁定模式，以确保为给定的一系列 SQL 语句分配自动递增值的顺序是可预测和可重复的，而基于行的复制不会受到 SQL 语句执行顺序的影响。

+   `innodb_autoinc_lock_mode = 0`（“传统”锁定模式）

    传统的锁模式提供了在引入 `innodb_autoinc_lock_mode` 变量之前存在的相同行为。传统的锁模式选项是为了向后兼容性、性能测试以及解决“混合模式插入”问题而提供的，因为可能存在语义上的差异。

    在此锁模式下，所有“类似于 INSERT”的语句为具有 `AUTO_INCREMENT` 列的表获取特殊的表级 `AUTO-INC` 锁。通常，此锁持续到语句结束（而不是事务结束），以确保为给定的一系列 `INSERT` 语句分配自增值的顺序是可预测且可重复的，并确保由任何给定语句分配的自增值是连续的。

    在基于语句的复制中，这意味着当 SQL 语句在副本服务器上复制时，自增列使用与源服务器相同的值。多个 `INSERT` 语句的执行结果是确定性的，并且副本会复制与源相同的数据。如果多个 `INSERT` 语句生成的自增值交错，那么两个并发的 `INSERT` 语句的结果将是不确定的，并且无法可靠地使用基于语句的复制传播到副本服务器。

    为了更清楚地说明，考虑一个使用此表的示例：

    ```sql
    CREATE TABLE t1 (
      c1 INT(11) NOT NULL AUTO_INCREMENT,
      c2 VARCHAR(10) DEFAULT NULL,
      PRIMARY KEY (c1)
    ) ENGINE=InnoDB;
    ```

    假设有两个正在运行的事务，每个事务都向具有 `AUTO_INCREMENT` 列的表中插入行。一个事务使用 `INSERT ... SELECT` 语句插入 1000 行，另一个使用简单的 `INSERT` 语句插入一行：

    ```sql
    Tx1: INSERT INTO t1 (c2) SELECT 1000 rows from another table ...
    Tx2: INSERT INTO t1 (c2) VALUES ('xxx');
    ```

    `InnoDB` 无法提前知道在 Tx1 中的 `INSERT` 语句中从 `SELECT` 检索到多少行，并且随着语句的执行，它逐个分配自增值。通过表级锁，持续到语句结束，只有一个涉及表 `t1` 的 `INSERT` 语句可以同时执行，并且不同语句生成的自增值不会交错。Tx1 的 `INSERT ... SELECT` 语句生成的自增值是连续的，而 Tx2 中 `INSERT` 语句使用的（单个）自增值要么比 Tx1 中使用的所有自增值小，要么大，具体取决于哪个语句先执行。

    只要在从二进制日志重放 SQL 语句时（在使用基于语句的复制或在恢复场景中）SQL 语句以相同的顺序执行，结果与 Tx1 和 Tx2 首次运行时的结果相同。因此，持有直到语句结束的表级锁使得使用自增的`INSERT`语句在基于语句的复制中是安全的。然而，这些表级锁会限制并发性和可伸缩性，当多个事务同时执行插入语句时。

    在上面的例子中，如果没有表级锁，用于 Tx2 中的`INSERT`的自增列的值取决于语句执行的时间。如果 Tx2 的`INSERT`在 Tx1 的`INSERT`运行时执行（而不是在其开始之前或完成之后），那么两个`INSERT`语句分配的具体自增值是不确定的，并且可能会因运行而异。

    在连续锁模式下，`InnoDB`可以避免对“简单插入”语句使用表级`AUTO-INC`锁，其中行数是预先知道的，并且仍然保持基于语句的复制的确定性执行和安全性。

    如果不使用二进制日志来重放 SQL 语句作为恢复或复制的一部分，可以使用交错锁模式来消除所有表级`AUTO-INC`锁的使用，以获得更大的并发性和性能，但代价是允许语句分配的自增号中存在间隙，并且可能会有并发执行语句分配的号码交错。

+   `innodb_autoinc_lock_mode = 1`（“连续”锁模式）

    在这种模式下，“批量插入”使用特殊的`AUTO-INC`表级锁，并在语句结束前保持该锁。这适用于所有`INSERT ... SELECT`、`REPLACE ... SELECT`和`LOAD DATA`语句。只能有一个持有`AUTO-INC`锁的语句可以执行。如果批量插入操作的源表与目标表不同，那么在从源表选择的第一行获取共享锁后，将在目标表上获取`AUTO-INC`锁。如果批量插入操作的源表和目标表是同一张表，则在选择的所有行上获取共享锁后，将获取`AUTO-INC`锁。

    “简单插入”（已知要插入的行数）通过在互斥锁（一种轻量级锁）的控制下获取所需数量的自增值来避免表级`AUTO-INC`锁，该锁仅在分配过程的持续时间内保持，*而不是*直到语句完成。除非另一个事务持有`AUTO-INC`锁，否则不会使用表级`AUTO-INC`锁。如果另一个事务持有`AUTO-INC`锁，则“简单插入”将等待`AUTO-INC`锁，就像它是“批量插入”一样。

    这种锁定模式确保，在存在不事先知道要插入的行数的`INSERT`语句中（并且自增数字是随着语句的进行而分配的），任何“`INSERT`-like”语句分配的所有自增值都是连续的，并且操作对于基于语句的复制是安全的。

    简而言之，这种锁定模式在显著提高可伸缩性的同时，对于基于语句的复制是安全的。此外，与“传统”锁定模式一样，任何给定语句分配的自增数字是*连续的*。与使用自增的“传统”模式相比，对于使用自增的任何语句，语义*没有变化*，只有一个重要的例外。

    例外情况是“混合模式插入”，其中用户为多行“简单插入”中的某些行的`AUTO_INCREMENT`列提供显式值，但不是所有行。对于这样的插入，`InnoDB`分配的自增值比要插入的行数多。然而，所有自动分配的值都是连续生成的（因此高于）最近执行的前一个语句生成的自增值。“多余”的数字会丢失。

+   `innodb_autoinc_lock_mode = 2`（“交错”锁定模式）

    在这种锁定模式下，没有“`INSERT`-like”语句使用表级`AUTO-INC`锁，并且多个语句可以同时执行。这是最快和最可伸缩的锁定模式，但在使用基于语句的复制或从二进制日志重放 SQL 语句的恢复场景时*不安全*。

    在这种锁定模式下，自增值保证在所有同时执行的“`INSERT`-like”语句中是唯一且单调递增的。然而，由于多个语句可以同时生成数字（即，数字的分配在语句之间*交错*进行），因此由任何给定语句插入的行生成的值可能不是连续的。

    如果唯一执行的语句是“简单插入”，其中要插入的行数是事先已知的，那么对于单个语句生成的数字不会有间隔，除了“混合模式插入”。然而，当执行“批量插入”时，任何给定语句分配的自增值可能存在间隔。

##### InnoDB AUTO_INCREMENT 锁定模式的使用影响

+   使用复制的自增

    如果您正在使用基于语句的复制，请将`innodb_autoinc_lock_mode`设置为 0 或 1，并在源和其副本上使用相同的值。如果您使用`innodb_autoinc_lock_mode` = 2（“交错”）或源和副本不使用相同锁定模式的配置，则不能确保副本上的自增值与源上的相同。

    如果您正在使用基于行或混合格式的复制，所有的自增锁定模式都是安全的，因为基于行的复制不受 SQL 语句执行顺序的影响（混合格式使用基于行的复制来处理任何对基于语句的复制不安全的语句）。

+   “丢失”的自增值和序列间隔

    在所有的锁模式（0、1 和 2）中，如果生成自增值的事务回滚，那些自增值就会“丢失”。一旦为自增列生成了一个值，无论“`INSERT`-like”语句是否完成，以及包含事务是否回滚，都无法回滚该值。这些丢失的值不会被重用。因此，表中的`AUTO_INCREMENT`列中的值可能存在间隔。

+   为`AUTO_INCREMENT`列指定 NULL 或 0

    在所有的锁模式（0、1 和 2）中，如果用户在`INSERT`中的`AUTO_INCREMENT`列中指定 NULL 或 0，`InnoDB`会将该行视为未指定值并为其生成一个新值。

+   为`AUTO_INCREMENT`列分配负值

    在所有的锁模式（0、1 和 2）中，如果将负值分配给`AUTO_INCREMENT`列，则自增机制的行为是未定义的。

+   如果`AUTO_INCREMENT`值变大于指定整数类型的最大整数

    在所有的锁模式（0、1 和 2）中，如果值变大于指定整数类型中可以存储的最大整数，则自增机制的行为是未定义的。

+   “批量插入”中的自增值间隔

    当`innodb_autoinc_lock_mode`设置为 0（“传统”）或 1（“连续”）时，由任何给定语句生成的自增值是连续的，没有间隔，因为表级别的`AUTO-INC`锁会一直保持到语句结束，而且一次只能执行一个这样的语句。

    当`innodb_autoinc_lock_mode`设置为 2（“交错”）时，可能会在“批量插入”生成的自增值中出现间隙，但只有在同时执行“类似`INSERT`”语句时才会出现。

    对于锁定模式 1 或 2，连续语句之间可能会出现间隙，因为对于批量插入，每个语句所需的自增值数量可能未知，可能会出现过估计。

+   “混合模式插入”分配的自增值

    考虑一个“混合模式插入”，其中一个“简单插入”为一些（但不是全部）结果行指定了自增值。这样的语句在锁定模式 0、1 和 2 中的行为不同。例如，假设`c1`是表`t1`的`AUTO_INCREMENT`列，并且最近自动生成的序列号是 100。

    ```sql
    mysql> CREATE TABLE t1 (
     -> c1 INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, 
     -> c2 CHAR(1)
     -> ) ENGINE = INNODB;
    ```

    现在，考虑以下“混合模式插入”语句：

    ```sql
    mysql> INSERT INTO t1 (c1,c2) VALUES (1,'a'), (NULL,'b'), (5,'c'), (NULL,'d');
    ```

    当`innodb_autoinc_lock_mode`设置为 0（“传统”）时，四行新数据为：

    ```sql
    mysql> SELECT c1, c2 FROM t1 ORDER BY c2;
    +-----+------+
    | c1  | c2   |
    +-----+------+
    |   1 | a    |
    | 101 | b    |
    |   5 | c    |
    | 102 | d    |
    +-----+------+
    ```

    下一个可用的自增值是 103，因为自增值是一次分配一个，而不是在语句执行开始时一次性分配所有。无论是否有同时执行的“类似`INSERT`”语句（任何类型），这个结果都是正确的。

    当`innodb_autoinc_lock_mode`设置为 1（“连续”）时，四行新数据也是：

    ```sql
    mysql> SELECT c1, c2 FROM t1 ORDER BY c2;
    +-----+------+
    | c1  | c2   |
    +-----+------+
    |   1 | a    |
    | 101 | b    |
    |   5 | c    |
    | 102 | d    |
    +-----+------+
    ```

    然而，在这种情况下，下一个可用的自增值是 105，而不是 103，因为在处理语句时分配了四个自增值，但只使用了两个。无论是否有同时执行的“类似`INSERT`”语句（任何类型），这个结果都是正确的。

    当`innodb_autoinc_lock_mode`设置为 2（“交错”）时，四行新数据为：

    ```sql
    mysql> SELECT c1, c2 FROM t1 ORDER BY c2;
    +-----+------+
    | c1  | c2   |
    +-----+------+
    |   1 | a    |
    |   *x* | b    |
    |   5 | c    |
    |   *y* | d    |
    +-----+------+
    ```

    *`x`*和*`y`*的值是唯一的且大于先前生成的任何行。然而，*`x`*和*`y`*的具体值取决于同时执行语句生成的自增值的数量。

    最后，考虑以下语句，在最近生成的序列号为 100 时发出：

    ```sql
    mysql> INSERT INTO t1 (c1,c2) VALUES (1,'a'), (NULL,'b'), (101,'c'), (NULL,'d');
    ```

    无论`innodb_autoinc_lock_mode`设置为何值，这个语句都会生成一个重复键错误 23000（`无法写入；表中有重复键`），因为 101 被分配给行`(NULL, 'b')`，插入行`(101, 'c')`失败。

+   修改`AUTO_INCREMENT`列值在一系列`INSERT`语句中间

    在 MySQL 5.7 及更早版本中，在一系列`INSERT`语句中间修改`AUTO_INCREMENT`列值可能会导致“重复条目”错误。例如，如果执行了一个将`AUTO_INCREMENT`列值更改为大于当前最大自增值的值的`UPDATE`操作，则后续未指定未使用的自增值的`INSERT`操作可能会遇到“重复条目”错误。在 MySQL 8.0 及更高版本中，如果将`AUTO_INCREMENT`列值修改为大于当前最大自增值的值，则新值会被持久化，并且后续的`INSERT`操作会从新的更大值开始分配自增值。这种行为在以下示例中展示。

    ```sql
    mysql> CREATE TABLE t1 (
     -> c1 INT NOT NULL AUTO_INCREMENT,
     -> PRIMARY KEY (c1)
     ->  ) ENGINE = InnoDB;

    mysql> INSERT INTO t1 VALUES(0), (0), (3);

    mysql> SELECT c1 FROM t1;
    +----+
    | c1 |
    +----+
    |  1 |
    |  2 |
    |  3 |
    +----+

    mysql> UPDATE t1 SET c1 = 4 WHERE c1 = 1;

    mysql> SELECT c1 FROM t1;
    +----+
    | c1 |
    +----+
    |  2 |
    |  3 |
    |  4 |
    +----+

    mysql> INSERT INTO t1 VALUES(0);

    mysql> SELECT c1 FROM t1;
    +----+
    | c1 |
    +----+
    |  2 |
    |  3 |
    |  4 |
    |  5 |
    +----+
    ```

##### InnoDB AUTO_INCREMENT 计数器初始化

本节描述了`InnoDB`如何初始化`AUTO_INCREMENT`计数器。

如果为`InnoDB`表指定了`AUTO_INCREMENT`列，内存中的表对象包含一个称为自增计数器的特殊计数器，用于为该列分配新值。

在 MySQL 5.7 及更早版本中，自增计数器存储在主内存中，而不是在磁盘上。要在服务器重新启动后初始化自增计数器，`InnoDB`会在包含`AUTO_INCREMENT`列的表中第一次插入时执行类似以下语句的操作。

```sql
SELECT MAX(ai_col) FROM *table_name* FOR UPDATE;
```

在 MySQL 8.0 中，此行为已更改。每次更改当前最大自增计数器值时，都会将其写入重做日志并保存到数据字典中的检查点。这些更改使得当前最大自增计数器值在服务器重新启动时保持持久性。

在正常关闭后的服务器重新启动时，`InnoDB` 使用数据字典中存储的当前最大自增值初始化内存中的自增计数器。

在服务器重新启动期间进行崩溃恢复时，`InnoDB` 使用数据字典中存储的当前最大自增值初始化内存中的自增计数器，并扫描重做日志，查找自上次检查点以来写入的自增计数器值。如果重做记录的值大于内存中的计数器值，则应用重做记录的值。然而，在意外服务器退出的情况下，无法保证之前分配的自增值是否会被重用。每次由于`INSERT`或`UPDATE`操作而更改当前最大自增值时，新值会被写入重做日志，但如果在重做日志刷新到磁盘之前发生意外退出，则在服务器重新启动后初始化自增计数器时之前分配的值可能会被重用。

仅当导入表时没有`.cfg`元数据文件时，`InnoDB`才会使用类似于`SELECT MAX(ai_col) FROM *`table_name`* FOR UPDATE`语句来初始化自增计数器的等效值。否则，如果存在`.cfg`元数据文件，则从中读取当前最大自增计数器值。除了计数器值的初始化外，当尝试使用`ALTER TABLE ... AUTO_INCREMENT = *`N`*`语句将计数器值设置为小于或等于持久化计数器值时，会使用类似于`SELECT MAX(ai_col) FROM *`table_name`*`语句来确定表的当前最大自增计数器值。例如，您可能在删除一些记录后尝试将计数器值设置为较小的值。在这种情况下，必须搜索表以确保新的计数器值不小于或等于实际当前最大计数器值。

在 MySQL 5.7 及更早版本中，服务器重新启动会取消`AUTO_INCREMENT = N`表选项的效果，该选项可用于在`CREATE TABLE`或`ALTER TABLE`语句中设置初始计数器值或修改现有计数器值。在 MySQL 8.0 中，服务器重新启动不会取消`AUTO_INCREMENT = N`表选项的效果。如果将自增计数器初始化为特定值，或者将自增计数器值更改为较大值，则新值会在服务器重新启动时持久化。

注意

`ALTER TABLE ... AUTO_INCREMENT = N`只能将自增计数器值更改为大于当前最大值的值。

在 MySQL 5.7 及更早版本中，`ROLLBACK`操作后立即重新启动服务器可能导致先前分配给回滚事务的自增值被重用，实际上回滚了当前最大自增值。在 MySQL 8.0 中，当前最大自增值是持久化的，防止了先前分配值的重用。

如果在初始化自增计数器之前`SHOW TABLE STATUS`语句检查表，则`InnoDB`会打开表并使用存储在数据字典中的当前最大自增值来初始化计数器值。然后将该值存储在内存中供后续插入或更新使用。计数器值的初始化使用对表的正常独占锁定读取，该读取持续到事务结束。当初始化具有大于 0 的用户指定自增值的新创建表的自增计数器时，`InnoDB`遵循相同的过程。

初始化自增计数器后，如果在插入行时没有明确指定自增值，`InnoDB` 会隐式递增计数器并将新值分配给列。如果插入一行时明确指定了自增列值，并且该值大于当前最大计数器值，则计数器将设置为指定值。

`InnoDB` 在服务器运行时使用内存中的自增计数器。当服务器停止并重新启动时，`InnoDB` 会重新初始化自增计数器，如前所述。

`auto_increment_offset` 变量确定 `AUTO_INCREMENT` 列值的起始点。默认设置为 1。

`auto_increment_increment` 变量控制连续列值之间的间隔。默认设置为 1。

##### 注意

当 `AUTO_INCREMENT` 整数列用尽数值时，后续的 `INSERT` 操作会返回重复键错误。这是一般的 MySQL 行为。
