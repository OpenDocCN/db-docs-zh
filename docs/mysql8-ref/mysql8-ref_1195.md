> 原文：[`dev.mysql.com/doc/refman/8.0/en/innodb-deadlocks-handling.html`](https://dev.mysql.com/doc/refman/8.0/en/innodb-deadlocks-handling.html)

#### 17.7.5.3 如何最小化和处理死锁

本节建立在关于死锁的概念信息之上，详见第 17.7.5.2 节，“死锁检测”。它解释了如何组织数据库操作以最小化死锁，并说明了应用程序中所需的后续错误处理。

死锁是事务性数据库中的经典问题，但除非它们频繁到您根本无法运行某些事务，否则它们并不危险。通常，您必须编写应用程序，以便它们始终准备好在由于死锁而回滚事务时重新发出该事务。

`InnoDB`使用自动的行级锁定。即使是仅插入或删除单行的事务，也可能发生死锁。这是因为这些操作并不真正“原子化”；它们会自动在插入或删除的行的（可能是多个）索引记录上设置锁。

您可以通过以下技术来应对死锁并减少其发生的可能性：

+   随时使用`SHOW ENGINE INNODB STATUS`来确定最近死锁的原因。这可以帮助您调整应用程序以避免死锁。

+   如果频繁的死锁警告引起关注，可以通过启用`innodb_print_all_deadlocks`变量来收集更广泛的调试信息。每个死锁的信息，而不仅仅是最新的那个，都记录在 MySQL 的错误日志中。调试完成后请禁用此选项。

+   如果由于死锁而事务失败，请随时准备重新发出该事务。死锁并不危险。只需再试一次。

+   保持事务小且持续时间短，以减少碰撞的可能性。

+   在进行一组相关更改后立即提交事务，以减少碰撞的可能性。特别是，不要将一个交互式**mysql**会话保持打开很长时间且有未提交的事务。

+   如果使用锁定读取（`SELECT ... FOR UPDATE`或`SELECT ... FOR SHARE`），请尝试使用较低的隔离级别，如`READ COMMITTED`。

+   在事务中修改多个表或同一表中的不同行集时，每次都以一致的顺序执行这些操作。然后事务形成明确定义的队列，不会发生死锁。例如，将数据库操作组织成应用程序中的函数，或调用存储过程，而不是在不同位置编写多个类似的`INSERT`、`UPDATE`和`DELETE`语句序列。

+   为表添加精心选择的索引，以便查询扫描更少的索引记录并设置更少的锁。使用`EXPLAIN SELECT`来确定 MySQL 服务器认为哪些索引对您的查询最合适。

+   减少锁定。如果您可以允许`SELECT`从旧快照返回数据，请不要为其添加`FOR UPDATE`或`FOR SHARE`子句。在这里使用`READ COMMITTED`隔离级别是很好的，因为同一事务内的每个一致读取都从自己的新快照中读取。

+   如果没有其他办法，使用表级锁串行化您的事务。在使用事务表（如`InnoDB`表）时，正确使用`LOCK TABLES`的方法是以`SET autocommit = 0`（而不是`START TRANSACTION`）开始事务，然后跟随`LOCK TABLES`，直到显式提交事务前不调用`UNLOCK TABLES`。例如，如果您需要写入表`t1`并从表`t2`读取，可以这样做：

    ```sql
    SET autocommit=0;
    LOCK TABLES t1 WRITE, t2 READ, ...;
    *... do something with tables t1 and t2 here ...* COMMIT;
    UNLOCK TABLES;
    ```

    表级锁可以防止对表的并发更新，在繁忙系统中避免死锁，但会降低系统的响应速度。

+   另一种串行化事务的方法是创建一个仅包含单行的辅助“信号量”表。让每个事务在访问其他表之前更新该行。这样，所有事务都以串行方式发生。请注意，`InnoDB`即时死锁检测算法在这种情况下也适用，因为串行化锁是行级锁。对于 MySQL 表级锁，必须使用超时方法来解决死锁。
