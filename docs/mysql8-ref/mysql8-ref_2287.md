# A.14 MySQL 8.0 FAQ: 复制

> 原文：[`dev.mysql.com/doc/refman/8.0/en/faqs-replication.html`](https://dev.mysql.com/doc/refman/8.0/en/faqs-replication.html)

在接下来的部分中，我们提供关于 MySQL 复制最常见问题的答案。

A.14.1\. 副本必须始终连接到源吗？

A.14.2\. 必须在源和副本上启用网络才能启用复制吗？

A.14.3\. 如何知道副本相对于源有多晚？换句话说，如何知道副本复制的最后一个语句的日期？

A.14.4\. 如何强制源阻止更新，直到副本赶上？

A.14.5\. 设置双向复制时应注意的问题

A.14.6\. 如何利用复制来提高系统性能？

A.14.7\. 我应该如何准备自己应用程序中的客户端代码以使用性能增强的复制？

A.14.8\. MySQL 复制何时以及在多大程度上可以提高系统性能？

A.14.9\. 如何利用复制提供冗余或高可用性？

A.14.10\. 如何确定复制源服务器是使用基于语句还是基于行的二进制日志格式？

A.14.11\. 如何告诉副本使用基于行的复制？

A.14.12\. 如何防止 GRANT 和 REVOKE 语句复制到副本机器？

A.14.13\. 复制是否适用于混合操作系统（例如，源在 Linux 上运行，而副本在 macOS 和 Windows 上运行）？

A.14.14\. 复制是否适用于混合硬件架构（例如，源在 64 位机器上运行，而副本在 32 位机器上运行）？

| **A.14.1.** | 副本必须始终连接到源吗？ |
| --- | --- |
|  | 不，它不会。复制品可以在几个小时甚至几天内断开连接，然后重新连接并赶上更新。例如，您可以在仅偶尔连接且连接时间很短的拨号链接上建立源/复制品关系。这意味着，在任何给定时间，除非您采取一些特殊措施，否则不能保证复制品与源同步。为了确保断开连接的复制品可以进行追赶，您不能从包含尚未复制到复制品的信息的源中删除二进制日志文件。异步复制只有在复制品能够从上次读取事件的地方继续读取二进制日志时才能工作。 |
| **A.14.2.** | 我必须在源和复制品上启用网络才能启用复制吗？ |
|  | 是的，必须在源和复制品上启用网络。如果未启用网络，则复制品无法连接到源并传输二进制日志。请验证配置文件中未启用`skip_networking`系统变量。 |
| **A.14.3.** | 我如何知道复制品相对于源有多晚？换句话说，我如何知道复制品复制的最后一个语句的日期？ |
|  | 在`SHOW REPLICA &#124; SLAVE STATUS`的输出中检查`Seconds_Behind_Master`列。参见 Section 19.1.7.1，“检查复制状态”。当复制 SQL 线程执行从源读取的事件时，它会将自己的时间修改为事件时间戳。（这就是为什么`TIMESTAMP`很好地复制。）在`SHOW PROCESSLIST`的输出中的`Time`列中，复制 SQL 线程显示的秒数是最后一个复制事件的时间戳与复制品机器的实际时间之间的秒数。您可以使用此来确定最后一个复制事件的日期。请注意，如果您的复制品与源断开连接了一个小时，然后重新连接，您可能会立即看到大的`Time`值，例如在`SHOW PROCESSLIST`中的复制 SQL 线程为 3600。这是因为复制品正在执行一个小时前的语句。参见 Section 19.2.3，“复制线程”。 |
| **A.14.4.** | 我如何强制源阻止更新直到复制品赶上？ |

|  | 使用以下步骤：

1.  在源上执行以下语句：

    ```sql
    mysql> FLUSH TABLES WITH READ LOCK;
    mysql> SHOW MASTER STATUS;
    ```

    记录从`SHOW`语句的输出中获取的复制坐标（当前二进制日志文件名和位置）。

1.  在复制品上，发出以下语句，其中`SOURCE_POS_WAIT()`或`MASTER_POS_WAIT()`函数的参数是在上一步中获取的复制坐标值：

    ```sql
    mysql> SELECT MASTER_POS_WAIT('*log_name*', *log_pos*);

    Or from MySQL 8.0.26:
    mysql> SELECT SOURCE_POS_WAIT('*log_name*', *log_pos*);
    ```

    `SELECT` 语句会阻塞，直到复制品达到指定的日志文件和位置。在那一点上，复制品与源头同步，语句返回。

1.  在源头上，发出以下语句以使源头能够再次开始处理更新：

    ```sql
    mysql> UNLOCK TABLES;
    ```

|

| **A.14.5.** | 在设置双向复制时我应该注意哪些问题？ |
| --- | --- |
|  | MySQL 复制目前不支持源头和复制品之间的任何锁定协议，以保证分布式（跨服务器）更新的原子性。换句话说，客户端 A 可能会对共源 1 进行更新，同时，在它传播到共源 2 之前，客户端 B 可能会对共源 2 进行更新，使得客户端 A 的更新在共源 1 上的工作方式与共源 2 上的工作方式不同。因此，当客户端 A 的更新到达共源 2 时，它生成的表与您在共源 1 上拥有的表不同，即使所有来自共源 2 的更新也已传播。这意味着您不应该将两个服务器链接在一起形成双向复制关系，除非您确信您的更新可以安全地以任何顺序发生，或者除非您在客户端代码中以某种方式处理错误排序的更新。您还应该意识到，双向复制实际上在更新方面并没有多大（如果有的话）性能提升。每个服务器必须执行相同数量的更新，就像您只有一个服务器执行一样。唯一的区别是，由于来自另一个服务器的更新在一个复制线程中串行化，因此锁定争用会少一点。即使这种好处可能会被网络延迟抵消。 |
| **A.14.6.** | 我如何利用复制来提高系统性能？ |
|  | 将一个服务器设置为源服务器，并将所有写操作定向到该服务器。然后配置尽可能多的副本，以适应预算和机架空间，并在源服务器和副本之间分配读操作。您还可以使用`--skip-innodb`选项启动副本，启用`low_priority_updates`系统变量，并将`delay_key_write`系统变量设置为`ALL`，以在副本端获得速度改进。在这种情况下，副本使用非事务性的`MyISAM`表而不是`InnoDB`表，通过消除事务开销来获得更快的速度。 |
| **A.14.7.** | 我应该如何准备自己应用程序中的客户端代码以使用性能增强的复制？ |
|  | 查看使用复制作为扩展解决方案的指南，第 19.4.5 节，“使用复制进行扩展”。 |
| **A.14.8.** | MySQL 复制何时以及在多大程度上可以提高系统性能？ |

|  | MySQL 复制对于处理频繁读取和不频繁写入的系统最为有益。理论上，通过使用单源/多副本设置，您可以通过添加更多副本来扩展系统，直到您耗尽网络带宽，或者更新负载增长到源服务器无法处理的程度。要确定在增加副本数量之前增加的好处何时开始趋于平稳，以及您可以提高站点性能多少，您必须了解您的查询模式，并通过基准测试确定典型源服务器和典型副本之间读取和写入吞吐量之间的关系。这里的示例展示了对假设系统使用复制可以获得的相当简化的计算。让`reads`和`writes`分别表示每秒读取和写入的次数。假设系统负载由 10%的写入和 90%的读取组成，并且我们通过基准测试确定`reads`为 1200 - 2 * `writes`。换句话说，系统可以在没有写入的情况下每秒进行 1,200 次读取，平均写入速度是平均读取速度的两倍，且关系是线性的。假设源服务器和每个副本具有相同的容量，并且我们有一个源服务器和*N*个副本。那么对于每台服务器（源服务器或副本）：`reads` = 1200 - 2 * `writes``reads` = 9 * `writes` / (*N* + 1)（读取被分割，但写入被复制到所有副本）9 * `writes` / (*N* + 1) + 2 * `writes` = 1200`writes` = 1200 / (2 + 9/(*N* + 1))最后一个方程表示了在*N*个副本的情况下，给定每秒最大可能的读取速率为 1,200 次和九次读取一次写入的比率，最大写入次数。这个分析得出以下结论：

+   如果*`N`* = 0（表示我们没有复制），我们的系统可以处理约 1200/11 = 109 次写入每秒。

+   如果*`N`* = 1，我们可以达到每秒 184 次写入。

+   如果*`N`* = 8，我们可以达到每秒 400 次写入。

+   如果*`N`* = 17，我们可以达到每秒 480 次写入。

+   最终，当*`N`*趋近于无穷大（我们的预算趋近于负无穷大）时，我们可以接近每秒 600 次写入，系统吞吐量增加约 5.5 倍。然而，只有八台服务器时，我们将其增加近四倍。

这些计算假定有无限的网络带宽，并忽略了可能在您的系统上具有重要意义的其他几个因素。在许多情况下，您可能无法执行类似于刚刚显示的计算，准确预测如果添加*`N`*个副本会发生什么。然而，回答以下问题应该帮助您决定复制可能如何以及在多大程度上改善系统性能：

+   你的系统读写比是多少？

+   如果减少读取，一个服务器可以处理多少更多的写入负载？

+   你的网络上有多少副本可以使用带宽？

|

| **A.14.9.** | 如何使用复制提供冗余或高可用性？ |
| --- | --- |
|  | 如何实现冗余完全取决于您的应用程序和情况。高可用性解决方案（具有自动故障转移）需要主动监视和自定义脚本或第三方工具来提供从原始 MySQL 服务器到副本的故障转移支持。要手动处理该过程，您应该能够通过修改应用程序以与新服务器通信或通过调整 MySQL 服务器的 DNS 从故障服务器切换到新服务器来切换从失败源到预配置副本。有关更多信息和一些示例解决方案，请参见 Section 19.4.8, “Switching Sources During Failover”。 |
| **A.14.10.** | 如何确定复制源服务器是使用基于语句还是基于行的二进制日志格式？ |

|  | 检查`binlog_format`系统变量的值：

```sql
mysql> SHOW VARIABLES LIKE 'binlog_format';
```

显示的值始终是`STATEMENT`、`ROW`或`MIXED`之一。对于`MIXED`模式，默认情况下使用基于语句的日志记录，但在某些条件下，例如不安全的语句，复制会自动切换到基于行的日志记录。有关可能发生这种情况的信息，请参见 Section 7.4.4.3, “Mixed Binary Logging Format”。

| **A.14.11.** | 如何告诉副本使用基于行的复制？ |
| --- | --- |
|  | 副本自动知道要使用哪种格式。 |
| **A.14.12.** | 如何防止`GRANT`和`REVOKE`语句复制到副本机器？ |
|  | 使用`--replicate-wild-ignore-table=mysql.%`选项启动服务器，以忽略`mysql`数据库中的表的复制。 |
| **A.14.13.** | 复制是否在混合操作系统上工作（例如，源在 Linux 上运行，而副本在 macOS 和 Windows 上运行）？ |
|  | 是的。 |
| **A.14.14.** | 复制是否在混合硬件架构上工作（例如，源在 64 位机器上运行，而副本在 32 位机器上运行）？ |
|  | 是的。 |
