# 1\. 引言

> 原文：[`sqlite.com/testing.html`](https://sqlite.com/testing.html)

SQLite 的可靠性和健壮性部分得益于彻底和谨慎的测试。

截至 版本 3.42.0（2023-05-16），SQLite 库大约由 155.8 KSLOC 的 C 代码组成。（KSLOC 意为千行源代码，即不包括空白行和注释的代码行数。）相比之下，项目的测试代码和测试脚本有 590 倍之多 - 92053.1 KSLOC。

## 1.1\. 执行摘要

+   四个独立开发的测试工具

+   部署配置下分支测试覆盖率达到 100%

+   数以百万计的测试用例

+   内存不足测试

+   I/O 错误测试

+   崩溃和断电测试

+   模糊测试

+   边界值测试

+   禁用优化测试

+   回归测试

+   数据库格式错误测试

+   广泛使用 assert() 和运行时检查

+   Valgrind 分析

+   未定义行为检查

+   检查清单

# 2\. 测试工具

用于测试核心 SQLite 库的四个独立测试工具。每个测试工具都是设计、维护和管理分开的。

1.  **TCL 测试** 是 SQLite 的原始测试。它们包含在与 SQLite 核心相同的源树中，并且像 SQLite 核心一样属于公共领域。TCL 测试是开发过程中主要使用的测试。TCL 测试使用[TCL 脚本语言](http://www.tcl-lang.org/)编写。TCL 测试工具本身由 27.2 KSLOC 的 C 代码组成，用于创建 TCL 接口。测试脚本包含在 1390 个文件中，总大小为 23.2MB。有 51445 个独立的测试用例，但许多测试用例是参数化的，并且以不同的参数多次运行，因此在完整测试运行中执行了数百万个单独的测试。

1.  **TH3** 测试工具是一组专有测试，用 C 语言编写，为核心 SQLite 库提供了 100%的分支测试覆盖率（以及 100%的 MC/DC 测试覆盖率）。TH3 测试旨在运行于嵌入式和专用平台，这些平台不易支持 TCL 或其他工作站服务。TH3 测试仅使用公开的 SQLite 接口。TH3 包含约 76.9 MB 或 1055.4 KSLOC 的 C 代码，实现了 50362 个独立的测试用例。尽管 TH3 测试具有很强的参数化特性，但完整覆盖测试约会运行大约 240 万个不同的测试实例。提供 100%分支测试覆盖的案例是总 TH3 测试套件的一个子集。发布前的浸泡测试大约执行了 2.485 亿次测试。关于 TH3 的更多信息可单独获取。

1.  [**SQL 逻辑测试**](https://www.sqlite.org/sqllogictest)或 SLT 测试框架用于针对 SQLite 和其他几个 SQL 数据库引擎运行大量 SQL 语句，并验证它们是否得到相同的答案。SLT 目前将 SQLite 与 PostgreSQL、MySQL、Microsoft SQL Server 和 Oracle 10g 进行比较。SLT 运行 720 万个查询，包括 1.12GB 的测试数据。

1.  **dbsqlfuzz**引擎是专有的模糊测试工具。其他 SQLite 的 fuzzers 会改变 SQL 输入或数据库文件。Dbsqlfuzz 同时改变 SQL 和数据库文件，因此能够达到新的错误状态。Dbsqlfuzz 使用 LLVM 的[libFuzzer](http://llvm.org/docs/LibFuzzer.html)框架并带有自定义变异器。共有 336 个种子文件。dbsqlfuzz 每天运行大约 10 亿次测试变异。Dbsqlfuzz 有助于确保 SQLite 对通过恶意 SQL 或数据库输入进行的攻击具有鲁棒性。

除了四个主要的测试框架外，还有许多实现专门测试的小程序。以下是一些示例：

1.  "speedtest1.c"程序估计了 SQLite 在典型工作负载下的性能。

1.  "mptester.c"程序是用于多进程并发读写单个数据库的压力测试。

1.  "threadtest3.c"程序是用于测试多线程同时使用 SQLite 的压力测试。

1.  "fuzzershell.c"程序用于运行一些 fuzz tests。

1.  "jfuzz"程序是基于 libfuzzer 的模糊器，用于 JSONB 输入到 JSON SQL 函数。

所有上述测试在每次 SQLite 发布前，必须在多个平台和多个编译时配置下成功运行。

在每次提交到 SQLite 源代码树之前，开发人员通常运行 Tcl 测试的子集（称为"veryquick"），包括约 304.7 万个测试用例。veryquick 测试包括大多数测试，但不包括异常、模糊和浸泡测试。veryquick 测试的想法是，它们足以捕捉大多数错误，但运行时间仅为几分钟，而不是几小时。

# 3\. 异常测试

异常测试是用于验证 SQLite 在发生问题时的正确行为的测试。构建一个在功能完好的计算机上对良好形式输入表现正确的 SQL 数据库引擎相对较容易。构建一个在遇到无效输入和系统故障后继续正常运行的系统则更具挑战性。异常测试旨在验证后者的行为。

## 3.1\. 内存耗尽测试

SQLite，像所有 SQL 数据库引擎一样，广泛使用 malloc() 函数（详见关于 SQLite 中动态内存分配 的单独报告）。在服务器和工作站上，malloc() 函数实际上不会失败，因此正确处理内存耗尽（OOM）错误并不是特别重要。但是在嵌入式设备上，OOM 错误非常常见，并且由于 SQLite 经常用于嵌入式设备，因此 SQLite 能够优雅地处理这些错误非常重要。

OOM 测试通过模拟 OOM 错误来实现。SQLite 允许应用程序使用 sqlite3_config(SQLITE_CONFIG_MALLOC,...) 接口替换替代的 malloc() 实现。TCL 和 TH3 测试工具都能够插入一个修改版的 malloc()，可以设置在一定数量的分配后失败。这些有仪器的 malloc 可以设置为仅在第一次分配失败后才继续工作，或者在第一次失败后继续持续失败。OOM 测试是在一个循环中进行的。在循环的第一次迭代中，有仪器的 malloc 被设置为在第一次分配时失败。然后执行一些 SQLite 操作，并检查确保 SQLite 正确处理了 OOM 错误。然后增加有仪器的 malloc 的失败计数器，并重复测试。直到整个操作在没有遇到模拟的 OOM 失败的情况下完成。这样的测试会运行两次，一次将有仪器的 malloc 设置为仅在失败一次后才继续工作，另一次则设置为在第一次失败后持续失败。

## 3.2\. I/O 错误测试

I/O 错误测试旨在验证 SQLite 对于失败的 I/O 操作能够做出合理响应。I/O 错误可能由于磁盘已满、磁盘硬件故障、使用网络文件系统时的网络中断、在 SQL 操作中途发生的系统配置或权限更改，或其他硬件或操作系统故障引起。无论造成错误的原因是什么，都很重要的是 SQLite 能够正确响应这些错误，而 I/O 错误测试就是为了验证它是否能够做到。

I/O 错误测试在概念上类似于 OOM 测试；模拟 I/O 错误并检查 SQLite 是否正确响应模拟的错误。在 TCL 和 TH3 测试工具中，通过插入一个特殊设置为在一定数量的 I/O 操作后模拟 I/O 错误的新虚拟文件系统对象来模拟 I/O 错误。与 OOM 错误测试类似，I/O 错误模拟器可以设置为仅失败一次，或者在第一次失败后持续失败。测试循环运行，逐渐增加失败点，直到测试用例在没有错误的情况下完成。循环运行两次，一次将 I/O 错误模拟器设置为仅模拟单次失败，另一次将其设置为在第一次失败后连续失败所有 I/O 操作。

在 I/O 错误测试中，禁用 I/O 错误模拟失败机制后，使用 PRAGMA integrity_check 检查数据库，确保 I/O 错误未引入数据库损坏。

## 3.3\. 崩溃测试

崩溃测试旨在证明 SQLite 数据库在应用程序或操作系统崩溃或数据库更新过程中发生电力故障时不会损坏。名为 SQLite 中的原子提交的独立白皮书描述了 SQLite 为防止崩溃后数据库损坏所采取的防御措施。崩溃测试旨在验证这些防御措施是否正常工作。

当然，使用真实的电力故障进行崩溃测试是不现实的，因此崩溃测试是在模拟中进行的。插入一个替代的虚拟文件系统，允许测试工具模拟数据库文件在崩溃后的状态。

在 TCL 测试工具中，崩溃模拟在一个单独的进程中进行。主测试进程生成一个子进程，在写操作的中途随机崩溃。一个特殊的 VFS 随机重新排序和损坏未同步的写操作，模拟缓冲文件系统的效果。子进程终止后，原始测试进程打开并读取测试数据库，并验证子进程尝试的更改是成功完成还是完全回滚。使用 integrity_check PRAGMA 确保没有数据库损坏发生。

TH3 测试套件需要运行在不一定具备生成子进程能力的嵌入式系统上，因此使用内存中的 VFS 来模拟崩溃。内存中的 VFS 可以被操纵，在一定 I/O 操作次数后进行整个文件系统的快照。崩溃测试在循环中运行。在每次循环迭代中，快照的生成点会被推进，直到正在测试的 SQLite 操作完全运行而不触发快照。在循环内部，完成 SQLite 操作后，文件系统被还原到快照状态，并引入随机文件损坏，这些损坏特征上电后可能见到的损坏。然后打开数据库并检查确保其形式良好，且事务完成或完全回滚。在每个快照中的循环内部，会多次重复，每次引入不同的随机损坏。

## 3.4\. 复合失败测试

SQLite 的测试套件还探索了多重失败叠加的结果。例如，运行测试以确保在尝试从先前的崩溃中恢复时发生 I/O 错误或 OOM 故障时的正确行为。

# 4\. 模糊测试

[模糊测试](http://en.wikipedia.org/wiki/Fuzz_testing)旨在验证 SQLite 对于无效、超出范围或格式错误的输入能够正确响应。

## 4.1\. SQL 模糊测试

SQL 模糊测试包括创建语法正确但极不合理的 SQL 语句，并将其输入 SQLite 以查看其反应。通常会返回某种错误（例如“表不存在”）。有时，纯粹偶然间，SQL 语句也可能在语义上是正确的。在这种情况下，运行生成的准备语句以确保其给出合理结果。

### 4.1.1\. 使用 American Fuzzy Lop 模糊测试器的 SQL 模糊测试

出现几十年的模糊测试概念，但直到 2014 年 Michal Zalewski 发明了第一个实用的基于配置文件引导的模糊测试工具[American Fuzzy Lop](http://lcamtuf.coredump.cx/afl/)或简称“AFL”，模糊测试才成为发现错误的有效方法。与以往盲目生成随机输入的模糊测试工具不同，AFL 通过修改 C 编译器生成的汇编语言输出来对被测试程序进行插桩，并利用这些插桩来检测输入何时导致程序执行不同行为，如跟踪新的控制路径或循环次数。触发新行为的输入将被保留并进一步变异。通过这种方式，AFL 能够“发现”测试中程序的新行为，甚至是设计者未曾预料到的行为。

AFL 在 SQLite 中发现了许多奥秘 bug。大多数发现都是在 assert()语句中，条件在奇怪的情况下为假。但 AFL 也发现了一些导致 SQLite 崩溃的 bug，甚至还有一些 SQLite 计算错误结果的情况。

由于其过去的成功，AFL 从版本 3.8.10（2015-05-07）开始成为 SQLite 测试策略的标准部分，直到在版本 3.29.0（2019-07-10）中被更好的模糊器取代。

### 4.1.2\. Google OSS Fuzz

2016 年，谷歌的一支工程师团队启动了[OSS Fuzz](https://github.com/google/oss-fuzz)项目。OSS Fuzz 使用谷歌基础设施上运行的 AFL 风格引导的模糊器。该模糊器会自动下载参与项目的最新提交，对其进行模糊测试，并向开发人员发送电子邮件报告任何问题。当有修复提交时，模糊器会自动检测到并向开发人员发送确认邮件。

SQLite 是许多开源项目中由 OSS Fuzz 测试的项目之一。SQLite 存储库中的[test/ossfuzz.c](https://www.sqlite.org/src/file/test/ossfuzz.c)源文件是 SQLite 与 OSS fuzz 的接口。

OSS Fuzz 在 SQLite 中不再发现历史性 bug。但它仍在运行，并偶尔在新的开发提交中发现问题。例如：[[1]](https://www.sqlite.org/src/timeline?y=ci&c=c422afb507dc8757) [[2]](https://www.sqlite.org/src/timeline?y=ci&c=0a2eb949f8a759e5) [[3]](https://www.sqlite.org/src/timeline?y=ci&c=62f2235adf796c72)。

### 4.1.3\. dbsqlfuzz 和 jfuzz 模糊器

自 2018 年末开始，SQLite 开始使用名为“dbsqlfuzz”的专有模糊器进行模糊测试。Dbsqlfuzz 是使用 LLVM 的[libFuzzer](http://llvm.org/docs/LibFuzzer.html)框架构建的。

dbsqlfuzz 模糊器同时变异 SQL 输入和数据库文件。Dbsqlfuzz 在专门的输入文件上使用自定义的[结构感知变异器](https://github.com/google/fuzzing/blob/master/docs/structure-aware-fuzzing.md)，该文件定义了输入数据库和要对其运行的 SQL 文本。因为它同时变异输入数据库和输入 SQL，dbsqlfuzz 能够发现一些先前的模糊器错过的 SQLite 中的隐蔽故障。SQLite 开发人员始终保持 dbsqlfuzz 针对主干的运行，使用大约 16 个核心。每个 dbsqlfuzz 程序能够每秒评估约 400 个测试用例，这意味着每天检查大约 5 亿个案例。

dbsqlfuzz 模糊器在加固 SQLite 代码库防御恶意攻击方面非常成功。自从将 dbsqlfuzz 添加到 SQLite 内部测试套件以来，来自 OSSFuzz 等外部模糊器的 bug 报告几乎停止了。

请注意，dbsqlfuzz *不是*基于 Protobuf 的 SQLite 结构感知模糊测试工具，该工具被 Chromium 使用，并在[结构感知变异器文章](https://github.com/google/fuzzing/blob/master/docs/structure-aware-fuzzing.md#user-content-example-sqlite)中描述。这两个模糊测试工具之间没有任何联系，除了它们都基于[libFuzzer](http://llvm.org/docs/LibFuzzer.html)。SQLite 的 Protobuf 模糊器由 Google 的 Chromium 团队编写和维护，而 dbsqlfuzz 由原始 SQLite 开发人员编写和维护。对 SQLite 进行多个独立开发的模糊测试工具是件好事，因为这意味着更容易发现一些隐晦的问题。

在 2024 年 1 月底，第二个基于 libFuzzer 的工具"jfuzz"开始使用。Jfuzz 生成损坏的 JSONB 二进制大对象，并将它们馈送到 JSON SQL 函数中，以验证 JSON 函数能够安全高效地处理损坏的二进制输入。

### 4.1.4\. 其他第三方模糊测试工具

SQLite 似乎是第三方模糊测试的一个受欢迎目标。开发人员听说有许多人尝试对 SQLite 进行模糊测试，并偶尔收到独立模糊测试工具发现的 bug 报告。所有这些报告都会及时修复，因此产品得以改进，整个 SQLite 用户社区也因此受益。这种具有多个独立测试者的机制类似于[Linus 定律](https://en.wikipedia.org/wiki/Linus%27s_law)："足够多的眼睛，所有的 bug 都很浅显"。

特别值得一提的一个模糊测试研究人员是[Manuel Rigger](https://www.manuelrigger.at/)。大多数模糊测试工具只寻找断言错误、崩溃、未定义行为（UB）或其他易于检测的异常情况。另一方面，Rigger 博士的模糊测试工具能够找到 SQLite 计算出错误答案的情况。Rigger 发现了[许多这样的案例](https://www.sqlite.org/src/timeline?y=t&u=mrigger&n=all)。这些发现大多数是涉及类型转换和亲和性转换的角落案例，很多发现是针对未发布功能的。然而，他的发现仍然很重要，因为它们是真实的 bug，SQLite 开发人员很感激能够识别并修复潜在问题。

### 4.1.5\. fuzzcheck 测试工具

历史测试用例来自 AFL、OSS Fuzz 和 dbsqlfuzz，它们被收集在主 SQLite 源树中的一组数据库文件中，并由"fuzzcheck"实用程序重新运行，每当运行"make test"时。Fuzzcheck 只运行了数千个"有趣"的案例，而各种模糊测试工具多年来检查的案例数量则达到了数十亿。"有趣"的案例是表现出先前未见行为的案例。由模糊测试工具找到的实际错误始终包含在有趣的测试用例中，但大多数由 fuzzcheck 运行的案例实际上并非错误。

### 4.1.6\. 模糊测试与 100% MC/DC 测试之间的紧张关系

模糊测试和 100% MC/DC 测试 是相互对立的。也就是说，经过 100% MC/DC 测试的代码往往更容易受到模糊测试发现的问题的影响，而在模糊测试中表现良好的代码往往不会达到 100% MC/DC。这是因为 MC/DC 测试会阻止包含不可达分支的防御性代码，但是没有防御性代码，模糊器更可能找到导致问题的路径。MC/DC 测试似乎非常适合构建在正常使用时健壮的代码，而模糊测试则有助于构建能够抵御恶意攻击的代码。

当然，用户希望的是在正常使用中既健壮又能抵御恶意攻击的代码。SQLite 的开发人员致力于提供这样的代码。本节的目的仅仅是指出同时做到这两点是困难的。

在其历史的大部分时间里，SQLite 一直专注于 100% 的 MC/DC 测试。对模糊测试攻击的抗拒力直到 2014 年 AFL 的引入才成为一个关注点。有一段时间，模糊测试器在 SQLite 中发现了许多问题。近年来，SQLite 的测试策略已经演变，更加强调模糊测试。我们仍然保持对核心 SQLite 代码的 100% MC/DC 覆盖率，但现在大多数的测试 CPU 周期都用于模糊测试。

尽管模糊测试和 100% MC/DC 测试存在紧张关系，但它们并不完全相互对立。SQLite 测试套件确实进行了 100% MC/DC 测试，这意味着当模糊测试器发现问题时，这些问题可以迅速修复，而且几乎没有引入新错误的风险。

## 4.2\. 格式不正确的数据库文件

有许多测试用例验证了 SQLite 能够处理格式不正确的数据库文件。这些测试首先构建一个格式良好的数据库文件，然后通过某种方式改变文件中一个或多个字节来引入破坏。然后使用 SQLite 来读取数据库。在某些情况下，字节的更改发生在数据的中间。这会导致数据库内容改变，同时保持数据库的格式正确。在其他情况下，修改文件未使用的字节，这不会影响数据库的完整性。有趣的情况是当文件中定义数据库结构的字节发生改变时。格式不正确的数据库测试验证了 SQLite 能够发现文件格式错误，并使用 SQLITE_CORRUPT 返回代码报告这些错误，而不会溢出缓冲区、取消引用空指针或执行其他不良操作。

dbsqlfuzz 模糊器也非常出色地验证了 SQLite 对格式不正确的数据库文件的响应是否合理。

## 4.3\. 边界值测试

SQLite 定义了其操作的若干限制，如表中列的最大数量、SQL 语句的最大长度或整数的最大值。TCL 和 TH3 测试套件都包含大量测试用例，将 SQLite 推到其定义的极限并验证其对所有允许值的正确执行。额外的测试超出了定义的限制，并验证 SQLite 正确返回错误。源代码包含测试用例宏，以验证每个边界的两侧是否都已经过测试。

# 5\. 回归测试

每当有关 SQLite 的错误报告时，只有在向 TCL 或 TH3 测试套件添加了能够显示错误的新测试用例后，该错误才被认为已修复。多年来，这已导致数千个新的测试用例。这些回归测试确保过去修复的错误不会重新引入到 SQLite 的未来版本中。

# 6\. 自动资源泄漏检测

资源泄漏是指系统资源被分配但从未被释放。许多应用程序中最棘手的资源泄漏是内存泄漏 - 使用 malloc()分配内存但未使用 free()释放。但其他类型的资源也可能泄漏：文件描述符、线程、互斥锁等。

TCL 和 TH3 测试框架自动跟踪系统资源，并在每次测试运行时报告资源泄漏。无需特殊配置或设置。测试框架特别关注内存泄漏。如果更改导致内存泄漏，测试框架将迅速识别出来。SQLite 设计为永不泄漏内存，即使发生诸如 OOM 错误或磁盘 I/O 错误等异常情况。测试框架积极地执行此操作。

# 7\. 测试覆盖

SQLite 核心，包括 unix VFS，在其默认配置下在 TH3 下具有 100%的分支测试覆盖率，由[gcov](http://gcc.gnu.org/onlinedocs/gcc/Gcov.html)测量。例如 FTS3 和 RTree 等扩展被排除在此分析之外。

## 7.1\. 语句与分支覆盖

有许多方法可以衡量测试覆盖率。最流行的度量标准是“语句覆盖率”。当你听到有人说他们的程序具有“XX%的测试覆盖率”而没有进一步解释时，他们通常指的是语句覆盖率。语句覆盖率衡量了测试套件至少一次执行的代码行的百分比。

分支覆盖率比语句覆盖率更严格。分支覆盖率衡量了在两个方向上至少评估一次的机器码分支指令的数量。

要说明语句覆盖率与分支覆盖率的区别，请考虑以下假设的 C 代码行：

```sql
if( a>b && c!=25 ){ d++; }

```

这样一行 C 代码可能会生成十几条单独的机器码指令。如果这些指令中的任何一条被评估，我们就说该语句已经被测试过了。例如，可能条件表达式总是假，而“d”变量从未递增。即便如此，语句覆盖率也会将这行代码视为已经被测试过。

分支覆盖率更为严格。在分支覆盖率下，每个测试和语句中的每个子块都被单独考虑。为了在上述例子中实现 100% 分支覆盖率，至少需要三个测试用例：

+   a<=b

+   a>b && c==25

+   a>b && c!=25

上述任何一个测试用例都可以提供 100% 语句覆盖率，但需要所有三个用例才能实现 100% 分支覆盖率。一般来说，100% 分支覆盖率意味着 100% 语句覆盖率，但反之则不成立。再次强调，SQLite 的 TH3 测试工具提供了更强的测试覆盖形式 - 100% 分支测试覆盖率。

## 7.2\. 防御性代码的覆盖测试

一个良好编写的 C 程序通常会包含一些防御性条件，这些条件在实践中总是真或总是假。这导致了一个编程困境：是删除防御性代码以获得 100% 分支覆盖率呢？

在 SQLite 中，对于前面的问题答案是“否”。为了测试目的，SQLite 源代码定义了名为 ALWAYS() 和 NEVER() 的宏。ALWAYS() 宏用于包围预期总是评估为真的条件，而 NEVER() 用于包围总是评估为假的条件。这些宏作为注释，表明这些条件是防御性代码。在发布构建中，这些宏是直通的：

```sql
#define ALWAYS(X)  (X)
#define NEVER(X)   (X)

```

在大多数测试中，如果这些宏的参数未具有预期的真值，它们将抛出一个断言故障。这能迅速提醒开发者发现设计上的错误假设。

```sql
#define ALWAYS(X)  ((X)?1:assert(0),0)
#define NEVER(X)   ((X)?assert(0),1:0)

```

在测量测试覆盖率时，这些宏被定义为常量真值，以便它们不生成汇编语言分支指令，因此在计算分支覆盖率时不起作用：

```sql
#define ALWAYS(X)  (1)
#define NEVER(X)   (0)

```

测试套件设计为运行三次，每次分别对应上述的 ALWAYS() 和 NEVER() 定义。所有三次测试运行应该得到完全相同的结果。有一个运行时测试使用 sqlite3_test_control(SQLITE_TESTCTRL_ALWAYS, ...) 接口，用于验证这些宏是否正确设置为第一种形式（直通形式）以供部署使用。

## 7.3\. 强制覆盖边界值和布尔向量测试

另一个与测试覆盖率测量一起使用的宏是 `testcase()` 宏。其参数是我们希望有测试用例能评估为真和为假的条件。在非覆盖率构建中（即发布构建中），`testcase()` 宏是一个空操作：

```sql
#define testcase(X)

```

但在覆盖率测量构建中，`testcase()`宏生成评估其参数中的条件表达式的代码。然后在分析期间，会检查以确保存在测试评估条件既为真又为假。例如，`testcase()`宏用于帮助验证边界值是否被测试。例如：

```sql
testcase( a==b );
testcase( a==b+1 );
if( a>b && c!=25 ){ d++; }

```

测试用例宏在`switch`语句的两个或多个情况进入同一段代码块时也会使用，以确保代码对所有情况都被执行：

```sql
switch( op ){
  case OP_Add:
  case OP_Subtract: {
    testcase( op==OP_Add );
    testcase( op==OP_Subtract );
    /* ... */
    break;
  }
  /* ... */
}

```

对于位掩码测试，`testcase()`宏用于验证位掩码的每一位对结果的影响。例如，在以下代码块中，如果掩码包含表示打开`MAIN_DB`或`TEMP_DB`的两个位之一，则条件为真。在`if`语句之前的`testcase()`宏验证了两种情况都被测试：

```sql
testcase( mask & SQLITE_OPEN_MAIN_DB );
testcase( mask & SQLITE_OPEN_TEMP_DB );
if( (mask & (SQLITE_OPEN_MAIN_DB|SQLITE_OPEN_TEMP_DB))!=0 ){ ... }

```

SQLite 源代码包含 1184 个`testcase()`宏的使用。

## 7.4\. 分支覆盖与 MC/DC

上述介绍了两种测量测试覆盖率的方法：“语句”和“分支”覆盖率。除了这两种之外，还有许多其他的测试覆盖率指标。另一个流行的指标是“修改条件/决策覆盖”（MC/DC）。[维基百科](http://en.wikipedia.org/wiki/Modified_Condition/Decision_Coverage)对 MC/DC 的定义如下：

+   每个决策尝试每种可能的结果。

+   每个决策中的每个条件都采用每种可能的结果。

+   每个进入和退出点都被调用。

+   决策中的每个条件都独立影响决策的结果。

在 C 编程语言中，`&&`和`||`是“短路”操作符，MC/DC 和分支覆盖几乎是一样的。主要区别在于布尔向量测试。可以测试位向量中的多个位中的任意一位，并且即使 MC/DC 的第二个元素——每个决策中的每个条件都采用每种可能的结果的要求可能未被满足，也可以获得 100%的分支测试覆盖。

SQLite 还使用如前节所述的`testcase()`宏来确保位向量决策中的每个条件都采用每种可能的结果。通过这种方式，SQLite 不仅实现了 100%的分支覆盖，还实现了 100%的 MC/DC。

## 7.5\. 测量分支覆盖率

SQLite 当前使用[gcov](https://gcc.gnu.org/onlinedocs/gcc/Gcov.html)测量分支覆盖率，使用“-b”选项。首先，使用选项“-g -fprofile-arcs -ftest-coverage”编译测试程序，然后运行测试程序。然后运行“gcov -b”生成覆盖率报告。覆盖率报告很冗长且不便于阅读，因此使用一些简单的脚本处理 gcov 生成的报告，使其更符合人类阅读习惯。当然，整个过程都是使用脚本自动化的。

请注意，使用 gcov 运行 SQLite 并不是对 SQLite 的测试 —— 它是对测试套件的测试。 gcov 运行不测试 SQLite，因为 -fprofile-args 和 -ftest-coverage 选项会导致编译器生成不同的代码。 gcov 运行仅仅验证测试套件是否提供了 100% 的分支测试覆盖率。 gcov 运行是测试测试的测试 - 一个元测试。

在运行 gcov 验证了 100% 的分支测试覆盖率之后，然后使用交付编译器选项（而不是特殊的 -fprofile-arcs 和 -ftest-coverage 选项）重新编译测试程序，并重新运行测试程序。 这第二次运行才是 SQLite 的实际测试。

验证 gcov 测试运行和第二次真实测试运行的输出相同非常重要。 任何输出上的差异都表明 SQLite 代码中使用了未定义或不确定的行为（从而是一个 bug），或者编译器存在 bug。 请注意，SQLite 在过去的十年中遇到了 GCC、Clang 和 MSVC 中的每个编译器的 bug。 编译器 bug 虽然罕见，但确实会发生，这就是为什么在交付配置下测试代码如此重要的原因。

## 7.6\. 突变测试

使用 gcov（或类似工具）显示每个分支指令在两个方向上都至少执行一次是测试套件质量的一个良好衡量标准。 但更好的是要显示每个分支指令对输出都产生影响。 换句话说，我们希望不仅显示每个分支指令既跳转又顺序执行，还要显示每个分支正在执行有用的工作，并且测试套件能够检测和验证这些工作。 当发现一个不影响输出的分支时，这表明可以删除与该分支相关联的代码（减少库的大小，或许使其运行更快），或者测试套件不足以测试该分支实现的功能。

SQLite 通过 [突变测试](https://zh.wikipedia.org/wiki/%E7%AA%81%E5%8F%98%E6%B5%8B%E8%AF%95) 力求验证每个分支指令的差异性。 一个脚本 首先将 SQLite 源代码编译成汇编语言（例如使用 gcc 的 -S 选项）。 然后，该脚本逐步遍历生成的汇编语言，并逐个将每个分支指令更改为无条件跳转或空操作，编译结果，并验证测试套件是否捕获到了这种变异。

不幸的是，SQLite 包含许多分支指令，这些指令帮助代码运行得更快，但并不改变输出。 这样的分支在突变测试中会产生假阳性。 例如，考虑以下用于加速表名查找的 [哈希函数](https://www.sqlite.org/src/artifact/55b5fb474?ln=55-62)：

```sql
55  static unsigned int strHash(const char *z){
56    unsigned int h = 0;
57    unsigned char c;
58    while( (c = (unsigned char)*z++)!=0 ){     /*OPTIMIZATION-IF-TRUE*/
59      h = (h<<3) ^ h ^ sqlite3UpperToLower[c];
60    }
61    return h;
62  }

```

如果 58 行实现“c!=0”测试的分支指令被改为空操作，那么 while 循环将永远循环下去，并且测试套件将因超时而失败。但如果该分支改为无条件跳转，则哈希函数将始终返回 0。问题在于 0 是有效的哈希值。即使哈希函数始终返回 0，在某种意义上 SQLite 仍然可以得到正确的答案。表名哈希表退化为链表，因此在解析 SQL 语句时进行的表名查找可能会慢一些，但最终结果将是一样的。

为了解决这个问题，在 SQLite 源代码中插入形如"`/*OPTIMIZATION-IF-TRUE*/`"和"`/*OPTIMIZATION-IF-FALSE*/`"的注释，告诉变异测试脚本忽略一些分支指令。

## 7.7\. 全覆盖测试的经验

SQLite 的开发人员发现全覆盖测试是一种非常有效的方法，用于定位和预防错误。因为 SQLite 核心代码中的每个分支指令都由测试用例覆盖，开发人员可以确信在代码的某个部分进行的更改不会在代码的其他部分产生意外后果。近年来为 SQLite 添加的许多新功能和性能改进如果没有全覆盖测试的支持是不可能的。

维护 100%的 MC/DC 测试工作繁琐且耗时。对于典型应用程序来说，维护全覆盖测试的努力程度可能不划算。然而，我们认为像 SQLite 这样的非常广泛部署的基础设施库，特别是对于数据库库而言，完全覆盖测试是合理的，因为其本质上“记住”了过去的错误。

# 8\. 动态分析

动态分析指的是在 SQLite 代码运行时进行的内部和外部检查。动态分析已被证明在维护 SQLite 代码质量方面非常有帮助。

## 8.1\. Assert

SQLite 核心包含 6754 个`assert()`语句，用于验证函数前置条件、后置条件和循环不变式。Assert()是 ANSI-C 的标准部分的宏。参数是一个布尔值，假定始终为真。如果断言为假，程序将打印错误消息并停止。

Assert()宏在编译时通过定义 NDEBUG 宏来禁用。在大多数系统中，assert 语句默认启用。但在 SQLite 中，assert 语句非常多，并且位于性能关键的位置，因此当启用 assert 时，数据库引擎的运行速度会慢大约三倍。因此，SQLite 的默认（生产）构建禁用 assert 语句。只有在定义了 SQLITE_DEBUG 预处理宏的情况下，assert 语句才会启用。

查看 SQLite 中 assert 的使用文档以获取有关 SQLite 如何使用 assert()的其他信息。

## 8.2\. Valgrind

[Valgrind](http://valgrind.org/)也许是世界上最令人惊奇和有用的开发者工具。 Valgrind 是一个模拟器 - 它模拟运行 Linux 二进制文件的 x86 架构。 （除 Linux 之外的平台上的 Valgrind 端口正在开发中，但截至本文撰写时，Valgrind 仅在 Linux 上可靠运行，SQLite 开发者认为 Linux 应该是所有软件开发的首选平台。）当 Valgrind 运行 Linux 二进制文件时，它寻找各种有趣的错误，例如数组溢出，从未初始化的内存读取，堆栈溢出，内存泄漏等等。 Valgrind 找到的问题往往可以轻易地溜过所有其他针对 SQLite 运行的测试。 而且，当 Valgrind 找到错误时，它可以将开发人员直接转到符号调试器，准确地定位错误发生的地方，以便快速修复。

因为它是一个模拟器，运行在 Valgrind 上的二进制比在本地硬件上运行要慢。 （从第一次近似来看，一个在工作站上通过 Valgrind 运行的应用程序将表现得与在智能手机上本地运行相似。）因此，通过 Valgrind 运行完整的 SQLite 测试套件是不切实际的。 然而，非常快速的测试和 TH3 测试的覆盖范围在每次发布之前都会通过 Valgrind 运行。

## 8.3\. Memsys2

SQLite 包含一个可插拔的内存分配子系统。 默认实现使用系统 malloc（）和 free（）。 但是，如果使用 SQLITE_MEMDEBUG 编译 SQLite，则会插入一个替代的内存分配包装器（memsys2），该包装器在运行时查找内存分配错误。 memsys2 包装器当然检查内存泄漏，但也查找缓冲区溢出，未初始化内存的使用以及尝试在释放后使用内存。 Valgrind 也执行这些相同的检查（实际上，Valgrind 执行得更好），但 memsys2 的优势在于比 Valgrind 快得多，这意味着可以更频繁地进行检查，并进行更长时间的测试。

## 8.4\. 互斥断言

SQLite 包含一个可插拔的互斥子系统。 根据编译时选项，默认的互斥系统包含接口 sqlite3_mutex_held（）和 sqlite3_mutex_notheld（），用于检测调用线程是否持有特定的互斥体。 在 SQLite 的 assert（）语句中广泛使用这两个接口，以验证互斥体在所有正确的时刻被持有和释放，以便仔细检查 SQLite 在多线程应用程序中是否正确工作。

## 8.5\. 日志测试

SQLite 为确保事务在系统崩溃和断电时是原子的而做的一项工作是，在修改数据库之前将所有更改写入回滚日志文件。TCL 测试工具包含一个备用的 OS 后端实现，帮助验证这一操作是否正确进行。"journal-test VFS"监视数据库文件与回滚日志之间的所有磁盘 I/O 流量，检查确保没有任何写入数据库文件的内容未先写入并同步到回滚日志。如果发现任何不一致，将引发断言错误。

日志测试是在崩溃测试之上的一种额外的双重检查，确保 SQLite 事务在系统崩溃和断电时是原子的。

## 8.6. 未定义行为检查

在 C 编程语言中，编写具有"未定义"或"实现定义"行为的代码非常容易。这意味着代码在开发过程中可能有效，但在不同系统或使用不同编译器选项重新编译时可能会得到不同的答案。ANSI C 中未定义和实现定义行为的例子包括：

+   有符号整数溢出。（有符号整数溢出不一定会环绕，正如大多数人所期望的那样。）

+   将 N 位整数向左或向右移动超过 N 位。

+   移动一个负数量。

+   移动一个负数。

+   在重叠缓冲区上使用 memcpy()函数。

+   函数参数的求值顺序。

+   "char"变量是有符号还是无符号。

+   等等……

由于未定义和实现定义的行为是不可移植的，并且很容易导致错误答案，SQLite 非常努力避免它。例如，在 SQL 语句中将两个整数列值相加时，SQLite 不仅仅使用 C 语言的"+"运算符将它们简单相加。相反，它首先检查确保加法不会溢出，如果会溢出，则使用浮点数进行加法运算。

为了确保 SQLite 不使用未定义或实现定义的行为，测试套件会使用带有检测未定义行为的仪器化构建重新运行。例如，测试套件使用 GCC 的"-ftrapv"选项运行。然后再次使用 Clang 的"-fsanitize=undefined"选项运行。然后再使用 MSVC 的"/RTC1"选项运行。然后使用"-funsigned-char"和"-fsigned-char"选项再次运行测试套件，以确保实现差异也无关紧要。测试还会在 32 位和 64 位系统上以及大端和小端系统上，使用各种 CPU 架构进行重复。此外，测试套件还增加了许多故意设计来引发未定义行为的测试用例。例如："**SELECT -1*(-9223372036854775808);**"。

# 9. 禁用优化测试

sqlite3_test_control(SQLITE_TESTCTRL_OPTIMIZATIONS, ...) 接口允许在运行时禁用选定的 SQL 语句优化。SQLite 应该在启用和禁用优化时始终生成完全相同的答案；只是在启用优化时答案会更快到达。因此，在生产环境中，通常保持优化开启（默认设置）。

对 SQLite 使用的一种验证技术是运行整个测试套件两次，一次保持优化开启，另一次关闭优化，并验证两次都获得相同的输出。这表明优化不会引入错误。

并非所有测试用例都可以通过这种方式处理。某些测试用例检查优化是否确实通过计算磁盘访问次数、排序操作、全扫描步骤或其他处理步骤来减少计算量。当禁用优化时，这些测试用例会出现失败。但大多数测试用例只是检查是否获得了正确答案，所有这些情况都可以在启用和禁用优化时成功运行，以表明优化不会导致故障。

# 10\. Checklists

SQLite 开发人员使用在线清单来协调测试活动，并在每次 SQLite 发布之前验证所有测试是否通过。[过去的检查清单](https://www.sqlite.org/checklists/index.html)被保留作为历史参考。（对于匿名互联网查看者，检查清单是只读的，但开发人员可以登录并在其网页浏览器中更新清单项。）SQLite 测试和其他开发活动中使用清单的灵感来自于 *[《清单宣言》](http://atulgawande.com/book/the-checklist-manifesto/)* 。

最新的检查清单包含大约 200 项，每个发布版本都会逐项进行验证。有些检查项只需几秒钟即可完成并标记。其他涉及运行数小时的测试套件。

发布清单并非自动化：开发人员手动运行清单中的每一项。我们发现保持人为参与很重要。有时即使测试本身通过，运行清单项时仍可能发现问题。在最高层级审查测试输出并持续询问“这真的正确吗？”是很重要的。

发布清单在不断发展。随着发现新问题或潜在问题，会添加新的清单项，以确保这些问题不会出现在后续发布中。发布清单已被证明是确保在发布过程中没有遗漏任何事项的宝贵工具。

# 11\. 静态分析

静态分析意味着在编译时分析源代码以检查正确性。静态分析包括编译器的警告信息以及更深入的分析引擎，如[Clang Static Analyzer](http://clang-analyzer.llvm.org/)。在 Linux 和 Mac 上，SQLite 在 GCC 和 Clang 使用 -Wall 和 -Wextra 标志编译时没有警告，在 Windows 上使用 MSVC 也是如此。Clang Static Analyzer 工具 "scan-build" 也没有生成有效警告（尽管最近的 clang 版本似乎生成了很多误报）。尽管如此，其他静态分析器可能会生成一些警告。建议用户不要过于担心这些警告，而是放心于上述 SQLite 的强大测试工作。

静态分析在发现 SQLite 中的错误方面并不那么有帮助。静态分析确实在 SQLite 中发现了一些错误，但那些属于例外。与通过静态分析找到的错误相比，更多的错误是在尝试消除警告以使 SQLite 编译通过时引入的。

# 12\. 总结

SQLite 是开源的。这让很多人误以为它没有商业软件那样经过充分测试，可能不可靠。但这种印象是错误的。SQLite 在实际应用中展现出非常高的可靠性和极低的缺陷率，尤其是考虑到它的快速发展速度。SQLite 的质量部分得益于精心设计和实现的代码，但广泛的测试也在维护和提升 SQLite 的质量中发挥着至关重要的作用。本文总结了每个 SQLite 发布版本都经历的测试流程，希望能够增强 SQLite 在关键任务应用中的可信度。
