# 1\. 通过恶意线程或进程覆盖文件

> 原文：[`sqlite.com/howtocorrupt.html`](https://sqlite.com/howtocorrupt.html)

## 概述

SQLite 数据库对损坏具有很高的抵抗力。如果应用程序崩溃，操作系统崩溃，甚至在事务进行中发生了断电，部分写入的事务应该在下次访问数据库文件时自动回滚。恢复过程完全自动化，不需要用户或应用程序采取任何操作。

虽然 SQLite 对数据库损坏有所抵抗，但并非完全免疫。本文描述了 SQLite 数据库可能遭到损坏的各种方式。

SQLite 数据库文件是普通的磁盘文件。这意味着任何进程都可以打开文件并用垃圾覆盖它。SQLite 库无法防范此类行为。

## 1.1\. 在关闭文件描述符后继续使用它

我们已经看到多种情况，其中一个文件描述符在文件上打开，然后该文件描述符被关闭并重新打开在一个 SQLite 数据库上。后来，一些其他线程继续向旧的文件描述符写入，没有意识到原始文件已经关闭。但因为文件描述符已被 SQLite 重新打开，本来应该进入原始文件的信息最终覆盖了 SQLite 数据库的部分内容，导致数据库损坏。

这种情况的一个例子发生在 2013-08-30 关于[Fossil DVCS 的规范库](http://www.fossil-scm.org/)。在那次事件中，文件描述符 2（标准错误）在 sqlite3_open_v2()之前被错误地关闭（我们怀疑是由[stunnel](http://www.stunnel.org/)执行），因此用于存储库数据库文件的文件描述符为 2。后来，一个应用程序错误导致 assert()语句通过调用 write(2,...)发出错误消息。但由于文件描述符 2 现在连接到数据库文件，错误消息覆盖了数据库的一部分。为了防止这种问题，SQLite 版本 3.8.1（2013-10-17）及更高版本拒绝使用低编号的文件描述符作为数据库文件。（有关更多信息，请参阅 SQLITE_MINIMUM_FILE_DESCRIPTOR。）

由于使用已关闭的文件描述符导致的腐败的另一个例子，[Facebook 工程师报道](https://code.facebook.com/posts/313033472212144/debugging-file-corruption-on-ios/)于 2014-08-12 在一篇博客中。

另一个这种错误的例子发生在 2019-07-11 针对[Fossil](https://fossil-scm.org/)。一个文件描述符用于调试输出，但随后被 SQLite 关闭并重新打开。但调试逻辑继续写入原始文件描述符。参见[论坛讨论](https://fossil-scm.org/forum/forumpost/c51b9a1169)以获取错误报告和修复链接。

## 1.2\. 在事务活动时备份或还原

在后台运行自动备份的系统可能会尝试在 SQLite 数据库文件处于事务中时创建备份副本。然后备份副本可能包含一些旧的和一些新的内容，从而变得损坏。

最可靠地备份 SQLite 数据库的方法是利用 SQLite 库的备份 API。如果无法使用该 API，则可以安全地复制 SQLite 数据库文件，只要没有任何进程正在进行事务。如果以前的事务失败，则重要的是任何回滚日志（`*-journal` 文件）或写前日志（`*-wal` 文件）都要与数据库文件一起复制。

## 1.3\. 删除热日志

SQLite 通常将所有内容存储在单个磁盘文件中。但是，在执行事务时，用于在崩溃或断电后恢复数据库的信息存储在辅助日志文件中。这些日志文件被描述为"热"。日志文件与原始数据库文件具有相同的名称，只是增加了 `-journal` 或 `-wal` 后缀。

SQLite 必须在崩溃或断电后看到日志文件才能恢复。如果热日志文件在崩溃或断电后被移动、删除或重命名，则自动恢复将无法工作，数据库可能会损坏。

另一个问题的表现形式是由于不一致使用 8+3 文件名造成的数据库损坏。

## 1.4\. 错配数据库文件和热日志

前面的例子是一个更普遍问题的特定案例：SQLite 数据库的状态由数据库文件和日志文件控制。在静止状态下，不存在日志文件，只有数据库文件重要。但如果存在日志文件，则必须与数据库文件一起保持以避免损坏。以下操作都可能导致损坏：

+   交换两个不同数据库之间的日志文件。

+   用不同的日志文件覆盖日志文件。

+   将一个数据库的日志文件移动到另一个数据库中。

+   复制数据库文件时不复制其日志。

+   在不删除原始数据库相关的任何热日志的情况下，用另一个数据库文件覆盖数据库文件。

# 2\. 文件锁定问题

SQLite 使用文件锁在数据库文件和预写式日志（write-ahead log）或 WAL 文件上，以协调并发进程之间的访问。没有协调，两个线程或进程可能同时尝试对数据库文件进行不兼容的更改，导致数据库损坏。

## 2.1\. 具有损坏或缺失锁定实现的文件系统

SQLite 依赖底层文件系统来执行锁定，正如文档所述。但是一些文件系统中存在其锁定逻辑中的错误，使得锁定不总是按照广告中的方式行事。这对网络文件系统和特别是 NFS 尤其真实。如果在存在锁定原语包含错误的文件系统上使用 SQLite，并且两个或更多线程或进程尝试同时访问同一数据库，则可能导致数据库损坏。

## 2.2\. 被关闭操作的独立线程取消的 POSIX 咨询锁定

SQLite 在 Unix 平台上使用的默认锁定机制是 POSIX 咨询锁定。不幸的是，POSIX 咨询锁定存在设计怪异之处，容易被误用和失败。特别是，同一进程中具有持有 POSIX 咨询锁定的文件描述符的任何线程可以使用另一个文件描述符覆盖该锁定。一个特别阴险的问题是，`close()` 系统调用会取消进程中所有线程和所有文件描述符对同一文件的所有 POSIX 咨询锁定。

所以，举例来说，假设一个多线程进程有两个或更多个线程，每个线程都有独立的 SQLite 数据库连接指向同一个数据库文件。然后第三个线程出现，并且想要自己读取那个同一个数据库文件的内容，而不使用 SQLite 库。第三个线程执行了`open()`，`read()`和`close()`操作。人们可能会认为这是无害的。但是，`close()`系统调用导致了所有其他线程持有的数据库锁被释放。这些其他线程无法知道它们的锁刚刚被清除（POSIX 没有提供任何机制来确定这一点），因此它们继续运行，假设它们的锁仍然有效。这可能导致两个或更多个线程或进程同时尝试写入数据库，导致数据库损坏。

请注意，使用 SQLite 库时，两个或更多个线程同时访问同一个 SQLite 数据库文件是完全安全的。SQLite 的 Unix 驱动程序了解 POSIX 建议锁定的怪癖并解决了这些问题。这个问题只在一个线程试图绕过 SQLite 库直接读取数据库文件时出现。

### 2.2.1\. 同一应用程序中链接的多个 SQLite 副本

正如前面段落所指出的，SQLite 采取措施来解决 POSIX 建议锁定的问题。其中一个解决方法是维护一个全局列表（受互斥锁保护）来管理已打开的 SQLite 数据库文件。但是，如果将多个 SQLite 副本链接到同一个应用程序中，则会有多个此全局列表的实例。使用一个 SQLite 库打开的数据库连接将不知道使用另一个副本打开的数据库连接，并且将无法解决 POSIX 建议锁定的问题。在一个连接上执行`close()`操作可能会无意中清除另一个数据库连接上的锁定，导致数据库损坏。

上述场景听起来离谱。但 SQLite 的开发人员至少意识到有一个商业产品正是以这种 bug 发布的。供应商向 SQLite 的开发人员寻求帮助，以追踪一些在 Linux 和 Mac 上偶发的数据库损坏问题。问题最终被追溯到应用程序链接了两个独立的 SQLite 副本。解决方案是修改应用程序的构建过程，改为只链接一个 SQLite 副本，而不是两个。

## 2.3\. 两个进程使用不同的锁定协议

SQLite 在 Unix 平台上使用的默认锁定机制是 POSIX 咨询锁定，但也有其他选择。通过使用 sqlite3_open_v2() 接口选择替代的 sqlite3_vfs，应用程序可以利用其他可能更适合某些文件系统的锁定协议。例如，在需要在不支持 POSIX 咨询锁定的 NFS 文件系统上运行的应用程序中，可能会选择使用点文件锁定。

所有连接到同一数据库文件的连接必须使用相同的锁定协议是很重要的。如果一个应用程序使用 POSIX 咨询锁定，而另一个应用程序使用点文件锁定，那么这两个应用程序将无法看到彼此的锁定，并且无法协调数据库访问，可能导致数据库损坏。

## 2.4\. 在使用中删除或重命名数据库文件

如果两个进程同时打开同一个数据库文件，并且其中一个进程关闭了连接、取消了文件的链接，然后用同样的名称创建了一个新的数据库文件并重新打开它，那么这两个进程将会连接到同名但不同的数据库文件。（注意，这种情况只可能发生在允许在文件仍然打开的情况下取消链接的类 Unix 系统上，Windows 不支持这种操作。）由于回滚日志和 WAL 文件是基于数据库文件名称命名的，这两个不同的数据库文件将共享同一个回滚日志或 WAL 文件。其中一个数据库的回滚或恢复可能会使用另一个数据库的内容，导致数据损坏。如果在打开的情况下重命名数据库文件并创建了一个旧名称的新文件，也会出现类似的问题。

换句话说，取消链接或重命名打开的数据库文件会导致未定义且可能不良的行为。

从 SQLite 版本 3.7.17（2013-05-20）开始，Unix 操作系统接口将会向错误日志发送 SQLITE_WARNING 消息，如果一个数据库文件在仍在使用时被取消链接。

## 2.5\. 同一个文件的多个链接

如果一个单一的数据库文件有多个链接（硬链接或软链接），那就意味着这个文件有多个名称。如果两个或更多进程使用不同的名称打开数据库，它们将使用不同的回滚日志和 WAL 文件。这意味着如果一个进程崩溃，另一个进程将无法恢复正在进行的事务，因为它会在错误的位置查找适当的日志。

换句话说，打开和使用具有两个或更多名称的数据库文件会导致未定义且可能不良的行为。

从 SQLite version 3.7.17（2013-05-20）开始，unix 操作系统接口将会向 错误日志 发送 SQLITE_WARNING 消息，如果数据库文件具有多个硬链接。

从 SQLite version 3.10.0（2016-01-06）开始，unix 操作系统接口将尝试通过其规范名称解析符号链接并打开数据库文件。在版本 3.10.0 之前，通过符号链接打开数据库文件类似于打开具有多个硬链接的数据库文件，并导致未定义的行为。

## 2.6\. 在 fork() 过程中传递打开的数据库连接

不要在打开 SQLite 数据库连接后进行 fork() 操作，然后尝试在子进程中使用该数据库连接。会导致各种锁定问题，并且很容易导致数据库损坏。SQLite 不设计支持这种行为。任何在子进程中使用的数据库连接必须在子进程中打开，而不是从父进程继承的。

如果连接是在父进程中打开的，请不要在子进程中甚至调用 sqlite3_close() 关闭数据库连接。关闭底层文件描述符是安全的，但是 sqlite3_close() 接口可能会调用清理活动，从而删除父进程下的内容，导致错误甚至数据库损坏。

# 3\. 同步失败

为了保证数据库文件始终一致，SQLite 会偶尔请求操作系统将所有待定写入刷新到持久存储，然后等待刷新完成。在 unix 下，这是通过 `fsync()` 系统调用实现的，在 Windows 下是通过 `FlushFileBuffers()`。我们称这种待定写入的刷新为“同步”。

实际上，如果一个人只关心原子性和一致性写入，并愿意放弃持久性写入，那么同步操作就不需要等到内容完全存储在持久介质上。相反，同步操作可以被视为 I/O 屏障。只要在同步之前发生的所有写入在同步之后发生的任何写入之前完成，就不会发生数据库损坏。如果同步操作作为 I/O 屏障而不是真正的同步运行，那么断电或系统崩溃可能导致一个或多个之前已提交的事务回滚（违反了"ACID"的"持久"属性），但数据库至少会继续保持一致性，这才是大多数人关心的。 

## 3.1\. 不支持同步请求的磁盘驱动器

不幸的是，大多数消费级大容量存储设备关于同步是虚假的。磁盘驱动器会报告内容已安全存储在持久介质上，只要达到磁道缓冲区并在实际写入氧化物之前。这使得磁盘驱动器看起来运行更快（对制造商至关重要，以便他们可以在商业杂志中展示良好的基准数据）。公平地说，谎言通常不会造成伤害，只要在实际写入氧化物之前没有断电或硬重置。但是，如果发生断电或硬重置，并且导致在同步之后写入的内容到达氧化物时，之前在磁道缓冲区中写入的内容仍然存在，那么数据库损坏就会发生。

USB 闪存盘似乎在同步请求方面特别具有欺诈性。可以通过将大型事务提交到 USB 内存棒上的 SQLite 数据库来轻松看到这一点。COMMIT 命令会相对较快地返回，表示内存棒已告诉操作系统，而操作系统已告诉 SQLite 所有内容都已安全存储在持久存储中，然而，内存棒尾部的 LED 灯会继续闪烁几秒钟。在 LED 仍在闪烁时拔出内存棒通常会导致数据库损坏。

请注意，SQLite 必须相信操作系统和硬件关于同步请求状态的信息。SQLite 没有办法检测操作系统或硬件是否在撒谎，并且写入可能以任意顺序发生。然而，与默认回滚日志模式相比，在 WAL 模式中，SQLite 对乱序写入更具宽容性。在 WAL 模式中，仅在 checkpoint 操作期间发生同步失败时才会导致数据库损坏。在 COMMIT 期间发生同步失败可能会导致耐久性丧失，但不会导致损坏的数据库文件。因此，防止因同步操作失败而导致数据库损坏的一种防线是将 SQLite 设置为 WAL 模式，并尽可能少地进行检查点操作。

## 3.2\. 使用 PRAGMAs 禁用同步

SQLite 执行的同步操作以帮助确保完整性可以在运行时使用 synchronous pragma 进行禁用。通过设置 PRAGMA synchronous=OFF，所有同步操作都将被省略。这使得 SQLite 似乎运行更快，但也允许操作系统自由重新排序写入，如果在所有内容到达持久存储之前发生断电或硬重置，这可能导致数据库损坏。

为了最大限度地提高可靠性并防止数据库损坏，SQLite 应始终以其默认的同步设置 FULL 模式运行。

# 4\. 磁盘驱动器和闪存存储器故障

如果由于磁盘驱动器或闪存存储器故障而导致文件内容发生变化，SQLite 数据库可能会损坏。这种情况非常罕见，但是磁盘偶尔会在一个扇区的中间翻转一个位。

## 4.1\. 非供电安全的闪存控制器

我们被告知，在一些闪存控制器中，磨损平衡逻辑可能会在写入过程中断电时造成随机的文件系统损坏。例如，这可能表现为文件中间的随机更改，而当时甚至没有打开这个文件。举例来说，当设备正在将内容写入闪存中的 MP3 文件时断电，这可能导致一个 SQLite 数据库被损坏，尽管在断电时根本没有使用该数据库。

## 4.2\. 伪装容量的 USB 闪存

目前市面上流通着许多虚假的 USB 闪存，声称具有很高的容量（例如：8GB），但实际上只能存储较小的容量（例如：1GB）。尝试在这些设备上写入数据通常会导致非相关文件被覆盖。因此，任何使用虚假闪存设备都很容易导致数据库损坏。例如，通过搜索“虚假容量 USB”等关键词可以找到大量关于这个问题的令人不安的信息。

# 5\. 内存损坏

SQLite 是一个运行在与其服务的应用程序相同地址空间的 C 库。这意味着应用程序中的偏移指针、缓冲区溢出、堆损坏或其他故障可能会损害 SQLite 的内部数据结构，并最终导致数据库文件损坏。通常这类问题会在数据库损坏之前就出现段错误，但确实有一些实例是因为应用程序代码错误导致 SQLite 表现出微妙的故障，最终导致数据库文件损坏而不是崩溃。

当使用内存映射 I/O 时，内存损坏问题变得更加严重。当数据库文件的全部或部分映射到应用程序的地址空间时，任何覆盖该映射空间的偏移指针都会立即损坏数据库文件，而不需要应用程序执行后续的 write() 系统调用。

# 6\. 其他操作系统问题

有时操作系统会表现出非标准的行为，这可能导致问题。这种非标准行为有时是故意的，有时是实现上的错误。但无论如何，如果操作系统的行为与 SQLite 预期的不同，就存在数据库损坏的可能性。

## 6.1\. Linux 线程

一些旧版本的 Linux 使用 LinuxThreads 库来支持线程。LinuxThreads 类似于 Pthreads，但在处理 POSIX 建议锁时略有不同。SQLite 从版本 2.2.3 到 3.6.23 在运行时识别到使用了 LinuxThreads，并采取适当措施来解决 LinuxThreads 的非标准行为。但是，大多数现代 Linux 实现都使用了更新且正确的 NPTL 实现的 Pthreads。从 SQLite 版本 3.7.0（2010-07-21）开始，假定使用 NPTL。不再进行检查。因此，如果在旧版本的 Linux 系统上运行使用 LinuxThreads 的多线程应用程序，最近的 SQLite 版本可能会出现细微的故障，并可能损坏数据库文件。

## 6.2\. QNX 上 mmap() 的失败

QNX 上存在一些关于 mmap() 的微妙问题，即对单个文件描述符进行第二次 mmap() 调用可能会导致从第一次 mmap() 调用获取的内存被清零。Unix 上的 SQLite 在 WAL 模式 下使用 mmap() 来创建用于事务协调的共享内存区域，并且对于大事务会多次调用 mmap()。已经证明 QNX 的 mmap() 在这种情况下会损坏数据库文件。QNX 的工程师们已经意识到了这个问题，并正在努力解决；可能在您阅读此文时，问题已经得到了修复。

在 QNX 上运行时，建议永远不要使用 内存映射 I/O。此外，要使用 WAL 模式，建议应用程序使用 独占锁定模式 以便在无共享内存的情况下使用 WAL。

## 6.3\. 文件系统损坏

由于 SQLite 数据库是普通的磁盘文件，因此文件系统中的任何故障都可能会导致数据库损坏。现代操作系统中的文件系统非常可靠，但仍然会出现错误。例如，在 2013-10-01 日，保存 [Tcl/Tk 维基](http://wiki.tcl-lang.org/) 的 SQLite 数据库在主机计算机移动到一个有文件系统层问题的不稳定内核版本后几天就损坏了。在那次事件中，文件系统最终变得如此严重损坏，以至于该计算机无法使用，但问题的最早症状是损坏的 SQLite 数据库。

# 7\. SQLite 配置错误

SQLite 内置了许多防止数据库损坏的保护措施。但是，许多这些保护措施可以通过配置选项禁用。如果禁用了这些保护措施，则可能会发生数据库损坏。

下面是禁用 SQLite 内置保护机制的示例：

+   设置 PRAGMA synchronous=OFF 可能会导致数据库在操作系统崩溃或停电时损坏，尽管该设置在应用程序崩溃时是安全的。

+   在其他数据库连接打开的情况下更改 PRAGMA schema_version。

+   使用 PRAGMA journal_mode=OFF 或者 PRAGMA journal_mode=MEMORY，在写事务进行中发生应用崩溃。

+   设置 PRAGMA writable_schema=ON 然后使用 DML 语句更改数据库模式，如果操作不慎可能会导致数据库完全无法读取。

# 8\. SQLite 中的错误

SQLite 经过 非常仔细的测试，以尽可能保证其没有错误。每个 SQLite 版本都进行了许多测试，包括模拟停电、I/O 错误和内存耗尽（OOM）错误，并验证在这些事件期间不会发生数据库损坏。SQLite 在大约 20 亿个活跃部署中得到了验证，没有遇到严重问题。

然而，没有软件是 100%完美的。 SQLite 曾经有过一些历史性的错误（现已修复），可能导致数据库损坏。而可能还存在一些尚未被发现的错误。由于 SQLite 进行了广泛的测试和广泛的使用，导致数据库损坏的错误往往非常隐蔽。应用程序遇到 SQLite 错误的可能性很小。以下列出了 SQLite 在 2009-04-01 至 2013-04-15 四年期间发现的所有数据库损坏错误。这些信息应该让读者直观地了解在测试程序中被忽略而进入发布版本的 SQLite 错误类型。

## 8.1\. 数据库缩小导致的虚假损坏报告

如果一个数据库先由 SQLite 版本 3.7.0 或更高版本编写，然后再由 SQLite 版本 3.6.23 或更早版本以使数据库文件大小减小的方式再次编写，则下一次 SQLite 版本 3.7.0 访问数据库文件时，可能会报告数据库文件损坏。然而，数据库文件实际上并没有损坏。版本 3.7.0 只是在其损坏检测中过于激进。

问题在 2011-02-20 修复。修复首次出现在 SQLite 版本 3.7.6 (2011-04-12)中。

## 8.2\. 在回滚和 WAL 模式之间切换后导致损坏。

反复在一个进程或线程中切换 SQLite 数据库的 WAL 模式，并在切换之间运行 VACUUM 命令，可能导致另一个打开数据库文件的进程或线程未能意识到数据库已经发生变化。然后，第二个进程或线程可能尝试使用过期的缓存来修改数据库，从而导致数据库损坏。

这个问题是在内部测试中发现的，从未在实际中观察到。该问题在 2011-01-27 修复，并在版本 3.7.5 中得到修复。

## 8.3\. 在获取锁时发生的 I/O 错误导致损坏。

如果操作系统在尝试在 WAL 模式的共享内存上获取某个锁时返回 I/O 错误，那么 SQLite 可能无法重置其缓存，如果尝试进行后续写操作，则可能导致数据库损坏。

注意，只有在尝试获取锁时导致 I/O 错误时才会出现这个问题。如果锁只是因为其他线程或进程已经持有冲突锁而未被授予，则不会发生任何损坏。我们不知道任何操作系统在尝试在共享内存上获取文件锁时会失败 I/O 错误。因此，这是一个理论上的问题而不是真实存在的问题。不用说，在野外从未观察到这个问题。这个问题是在模拟 SQLite 的压力测试中发现的，在这个测试中会模拟 I/O 错误。

这个问题在 SQLite 版本 3.7.3 中的 2010-09-20 被修复。

## 8.4\. 数据库页面从空闲页面列表中泄漏

当从 SQLite 数据库中删除内容时，不再使用的页面将被添加到空闲列表，并在后续插入时重用以容纳添加的内容。在 SQLite 中存在的一个 bug，在版本 3.6.16 到 3.7.2 中可能会导致页面在使用 incremental_vacuum 时从空闲列表中丢失。这不会导致数据丢失。但它会导致数据库文件比必要时更大。并且会导致 integrity_check pragma 报告从空闲列表中丢失的页面。

这个问题在 SQLite 版本 3.7.2 中的 2010-08-23 被修复。

## 8.5\. 在从 3.6 和 3.7 交替写入后出现的损坏

SQLite 版本 3.7.0 引入了一些新的增强功能到 SQLite 数据库文件格式（例如但不限于 WAL）。3.7.0 版本是这些新功能的一个摇摆版本。我们预计会发现问题，而且并未失望。

如果一个数据库最初是使用 SQLite 版本 3.7.0 创建的，然后使用 SQLite 版本 3.6.23.1 写入以增加数据库文件的大小，然后再次使用 SQLite 版本 3.7.0 写入，则数据库文件可能会损坏。

这个问题在 SQLite 版本 3.7.1 中的 2010-08-04 被修复。

## 8.6\. Windows 系统上恢复中的竞争条件

SQLite 版本 3.7.16.2 修复了 Windows 系统上锁逻辑中的一个微妙的竞争条件。当一个数据库文件需要恢复，因为前一个写入它的进程在事务中间崩溃，并且两个或更多进程同时尝试打开该数据库时，竞争条件可能导致其中一个进程错误地得到一个指示已经完成恢复的信息，从而允许该进程在运行恢复之前继续使用数据库文件。如果该进程向文件写入，则文件可能会损坏。这个竞争条件显然存在于所有之前的 SQLite 版本中，适用于从 2004 年起的所有 Windows 版本。但是这个竞争条件非常严格。实际上，你需要一台快速的多核机器，在其中启动两个进程同时在两个独立的核心上运行恢复操作。这个缺陷仅存在于 Windows 系统中，不影响 posix 操作系统接口。

## 8.7\. 嵌套事务使用的次要日志的边界值错误

当使用保存点启动嵌套事务时，SQLite 会使用一个次要回滚日志来跟踪嵌套事务的更改，以防内部事务需要回滚。次要日志不参与保护数据库免受程序崩溃或断电造成的损坏。次要日志仅在回滚嵌套事务的内部事务时起作用。

这些次要日志可以保存在内存中或作为临时文件存储在磁盘上。默认行为是将它们存储在磁盘上。但是可以通过-DSQLITE_TEMP_STORE 编译时选项或使用 PRAGMA temp_store 语句在运行时更改这一行为。只有当次要日志保存在内存中时才会出现此错误。

在 SQLite 版本 3.35.0 (2021-03-12) 中，添加了一个新的优化，以便当 SQLite 在内存中保存辅助日志时，使用的内存更少。不幸的是，新逻辑中的边界检查编码错误。本应该是 "<" 操作符的地方被编写成了 "<="。这个错误可能会导致辅助日志在回滚时进入不一致状态。如果做了额外的更改并且最终提交了外部事务，可能会使数据库处于不一致状态。

这个问题是由一位[独立研究者](https://sqlite.org/forum/forumpost/b03d86f9516cb3a2)发现的，他试图使用模糊测试工具在 SQLite 中找到漏洞。模糊测试工具发现了一个在用于验证辅助日志内部状态的 assert()语句中的故障。这个 bug 是一个足够隐秘的边缘案例，如果不是 SQLite 中对 assert() 语句的密集使用，安全研究人员的坚持和其定制的最先进的模糊测试工具，这个问题可能会在很多年内被忽略。

这个问题已经在 版本 3.37.2 (2022-01-06) 中 [修复](https://www.sqlite.org/src/info/73c2b50211d3ae26)。
