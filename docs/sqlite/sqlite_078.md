# 1\. 简介

> 原文：[`sqlite.com/tempfiles.html`](https://sqlite.com/tempfiles.html)

SQLite 的一个显著特点是数据库由单个磁盘文件组成。这简化了 SQLite 的使用，因为移动或备份数据库只需简单地复制一个文件。这也使得 SQLite 适合用作应用程序文件格式。但是，虽然一个完整的数据库存储在单个磁盘文件中，但在处理数据库过程中 SQLite 确实使用了许多临时文件。

本文描述了 SQLite 创建和使用的各种临时文件。它详细说明了文件的创建时间、删除时间、用途、重要性以及如何在创建临时文件成本高昂的系统上避免它们。

SQLite 使用临时文件的方式并不被视为 SQLite 与应用程序达成的协议的一部分。本文档中的信息是描述 SQLite 在撰写或最后更新本文档时的操作方式的正确说明。但不能保证未来版本的 SQLite 会以同样的方式使用临时文件。未来的版本可能会使用新的临时文件类型，而当前某些临时文件的使用可能会在后续 SQLite 版本中停止。

# 2\. 九种临时文件

SQLite 目前使用九种不同类型的临时文件：

1.  回滚日志

1.  超级日志

1.  预写日志（WAL）文件

1.  共享内存文件

1.  语句日志

1.  临时数据库

1.  视图和子查询的实体化

1.  临时索引

1.  VACUUM 使用的临时数据库

关于每种临时文件类型的详细信息将在续篇中给出。

## 2.1\. 回滚日志

一个回滚日志是在 SQLite 中实现原子提交和回滚功能时使用的临时文件（有关其工作原理的详细讨论，请参见名为 SQLite 中的原子提交的单独文件）。回滚日志始终位于与数据库文件相同的目录中，并且具有与数据库文件相同的名称，只是附加了 8 个字符的“-journal”。回滚日志通常在事务首次启动时创建，并且在事务提交或回滚时通常会被删除。回滚日志文件对于实现 SQLite 的原子提交和回滚功能至关重要。如果没有回滚日志，SQLite 将无法回滚不完整的事务，并且如果在事务的中间发生崩溃或断电，没有回滚日志的话，整个数据库可能会变得腐坏。

回滚日志*通常*在事务开始和结束时创建和销毁，但也有例外情况。

如果在事务的中间发生崩溃或断电，则会在磁盘上保留回滚日志文件。下次另一个应用程序尝试打开数据库文件时，它会注意到废弃的回滚日志（我们在这种情况下称其为“热日志”），并使用日志中的信息将数据库恢复到不完整事务开始之前的状态。这就是 SQLite 实现原子提交的方式。

如果一个应用程序使用 pragma 将 SQLite 设置为独占锁定模式：

> ```sql
> PRAGMA locking_mode=EXCLUSIVE;
> 
> ```

在独占锁定模式会话的第一个事务开始时，SQLite 会创建一个新的回滚日志。但在事务结束时，它不会删除回滚日志。回滚日志可能会被截断，或其头部可能会被置零（取决于您使用的 SQLite 版本），但回滚日志不会被删除。只有在退出独占访问模式时，回滚日志才会被删除。

回滚日志的创建和删除也会受到 journal_mode pragma 的影响。默认的日志模式是 DELETE，即在每次事务结束时删除回滚日志文件，如上所述。PERSIST 日志模式则避免了删除日志文件，而是用零覆盖回滚日志头部，这样可以防止其他进程回滚日志，从而达到与删除日志文件相同的效果，但不会实际从磁盘上删除文件。换句话说，PERSIST 日志模式展现了与 EXCLUSIVE 锁定模式相同的行为。OFF 日志模式导致 SQLite 省略回滚日志的创建。换句话说，如果将日志模式设置为 OFF，则永远不会写入回滚日志。OFF 日志模式会禁用 SQLite 的原子提交和回滚功能。当设置 OFF 日志模式时，ROLLBACK 命令不可用。如果在使用 OFF 日志模式的事务中发生崩溃或断电，则无法进行恢复，数据库文件可能会损坏。MEMORY 日志模式会将回滚日志存储在内存中而不是磁盘上。当日志模式为 MEMORY 时，ROLLBACK 命令仍然可用，但因为没有文件用于恢复，如果在使用 MEMORY 日志模式的事务中发生崩溃或断电，数据库可能会损坏。

## 2.2\. 写前日志（Write-Ahead Log，WAL）文件

使用写前日志（write-ahead log 或 WAL）文件来代替回滚日志记录在 SQLite 工作于 WAL 模式时。与回滚日志一样，WAL 文件的目的是为了实现原子提交和回滚。WAL 文件总是位于与数据库文件相同的目录中，并且具有与数据库文件相同的名称，只是末尾附加了 4 个字符“**-wal**”。当第一个连接到数据库时，WAL 文件就会被创建，并且通常在最后一个连接关闭时被删除。然而，如果最后一个连接没有正常关闭，WAL 文件将会保留在文件系统中，并且会在下一次打开数据库时自动清理。

## 2.3\. 共享内存文件

在 WAL 模式下操作时，所有与同一数据库文件相关的 SQLite 数据库连接都需要共享一些内存，以用作 WAL 文件的索引。在大多数实现中，这个共享内存是通过在专门为此目的创建的文件上调用 mmap()来实现的：共享内存文件。如果存在共享内存文件，它位于与数据库文件相同的目录中，并且具有与数据库文件相同的名称，只是末尾附加了 4 个字符“**-shm**”。共享内存文件仅在 WAL 模式下运行时存在。

共享内存文件不包含任何持久内容。共享内存文件的唯一目的是为多个进程提供一个共享内存块，所有这些进程都在 WAL 模式下访问同一个数据库。如果 VFS 能够提供一种替代方法来访问共享内存，那么可能会使用这种替代方法而不是共享内存文件。例如，如果 PRAGMA locking_mode 设置为 EXCLUSIVE（意味着只有一个进程能够访问数据库文件），那么共享内存将从堆分配而不是从共享内存文件中分配，并且共享内存文件将永远不会被创建。

共享内存文件的生命周期与其关联的 WAL 文件相同。共享内存文件在创建 WAL 文件时创建，并在删除 WAL 文件时删除。在 WAL 文件恢复期间，根据正在恢复的 WAL 文件的内容，共享内存文件从头开始重新创建。

## 2.4\. 超级日志文件

当单个事务对已通过 ATTACH 语句添加到单个 数据库连接 的多个数据库进行更改时，超级日志文件作为原子提交过程的一部分使用。超级日志文件始终位于与主数据库文件相同的目录中（主数据库文件是在原始 sqlite3_open()、sqlite3_open16() 或 sqlite3_open_v2() 调用中标识的数据库，该调用创建了 数据库连接）。超级日志文件具有随机后缀，其中包含在事务期间更改的各个附加辅助数据库的名称。当超级日志文件被删除时，多数据库事务提交。有关详细信息，请参阅名为 SQLite 中的原子提交 的文档。

没有超级日志文件时，多数据库事务提交对每个数据库来说是原子的，但对所有数据库来说不是原子的。换句话说，如果提交在中间被崩溃或断电打断，那么一个数据库的更改可能完成，而另一个数据库的更改可能回滚。超级日志文件导致所有数据库中的所有更改要么回滚要么一起提交。

超级日志文件仅在涉及多个数据库文件的 COMMIT 操作创建，其中至少两个数据库满足以下所有要求：

1.  事务修改数据库

1.  PRAGMA synchronous 设置不是 OFF

1.  PRAGMA journal_mode 不是 OFF、MEMORY 或 WAL

这意味着 SQLite 事务在数据库文件在断电时不是跨多个文件原子的，如果数据库文件关闭同步或者使用了 OFF、MEMORY 或 WAL 的日志模式。对于同步 OFF 和日志模式 OFF 以及 MEMORY，如果事务提交被断电中断，数据库通常会损坏。对于 WAL 模式，单个数据库文件在断电时会原子更新，但在多文件事务中，一些文件可能在断电后回滚，而其他文件可能会继续向前滚动。

## 2.5\. 语句日志文件

语句日志文件用于回滚大事务中单个语句的部分结果。例如，假设一个 UPDATE 语句尝试修改数据库中的 100 行。但在修改了前 50 行后，UPDATE 遇到了约束违规，应该阻止整个语句。语句日志用于撤消前 50 行的更改，以便数据库恢复到语句开始时的状态。

语句日志仅适用于可能更改数据库多行并且可能在触发器中遇到约束或 RAISE 异常并因此需要撤消部分结果的 UPDATE 或 INSERT 语句。如果 UPDATE 或 INSERT 不包含在 BEGIN...COMMIT 之内，并且在同一数据库连接上没有其他活动语句，则不会创建语句日志，因为可以使用普通回滚日志代替。如果使用了冲突解决算法的替代方案，则也会省略语句日志。例如：

> ```sql
> UPDATE OR FAIL ...
> UPDATE OR IGNORE ...
> UPDATE OR REPLACE ...
> UPDATE OR ROLLBACK ...
> INSERT OR FAIL ...
> INSERT OR IGNORE ...
> INSERT OR REPLACE ...
> INSERT OR ROLLBACK ...
> REPLACE INTO ....
> 
> ```

语句日志被赋予随机名称，并不一定位于主数据库相同目录中，并且在事务结束时自动删除。语句日志的大小与导致创建语句日志的 UPDATE 或 INSERT 语句实施的更改大小成比例。

## 2.6\. TEMP 数据库

使用 "CREATE TEMP TABLE" 语法创建的表仅对原始评估 "CREATE TEMP TABLE" 语句的 数据库连接 可见。这些 TEMP 表连同任何关联的索引、触发器和视图，统一存储在一个单独的临时数据库文件中，该文件在第一次看到 "CREATE TEMP TABLE" 语句时创建。这个单独的临时数据库文件还有一个关联的回滚日志。用于存储 TEMP 表的临时数据库文件在使用 sqlite3_close() 关闭 数据库连接 时会自动删除。

TEMP 数据库文件与使用 ATTACH 语句添加的辅助数据库文件非常相似，尽管具有一些特殊属性。当 数据库连接 关闭时，TEMP 数据库将自动删除。TEMP 数据库始终使用 synchronous=OFF 和 journal_mode=PERSIST PRAGMA 设置。而且，TEMP 数据库不能与 DETACH 一起使用，也不能被另一个进程 ATTACH。

与 TEMP 数据库及其回滚日志关联的临时文件仅在应用程序使用 "CREATE TEMP TABLE" 语句时创建。

## 2.7\. 视图和子查询的物化

包含子查询的查询有时必须单独评估子查询并将结果存储在临时表中，然后使用临时表的内容来评估外部查询。我们称之为"实体化"子查询。SQLite 中的查询优化器尝试避免实体化，但有时很难避免。实体化创建的临时表分别存储在它们自己的单独的临时文件中，在查询结束时会自动删除。这些临时表的大小取决于子查询的实体化中的数据量，当然。

IN 操作符右侧的子查询经常需要被实体化。例如：

> ```sql
> SELECT * FROM ex1 WHERE ex1.a IN (SELECT b FROM ex2);
> 
> ```

在上面的查询中，子查询"SELECT b FROM ex2" 被评估，并且其结果被存储在一个临时表中（实际上是一个临时索引），它可以通过简单的二分搜索确定 ex2.b 的值是否存在。一旦构建了这个表，外部查询就会运行，并且对于每个潜在的结果行，都会进行检查，看看 ex1.a 是否包含在临时表中。只有在检查为真时才会输出该行。

为了避免创建临时表，查询可能会被重写如下：

> ```sql
> SELECT * FROM ex1 WHERE EXISTS(SELECT 1 FROM ex2 WHERE ex2.b=ex1.a);
> 
> ```

SQLite 的最新版本（3.5.4 版本 2007-12-14 及以后）将自动执行此重写，如果在列 ex2.b 上存在索引。

如果 IN 操作符的右侧可以是一个值列表，如下所示：

> ```sql
> SELECT * FROM ex1 WHERE a IN (1,2,3);
> 
> ```

IN 操作符右侧的列表值被视为必须被实体化的子查询。换句话说，前面的语句的作用就好像是：

> ```sql
> SELECT * FROM ex1 WHERE a IN (SELECT 1 UNION ALL
>                               SELECT 2 UNION ALL
>                               SELECT 3);
> 
> ```

一个临时索引总是用于保存 IN 操作符的右侧值，当该右侧值是一个值列表时。

当子查询出现在 SELECT 语句的 FROM 子句中时，子查询也可能需要被实体化。例如：

> ```sql
> SELECT * FROM ex1 JOIN (SELECT b FROM ex2) AS t ON t.b=ex1.a;
> 
> ```

根据查询的不同，SQLite 可能需要将"(SELECT b FROM ex2)"子查询材料化为临时表，然后在 ex1 和临时表之间执行连接。查询优化器尝试通过"展开"查询来避免这种情况。在前面的示例中，查询可以被展开，SQLite 将自动转换查询为

> ```sql
> SELECT ex1.*, ex2.b FROM ex1 JOIN ex2 ON ex2.b=ex1.a;
> 
> ```

更复杂的查询可能无法利用查询展开来避免使用临时表。查询是否可以展开取决于诸如子查询或外部查询是否包含聚合函数、ORDER BY 或 GROUP BY 子句、LIMIT 子句等因素。查询能否展开的规则非常复杂，超出了本文档的范围。

## 2.8\. 瞬时索引

SQLite 可能会利用瞬时索引来实现诸如以下 SQL 语言特性：

+   ORDER BY 或 GROUP BY 子句

+   聚合查询中的 DISTINCT 关键字

+   使用 UNION、EXCEPT 或 INTERSECT 连接的复合 SELECT 语句

每个瞬时索引都存储在自己的临时文件中。瞬时索引的临时文件在使用它的语句结束时自动删除。

SQLite 努力使用预先存在的索引来实现 ORDER BY 子句。如果已经存在适当的索引，SQLite 将遍历该索引而不是底层表，以提取所需信息，并使行按照期望的顺序输出。但如果 SQLite 找不到适当的索引，它将评估查询并将每行存储在瞬时索引中，其中数据是行数据，键是 ORDER BY 项。在评估查询后，SQLite 将返回并遍历瞬时索引，以按照期望的顺序输出行。

SQLite 通过按照 GROUP BY 条款建议的顺序对输出行进行排序来实现 GROUP BY。每个输出行与前一行进行比较，以查看是否开始一个新的“组”。按照 GROUP BY 条款的排序方式与按照 ORDER BY 条款的排序方式完全相同。如果可能，将使用预先存在的索引，但如果没有合适的索引，则会创建一个临时索引。

在聚合查询上使用 DISTINCT 关键字通过在临时文件中创建一个临时索引并将每个结果行存储在该索引中来实现。计算新的结果行时，会检查它们是否已经存在于临时索引中，如果存在，则丢弃新的结果行。

复合查询的 UNION 运算符通过在临时文件中创建一个临时索引来实现，并将左右子查询的结果存储在临时索引中，丢弃重复项。在评估完两个子查询后，从头到尾遍历临时索引以生成最终输出。

复合查询的 EXCEPT 运算符通过在临时文件中创建一个临时索引实现，将左子查询的结果存储在该临时索引中，然后从临时索引中移除右子查询的结果，最后从头到尾遍历索引以获取最终输出。

复合查询的 INTERSECT 运算符通过在两个单独的临时文件中分别创建两个单独的临时索引来实现。左子查询和右子查询各自计算到单独的临时索引中。然后一起遍历这两个索引，并输出同时出现在两个索引中的条目。

请注意，复合查询的 UNION ALL 运算符本身不使用临时索引（尽管 UNION ALL 的右子查询和左子查询可能根据其组合方式使用临时索引）。

## 2.9\. VACUUM 使用的临时数据库

VACUUM 命令通过创建临时文件并将整个数据库重建到该临时文件中来工作。然后将临时文件的内容复制回原始数据库文件，最后删除临时文件。

VACUUM 命令创建的临时文件仅在命令执行期间存在。临时文件的大小不会大于原始数据库。

# 3\. SQLITE_TEMP_STORE 编译时参数和 Pragma

与事务控制相关的临时文件，即回滚日志、超级日志、预写式日志（WAL）文件和共享内存文件，始终写入磁盘。但其他类型的临时文件可能仅存储在内存中，永不写入磁盘。除回滚、超级和语句日志以外的临时文件是否写入磁盘或仅存储在内存取决于 SQLITE_TEMP_STORE 编译时参数、temp_store pragma 和临时文件的大小。

SQLITE_TEMP_STORE 编译时参数是一个 #define，其值是一个介于 0 和 3 之间（包括边界）的整数。SQLITE_TEMP_STORE 编译时参数的含义如下：

1.  无论设置如何，临时文件始终存储在磁盘上，而不受 temp_store pragma 的影响。

1.  默认情况下，临时文件存储在磁盘上，但可以通过 temp_store pragma 进行覆盖。

1.  默认情况下，临时文件存储在内存中，但可以通过 temp_store pragma 进行覆盖。

1.  无论如何设置，临时文件始终存储在内存中，而不受 temp_store pragma 的影响。

SQLITE_TEMP_STORE 编译时参数的默认值为 1，表示将临时文件存储在磁盘上，但提供使用 temp_store pragma 覆盖此行为的选项。

temp_store pragma 具有整数值，也会影响临时文件存储位置的决定。temp_store pragma 的值具有以下含义：

1.  根据 SQLITE_TEMP_STORE 编译时参数的设置，选择磁盘或内存存储临时文件。

1.  如果 SQLITE_TEMP_STORE 编译时参数指定临时文件使用内存存储，则应覆盖该决定，改用磁盘存储。否则，遵循 SQLITE_TEMP_STORE 编译时参数的建议。

1.  如果 SQLITE_TEMP_STORE 编译时参数指定临时文件使用磁盘存储，则应覆盖该决定，改用内存存储。否则，遵循 SQLITE_TEMP_STORE 编译时参数的建议。

temp_store pragma 的默认设置为 0，表示遵循 SQLITE_TEMP_STORE 编译时参数的建议。

重申一下，SQLITE_TEMP_STORE 编译时参数和 temp_store pragma 只影响回滚日志和超级日志以外的临时文件。无论 SQLITE_TEMP_STORE 编译时参数和 temp_store pragma 的设置如何，回滚日志和超级日志始终会被写入磁盘。

# 4\. 其他临时文件优化

SQLite 使用最近读取和写入的数据库页面的页面缓存。此页面缓存不仅用于主数据库文件，还用于存储在临时文件中的瞬态索引和表。如果 SQLite 需要使用临时索引或表，并且 SQLITE_TEMP_STORE 编译时参数和 temp_store pragma 设置为在磁盘上存储临时表和索引，信息仍然最初存储在页面缓存中的内存中。临时文件未打开，信息在页面缓存填满之前不会真正写入磁盘。

这意味着对于许多常见情况，临时表和索引很小（小到可以放入页面缓存中），不会创建临时文件，也不会发生磁盘 I/O。只有当临时数据变得太大，无法放入 RAM 时，信息才会溢出到磁盘。

每个临时表和索引都有自己的页面缓存，该缓存可以存储由 SQLITE_DEFAULT_TEMP_CACHE_SIZE 编译时参数确定的最大数据库页面数。（默认值为 500 页。）页面缓存中的数据库页面的最大数量对每个临时表和索引都是相同的。该值不能在运行时或每个表或索引基础上更改。每个临时文件都有自己的私有页面缓存，其自己的 SQLITE_DEFAULT_TEMP_CACHE_SIZE 页面限制。

# 5\. 临时文件存储位置

临时文件的创建目录由特定于操作系统的 VFS 决定。

在类 Unix 系统中，目录按以下顺序搜索：

1.  由 PRAGMA temp_store_directory 或 sqlite3_temp_directory 全局变量设置的目录

1.  SQLITE_TMPDIR 环境变量

1.  TMPDIR 环境变量

1.  /var/tmp

1.  /usr/tmp

1.  /tmp

1.  当前工作目录（"."）

找到存在且具有写入和执行权限的第一个文件夹将被使用。对于某些在没有标准临时文件位置的 chroot jails 中使用 SQLite 的应用程序来说，最后的"."备用选项非常重要。

在 Windows 系统上，文件夹按以下顺序搜索：

1.  由 PRAGMA temp_store_directory 或全局变量 sqlite3_temp_directory 设置的文件夹。

1.  由 GetTempPath()系统接口返回的文件夹。

在这种情况下，SQLite 本身不关心环境变量，尽管可以假定 GetTempPath()系统调用会关注。对于 CYGWIN 构建，搜索算法有所不同。请查阅源代码获取详细信息。
