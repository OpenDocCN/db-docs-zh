# 常见问题解答

> 原文：[`sqlite.com/faq.html`](https://sqlite.com/faq.html)

1.  **(1) 如何创建一个自动增量字段？**

1.  SQLite 支持哪些数据类型？

1.  SQLite 允许我将字符串插入到类型为整数的数据库列中！

1.  为什么 SQLite 不允许我在同一表的两行中使用 '0' 和 '0.0' 作为主键？

1.  多个应用程序或同一个应用程序的多个实例可以同时访问单个数据库文件吗？

1.  SQLite 是线程安全的吗？

1.  如何列出 SQLite 数据库中包含的所有表/索引？

1.  SQLite 数据库有已知的大小限制吗？

1.  SQLite 中 VARCHAR 的最大尺寸是多少？

1.  SQLite 支持 BLOB 类型吗？

1.  如何在 SQLite 中对现有表格添加、删除或重命名列？

1.  我删除了很多数据，但数据库文件并没有变小。这是一个 bug 吗？

1.  我可以在商业产品中使用 SQLite 而不支付版税吗？

1.  如何使用包含嵌入单引号（'）字符的字符串字面值？

1.  什么是 SQLITE_SCHEMA 错误，我为什么会遇到这个错误？

1.  当我编译 SQLite 时，我得到了一些编译器警告。这是个问题吗？这是否表明代码质量差？

1.  Unicode 字符的不区分大小写匹配不起作用。

1.  插入操作非常慢 - 每秒只能执行几十个 INSERT 操作

1.  我不小心从我的 SQLite 数据库中删除了一些重要信息。如何恢复它？

1.  什么是 SQLITE_CORRUPT 错误？数据库"畸形"意味着什么？为什么我会遇到这个错误？

1.  SQLite 支持外键吗？

1.  如果在构建 SQLite 时使用 SQLITE_OMIT_... 编译选项，我会得到编译器错误。

1.  我的 WHERE 子句表达式 `column1="column1"` 不起作用。它导致返回表中的每一行，而不仅仅是 column1 值为 "column1" 的行。

1.  SQLite 的语法图（也称为“铁路图”）是如何生成的？

1.  SQL 标准要求即使约束中的一个或多个列为 NULL，唯一约束也必须执行，但 SQLite 不执行。这不是一个 bug 吗？

1.  SQLite 的出口管制分类号（ECCN）是什么？

1.  我的查询没有返回我期望的列名。这是一个 bug 吗？

1.  我的数据库去哪了？（或者说：我的数据库怎么变空了？）

**(1) 如何创建一个自动增量字段？**

> 简短回答：声明为 INTEGER PRIMARY KEY 的列会自动增长。
> 
> 更长的答案：如果你声明表的某列为 INTEGER PRIMARY KEY，那么无论何时你在该列插入一个 NULL，该 NULL 会自动转换为一个整数，该整数比表中所有其他行中该列的最大值大一，或者如果表为空则为 1。或者，如果最大的现有整数键 9223372036854775807 正在使用，则会随机选择一个未使用的键值。例如，假设你有这样一张表：
> 
> > ```sql
> > CREATE TABLE t1(
> >   a INTEGER PRIMARY KEY,
> >   b INTEGER
> > );
> > 
> > ```
> > 
> 对于这张表，语句
> 
> > ```sql
> > INSERT INTO t1 VALUES(NULL,123);
> > 
> > ```
> > 
> 逻辑上等同于说：
> 
> > ```sql
> > INSERT INTO t1 VALUES((SELECT max(a) FROM t1)+1,123);
> > 
> > ```
> > 
> 有一个名为 sqlite3_last_insert_rowid()的函数，它将返回最近插入操作的整数键。
> 
> 请注意，整数键是插入前表中存在的最大键加一。新键将在当前表中所有键中是唯一的，但可能会与以前从表中删除的键重叠。为了创建在表的生命周期内唯一的键，请在 INTEGER PRIMARY KEY 声明中添加 AUTOINCREMENT 关键字。然后选择的键将比该表中曾经存在的最大键多一。如果以前在该表中存在最大可能的键，则 INSERT 将失败，并显示 SQLITE_FULL 错误代码。

**(2) SQLite 支持哪些数据类型？**

> SQLite 使用 dynamic typing。内容可以存储为 INTEGER、REAL、TEXT、BLOB 或 NULL。

**(3) SQLite 让我在整数类型的数据库列中插入字符串！**

> 这是一个特性，而不是错误。SQLite 使用 dynamic typing。它不强制数据类型约束。可以（通常）将任何类型的数据插入到任何列中。可以将任意长度的字符串放入整数列中，将浮点数放入布尔列中，或将日期放入字符列中。在 CREATE TABLE 命令中分配给列的 datatype 不限制可以放入该列的数据。每列能够容纳任意长度的字符串。（有一个例外：类型为 INTEGER PRIMARY KEY 的列只能包含 64 位有符号整数。如果尝试将除整数外的任何内容放入 INTEGER PRIMARY KEY 列中，则会报错。）
> 
> 但 SQLite 确实使用列的声明类型作为你偏好该格式值的提示。因此，例如，如果某列的类型为 INTEGER 并且你尝试将字符串插入该列，SQLite 会尝试将字符串转换为整数。如果可以，它会插入整数。否则，它会插入字符串。这个特性被称为 type affinity。

**(4) 为什么 SQLite 不允许我在同一表的两行中使用'0'和'0.0'作为主键？**

> 当您的主键是数值类型时会出现这个问题。将您的主键的数据类型更改为 TEXT，问题应该就可以解决了。
> 
> 每行必须具有唯一的主键。对于数值类型的列，SQLite 认为**'0'**和**'0.0'**是相同的值，因为它们在数值上相等（请参见前面的问题）。因此这些值并不是唯一的。

**（5）多个应用程序或同一应用程序的多个实例可以同时访问单个数据库文件吗？**

> 多个进程可以同时打开同一个数据库。多个进程可以同时执行 SELECT 操作。但在任何时刻只有一个进程可以对数据库进行更改。
> 
> SQLite 使用读者/写者锁来控制对数据库的访问。（在缺乏读者/写者锁支持的 Win95/98/ME 上，将使用概率模拟。）但要小心：如果数据库文件保存在 NFS 文件系统上，此锁定机制可能无法正常工作。这是因为在许多 NFS 实现中，fcntl()文件锁定是有问题的。如果可能有多个进程尝试同时访问文件，请避免将 SQLite 数据库文件放在 NFS 上。在 Windows 上，微软的文档说如果您没有运行 Share.exe 守护程序，那么在 FAT 文件系统上锁定可能无法工作。那些对 Windows 有丰富经验的人告诉我，网络文件的文件锁定非常不稳定且不可靠。如果他们说的是真的，那么在两台或更多 Windows 机器之间共享 SQLite 数据库可能会导致意外的问题。
> 
> 我们知道没有其他*嵌入式*SQL 数据库引擎像 SQLite 那样支持如此多的并发性。SQLite 允许多个进程同时打开数据库文件，并且允许多个进程同时读取数据库。当任何进程想要写入时，它必须锁定整个数据库文件以完成更新。但这通常只需要几毫秒。其他进程只需等待写入者完成，然后继续他们的工作。其他嵌入式 SQL 数据库引擎通常只允许一个进程同时连接到数据库。
> 
> 然而，客户端/服务器数据库引擎（如 PostgreSQL、MySQL 或 Oracle）通常支持更高级别的并发，并允许多个进程同时向同一个数据库写入。这在客户端/服务器数据库中是可能的，因为总是有一个单一的、良好控制的服务器进程可用于协调访问。如果您的应用程序需要大量并发性，则应考虑使用客户端/服务器数据库。但经验表明，大多数应用程序所需的并发性远远少于其设计者想象的那么多。
> 
> 当 SQLite 尝试访问由另一个进程锁定的文件时，默认行为是返回 SQLITE_BUSY。您可以使用 C 代码或 sqlite3_busy_timeout()API 函数来调整此行为。

**(6) SQLite 是否是线程安全的？**

> [线程是邪恶的](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2006/EECS-2006-1.html)。避免使用它们。
> 
> SQLite 是线程安全的。我们做出这个让步是因为许多用户选择忽略前一段中给出的建议。但是为了线程安全，SQLite 必须使用`SQLITE_THREADSAFE`预处理宏设置为 1 进行编译。分发中的 Windows 和 Linux 预编译二进制文件都是这样编译的。如果您不确定您正在链接的 SQLite 库是否编译为线程安全，可以调用 sqlite3_threadsafe()接口来查找。
> 
> SQLite 是线程安全的，因为它使用互斥锁来串行访问共享数据结构。然而，获取和释放这些互斥锁的工作会稍微减慢 SQLite 的速度。因此，如果不需要 SQLite 是线程安全的，应该禁用互斥锁以获得最大性能。有关更多信息，请参阅线程模式文档。
> 
> 在 Unix 环境下，不应该在`fork()`系统调用中将打开的 SQLite 数据库传递到子进程中。

**(7) 我如何列出包含在 SQLite 数据库中的所有表/索引**

> 如果您正在运行**sqlite3**命令行访问程序，可以键入"**.tables**"以获取所有表的列表。或者可以键入"**.schema**"以查看完整的数据库架构，包括所有表和索引。这些命令之一后面可以跟一个 LIKE 模式，该模式将限制显示的表。
> 
> 在 C/C++程序（或使用 Tcl/Ruby/Perl/Python 绑定的脚本）中，您可以通过对名为"**SQLITE_SCHEMA**"的特殊表进行 SELECT 来获取表和索引名称。每个 SQLite 数据库都有一个定义数据库模式的 SQLITE_SCHEMA 表。SQLITE_SCHEMA 表如下所示：
> 
> > ```sql
> > CREATE TABLE sqlite_schema (
> >   type TEXT,
> >   name TEXT,
> >   tbl_name TEXT,
> >   rootpage INTEGER,
> >   sql TEXT
> > );
> > 
> > ```
> > 
> 对于表，**type**字段将始终是**'table'**，**name**字段将是表的名称。因此，要获取数据库中所有表的列表，请使用以下 SELECT 命令：
> 
> > ```sql
> > SELECT name FROM sqlite_schema
> > WHERE type='table'
> > ORDER BY name;
> > 
> > ```
> > 
> 对于索引，**type**等于**'index'**，**name**是索引的名称，**tbl_name**是索引所属的表的名称。对于表和索引，**sql**字段是创建表或索引的原始 CREATE TABLE 或 CREATE INDEX 语句的文本。对于自动创建的索引（用于实现 PRIMARY KEY 或 UNIQUE 约束），**sql**字段为 NULL。
> 
> SQLITE_SCHEMA 表不能使用 UPDATE、INSERT 或 DELETE 修改（除非在特殊情况下）。SQLITE_SCHEMA 表会被像 CREATE TABLE、CREATE INDEX、DROP TABLE 和 DROP INDEX 等命令自动更新。
> 
> 临时表不会出现在 SQLITE_SCHEMA 表中。临时表及其索引和触发器出现在另一个名为 SQLITE_TEMP_SCHEMA 的特殊表中。SQLITE_TEMP_SCHEMA 的工作方式与 SQLITE_SCHEMA 相同，但只对创建临时表的应用程序可见。要获取所有表（包括永久和临时表）的列表，可以使用类似以下命令的命令：
> 
> > ```sql
> > SELECT name FROM 
> >    (SELECT * FROM sqlite_schema UNION ALL
> >     SELECT * FROM sqlite_temp_schema)
> > WHERE type='table'
> > ORDER BY name
> > 
> > ```

**(8) SQLite 数据库有已知的大小限制吗？**

> 参见 limits.html 以获取有关 SQLite 限制的完整讨论。

**(9) SQLite 中 VARCHAR 的最大大小是多少？**

> SQLite 不强制 VARCHAR 的长度。您可以声明一个 VARCHAR(10)，SQLite 将很高兴地在那里存储一个 5 亿字符的字符串。它将保持所有 5 亿个字符完整。您的内容不会被截断。SQLite 将"VARCHAR(*N*)"列类型理解为"TEXT"，无论*N*的值如何。

**(10) SQLite 支持 BLOB 类型吗？**

> SQLite 允许您在任何列中存储 BLOB 数据，即使声明为其他类型也可以。甚至可以将 BLOB 用作主键。

**(11) 我如何在 SQLite 中的现有表中添加、删除或重命名列？**

> SQLite 有限的 ALTER TABLE 支持可用于添加、重命名或删除列，或更改表名，详细信息请参见 ALTER TABLE。
> 
> 如果您想对表或其列的结构或约束进行更复杂的更改，您将不得不重新创建它。您可以将现有数据保存到临时表中，删除旧表，创建新表，然后将数据从临时表复制回来。请参阅进行其他类型的表模式更改以获取详细步骤。

**(12) 我删除了很多数据，但数据库文件大小没有变小。这是一个 bug 吗？**

> 不会。当您从 SQLite 数据库中删除信息时，未使用的磁盘空间将添加到内部的“空闲列表”，并在下次插入数据时重新使用。磁盘空间并没有丢失。但也没有归还给操作系统。
> 
> 如果您删除了大量数据并希望缩小数据库文件，请运行 VACUUM 命令。VACUUM 将从头开始重建数据库。这将使数据库具有空的空闲列表和最小尺寸的文件。然而，请注意，VACUUM 可能需要一些时间来运行，并且在运行时可能使用原始文件两倍的临时磁盘空间。
> 
> 使用 auto_vacuum pragma 来启用自动清理模式，而不是使用 VACUUM 命令的另一种选择。

**(13) 我可以在我的商业产品中使用 SQLite 而无需支付版税吗？**

> 是的。SQLite 属于公有领域。我们对代码的任何部分都不主张所有权。你可以对其做任何想做的事情。

**(14) 如何使用包含嵌入式单引号（'）字符的字符串字面量？**

> SQL 标准指定字符串中的单引号通过连续放置两个单引号来转义。在这方面，SQL 的工作方式类似于 Pascal 编程语言。例如：
> 
> > ```sql
> >     INSERT INTO xyz VALUES('5 O''clock');
> >   
> > ```

**(15) 什么是 SQLITE_SCHEMA 错误，为什么我会收到这个错误？**

> 当准备的 SQL 语句不再有效且无法执行时，会返回一个 SQLITE_SCHEMA 错误。发生这种情况时，必须使用 sqlite3_prepare() API 重新从 SQL 编译语句。只有在使用 sqlite3_prepare()和 sqlite3_step()接口运行 SQL 时才会出现 SQLITE_SCHEMA 错误。从 sqlite3_exec()执行语句时，你永远不会收到 SQLITE_SCHEMA 错误。如果使用 sqlite3_prepare_v2()而不是 sqlite3_prepare()准备语句，也不会收到错误。
> 
> sqlite3_prepare_v2()接口创建一个准备语句，如果模式更改，它将自动重新编译。处理 SQLITE_SCHEMA 错误的最简单方法是始终使用 sqlite3_prepare_v2()而不是 sqlite3_prepare()。

**(17) 我在编译 SQLite 时收到一些编译器警告。这是问题吗？这是否表明代码质量不佳？**

> SQLite 的质量保证通过全覆盖测试进行，而不是通过编译器警告或其他静态代码分析工具。换句话说，我们验证 SQLite 确实得到了正确答案，而不仅仅是满足风格上的约束。大部分 SQLite 代码库完全用于测试。SQLite 测试套件运行数以万计的单独测试用例，并且其中许多测试用例是参数化的，以便在每个发布之前运行和评估数十亿个 SQL 语句的数百万个测试，并验证其正确性。开发人员使用代码覆盖工具验证代码的所有路径是否都经过测试。每当在 SQLite 中发现错误时，都会编写新的测试用例来展示该错误，以确保将来不会再次无法检测到该错误。
> 
> 在测试期间，SQLite 库被编译时使用特殊的工具来允许测试脚本模拟各种故障，以验证 SQLite 的恢复能力。内存分配被仔细跟踪，即使在内存分配失败后也不会发生内存泄漏。自定义的 VFS 层用于模拟操作系统崩溃和电源故障，以确保事务在这些事件中是原子性的。一种有意注入 I/O 错误的机制显示，SQLite 对这些故障有很强的恢复能力。（作为实验，请尝试在其他 SQL 数据库引擎上引发这些类型的错误，看看会发生什么！）
> 
> 我们还在 Linux 上使用 [Valgrind](http://valgrind.org) 运行 SQLite 并验证其未发现问题。
> 
> 有些人说我们应该消除所有警告，因为良性警告掩盖了可能在未来变更中出现的真正警告。这倒也有些道理。但开发者指出，所有警告已经在用于 SQLite 开发的构建中（各种版本的 GCC、MSVC 和 clang）中修复过了。编译器警告通常只会因为 SQLite 开发者自己不使用的编译器或编译时选项而产生。

**(18) Unicode 字符的大小写不敏感匹配不起作用。**

> SQLite 的默认配置仅支持对 ASCII 字符的大小写不敏感比较。原因是，实现完整的 Unicode 大小写不敏感比较和大小写转换需要的表和逻辑将几乎使 SQLite 库的大小增加一倍。SQLite 开发者认为，任何需要完整 Unicode 支持的应用程序可能已经具备了必要的表和函数，因此 SQLite 不应占用空间来复制这种能力。
> 
> SQLite 不会默认提供完整的 Unicode 大小写支持，而是提供了链接外部 Unicode 比较和转换例程的能力。应用程序可以重载内置的 NOCASE 排序序列（使用 sqlite3_create_collation()），以及内置的 like()，upper()，和 lower()函数（使用 sqlite3_create_function()）。SQLite 源代码包含一个 "ICU" 扩展来实现这些重载。开发者也可以基于项目内已有的 Unicode 比较例程编写自己的重载。

**(19) 插入操作非常慢 - 我每秒只能做几十次插入。**

> 实际上，SQLite 在普通台式计算机上每秒可以轻松执行 50,000 个或更多 INSERT 语句。但是每秒只能执行几十个事务。事务速度受限于磁盘驱动器的旋转速度。一个事务通常需要磁盘盘片的两次完整旋转，在 7200RPM 磁盘驱动器上，这限制了你大约每秒执行 60 个事务。
> 
> 事务速度受限于磁盘驱动器的速度，因为（默认情况下）SQLite 会等待数据确实安全存储到磁盘表面后才完成事务。这样，如果突然断电或操作系统崩溃，你的数据仍然是安全的。详情请阅读关于 SQLite 中的原子提交的内容。
> 
> 默认情况下，每个 INSERT 语句都是自己的事务。但是，如果你用 BEGIN...COMMIT 将多个 INSERT 语句包裹起来，那么所有的插入将被组织成一个单独的事务。提交事务的时间摊销到所有的插入语句上，因此每个插入语句的时间大大缩短。
> 
> 另一个选项是运行 PRAGMA synchronous=OFF。此命令会导致 SQLite 不等待数据到达磁盘表面，这将使写入操作看起来更快。但是如果在事务进行中断电，你的数据库文件可能会损坏。

**(20) 我不小心从我的 SQLite 数据库中删除了一些重要信息。我如何恢复它？**

> 如果你有数据库文件的备份副本，可以从备份中恢复信息。
> 
> 如果你没有备份，恢复会非常困难。你可能能在原始数据库文件的二进制转储中找到部分字符串数据。使用特殊工具可能也能恢复数值数据，尽管据我们所知目前没有这样的工具存在。SQLite 有时会使用 SQLITE_SECURE_DELETE 选项编译，这会用零覆盖所有已删除的内容。如果情况是这样的话，那么恢复显然是不可能的。如果在数据被删除后运行了 VACUUM，恢复也是不可能的。如果没有使用 SQLITE_SECURE_DELETE 并且没有运行 VACUUM，那么部分已删除的内容可能仍然存在于数据库文件中，位于标记为重用的区域。但是，据我们所知，不存在任何过程或工具可以帮助你恢复这些数据。

**(21) 什么是 SQLITE_CORRUPT 错误？数据库“格式错误”是什么意思？为什么我会收到这个错误？**

> 当 SQLite 检测到数据库文件的结构、格式或其他控制元素存在错误时，会返回 SQLITE_CORRUPT 错误。
> 
> SQLite 不会在没有外部帮助的情况下损坏数据库文件。如果应用程序在更新中崩溃，您的数据是安全的。即使操作系统崩溃或断电，数据库也是安全的。SQLite 的崩溃抵抗性经过了广泛的研究和测试，并且已经由数十亿用户多年的实际经验证明。
> 
> 话虽如此，外部程序或硬件/操作系统中的错误可能会损坏数据库文件。有关详细信息，请参阅 如何损坏 SQLite 数据库文件。
> 
> 您可以使用 PRAGMA integrity_check 对数据库完整性进行彻底但耗时的测试。
> 
> 您可以使用 PRAGMA quick_check 对数据库完整性进行更快但不够彻底的测试。
> 
> 取决于数据库的损坏程度，您可以尝试使用 CLI 将模式和内容转储到文件中，然后重新创建来恢复部分数据。不幸的是，一旦"破鸡蛋"从墙上掉下来，通常是无法再将其恢复。

**(22) SQLite 支持外键吗？**

> 自 版本 3.6.19（2009-10-14）起，SQLite 支持 外键约束。但是默认情况下关闭了外键约束的执行（为了向后兼容性）。要启用外键约束执行，请运行 PRAGMA foreign_keys=ON 或使用 -DSQLITE_DEFAULT_FOREIGN_KEYS=1 进行编译。

**(23) 如果我在构建 SQLite 时使用 SQLITE_OMIT_... 编译时选项，会得到编译器错误。**

> SQLITE_OMIT_... 编译时选项仅在从规范的源文件构建时起作用。在使用 SQLite 混合编译 或预处理源文件构建时，不起作用。
> 
> 可以构建一个特殊的 混合编译，以使用预设的 SQLITE_OMIT_... 选项集。有关如何执行此操作的说明可以在 SQLITE_OMIT_... 文档 中找到。

**(24) 我的 WHERE 子句表达式 `column1="column1"` 不起作用。它导致返回表的每一行，而不仅仅是 column1 值为 "column1" 的行。**

> 在 SQL 中，字符串字面量应使用单引号而不是双引号。这是 SQL 标准要求的。因此，您的 WHERE 子句表达式应该是：`column1='column1'`
> 
> SQL 在包含特殊字符或是关键字的标识符（列或表名）周围使用双引号。因此，双引号是转义标识符名称的一种方式。因此，当您说 `column1="column1"` 时，这等效于 `column1=column1`，显然始终为真。

**(25) SQLite 的语法图（也称为 "铁路图"）是如何生成的？**

> 每个图表都是使用[Pikchr](https://pikchr.org/)绘图语言手工编写的。这些手工编写的规范将被转换为 SVG，并作为文档构建过程的一部分内联插入到 HTML 文件中。
> 
> 许多历史版本的 SQLite 文档使用了不同的流程来生成语法图。历史流程基于 Tcl/Tk，并在[`wiki.tcl-lang.org/21708`](http://wiki.tcl-lang.org/21708)中有描述。基于 Pikchr 的新语法图首次于 2020-09-26 登陆主干。

**(26) SQL 标准要求即使约束中的一个或多个列为 NULL，也必须强制执行唯一约束，但 SQLite 不这样做。这难道不是一个 bug 吗？**

> 或许您指的是 SQL92 中的以下声明：
> 
> > 唯一约束条件只有当表中的两行在唯一列中没有相同的非空值时才得到满足。
> > 
> 该语句有歧义，至少有两种可能的解释：
> 
> 1.  唯一约束条件只有当表中的两行在唯一列中没有相同的值且具有非空值时才得到满足。
> 1.  
> 1.  唯一约束条件只有当表中的两行在唯一列的非空值子集中没有相同的值时才得到满足。
> 1.  
> SQLite 遵循解释（1），与 PostgreSQL、MySQL、Oracle 和 Firebird 一样。确实，Informix 和 Microsoft SQL Server 使用解释（2），但 SQLite 开发人员认为解释（1）是对需求最自然的理解，并且我们也希望最大化与其他 SQL 数据库引擎的兼容性，大多数其他数据库引擎也选择了（1），所以 SQLite 也是如此。

**(27) SQLite 的出口管制分类编号（ECCN）是什么？**

> 经过对商业控制清单（CCL）的仔细审查，我们确信核心公有领域的 SQLite 源代码没有被任何 ECCN 描述，因此 ECCN 应报告为**EAR99**。
> 
> 对于核心公有领域的 SQLite 来说，上述说法是正确的。如果您通过添加新代码扩展了 SQLite，或者将 SQLite 与您的应用程序静态链接，这可能会改变您特定情况下的 ECCN。

**(28) 我的查询没有返回我期望的列名。这是一个 bug 吗？**

> 如果您的结果集的列由 AS 子句命名，则 SQLite 保证使用 AS 关键字右侧的标识符作为列名。如果结果集没有使用 AS 子句，则 SQLite 可以随意命名列。有关更多信息，请参阅 sqlite3_column_name()文档。

**(29) 我的数据库去哪了？（或：我的数据库怎么变空了？）**

> 除非使用阻止它的标志打开，否则如果不存在，SQLite 数据库将被创建。新创建的数据库最初是空的。这可能会让人困惑，他们在不同的上下文中无意中打开不同的数据库文件，可能是由于文件名拼写错误或者相对路径名与打开过程中不同的当前目录使用有关。
