# SQLite 作为应用程序文件格式

> 原文：[`sqlite.com/appfileformat.html`](https://sqlite.com/appfileformat.html)

## 执行摘要

具有定义的模式的 SQLite 数据库文件通常是一个出色的应用程序文件格式。以下是为何如此的十几个理由：

1.  简化应用开发

1.  单文件文档

1.  高级查询语言

1.  可访问的内容

1.  跨平台

1.  原子事务

1.  增量和连续更新

1.  易于扩展

1.  性能

1.  多进程并发使用

1.  多种编程语言

1.  更好的应用程序

在详细描述这些点之前，我们先更仔细地考虑“应用程序文件格式”的含义。另请参阅本白皮书的简短版本。

## 什么是应用程序文件格式？

“应用程序文件格式”是用于将应用程序状态持久化到磁盘或在程序之间交换信息的文件格式。今天有成千上万种应用程序文件格式在使用中。以下仅是一些示例：

+   DOC - Word Perfect 和 Microsoft Office 文档

+   DWG - AutoCAD 绘图

+   PDF - Adobe 的便携式文档格式

+   XLS - Microsoft Excel 电子表格

+   GIT - Git 源代码仓库

+   EPUB - 非 Kindle 电子书使用的电子出版格式

+   ODT - OpenOffice 和其他应用使用的开放文档格式

+   PPT - Microsoft PowerPoint 演示文稿

+   ODP - OpenOffice 和其他应用使用的开放文档演示格式

我们区分“文件格式”和“应用程序格式”。文件格式用于存储单个对象。因此，例如，GIF 或 JPEG 文件存储单个图像，XHTML 文件存储文本，因此它们是“文件格式”，而不是“应用程序格式”。相比之下，EPUB 文件存储文本和图像（作为包含的 XHTML 和 GIF/JPEG 文件），因此被视为“应用程序格式”。本文讨论的是“应用程序格式”。

文件格式和应用程序格式之间的边界并不清晰。本文将 JPEG 称为文件格式，但对于图像编辑器来说，JPEG 可能被视为应用程序格式。很大程度上取决于上下文。对于本文，让我们说文件格式存储一个单一对象，而应用程序格式存储许多不同的对象及它们之间的关系。

大多数应用程序格式可归为以下三类：

1.  **完全自定义格式。** 自定义格式专门为单个应用程序设计。DOC、DWG、PDF、XLS 和 PPT 是自定义格式的例子。自定义格式通常包含在单个文件中，方便传输。它们通常是二进制的，尽管 DWG 格式是一个值得注意的例外。自定义文件格式需要专门的应用程序代码来读取和写入，并且通常无法访问常用工具（例如 unix 命令行程序和文本编辑器）。换句话说，自定义格式通常是"不透明的数据块"。要访问自定义应用程序文件格式的内容，需要一个专门设计用于读取和/或写入该格式的工具。

1.  **文件堆叠格式**。有时候应用程序状态被存储为一个文件层次结构。Git 就是一个典型的例子，虽然这种现象经常在一次性和定制的应用程序中出现。文件堆叠格式实质上是将文件系统用作键/值数据库，将小块信息存储到单独的文件中。这使得内容更容易被常见的实用程序（如文本编辑器或者"awk"或者"grep"）访问。但即使在文件堆叠格式中许多文件是容易读取的，通常也会有一些文件有着自己的自定义格式（例如：Git 的"Packfiles"）因此是"不透明的块"，没有专门的工具是不可读或可写的。另外，将文件堆叠从一处或一台机器移到另一处或另一台机器上并不是那么方便，而将一个单一文件移动则更为方便。比如，将文件堆叠文档作为邮件附件发送也是很困难的。最后，文件堆叠格式破坏了"文件隐喻"：没有一个用户可以指出的文件是"该文件"。

1.  **封装的文件堆叠格式**。一些应用程序使用文件堆叠，然后封装到某种单一文件容器中，通常是 ZIP 档案。EPUB、ODT 和 ODP 就是这种方法的例子。EPUB 书籍实际上就是一个包含书籍章节文本的各种 XHTML 文件、艺术作品的 GIF 和 JPEG 图像以及一个告诉电子书阅读器所有 XML 和图像文件如何组合在一起的专门目录文件的 ZIP 档案。OpenOffice 文档（ODT 和 ODP）也是包含 XML 和图像表示其内容的 ZIP 档案，以及显示组成部分之间相互关系的"目录"文件。

    包装的文件堆格式是完全自定义文件格式和纯粹的文件堆格式之间的折衷。包装的文件堆格式在某种程度上不像自定义格式中的不透明数据块那样，因为组件部分仍然可以使用任何常见的 ZIP 压缩工具访问，但该格式不像纯粹的文件堆格式那样易于访问，因为使用该格式仍然需要 ZIP 压缩工具，并且通常不能直接在文件层次结构上使用诸如 "find" 这样的命令行工具而不先解压它。另一方面，包装的文件堆格式通过将所有内容放入单个磁盘文件中来保留文档隐喻。并且由于其压缩，包装的文件堆格式往往更紧凑。

    与自定义文件格式一样，与纯粹的文件堆格式不同，包装的文件堆格式不容易编辑，因为通常必须重写整个文件才能更改任何组件部分。

本文旨在支持第四种新类别的应用文件格式：SQLite 数据库文件。

## SQLite 作为应用文件格式

任何可以记录在文件堆中的应用状态也可以记录在具有简单键/值模式的 SQLite 数据库中，如下所示：

> ```sql
> CREATE TABLE files(filename TEXT PRIMARY KEY, content BLOB);
> 
> ```

如果内容经过压缩，那么这种 SQLite 归档 数据库会与等效的 ZIP 归档 大小相同（±1%），并且具有能够更新单独的 "文件" 而无需重写整个文档的优势。

但是，SQLite 数据库并不仅限于简单的键/值结构，如文件堆积数据库。一个 SQLite 数据库可以有数十个、数百个或数千个不同的表，每个表都可以有数十个、数百个或数千个字段，每个字段都具有不同的数据类型、约束和特定含义，彼此交叉引用，适当地和自动地索引以便快速检索，而且所有数据高效且紧凑地存储在一个单独的磁盘文件中。而所有这些结构都通过 SQL 模式简洁地为人类文档化。

换句话说，SQLite 数据库可以做到文件堆积或包装文件堆积格式所能做的一切，而且更多，且更加清晰明了。SQLite 数据库是比键/值文件系统或 ZIP 档案更为多才多艺的容器。（详细示例请参阅 OpenOffice 案例研究论文。）

理论上可以通过自定义文件格式实现 SQLite 数据库的强大功能。但是，任何一个与关系数据库同样表达能力的自定义文件格式很可能需要一个庞大的设计规范，并且需要许多数万行的代码来实现。而最终的结果将是一个需要专门工具才能访问的“不透明块”。

相对于其他方法，将 SQLite 数据库作为应用文件格式具有明显的优势。以下是其中几点优势，逐条列举并详细说明：

1.  **简化应用程序开发。** 读取或写入应用程序文件不需要编写新代码。只需链接 SQLite 库，或者将 单一的 "sqlite3.c" 源文件 包含到应用程序的其余 C 代码中，SQLite 将负责处理所有应用程序文件的 I/O 操作。这可以大大减少应用程序代码的行数，从而节省开发和维护成本。

    SQLite 是世界上使用最广泛的软件库之一。每天在智能手机、设备和桌面应用程序中使用的 SQLite 数据库文件数量可达数十亿之多。SQLite 经过严格测试，被证明非常可靠。它不需要太多的调优或调试，使开发者可以集中精力解决应用程序逻辑。

1.  **单文件文档。** SQLite 数据库包含在单个文件中，可以轻松复制、移动或附加。保留了“文档”比喻。

    SQLite 没有任何文件命名要求，因此应用程序可以使用任何自定义文件后缀来帮助识别文件作为应用程序的一部分。SQLite 数据库文件在其头部包含一个 4 字节的应用程序 ID，可以设置为应用程序定义的值，然后用于诸如[file(1)](http://linux.die.net/man/1/file)之类的实用程序中，进一步增强文档的比喻。

1.  **高级查询语言。** SQLite 是完整的关系数据库引擎，这意味着应用程序可以使用高级查询访问内容。应用开发者无需花费时间考虑如何从文档中检索所需信息。开发者编写 SQL 来表达他们想要的信息，让数据库引擎来决定如何最好地检索内容。这有助于开发者保持“高效操作”，集中精力解决用户问题，避免花费时间在低级文件格式化细节上。

    堆栈文件格式可以被视为键/值数据库。键/值数据库比没有数据库好得多。但是没有事务、索引、高级查询语言或适当的模式，使用键/值数据库比关系数据库更难且更容易出错。

1.  **可访问内容。** 存储在 SQLite 数据库文件中的信息可以使用常见的开源命令行工具访问 - 这些工具默认安装在 Mac 和 Linux 系统上，并作为一个独立的 EXE 文件在 Windows 上免费提供。与自定义文件格式不同，不需要特定于应用程序的程序来读取或写入 SQLite 数据库中的内容。SQLite 数据库文件不是一个不透明的块。的确，像文本编辑器、"grep"或"awk"之类的命令行工具在 SQLite 数据库上不起作用，但 SQL 查询语言是一种更强大和方便的查看内容的方式，因此不能使用 "grep"、"awk"等工具不被视为损失。

    SQLite 数据库是定义明确且有文档支持的文件格式，目前被数百万应用广泛使用，并且向后兼容至 2004 年的发布，并承诺在未来几十年内仍然保持兼容性。对于定制应用程序来说，SQLite 数据库文件的长寿特别重要，因为它可以在原始应用程序的所有痕迹都丢失后的未来很长时间内访问文档内容。数据比代码更持久。SQLite 数据库被美国国会图书馆推荐作为长期保存数字内容的存储格式。

1.  **跨平台。** SQLite 数据库文件在 32 位和 64 位机器之间、大端和小端架构之间、以及各种风格的 Windows 和类 Unix 操作系统之间都是可移植的。使用 SQLite 应用文件格式的应用程序可以存储二进制数字数据，而不必担心整数或浮点数的字节顺序。文本内容可以按 UTF-8、UTF-16LE 或 UTF-16BE 读取或写入，并且 SQLite 会自动进行必要的即时转换。

1.  **原子事务。** 写入 SQLite 数据库的操作是原子性的。它们要么完全发生，要么完全不发生，即使在系统崩溃或断电时也是如此。因此，即使在将更改写入磁盘的同时电源突然中断，也不会因此而损坏文档。

    SQLite 是事务性的，意味着可以将多个更改组合在一起，要么全部发生，要么全部不发生，并且如果在提交之前发现问题，则可以回滚更改。这允许应用程序逐步进行更改，然后在将更改提交到磁盘之前对生成的数据进行各种健全性和一致性检查。[Fossil](http://www.fossil-scm.org/) 分布式版本控制系统 [使用这种技术](http://www.fossil-scm.org/fossil/doc/tip/www/selfcheck.wiki) 来验证在每次更改之前未丢失任何存储库历史。

1.  **增量和连续更新。** 当向 SQLite 数据库文件写入时，只会将实际更改的部分写入磁盘。这使得写入速度更快，并减少了对 SSD 的磨损。这与自定义和封装的文件堆格式相比具有巨大的优势，后者通常需要重新编写整个文档才能更改单个字节。纯文件堆格式在某种程度上也可以进行增量更新，尽管与 SQLite（单个页面）相比，写入的粒度通常更大。

    SQLite 还支持连续更新。不是将更改收集在内存中，然后仅在执行“文件/保存”操作时将其写入磁盘，而是可以在发生更改时立即将其写回磁盘。这样可以避免在系统崩溃或断电时丢失工作。一个使用触发器管理的自动化撤销/重做堆栈可以保留在磁盘上的数据库中，这意味着可以跨会话边界进行撤销/重做。

1.  **易于扩展。** 随着应用程序的增长，可以通过向模式添加新表或向现有表添加新列，简单地扩展 SQLite 应用程序文件格式。添加列或表不会改变先前查询的含义，因此只需小心确保保留旧列和表的含义，就可以保持向后兼容性。

    当然，自定义或一堆文件格式也可以扩展，但这样做通常要困难得多。如果添加了索引，那么必须定位并修改所有更改相应表的应用程序代码，以保持这些索引的最新状态。如果添加了列，则必须定位并修改所有访问相应表的应用程序代码，以考虑新列。

1.  **性能。** 在许多情况下，SQLite 应用程序文件格式比一堆文件格式或自定义格式**更快**。除了在原始读写操作上更快之外，SQLite 通常还会显著改善启动时间，因为应用程序无需读取并解析整个文档到内存中，而是可以通过查询仅提取初始化屏幕所需的信息。随着应用程序的进行，它只需加载足够绘制下一个屏幕所需的内容，并且可以丢弃不再使用的先前屏幕的信息。这有助于保持应用程序的内存占用量在控制范围内。

    像 SQLite 一样，可以逐步读取堆叠文件格式。但许多开发人员惊讶地发现，SQLite 可以更快地从其数据库中读取和写入较小的 BLOB（小于约 100KB 的大小），而不是从文件系统中作为单独文件读取或写入这些 BLOB。 (参见 比文件系统快 35% 和 内部与外部 BLOB 以获取更多信息。) 然而，操作关系数据库引擎会带来一定的开销，但不应假设直接文件 I/O 比 SQLite 数据库 I/O 更快，因为通常情况下并非如此。

    无论哪种情况，如果在 SQLite 应用中出现性能问题，通常可以通过向模式添加一两个 CREATE INDEX 语句或者运行 ANALYZE 一次来解决这些问题，而无需触及任何一行应用代码。但是，如果在自定义或堆叠文件格式中出现性能问题，则通常需要对应用代码进行大量更改，以添加和维护新的索引或使用不同的算法提取信息。

1.  **多进程并发使用。** SQLite 自动协调多个线程和/或进程从同一文档中进行并发访问。两个或更多应用程序可以同时连接并从同一文档中读取。写操作是串行化的，但由于写操作通常只需毫秒级时间，因此应用程序只需轮流进行写操作。SQLite 自动确保文档的底层格式不被破坏。相比之下，在自定义或堆叠文件格式中实现相同功能需要应用程序中的大量支持。而支持并发性所需的应用逻辑是一个臭名昭著的错误源。

1.  **多种编程语言。** 虽然 SQLite 本身是用 ANSI-C 编写的，但几乎可以为你所能想到的每一种编程语言提供接口：C++、C#、Objective-C、Java、Tcl、Perl、Python、Ruby、Erlang、JavaScript 等等。因此，程序员可以使用他们最熟悉且最适合项目需求的任何语言进行开发。

    在存在一组或“联邦”独立程序的情况下，SQLite 应用程序文件格式是一个极佳的选择，这种情况在研究或实验室环境中经常出现，其中一个团队负责数据采集，其他团队负责各个分析阶段。每个团队可以使用他们最熟悉的硬件、操作系统、编程语言和开发方法论，只要所有程序使用具有共同模式的 SQLite 数据库，它们就可以互操作。

1.  **更好的应用程序。** 如果应用程序文件格式是一个 SQLite 数据库，那么该文件格式的完整文档包括数据库模式，可能还会有一些关于每个表和列代表的额外说明。另一方面，自定义文件格式的描述通常会延续数百页。虽然文件堆叠格式比完全自定义格式简单得多且更容易描述，但仍然比 SQL 模式转储要大得多且更复杂，因为仍需描述各个文件的名称和格式。

    这并非一个琐碎的观点。清晰、简洁且易于理解的文件格式是任何应用程序设计中至关重要的一部分。在他有史以来最畅销的计算机科学著作《人月神话》中，Fred Brooks 如是说：

    > *表达是计算机编程的本质。
    > 
    > ...
    > 
    > *给我看你的流程图，隐藏你的表，我将继续感到困惑。给我看你的表，我通常就不需要你的流程图；它们会很明显。*

    罗布·派克在他的*编程规则*中以这样的方式表达了相同的观点：

    > *数据至上。如果你选择了合适的数据结构并组织得当，算法几乎总是不言自明的。数据结构，而不是算法，是编程的核心。*

    Linus Torvalds 在 2006-06-27 年的 Git 邮件列表上用不同的措辞表达了同样的观点：

    > *糟糕的程序员担心代码。好的程序员关心数据结构及其关系。*

    关键在于：一个 SQL 数据库模式几乎总是更好地定义和组织表和数据结构及其关系。拥有清晰、简明和明确定义的表示几乎总是会导致一个性能更好、问题更少、更易开发和维护的应用程序。

## 结论

对于每种情况，SQLite 都不是完美的应用文件格式。但在许多情况下，SQLite 是远比自定义文件格式、一堆文件或包装一堆文件更好的选择。SQLite 是一个高级、稳定、可靠、跨平台、广泛部署、可扩展、高性能、易访问、并发的文件格式。在你的下一个应用设计中，它值得成为标准文件格式。
