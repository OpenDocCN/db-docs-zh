# 1\. SQLite 共享缓存模式

> 原文：[`sqlite.com/sharedcache.html`](https://sqlite.com/sharedcache.html)

从 版本 3.3.0（2006-01-11）开始，SQLite 包括一种特殊的“共享缓存”模式（默认情况下禁用），旨在用于嵌入式服务器。如果启用了共享缓存模式，并且一个线程建立了对同一数据库的多个连接，这些连接将共享单一的数据和模式缓存。这可以显著减少系统所需的内存和 IO 操作量。

在 版本 3.5.0（2007-09-04）中，共享缓存模式被修改，使得相同的缓存可以在整个进程中共享，而不仅仅在单个线程内。在这一变更之前，存在于线程间传递数据库连接的限制。这些限制在 3.5.0 更新中被取消。本文档描述了版本 3.5.0 中的共享缓存模式。

在某些情况下，共享缓存模式改变了锁定模型的语义。这些细节由本文档描述。假定对正常的 SQLite 锁定模型有基本的理解（详情请参见 SQLite 版本 3 中的文件锁定与并发性）。

## 1.1\. 不建议使用共享缓存

共享缓存模式是一个已经过时的功能。不建议使用共享缓存模式。大多数共享缓存的使用场景通过 WAL 模式 更好地实现。

共享缓存模式是在 2006 年由 [Symbian](https://zh.wikipedia.org/wiki/Symbian) 的开发人员请求发明的。他们的问题是，如果手机上的联系人数据库正在同步，那么会锁定数据库文件。然后，如果有来电，数据库锁将阻止他们查询联系人数据库以查找适当的铃声或显示来电者的照片等信息。 WAL 模式（约 2010 年）是这个问题的更好解决方案，因为它允许在不破坏事务隔离的情况下进行同时访问。

鼓励从源代码构建他们自己的 SQLite 的应用程序使用 -DSQLITE_OMIT_SHARED_CACHE 编译时选项，因为生成的二进制文件将更小更快。

这里描述的共享缓存接口将继续在 SQLite 中得到支持，以确保完全向后兼容。然而，不建议使用共享缓存。

# 2\. 共享缓存锁模型

从另一个进程或线程的角度来看，使用共享缓存的两个或更多个 数据库连接 看起来像是单个连接。用于在多个共享缓存或常规数据库用户之间进行仲裁的锁定协议在其他地方描述。

| ![](img/112aab80027912de767daa79863773dc.png) |
| --- |

图 1

图 1 显示了一个运行时配置示例，其中建立了三个数据库连接。连接 1 是一个普通的 SQLite 数据库连接。连接 2 和连接 3 共享一个缓存。用于在连接 2 和连接 3 之间序列化（或不序列化，参见下文的“读未提交隔离模式”）访问共享缓存的内部协议在本节的其余部分描述。

共享缓存锁定模型有三个级别，即事务级别锁定、表级别锁定和模式级别锁定。它们在以下三个小节中描述。

## 2.1\. 事务级别锁定

SQLite 连接可以打开两种类型的事务，读事务和写事务。这并不是显式执行的，事务隐式地是一个读事务，直到首次向数据库表写入，此时它变成一个写事务。

在单个共享缓存中，最多只能有一个连接同时打开写事务。这可以与任意数量的读事务共存。

## 2.2\. 表级别锁定

当两个或更多连接使用共享缓存时，锁定用于在每个表的基础上序列化并发访问尝试。表支持两种类型的锁定，“读锁定”和“写锁定”。锁定授予连接 - 同一时间，每个数据库连接对每个数据库表要么具有读锁定、写锁定，要么没有锁定。

同一时间，单个表可以具有任意数量的活动读锁或单个活动写锁。要从表中读取数据，连接必须首先获取读锁。要向表中写入数据，连接必须在该表上获取写锁。如果无法获取所需的表锁定，则查询失败，并返回 SQLITE_LOCKED 给调用者。

一旦连接获取了表锁定，直到当前事务（读或写）结束为止，该锁定才会被释放。

### 2.2.1\. 读未提交隔离模式

上述行为可以通过使用 read_uncommitted pragma 轻微修改，从串行化（默认）修改为读未提交的隔离级别。

在读未提交模式下的数据库连接在从数据库表中读取之前不会尝试获取读锁，如上所述。如果另一个数据库连接在读取时修改了表，可能导致查询结果不一致，但这也意味着由读未提交模式中的连接打开的读事务既不会被阻塞也不会阻塞其他任何连接。

读未提交模式对写入数据库表所需的锁定没有影响（即，读未提交连接仍然必须获取写锁定，因此数据库写入可能仍然会被阻塞或被阻塞）。此外，读未提交模式对下面列出的规则所需的 sqlite_schema 锁也没有影响（请参见“模式（sqlite_schema）级别锁定”章节）。

> ```sql
>   /* Set the value of the read-uncommitted flag:
>   **
>   **   True  -> Set the connection to read-uncommitted mode.
>   **   False -> Set the connection to serialized (the default) mode.
>   */
>   PRAGMA read_uncommitted = <boolean>;
> 
>   /* Retrieve the current value of the read-uncommitted flag */
>   PRAGMA read_uncommitted;
> 
> ```

## 2.3\. 模式（sqlite_schema）级锁定

表 sqlite_schema 与所有其他数据库表一样支持共享缓存读写锁（请参见上述说明）。还有以下特殊规则适用：

+   在访问任何数据库表或获取任何其他读或写锁之前，连接必须在*sqlite_schema*上获取读锁。

+   在执行修改数据库模式的语句（如 CREATE 或 DROP TABLE 语句）之前，连接必须在*sqlite_schema*上获取写锁。

+   如果任何其他连接持有对任何附加数据库（包括默认数据库“main”）的*sqlite_schema*表的写锁，则连接可能无法编译 SQL 语句。

# 3\. 与线程相关的问题

在启用共享缓存模式的 SQLite 版本 3.3.0 至 3.4.2 中，数据库连接只能由调用 sqlite3_open()创建它的线程使用。连接也只能与同一线程中的另一个连接共享缓存。这些限制从 SQLite 版本 3.5.0（2007-09-04）开始被取消。

# 4\. 共享缓存和虚拟表

在较旧版本的 SQLite 中，无法将共享缓存模式与虚拟表一起使用。此限制在 SQLite 版本 3.6.17（2009-08-10）中被移除。

# 5\. 启用共享缓存模式

共享缓存模式是基于进程的。使用 C 接口，可以使用以下 API 全局启用或禁用共享缓存模式：

> ```sql
> int sqlite3_enable_shared_cache(int);
> 
> ```

每次调用 sqlite3_enable_shared_cache()都会影响使用 sqlite3_open()、sqlite3_open16()或 sqlite3_open_v2()创建的后续数据库连接。已存在的数据库连接不受影响。每次调用 sqlite3_enable_shared_cache()都会覆盖同一进程中先前的所有调用。

使用 sqlite3_open_v2()创建的单独数据库连接可以通过在第三个参数中使用 SQLITE_OPEN_SHAREDCACHE 或 SQLITE_OPEN_PRIVATECACHE 标志来选择是否参与共享缓存模式。使用这些标志之一将覆盖由 sqlite3_enable_shared_cache()建立的全局共享缓存模式设置。不应同时使用 SQLITE_OPEN_SHAREDCACHE 和 SQLITE_OPEN_PRIVATECACHE 标志；如果在 sqlite3_open_v2()的第三个参数中同时使用这两个标志，则行为未定义。

当使用 URI 文件名时，可以使用 "cache" 查询参数来指定数据库是否使用共享缓存。使用 "cache=shared" 来启用共享缓存，使用 "cache=private" 来禁用共享缓存。使用 URI 查询参数来指定数据库连接的缓存共享行为允许在 ATTACH 语句中控制缓存共享。例如：

> ```sql
> ATTACH 'file:aux.db?cache=shared' AS aux;
> 
> ```

# 6\. 共享缓存和内存数据库

从 SQLite 版本 3.7.13（2012-06-11）开始，可以在创建使用 URI 文件名的内存数据库时使用共享缓存。为了向后兼容，如果使用未加修饰的名称 ":memory:" 打开数据库，则始终禁用内存数据库的共享缓存。在版本 3.7.13 之前，无论使用的数据库名称、当前系统共享缓存设置还是查询参数或标志如何，内存数据库的共享缓存始终被禁用。

启用内存数据库的共享缓存允许同一进程中的两个或多个数据库连接访问同一个内存数据库。共享缓存中的内存数据库在最后一个连接关闭时会自动删除并释放内存。
