# 1\. 概述

> 原文：[`sqlite.com/wal.html`](https://sqlite.com/wal.html)

SQLite 实现 原子提交和回滚 的默认方法是使用 回滚日志。从 3.7.0 版本（2010-07-21）开始，新增了一种称为 "写前日志"（WAL）的选项。

使用 WAL 而不是回滚日志有其优缺点。优点包括：

1.  在大多数情况下，WAL 明显更快。

1.  WAL 提供更高的并发性，因为读者不会阻塞写者，写者也不会阻塞读者。读写可以并发进行。

1.  使用 WAL 时，磁盘 I/O 操作通常更加顺序化。

1.  在 WAL 模式下，使用的 fsync() 操作较少，因此在 fsync() 系统调用存在问题的系统上，它不太容易出现问题。

但是也存在一些缺点：

1.  WAL 通常要求 VFS 支持共享内存原语。（例外情况：无共享内存的 WAL）内置的 unix 和 windows VFS 支持此功能，但是针对自定义操作系统的第三方扩展 VFS 可能不支持。

1.  使用数据库的所有进程必须在同一台主机上；WAL 不适用于网络文件系统。

1.  跨多个 ATTACHed 数据库进行更改的事务在每个单独的数据库中是原子的，但在所有数据库作为一个集合时却不是原子的。

1.  进入 WAL 模式后，无论是在空数据库上，还是通过使用 VACUUM 或通过使用 备份 API 从备份中恢复，都不能更改 page_size。更改页面大小必须处于回滚日志模式。

1.  自 版本 3.22.0 (2018-01-22) 起，如果 `-shm` 和 `-wal` 文件已经存在，或者可以创建这些文件，或者数据库是不可变的，可以打开一个只读的 WAL 模式数据库文件。

1.  在大多数是读取而很少写入的应用程序中，WAL 可能比传统的回滚日志方法稍微慢一些（也许慢 1% 或 2%）。

1.  每个数据库都有一个额外的准持久化 `-wal` 文件和与之关联的 `-shm` 共享内存文件，这使得 SQLite 在作为应用程序文件格式时显得不太合适。

1.  还有一个额外的操作是检查点，虽然默认情况下是自动的，但应用程序开发者仍需注意这一点。

1.  自 版本 3.11.0 (2016-02-15) 起，WAL 模式在处理大事务时与回滚模式一样高效。

# 2\. WAL 的工作原理

传统的回滚日志工作方式是将原始未更改的数据库内容的副本写入单独的回滚日志文件，然后直接将更改写入数据库文件。在崩溃或回滚时，回滚日志中包含的原始内容将播放回数据库文件，将数据库文件恢复到其原始状态。提交时删除回滚日志。

WAL 方法则相反。原始内容保留在数据库文件中，并将更改附加到单独的 WAL 文件中。当追加到 WAL 的特殊记录指示提交时，提交即发生。因此，可以在不写入原始数据库的情况下执行提交，这允许读者继续从原始未更改的数据库中操作，同时将更改同时提交到 WAL 中。多个事务可以附加到单个 WAL 文件的末尾。

## 2.1\. 检查点

当然，最终希望将附加在 WAL 文件中的所有事务转移到原始数据库中。将 WAL 文件事务转移到数据库中称为"*检查点*"。

另一种思考回滚和预写日志之间差异的方式是，在回滚日志方法中，有两种原始操作，读取和写入，而使用预写日志则有三种原始操作：读取、写入和**检查点**。

默认情况下，SQLite 在 WAL 文件达到 1000 页的阈值大小时会自动执行检查点操作。（SQLITE_DEFAULT_WAL_AUTOCHECKPOINT 编译时选项可用于指定不同的默认值。）使用 WAL 的应用程序无需采取任何措施即可执行这些检查点。但如果它们希望，应用程序可以调整自动检查点的阈值。或者它们可以关闭自动检查点，并在空闲时段或在单独的线程或进程中运行检查点。

## 2.2\. 并发性

当在 WAL 模式数据库上开始读取操作时，首先记住 WAL 中最后一个有效提交记录的位置。将此点称为“结束标记”。因为 WAL 可以在各个读者连接到数据库时继续增长并添加新的提交记录，所以每个读者可能会有自己的结束标记。但对于任何特定的读者，在事务期间结束标记不会改变，因此确保单个读取事务只能看到数据库在某个特定时间点存在的内容。

当读取者需要页面内容时，首先检查 WAL，查看页面是否出现在其中，如果是，则拉取读取者结束标记之前在 WAL 中出现的页面的最后一个副本。如果在读取者结束标记之前的 WAL 中不存在页面的副本，则从原始数据库文件中读取页面。由于读取者可以存在于单独的进程中，为了避免强制每个读取者扫描整个 WAL 以寻找页面（WAL 文件的大小可能会增长到多兆字节，这取决于检查点运行的频率），维护了一个称为“wal-index”的数据结构在共享内存中，帮助读取者快速定位 WAL 中的页面，并尽量减少 I/O 操作。wal-index 大大提高了读取者的性能，但由于使用了共享内存，这意味着所有读取者必须存在于同一台机器上。这就是为什么预写式日志实现在网络文件系统上无法工作的原因。

写入者只需将新内容追加到 WAL 文件的末尾。因为写入者不会执行任何会干扰读取者操作的动作，所以写入者和读取者可以同时运行。但由于只有一个 WAL 文件，因此一次只能有一个写入者。

检查点操作将 WAL 文件中的内容传输回原始数据库文件。检查点可以与读取者并发运行，但当检查点达到超过任何当前读取者结束标记的 WAL 页面时，必须停止检查点。检查点必须在那一点停止，因为否则它可能会覆盖读取者正在活跃使用的数据库文件的部分。检查点在 wal-index 中记住它的进展，并将在下一次调用时从离开的地方继续将 WAL 中的内容传输到数据库中。

因此，一个长时间运行的读取事务可能会阻止检查点进展。但可以假设每个读取事务最终都会结束，检查点就可以继续进行。

每当发生写操作时，写入器会检查检查点的进度，如果整个 WAL 已转移至数据库并已同步，并且没有读取器在使用 WAL，则写入器将倒回 WAL 到开头，并开始将新事务放在 WAL 的开头。这种机制防止 WAL 文件无限增长。

## 2.3\. 性能考虑

写入事务非常快，因为它们只涉及写入内容一次（与回滚日志事务相比需要写入两次），并且写入是顺序的。此外，只要应用程序愿意在断电或硬重启后牺牲耐久性，就不需要将内容同步到磁盘。（如果 PRAGMA synchronous 设置为 FULL，则写入器在每个事务提交时同步 WAL，但如果设置为 NORMAL，则省略此同步。）

另一方面，随着 WAL 文件的增长，读取性能会下降，因为每个读取器必须检查 WAL 文件的内容，检查所需的时间与 WAL 文件的大小成正比。wal-index 有助于更快地查找 WAL 文件中的内容，但随着 WAL 文件大小的增加，性能仍会下降。因此，为了保持良好的读取性能，通过定期运行检查点来控制 WAL 文件的大小至关重要。

Checkpointing 在避免由于断电或硬重启而导致数据库损坏的可能性时需要进行同步操作。在将 WAL 内容移动到数据库之前，必须将 WAL 同步到持久存储，并且在重置 WAL 之前必须将数据库文件同步。Checkpoint 还需要更多的寻址操作。Checkpointer 会尽可能多地将数据库写为顺序页面（页面按升序从 WAL 转移到数据库），但即使如此，页面写入中通常会有许多寻址操作穿插其中。这些因素结合起来使得 checkpoints 比写入事务慢。

默认策略是允许连续的写入事务增加 WAL 的大小，直到 WAL 的大小达到大约 1000 页，然后为每个后续的 COMMIT 运行一次 checkpoint 操作，直到将 WAL 重置为小于 1000 页为止。默认情况下，checkpoint 将由执行将 WAL 推到其大小限制以上的 COMMIT 的同一线程自动运行。这使得大多数 COMMIT 操作非常快，但偶尔会有较慢的 COMMIT（触发 checkpoint 的那些）。如果这种效果不理想，则应用程序可以禁用自动 checkpoint 并在单独的线程或进程中运行定期 checkpoints。 （可以查看 下面 显示的命令和接口来实现这一点。）

注意，当将 PRAGMA synchronous 设置为 NORMAL 时，checkpoint 是唯一会发出 I/O 屏障或同步操作（unix 上的 fsync()或 windows 上的 FlushFileBuffers()）。因此，如果应用程序在单独的线程或进程中运行 checkpoint，执行数据库查询和更新的主线程或进程将永远不会因为同步操作而阻塞。这有助于防止在忙碌的磁盘驱动器上运行的应用程序出现"latch-up"。这种配置的缺点是事务不再是持久的，可能会在断电或硬重置后回滚。

同样要注意的是，平均读性能和平均写性能之间存在权衡。为了最大化读性能，应该尽可能保持 WAL 尽可能小，并因此频繁运行 checkpoint，甚至可能在每个 COMMIT 后运行一次。为了最大化写性能，应该将每次 checkpoint 的成本分摊到尽可能多的写操作上，这意味着应该不经常运行 checkpoint，并允许 WAL 在每次 checkpoint 之前尽可能增长。因此，决定何时运行 checkpoint 的频率可能因应用程序的相对读写性能需求而异。默认策略是一旦 WAL 达到 1000 页就运行一次 checkpoint，在工作站上的测试应用程序中，这种策略似乎效果很好，但在不同平台或不同工作负载下可能有更好的策略。

# 3\. 激活和配置 WAL 模式

SQLite 数据库连接默认为 journal_mode=DELETE。要转换为 WAL 模式，请使用以下 pragma：

> ```sql
> PRAGMA journal_mode=WAL;
> 
> ```

pragma `journal_mode` 返回一个字符串，表示新的日志模式。成功时，该 pragma 将返回字符串 "`wal`"。如果无法完成转换为 WAL（例如，如果 VFS 不支持必要的共享内存原语），则日志模式将保持不变，并且从原始原语返回的字符串将是先前的日志模式（例如 "`delete`"）。

## 3.1\. 自动检查点

默认情况下，SQLite 将在 WAL 文件大小达到 1000 页或更大时，或者当数据库文件上的最后一个连接关闭时，自动进行检查点。默认配置旨在适用于大多数应用程序。但是，希望获得更多控制的程序可以使用 wal_checkpoint pragma 强制进行检查点，或者通过调用 sqlite3_wal_checkpoint() C 接口。可以通过使用 wal_autocheckpoint pragma 或者调用 sqlite3_wal_autocheckpoint() C 接口来更改自动检查点阈值或完全禁用自动检查点。程序还可以使用 sqlite3_wal_hook() 注册回调函数，在每次事务提交到 WAL 时调用回调函数。然后，此回调函数可以根据其认为合适的任何标准调用 sqlite3_wal_checkpoint() 或 sqlite3_wal_checkpoint_v2()。（自动检查点机制实现为围绕 sqlite3_wal_hook() 的简单包装。）

## 3.2\. 应用程序启动的检查点

应用程序可以通过在数据库上任何可写的数据库连接上调用 sqlite3_wal_checkpoint()或 sqlite3_wal_checkpoint_v2()来启动检查点。有三种检查点子类型，它们在执行时的严格程度不同：PASSIVE（被动）、FULL（完全）和 RESTART（重启）。默认检查点样式是 PASSIVE，它尽可能多地工作而不干扰其他数据库连接，并且如果有并发的读取或写入可能不会完全执行。所有由 sqlite3_wal_checkpoint()和自动检查点机制启动的检查点都是 PASSIVE。FULL 和 RESTART 检查点会更努力地执行检查点以完成，只能通过调用 sqlite3_wal_checkpoint_v2()来启动。有关 FULL 和 RESET 检查点的更多信息，请参阅 sqlite3_wal_checkpoint_v2()文档。

## 3.3\. WAL 模式的持久性

与其他日志记录模式不同，PRAGMA journal_mode=WAL 是持久的。如果一个进程设置了 WAL 模式，然后关闭并重新打开数据库，数据库将以 WAL 模式重新打开。相比之下，如果一个进程设置（例如）PRAGMA journal_mode=TRUNCATE，然后关闭并重新打开数据库，数据库将以默认的回滚模式 DELETE 而不是之前的 TRUNCATE 设置重新打开。

WAL 模式的持久性意味着应用程序可以将 SQLite 转换为使用 WAL 模式而不必对应用程序本身进行任何更改。只需使用命令行 shell 或其他实用工具在数据库文件上运行"`PRAGMA journal_mode=WAL;`"，然后重新启动应用程序。

如果在任何一个连接上设置了 WAL 模式，则将在同一数据库文件的所有连接上设置 WAL 日志记录模式。

# 4\. WAL 文件

当在 WAL 模式下的数据库上有一个 数据库连接 打开时，SQLite 会维护一个额外的日志文件，称为 "Write Ahead Log" 或 "WAL 文件"。这个文件在磁盘上的名称通常是数据库文件名加上额外的 "`-wal`" 后缀，尽管如果 SQLite 使用了 SQLITE_ENABLE_8_3_NAMES，可能会适用不同的命名规则。

WAL 文件存在于任何 数据库连接 打开时。通常情况下，当最后一个连接到数据库的进程关闭时，WAL 文件会被自动删除。然而，如果最后一个拥有数据库连接的进程在没有干净关闭数据库连接的情况下退出，或者使用了 SQLITE_FCNTL_PERSIST_WAL 文件控制，那么 WAL 文件可能会在所有数据库连接关闭后仍然保留在磁盘上。WAL 文件是数据库的持久状态的一部分，如果数据库被复制或移动，应该与数据库一起保留。如果数据库文件与其 WAL 文件分离，那么之前提交到数据库的事务可能会丢失，或者数据库文件可能会损坏。删除 WAL 文件的唯一安全方式是使用 sqlite3_open() 接口打开数据库文件，然后立即使用 sqlite3_close() 关闭数据库。

WAL 文件格式 被精确定义，并且是跨平台的。

# 5\. 只读数据库

旧版本的 SQLite 无法读取只读的 WAL 模式数据库。换句话说，要读取 WAL 模式数据库需要写入访问权限。从 SQLite 版本 3.22.0 (2018-01-22) 开始，这个限制得到了放宽。

在较新版本的 SQLite 上，WAL 模式数据库在只读介质上，或者缺乏写权限的情况下，仍然可以被读取，只要满足以下一个或多个条件：

1.  `-shm`和`-wal`文件已经存在且可读。

1.  数据库所在目录具有写权限，以便创建`-shm`和`-wal`文件。

1.  数据库连接是使用不可变查询参数打开的。

尽管可以打开只读 WAL 模式数据库，但最好在将 SQLite 数据库映像刻录到只读介质之前将其转换为 PRAGMA journal_mode=DELETE 的良好做法。

# 6\. 避免过大的 WAL 文件

在正常情况下，新内容将被追加到 WAL 文件，直到 WAL 文件累积约 1000 页（大约 4MB 大小），此时会自动运行一个检查点并回收 WAL 文件。检查点通常不会截断 WAL 文件（除非设置了 journal_size_limit pragma）。相反，它仅使 SQLite 从头开始覆写 WAL 文件。这样做是因为覆盖现有文件通常比追加更快。当最后一个数据库连接关闭时，该连接会执行最后一个检查点，然后删除 WAL 文件及其关联的共享内存文件，以清理磁盘。

所以在绝大多数情况下，应用程序无需担心 WAL 文件。SQLite 会自动处理它。但是可能会导致 SQLite 处于一种状态，其中 WAL 文件会无限增长，导致磁盘空间使用过多和查询速度变慢。以下列出了一些可能发生这种情况的方式以及如何避免它们。

+   **禁用自动检查点机制。** 在其默认配置中，SQLite 将在 WAL 文件超过 1000 页长时，在任何事务结束时检查 WAL 文件。但是，存在可以禁用或延迟此自动检查点的编译时和运行时选项。如果应用程序禁用了自动检查点，则没有任何东西可以防止 WAL 文件过度增长。

+   **检查点饥饿。** 只有当没有其他数据库连接使用 WAL 文件时，检查点才能完成运行并重置 WAL 文件。如果另一个连接有一个打开的读取事务，则检查点无法重置 WAL 文件，因为这样做可能会在读取者下方删除内容。检查点将尽可能多地工作，而不会打扰读取者，但无法完成运行。在下一个写事务后，检查点将从上次中断的地方重新启动。这种情况重复发生，直到某个检查点能够完成。

    但是，如果数据库有许多并发的重叠读取者，并且始终至少有一个活动的读取者，则不会能够完成任何检查点，因此 WAL 文件将无限增长。

    可以通过确保存在“读取者间隙”来避免这种情况：即没有进程从数据库中读取并且在这些时间内尝试检查点。在具有许多并发读取者的应用程序中，也可以考虑使用 SQLITE_CHECKPOINT_RESTART 或 SQLITE_CHECKPOINT_TRUNCATE 选项手动运行检查点，这将确保检查点在返回之前完成。使用 SQLITE_CHECKPOINT_RESTART 和 SQLITE_CHECKPOINT_TRUNCATE 的缺点是，在检查点运行时，读取者可能会被阻塞。

+   **非常大的写事务。** 只有当没有其他事务运行时，检查点才能完成，这意味着无法在写事务中间重置 WAL 文件。因此，对大型数据库进行大量更改可能导致 WAL 文件变得非常大。一旦写事务完成（假设没有其他读者阻塞），WAL 文件将被检查点处理，但在此期间，文件可能会变得非常大。

    截至 SQLite 版本 3.11.0（2016-02-15），单个事务的 WAL 文件大小应与事务本身成比例。事务更改的页面只应写入 WAL 文件一次。但是，对于旧版 SQLite，如果事务增长超过页面缓存，同一页面可能会多次写入 WAL 文件。

# 7\. 实现 WAL-Index 的共享内存

wal-index 是通过普通文件实现的，用于提高鲁棒性。早期（预发布）的 WAL 模式实现将 wal-index 存储在易失性共享内存中，例如 Linux 上创建在/dev/shm 或其他 Unix 系统上的/tmp 文件。这种方法的问题在于，具有不同根目录的进程（通过[chroot](http://en.wikipedia.org/wiki/Chroot)更改）将看到不同的文件，因此使用不同的共享内存区域，导致数据库损坏。在各种 Unix 系统中，创建无名称的共享内存块的其他方法并不具有可移植性。我们无法找到任何在 Windows 上创建无名称共享内存块的方法。确保所有访问同一数据库文件的进程使用相同共享内存的唯一方法是通过在与数据库本身相同的目录中 mmapping 文件来创建共享内存。

使用普通磁盘文件作为共享内存的缺点在于，可能会通过将共享内存写入磁盘而执行不必要的磁盘 I/O 操作。然而，开发人员认为这并不是一个主要问题，因为 wal-index 很少超过 32 KiB 的大小，并且从不同步。此外，当最后一个数据库连接断开时，wal-index 的后备文件会被删除，这通常可以避免任何真正的磁盘 I/O 操作发生。

针对默认的共享内存实现不可接受的专用应用程序可以通过自定义的 VFS 设计替代方法。例如，如果已知特定数据库只会被单一进程内的线程访问，那么可以使用堆内存而不是真正的共享内存来实现 wal-index。

# 8\. 在没有共享内存的情况下使用 WAL

从 SQLite 版本 3.7.4（2010-12-07）开始，即使共享内存不可用，也可以创建、读取和写入 WAL 数据库，只要在第一次尝试访问之前将 locking_mode 设置为 EXCLUSIVE。换句话说，如果保证只有一个进程访问数据库，那么该进程可以与 WAL 数据库交互而不使用共享内存。此功能允许旧版的 VFSes 可以创建、读取和写入 WAL 数据库，这些 VFSes 缺乏在 sqlite3_io_methods 对象上的“版本 2”共享内存方法 xShmMap、xShmLock、xShmBarrier 和 xShmUnmap。

如果在第一个 WAL 模式数据库访问之前设置了 EXCLUSIVE 锁定模式，那么 SQLite 永远不会尝试调用任何共享内存方法，因此永远不会创建共享内存的 WAL 索引。在这种情况下，只要日志模式为 WAL，数据库连接就保持在 EXCLUSIVE 模式；尝试使用 "`PRAGMA locking_mode=NORMAL;`" 来更改锁定模式将不起作用。唯一更改出 EXCLUSIVE 锁定模式的方法是先退出 WAL 日志模式。

如果对第一个 WAL 模式数据库访问采用了 NORMAL 锁定模式，则会创建共享内存的 WAL 索引。这意味着底层 VFS 必须支持“版本 2”共享内存方法。如果 VFS 不支持共享内存方法，则尝试打开已经处于 WAL 模式的数据库，或者尝试将数据库转换为 WAL 模式，将会失败。只要有一个连接在使用共享内存的 WAL 索引，锁定模式可以在 NORMAL 和 EXCLUSIVE 之间自由切换。只有在省略共享内存的 WAL 索引时，也就是在第一个 WAL 模式数据库访问之前，锁定模式才会被固定在 EXCLUSIVE。

# 9\. 有时在 WAL 模式下查询会返回 SQLITE_BUSY

WAL 模式的第二个优势是写操作不会阻塞读操作，读操作也不会阻塞写操作。这在大多数情况下是正确的。但是在一些不太常见的情况下，针对 WAL 模式数据库的查询可能会返回 SQLITE_BUSY，因此应用程序应该为此偶发事件做好准备。

在 WAL 模式数据库中，可能会导致查询返回 SQLITE_BUSY 的情况包括以下几种：

+   如果另一个数据库连接以独占锁定模式打开数据库，则所有针对该数据库的查询都将返回 SQLITE_BUSY。Chrome 和 Firefox 都以独占锁定模式打开它们的数据库文件，因此在这些应用程序运行时尝试读取 Chrome 或 Firefox 数据库将会遇到此问题。

+   当最后一个连接到特定数据库关闭时，该连接将在清理 WAL 和共享内存文件时短暂获取独占锁定。如果在第一个连接仍在清理过程中时尝试打开和查询数据库，则第二个连接可能会遇到 SQLITE_BUSY 错误。

+   如果最后一个数据库连接崩溃，则第一个打开数据库的新连接将启动恢复过程。在恢复期间会持有独占锁定。因此，如果第三个数据库连接在第二个连接正在运行恢复时尝试插入并查询，则第三个连接将会遇到 SQLITE_BUSY 错误。

# 10\. 向后兼容性

WAL 模式下数据库文件格式未更改。但是，WAL 文件和 wal-index 是新概念，因此旧版本的 SQLite 不会知道如何恢复在发生崩溃时正在 WAL 模式下运行的 SQLite 数据库。为防止旧版本的 SQLite （早于版本 3.7.0，2010-07-22）尝试恢复 WAL 模式数据库（并使情况更糟），数据库文件格式版本号（在数据库头部的第 18 和 19 字节）在 WAL 模式下从 1 增加到 2。因此，如果旧版本的 SQLite 尝试连接处于 WAL 模式的 SQLite 数据库，它将报告类似于“文件已加密或不是数据库”的错误。

可以使用如下的 pragma 明确退出 WAL 模式：

> ```sql
> PRAGMA journal_mode=DELETE;
> 
> ```

退出 WAL 模式会将数据库文件格式版本号改回 1，这样旧版 SQLite 就能再次访问数据库文件。
