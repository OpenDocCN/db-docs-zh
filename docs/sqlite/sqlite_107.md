# SQLite 版本 3 概述

> 原文：[`sqlite.com/version3.html`](https://sqlite.com/version3.html)

| **编辑注释：** 本文档于 2004 年撰写，是为了指导那些从 SQLite2 迁移到 SQLite3 的程序员。它作为 SQLite 历史记录的一部分保留。现代程序员应参考本网站其他地方提供的更为实时的 SQLite 文档。 |
| --- |

SQLite 版本 3.0 对库引入了重要的更改，包括：

+   更为紧凑的数据库文件格式。

+   显式类型转换和 BLOB 支持。

+   支持 UTF-8 和 UTF-16 文本。

+   用户定义的文本排序序列。

+   64 位 ROWID。

+   改进的并发性。

本文档是针对已熟悉 SQLite 2.8 版本的用户的 SQLite 3.0 更改的快速介绍。

### 更名变更

SQLite 版本 2.8 将继续通过 bug 修复进行支持，可以预见的将来。为了允许 SQLite 版本 2.8 和 SQLite 版本 3.0 和平共处，SQLite 版本 3.0 中关键文件和 API 的名称已更改以包含字符 "3"。例如，用于 C 程序的包含文件已从 "sqlite.h" 更改为 "sqlite3.h"。用于与数据库交互的 shell 程序的名称也从 "sqlite.exe" 更改为 "sqlite3.exe"。通过这些更改，可以在同一系统上同时安装 SQLite 2.8 和 SQLite 3.0，并且可以使同一 C 程序同时链接并同时使用 SQLite 2.8 和 SQLite 3.0 库。

### 新文件格式

SQLite 数据库文件使用的格式已完全修订。旧版 2.1 格式和新版 3.0 格式不兼容。SQLite 2.8 版本将无法读取 3.0 版本的数据库文件，而 SQLite 3.0 版本也无法读取 2.8 版本的数据库文件。

要将 SQLite 2.8 数据库转换为 SQLite 3.0 数据库，请准备好两个版本（2.8 和 3.0）的命令行 shell。然后输入类似以下的命令：

> ```sql
> sqlite OLD.DB .dump | sqlite3 NEW.DB
> 
> ```

新的数据库文件格式使用 B+ 树来存储表格数据。在 B+ 树中，所有数据都存储在叶子节点中，而不是同时存储在叶子节点和中间分支节点中。使用 B+ 树来存储表格数据可以更好地实现可扩展性，并且在不使用溢出页面的情况下存储更大的数据字段。传统的 B 树仍然用于索引。

新文件格式还支持 512 到 65536 字节之间的可变页面大小。页面大小存储在文件头中，因此同一个库理论上可以读取具有不同页面大小的数据库，尽管这一特性尚未在实践中实现。

新文件格式从其磁盘映像中省略了未使用的字段。例如，索引仅使用 B 树记录的关键部分而不使用数据。因此，对于索引，记录数据长度的字段被省略。整数值（如关键字和数据的长度）使用可变长度编码存储，因此通常只需要一到两个字节来存储最常见的情况，但如果需要，可以编码高达 64 位的信息。整数和浮点数据以二进制形式存储在磁盘上，而不是像 SQLite 版本 2.8 中那样转换为 ASCII。这些变化综合起来导致数据库文件通常比 SQLite 版本 2.8 中相应的文件小 25%到 35%。

SQLite 版本 3.0 中使用的低级 B 树格式的详细信息可以在 [btreeInt.h](https://www.sqlite.org/src/finfo?name=src/btreeInt.h) 源文件的头部注释以及 文件格式 文档中找到。

### 显式类型和 BLOB 支持

SQLite 2.8 在内部处理各种格式的数据，但在写入磁盘或通过其 API 进行交互时，总是将数据转换为 ASCII 文本。相反，SQLite 3.0 向用户公开其内部数据表示，并在适当时将二进制表示存储到磁盘。公开非 ASCII 表示是为了支持 BLOBs。

SQLite 2.8 版本具有一个特性，即无论声明的列类型如何，任何类型的数据都可以存储在任何表列中。这一特性在 3.0 版本中得到保留，尽管形式稍有改变。每个表列都将存储任何类型的数据，尽管列对其声明的数据类型定义的格式具有偏好性。当数据插入到列中时，该列将尝试将数据格式转换为列声明的类型。所有 SQL 数据库引擎都会这样做。不同之处在于，SQLite 3.0 即使无法进行格式转换，仍会存储数据。

例如，如果您有一个声明为 "INTEGER" 类型的表列，并尝试插入一个字符串，该列将查看文本字符串并检查其是否类似于一个数字。如果字符串看起来像一个数字，则转换为数字，并且如果数字没有小数部分，则转换为整数，并以这种方式存储。但是，如果字符串不是格式良好的数字，则仍将其存储为字符串。类型为 "TEXT" 的列在存储之前会尝试将数字转换为 ASCII 文本表示。但是，BLOBs 作为 BLOBs 存储在 TEXT 列中，因为通常无法将 BLOB 转换为文本。

在大多数其他 SQL 数据库引擎中，数据类型与持有数据的表列相关联 - 与数据容器相关联。在 SQLite 3.0 中，数据类型与数据本身相关联，而不是与其容器相关联。[保罗·格雷厄姆](http://www.paulgraham.com/)在他的书 *[ANSI Common Lisp](http://www.paulgraham.com/acl.html)* 中称这种特性为 "显式类型"。其他作家对术语 "显式类型" 有其他定义，因此要注意混淆。但无论如何称呼，这就是 SQLite 3.0 支持的数据类型模型。

有关 SQLite 3.0 版本中数据类型的其他信息可在 单独页面 中找到。

### 支持 UTF-8 和 UTF-16

SQLite 3.0 的新 API 包含接受文本作为本地主机机器的 UTF-8 和 UTF-16 的例程。每个数据库文件将文本管理为 UTF-8、UTF-16BE（大端）或 UTF-16LE（小端）。在内部和磁盘文件中，所有地方都使用相同的文本表示。如果数据库文件指定的文本表示（在文件头中）与接口例程所需的文本表示不匹配，则文本将在运行时进行转换。不断将文本从一种表示转换为另一种表示可能会消耗大量计算资源，因此建议程序员选择一种表示并在其应用程序中坚持使用。

在当前的 SQLite 实现中，SQL 解析器仅适用于 UTF-8 文本。因此，如果您提供 UTF-16 文本，它将被转换。这只是一个实现问题，并且没有什么可以阻止 SQLite 的未来版本本地解析 UTF-16 编码的 SQL。

当创建新的用户定义的 SQL 函数和排序序列时，每个函数或排序序列可以指定它是否与 UTF-8、UTF-16be 或 UTF-16le 一起工作。可以为每种编码注册单独的实现。如果需要 SQL 函数或排序序列，但当前文本编码的版本不可用，则文本会自动转换。与以前一样，这种转换需要计算时间，因此建议程序员选择一种编码并坚持使用，以最小化不必要的格式转换量。

SQLite 不关心它接收的文本，并且非常乐意处理未标准化或甚至不规范的 UTF-8 或 UTF-16 文本字符串。因此，想要存储 ISO8859 数据的程序员可以使用 UTF-8 接口。只要不尝试使用 UTF-16 排序序列或 SQL 函数，文本的字节序列就不会以任何方式被修改。

### 用户定义的排序序列

排序序列只是文本的定义顺序。当 SQLite 3.0 进行排序（或使用像"<"或">="的比较运算符）时，排序顺序首先由数据类型决定。

+   NULL 值首先排序

+   数值按数值顺序排序。

+   文本值位于数字之后

+   BLOBs 最后排序

排序序列用于比较两个文本字符串。排序序列不会改变 NULL、数字或 BLOB 的排序，只改变文本。

排序序列被实现为一个函数，该函数以比较的两个字符串作为输入，并根据第一个字符串小于、等于或大于第二个字符串返回负数、零或正数。SQLite 3.0 自带一个名为"BINARY"的内置排序序列，它使用标准 C 库中的 memcmp()例程实现。BINARY 排序序列适用于英文文本。对于其他语言或区域设置，可能更喜欢替代的排序序列。

SQL 中由 COLLATE 子句控制使用的排序序列的决定。COLLATE 子句可以出现在表定义中，用于为表列定义默认的排序序列，或者出现在索引字段或 SELECT 语句的 ORDER BY 子句中。SQLite 的计划增强功能包括标准 CAST() 语法，允许定义表达式的排序序列。

### 64 位的 ROWID

表的每一行都有一个唯一的 rowid。如果表定义了一个类型为 "INTEGER PRIMARY KEY" 的列，则该列成为 rowid 的别名。但无论是否有 INTEGER PRIMARY KEY 列，每一行都仍然有一个 rowid。

在 SQLite 版本 3.0 中，rowid 是一个 64 位有符号整数。这是对 SQLite 版本 2.8 的扩展，后者仅允许 32 位的 rowid。

为了最小化存储空间，64 位的 rowid 被存储为可变长度整数。0 到 127 的 rowid 仅使用一个字节。0 到 16383 的 rowid 仅使用 2 个字节。最多 2097152 使用三个字节，依此类推。负数 rowid 虽然被允许，但它们始终使用九个字节的存储空间，因此不建议使用。当 SQLite 自动生成 rowid 时，它们总是非负数。

### 改进的并发性

SQLite 版本 2.8 允许多个同时读取者或单个写入者，但不能同时存在。SQLite 版本 3.0 允许一个进程在其他进程继续读取时开始写入数据库。写入者仍然必须在提交更改时对数据库获取独占锁，但不再需要整个写入操作期间保持独占锁。有关 SQLite 版本 3.0 锁定行为的更详细报告可以单独查阅。

SQLite 现在也支持一种有限的表级锁定。如果每个表存储在单独的数据库文件中，这些单独的文件可以附加到主数据库（使用 ATTACH 命令），并且合并的数据库将作为一个整体运行。但锁定只会在需要时在各个文件上获取。因此，如果重新定义“数据库”以表示两个或更多个数据库文件，那么完全可以同时有两个进程在写入同一个数据库。为了进一步支持这种能力，涉及两个或更多 ATTACHed 数据库的事务提交现在是原子的。

### Credits

SQLite 3.0 版本的实现在一定程度上得益于支持和采用优秀开源软件的 AOL 开发人员。
