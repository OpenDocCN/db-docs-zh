# 1.0 SQLite 版本 3 中的文件锁定与并发

> 原文：[`sqlite.com/lockingv3.html`](https://sqlite.com/lockingv3.html)

本文最初创建于 2004 年初，当时 SQLite 版本 2 仍广泛使用，并旨在向已熟悉 SQLite 版本 2 的读者介绍 SQLite 版本 3 的新概念。但如今，大多数本文的读者可能从未见过 SQLite 版本 2，只熟悉 SQLite 版本 3。尽管如此，本文仍作为 SQLite 版本 3 中数据库文件锁定工作原理的权威参考。

本文仅描述了较旧的回滚模式事务机制的锁定。关于较新的预写式日志或 WAL 模式的锁定是另有描述的。

SQLite Version 3.0.0 引入了一种新的锁定和日志机制，旨在改善与 SQLite 版本 2 相比的并发性，并减少写入饥饿问题。新机制还允许涉及多个数据库文件的事务的原子提交。本文描述了新的锁定机制。目标读者是希望理解和/或修改 pager 代码的程序员，以及工作于验证 SQLite 版本 3 设计的审阅人员。

## 2.0 概述

数据库锁定和并发控制由[pager 模块](https://www.sqlite.org/src/finfo?name=src/pager.c)处理。pager 模块负责使 SQLite “ACID”（原子性、一致性、隔离性和持久性）。pager 模块确保更改一次性发生，要么所有更改发生，要么都不发生；两个或多个进程不能同时以不兼容的方式访问数据库；一旦更改被写入，它们将持久保存直至显式删除。pager 还提供磁盘文件部分内容的内存缓存。

分页器并不关心 B 树、文本编码、索引等细节。从分页器的角度看，数据库由一个统一大小的块文件组成。每个块称为一个“页”，通常大小为 1024 字节。页从 1 开始编号。因此，数据库的前 1024 字节称为“第一页”，第二个 1024 字节称为“第二页”，依此类推。所有其他编码细节由库的更高层处理。分页器使用操作系统的一个或多个模块与操作系统通信（示例：[os_unix.c](https://www.sqlite.org/src/finfo?name=src/os_unix.c)，[os_win.c](https://www.sqlite.org/src/finfo?name=src/os_win.c)），提供操作系统服务的统一抽象。

分页器模块有效地控制了各个线程或进程的访问。在本文档中，每当提到“进程”时，您可以替换为“线程”而不改变陈述的真实性。

## 3.0 锁定

对于单个进程来说，数据库文件可以处于五种锁定状态之一：

| UNLOCKED | 数据库上没有任何锁定。数据库既不能读取也不能写入。任何内部缓存的数据在使用之前必须与数据库文件进行验证。其他进程可以根据其自身的锁定状态读取或写入数据库。这是默认状态。 |
| --- | --- |
| SHARED | 可以读取但不能写入数据库。多个进程可以同时持有共享锁，因此可以有多个同时读取者。但只要有一个或多个共享锁处于活动状态，就不允许其他线程或进程向数据库文件写入。 |
| 预留锁 | 预留锁表示进程计划在未来某个时刻向数据库文件写入内容，但当前只是从文件中读取。一次只能有一个预留锁活动，尽管多个共享锁可以与单个预留锁共存。预留锁与待处理锁的区别在于，在存在预留锁时可以获取新的共享锁。 |
| 待处理锁 | 待处理锁表示持有锁的进程希望尽快写入数据库，只是在等待所有当前共享锁清除，以便获取独占锁。如果存在待处理锁，则不允许对数据库获取新的共享锁，但允许现有的共享锁继续存在。 |
| 独占锁 | 为了向数据库文件写入内容，需要获取独占锁。同一文件只能存在一个独占锁，且不允许与独占锁共存的其他任何锁。为了最大化并发性，SQLite 努力减少独占锁的持有时间。 |

操作系统接口层理解和跟踪上述五种锁定状态。分页器模块仅跟踪其中四种锁定状态。待处理锁只是在获取独占锁的路径上的一个临时过渡状态，因此分页器模块不跟踪待处理锁。

## 4.0 回滚日志

当进程想要修改数据库文件（且不处于 WAL 模式时），首先会在一个*回滚日志*中记录未改变的原始数据库内容。回滚日志是一个普通的磁盘文件，总是位于与数据库文件相同的目录或文件夹中，并且与数据库文件同名，只是在后面加了一个 `-journal` 后缀。回滚日志还记录了数据库的初始大小，因此如果数据库文件增长，则可以在回滚时将其截断回到原始大小。

如果 SQLite 同时处理多个数据库（使用 ATTACH 命令），则每个数据库都有其自己的回滚日志。但是还有一个名为*超级日志*的单独的聚合日志。超级日志不包含用于回滚更改的页面数据。相反，超级日志包含每个附加数据库的单独数据库回滚日志的名称。每个单独的数据库回滚日志也包含超级日志的名称。如果没有附加数据库（或者如果没有附加的数据库参与当前事务），则不会创建超级日志，并且普通的回滚日志在通常用于记录超级日志名称的位置上包含空字符串。

回滚日志被称为热，如果需要回滚以恢复数据库的完整性。当进程正在进行数据库更新并且程序或操作系统崩溃或断电导致更新未能完成时，将创建热日志。热日志是一种异常情况。热日志用于从崩溃和断电中恢复。如果一切正常（即没有崩溃或断电），您永远不会遇到热日志。

如果没有涉及超级日志，则如果日志存在且具有非零头，并且相应的数据库文件没有保留锁，则日志为热。如果在文件日志中命名了超级日志，则如果其超级日志存在并且相应的数据库文件上没有保留锁，则文件日志为热。了解何时日志为热是很重要的，因此前述规则将重复列举如下：

+   如果一个日志文件...

    +   它存在，并且

    +   大小大于 512 字节，并且

    +   日志头非零且格式良好，并且

    +   其超级日志存在或超级日志名称为空字符串，并且

    +   对应的数据库文件上没有保留锁。

### 4.1 处理热日志

在从数据库文件读取之前，SQLite 始终会检查该数据库文件是否有热日志。如果文件确实有热日志，则在读取文件之前回滚该日志。通过这种方式，我们确保在读取之前数据库文件处于一致的状态。

当进程想要从数据库文件读取时，它遵循以下步骤序列：

1.  打开数据库文件并获取共享锁。如果无法获取共享锁，则立即失败并返回 SQLITE_BUSY。

1.  检查数据库文件是否有热日志。如果文件没有热日志，我们就完成了。立即返回。如果有热日志，则必须通过后续步骤回滚该日志。

1.  在数据库文件上获取挂起锁，然后获取排他锁。 （注意：不要获取保留锁，因为那会让其他进程认为日志不再是热的。）如果我们无法获取这些锁，则意味着另一个进程已经尝试进行回滚。在这种情况下，释放所有锁，关闭数据库，并返回 SQLITE_BUSY。

1.  读取日志文件并回滚更改。

1.  等待回滚的更改写入持久存储。这样可以在发生另一次断电或崩溃时保护数据库的完整性。

1.  删除日志文件（如果设置了 PRAGMA journal_mode=TRUNCATE，则将日志截断为零字节长度，或者如果设置了 PRAGMA journal_mode=PERSIST，则将日志头部清零）。

1.  如果可以的话，删除超级日志文件。这一步骤是可选的。这么做仅仅是为了防止过时的超级日志文件堆积在磁盘驱动器上。详细信息请参见下面的讨论。

1.  丢弃排他锁和挂起锁，但保留共享锁。

在上述算法成功完成后，从数据库文件中读取是安全的。一旦所有的读取完成，SHARED 锁就会被释放。

### 4.2 删除陈旧的超级日志

一个陈旧的超级日志是指不再用于任何目的的超级日志。没有必要删除陈旧的超级日志。唯一的原因是为了释放磁盘空间。

一个超级日志在没有个别文件日志指向它时就变得陈旧了。要确定一个超级日志是否陈旧，我们首先读取超级日志以获取所有文件日志的名称。然后我们检查每一个文件日志。如果任何一个在超级日志中命名的文件日志存在，并指向回超级日志，则该超级日志不是陈旧的。如果所有文件日志要么丢失要么指向其他超级日志或者根本没有超级日志，那么我们正在测试的超级日志就是陈旧的，可以安全删除。

## 5.0 写入数据库文件

要向数据库写入，进程必须首先像上面描述的那样获取一个 SHARED 锁（如果存在热日志，则可能回滚不完整的更改）。获取 SHARED 锁后，必须获取 RESERVED 锁。 RESERVED 锁表示进程打算在将来某个时候写入数据库。一次只有一个进程可以持有 RESERVED 锁。但是在持有 RESERVED 锁期间，其他进程仍然可以继续读取数据库。

如果试图写入的进程无法获取一个 RESERVED 锁，这必须意味着另一个进程已经拥有一个 RESERVED 锁。在这种情况下，写入尝试失败并返回 SQLITE_BUSY。

在获得 RESERVED 锁之后，希望写入的进程会创建一个回滚日志。日志的头部会被初始化为数据库文件的原始大小。日志头部还预留了超级日志名称的空间，尽管超级日志名称最初是空的。

在对数据库的任何页面进行更改之前，进程将页面的原始内容写入回滚日志。页面的更改首先保存在内存中，并未写入磁盘。原始数据库文件保持不变，这意味着其他进程可以继续读取数据库。

最终，写入过程将希望更新数据库文件，无论是因为其内存缓存已满还是准备提交其更改。在此之前，写入程序必须确保没有其他进程正在读取数据库，并且回滚日志数据已安全地存储在磁盘表面，以便在断电时可以用来回滚不完整的更改。步骤如下：

1.  确保所有回滚日志数据确实已写入磁盘表面（而不仅仅是保存在操作系统或磁盘控制器缓存中），以便在发生断电时，数据在电源恢复后仍然存在。

1.  获得数据库文件的**PENDING**锁，然后再获取**EXCLUSIVE**锁。如果其他进程仍然持有**SHARED**锁，则写入程序可能需要等待直到这些**SHARED**锁被清除才能获取**EXCLUSIVE**锁。

1.  将当前保存在内存中的所有页面修改写入原始数据库磁盘文件。

如果写入数据库文件的原因是因为内存缓存已满，那么写入程序将不会立即提交。相反，写入程序可能会继续对其他页面进行更改。在将后续更改写入数据库文件之前，必须再次将回滚日志刷新到磁盘。还需注意，最初为了写入数据库而获取的**EXCLUSIVE**锁必须在所有更改提交之前保持。这意味着从内存缓存首次溢出到磁盘直到事务提交之前，其他进程无法访问数据库。

当写入者准备提交其更改时，执行以下步骤：

1.  获取数据库文件的 EXCLUSIVE 锁，并确保所有内存更改都已使用步骤 1-3 的算法写入数据库文件。

1.  刷新所有数据库文件的更改到磁盘。等待这些更改实际被写入磁盘表面。

1.  删除日志文件。（或者如果 PRAGMA journal_mode 是 TRUNCATE 或 PERSIST，则分别截断日志文件或将日志文件头部清零。）这是提交更改的时刻。在删除日志文件之前，如果发生断电或崩溃，下一个打开数据库的进程将看到有一个热日志，并将回滚更改。日志文件删除后，将不再存在热日志，并且更改将持久保存。

1.  从数据库文件中删除 EXCLUSIVE 和 PENDING 锁。

一旦从数据库文件中释放了 PENDING 锁，其他进程可以再次开始读取数据库。在当前实现中，RESERVED 锁也被释放，但这对于正确的操作并不是必要的。

如果一个事务涉及多个数据库，则使用更复杂的提交顺序，如下所示：

1.  确保所有单个数据库文件具有 EXCLUSIVE 锁和有效的日志。

1.  创建一个超级日志。超级日志的名称是任意的。（当前实现将随机后缀附加到主数据库文件的名称，直到找到一个之前不存在的名称。）用所有单个日志的名称填充超级日志，并将其内容刷新到磁盘。

1.  将超级日志的名称写入所有单个日志（在单个日志头部专门留出的空间中），并刷新单个日志的内容到磁盘，并等待这些更改达到磁盘表面。

1.  刷新所有数据库文件更改到磁盘。等待这些更改确实被写入磁盘表面。

1.  删除超级日志文件。这是提交更改的时刻。在删除超级日志文件之前，如果发生断电或崩溃，个别文件日志将被下一个尝试读取它们的进程视为热点并将其回滚。删除超级日志后，文件日志将不再被视为热点，更改将持久保存。

1.  删除所有单独的日志文件。

1.  从所有数据库文件中删除排他锁和挂起锁。

### 5.1 写入饥饿

在 SQLite 第 2 版中，如果有很多进程在从数据库中读取数据，可能永远不会出现没有活跃读取者的情况。如果数据库上始终至少有一个读取锁，任何进程都无法对数据库进行更改，因为无法获取写入锁。这种情况称为*写入饥饿*。

SQLite 第 3 版试图通过使用 PENDING 锁来避免写入饥饿。PENDING 锁允许现有的读取者继续，但阻止新的读取者连接到数据库。因此，当一个进程想要写入一个繁忙的数据库时，可以设置一个 PENDING 锁，这将阻止新的读取者进入。假设现有的读取者最终完成，所有共享锁最终将清除，写入者将有机会进行更改。

## 6.0 如何损坏你的数据库文件

Pager 模块非常强大，但也可以被破坏。本节试图识别和解释风险。（另请参阅 Things That Can Go Wrong 一文中关于原子提交部分。）

显然，硬件或操作系统故障导致数据库文件或日志中插入不正确数据将会引起问题。同样地，如果恶意进程打开数据库文件或日志，并向其中写入格式错误的数据，那么数据库将会损坏。对于这些问题，没有太多可以做的，因此它们不再受到进一步的关注。

SQLite 在 Unix 上使用 POSIX 咨询锁来实现锁定。在 Windows 上，它使用 `LockFile()`、`LockFileEx()` 和 `UnlockFile()` 系统调用。SQLite 假设这些系统调用都按照它们的宣称工作。如果情况不是这样，可能会导致数据库损坏。需要注意的是，众所周知，POSIX 咨询锁在许多 NFS 实现（包括最近的 Mac OS X 版本）上存在问题，甚至未实现，并且有关 Windows 下网络文件系统的锁定问题的报道。你最好的防御措施是不要在网络文件系统上使用 SQLite。

SQLite 在 Unix 下使用 `fsync()` 系统调用将数据刷新到磁盘，在 Windows 下则使用 `FlushFileBuffers()` 来完成相同的操作。再次强调，SQLite 假设这些操作系统服务按照它们的宣称工作。但有报道称，特别是在某些网络文件系统或廉价的 IDE 硬盘上，`fsync()` 和 `FlushFileBuffers()` 并不总是正常工作。显然，一些 IDE 硬盘的制造商的控制器芯片会报告数据已经达到磁盘表面，但实际上数据仍然存在于磁盘驱动电子设备的易失性缓存内存中。还有报道称，由于未指明的原因，Windows 有时会选择忽略 `FlushFileBuffers()`。作者无法验证这些报告的真实性。但如果这些问题确实存在，意味着在意外断电后可能会导致数据库损坏。这些都是 SQLite 无法应对的硬件和/或操作系统错误。

如果 Linux 的 [ext3](http://zh.wikipedia.org/wiki/Ext3) 文件系统在 [/etc/fstab](http://zh.wikipedia.org/wiki/fstab) 中没有使用 "barrier=1" 选项挂载，并且磁盘驱动器写缓存已启用，则在断电或操作系统崩溃后可能会导致文件系统损坏。是否会发生损坏取决于磁盘控制硬件的细节；使用廉价的消费者级磁盘时更容易发生损坏，而企业级存储设备则相对较少出现此问题，因为其具有诸如非易失性写缓存等先进功能。各种 ext3 专家 [确认了这种行为](http://www.redhat.com/archives/ext3-users/2010-July/msg00001.html)。我们被告知，大多数 Linux 发行版都不使用 barrier=1，也不禁用写缓存，因此大多数 Linux 发行版都容易受到此问题的影响。请注意，这是一个操作系统和硬件问题，SQLite 无法通过任何方式避免它。[其他数据库引擎](http://ozlabs.org/~rusty/index.cgi/tech/2009-10-20.html) 也遇到了相同的问题。

如果崩溃或断电导致存在热日志但该日志被删除，那么下一个打开数据库的进程将不知道它包含需要回滚的更改。回滚将不会发生，数据库将处于不一致状态。可能会因各种原因删除回滚日志：

+   如果管理员在操作系统崩溃或停电后进行清理，并看到日志文件，可能会误认为它是垃圾而将其删除。

+   某人（或某个进程）可能会重命名数据库文件但未能同时重命名其相关联的日志文件。

+   如果数据库文件有别名（硬链接或软链接），并且文件是通过与用于创建日志的不同别名打开的，那么将找不到日志。为避免此问题，不应创建指向 SQLite 数据库文件的链接。

+   在断电后可能会导致文件系统损坏，从而使日志被重命名或删除。

最后（第四条）上述内容需要额外的评论。当 SQLite 在 Unix 上创建日志文件时，它会打开包含该文件的目录，并调用该目录上的`fsync()`函数，以尝试将目录信息推送到磁盘上。但假设在数据库和日志所在的目录在停电时，其他进程正在添加或删除不相关的文件。这些其他进程的看似无关的操作可能导致日志文件从目录中删除并移动到"lost+found"目录中。这是一个不太可能的情况，但却有可能发生。最佳防御措施是使用日志文件系统或将数据库和日志保持在单独的目录中。

对于涉及多个数据库和超级日志的提交，如果各个数据库位于不同的磁盘卷上，并且在提交过程中发生停电，则在机器重新启动时，磁盘可能会以不同的名称重新挂载。或者某些磁盘可能根本未被挂载。当出现这种情况时，各个文件日志和超级日志可能无法互相找到。这种情况的最坏结果是提交不再是原子性的。某些数据库可能会被回滚，而其他数据库则不会。所有数据库仍将保持自洽性。为了防范这个问题，保持所有数据库位于同一磁盘卷上，并/或在停电后确保使用完全相同的名称重新挂载磁盘。

## 7.0 SQL 层面的事务控制

SQLite 版本 3 中锁定和并发控制的更改还引入了 SQL 语言层面事务工作方式的一些微妙变化。默认情况下，SQLite 版本 3 在*自动提交*模式下运行。在自动提交模式下，与当前数据库连接关联的所有操作完成后，对数据库的所有更改都会立即提交。

SQL 命令 "BEGIN TRANSACTION" （TRANSACTION 关键字是可选的） 用于将 SQLite 从自动提交模式中移出。请注意，BEGIN 命令不会对数据库获取任何锁定。在执行第一个 SELECT 语句时，将获取一个 SHARED 锁。在执行第一个 INSERT、UPDATE 或 DELETE 语句时将获取一个 RESERVED 锁。直到内存缓存填满且必须溢出到磁盘或者事务提交之前，都不会获取 EXCLUSIVE 锁。通过这种方式，系统推迟了对文件的读取访问的阻塞，直到最后可能的时刻。

SQL 命令 "COMMIT" 实际上并不会将更改提交到磁盘。它只是重新打开自动提交。然后，在命令结束时，常规的自动提交逻辑接管并导致将实际提交到磁盘。SQL 命令 "ROLLBACK" 也通过重新打开自动提交来操作，但它还设置了一个标志，告诉自动提交逻辑执行回滚而不是提交。

如果 SQL COMMIT 命令打开了自动提交，然后自动提交逻辑尝试提交更改，但由于其他进程持有 SHARED 锁而失败，则自动提交会自动关闭。这允许用户在稍后，等待 SHARED 锁有机会清除之后，重新尝试 COMMIT。
