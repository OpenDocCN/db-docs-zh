# SQLite 中的隔离

> 原文：[`sqlite.com/isolation.html`](https://sqlite.com/isolation.html)

数据库的 "隔离" 属性决定了一个操作对数据库所做的更改何时对其他并发操作可见。

## 数据库连接之间的隔离

如果同一个数据库通过两个不同的 数据库连接（通过分别调用 sqlite3_open() 返回的两个不同的 sqlite3 对象）进行读取和写入，并且这两个数据库连接没有 共享缓存，那么读取者只能看到写入者完整提交的事务。写入者未提交的部分更改对于读取者是不可见的。这一点不论这两个数据库连接是否在同一个线程中，不同线程的同一进程中，还是不同进程中，对于 SQL 数据库系统来说，这是通常且预期的行为。

在 共享缓存模式 下，只要 read_uncommitted pragma 保持关闭，前一段也是真实的（单独的数据库连接彼此隔离）。read_uncommitted pragma 默认关闭，因此如果应用程序没有执行任何操作将其打开，它将保持关闭。因此，除非使用 read_uncommitted pragma 改变默认行为，否则一个数据库连接所做的更改对于共享同一缓存的另一个数据库连接的读取者是不可见的，直到写入者提交其事务。

如果两个数据库连接共享相同的缓存，并且读者已启用了 read_uncommitted pragma，那么读者就能够在写者事务提交之前看到写者所做的更改。共享缓存模式和 read_uncommitted pragma 的组合是一个数据库连接能够看到另一个数据库连接的未提交更改的唯一方式。在所有其他情况下，各个数据库连接彼此完全隔离。

除了共享缓存数据库连接开启 PRAGMA read_uncommitted 的情况外，SQLite 中的所有事务都显示为“可串行化”隔离。SQLite 通过实际序列化写操作来实现可串行化事务。SQLite 数据库一次只能有一个写者，虽然可以同时打开多个数据库连接，并且所有这些数据库连接都可以写入数据库文件，但它们必须轮流进行。SQLite 使用锁来自动序列化写操作；这不是使用 SQLite 的应用程序需要担心的事情。

## 隔离与并发

SQLite 使用临时日志文件来实现隔离和并发控制（以及原子性），这些日志文件出现在与数据库文件相同的目录中。有两种主要的“日志模式”。较旧的“回滚模式”对应于使用 journal_mode pragma 中的“DELETE”、“PERSIST”或“TRUNCATE”选项。在回滚模式下，更改直接写入数据库文件，同时构建一个单独的回滚日志文件，如果事务回滚，可以将数据库恢复到其原始状态。回滚模式（特别是 DELETE 模式，意味着回滚日志在每个事务结束时从磁盘上删除）是当前的默认行为。

自 版本 3.7.0（2010-07-21）起，SQLite 还支持“WAL 模式”（wal.html）。在 WAL 模式下，更改不会写入原始数据库文件。而是写入一个单独的“预写日志”或“WAL”文件。稍后，在事务提交后，这些更改将从 WAL 文件移回原始数据库，称为“checkpoint”操作。通过运行 “PRAGMA journal_mode=WAL” 可以启用 WAL 模式。

在回滚模式下，SQLite 通过锁定数据库文件并阻止其他数据库连接的任何读取来实现隔离，而每个写事务正在进行中。 读者可以在写入之前活跃，在任何内容刷新到磁盘之前，而所有更改仍然保留在写者的私有内存空间中。 但在任何更改被写入磁盘文件之前，所有读者必须暂时被驱逐，以便给予写者对数据库文件的独占访问权限。 因此，通过被拒绝数据库访问，读者被禁止看到不完整的事务。 只有在事务完全写入并同步到磁盘并提交后，读者才被允许重新进入数据库。 因此，读者永远不会有机会看到部分写入的更改。

WAL 模式允许同时进行读操作和写操作。 它之所以能够做到这一点，是因为更改不会覆盖原始数据库文件，而是进入单独的 “预写日志” 文件中。 这意味着读者可以继续从原始数据库文件中读取旧的、未经改变的内容，同时写者正在向 “预写日志” 追加内容。在 WAL 模式下，SQLite 展示了“快照隔离”。 当读事务开始时，该读者将继续看到数据库文件的一个不变的 “快照”，即在读事务开始时的数据库文件的时刻。 任何在活动读事务时提交的写事务对于读事务仍然是不可见的，因为读者正在看到以前某个时刻的数据库文件的 “快照”。

举例：假设有两个数据库连接 X 和 Y。X 使用 BEGIN 开始一个读取事务，然后跟着一个或多个 SELECT 语句。然后 Y 来了，并运行一个 UPDATE 语句来修改数据库。X 随后可以对 Y 修改的记录进行 SELECT，但 X 将看到旧的未修改的条目，因为在 X 持有读取事务时，Y 的更改对 X 来说是看不见的。如果 X 想要看到 Y 所做的更改，那么 X 必须结束它的读取事务，并开始一个新的事务（通过运行 COMMIT 然后另一个 BEGIN）。

另一个例子：X 使用 BEGIN 和 SELECT 开始一个读取事务，然后 Y 使用 UPDATE 对数据库进行更改。然后 X 试图使用 UPDATE 对数据库进行更改。X 试图将其事务从读取事务升级为写入事务的尝试，会因 SQLITE_BUSY_SNAPSHOT 错误失败，因为 X 所观察的数据库快照不再是数据库的最新版本。如果允许 X 进行写入，它将分叉数据库文件的历史，这是 SQLite 不支持的。为了 X 能够对数据库进行写入，它必须首先释放它的快照（例如使用 ROLLBACK），然后启动一个新的事务，并接着使用 BEGIN。

如果 X 开始一个事务，最初只读取但 X 知道最终会想要写入，并且不想被可能出现的 SQLITE_BUSY_SNAPSHOT 错误所困扰（因为另一个连接已经排在它前面），那么 X 可以发出即时开始来启动它的事务，而不仅仅是普通的 BEGIN。即时开始命令继续并启动写入事务，从而阻止所有其他写入者。如果即时开始操作成功，那么该事务中的后续操作将不会因为 SQLITE_BUSY 错误而失败。

## 在同一数据库连接上的操作之间不存在隔离。

SQLite 在不同数据库连接的操作之间提供隔离。然而，在同一数据库连接内部的操作之间没有隔离。

换句话说，如果 X 使用即时开始开始写入事务，然后发出一个或多个 UPDATE，DELETE 和/或 INSERT 语句，那么这些更改将对在数据库连接 X 中评估的后续 SELECT 语句可见。在不同数据库连接 Y 上的 SELECT 语句将在 X 事务提交之前不显示任何更改。但是 X 中的 SELECT 语句将显示提交之前的更改。

在单个数据库连接 X 中，SELECT 语句始终可以看到在 SELECT 语句开始之前已经完成的数据库所有更改，无论这些更改是已提交还是未提交的。而且，显然 SELECT 语句不会看到在 SELECT 语句完成之后发生的任何更改。但是，当 SELECT 语句正在运行时会发生什么呢？如果一个 SELECT 语句启动并且 sqlite3_step() 接口大约完成了其输出的一半，然后应用程序运行了一些 UPDATE 语句来修改 SELECT 语句正在读取的表，然后再次调用 sqlite3_step() 来完成 SELECT 语句的后续步骤呢？后续步骤会看到 UPDATE 所做的更改吗？答案是这种行为是未定义的。特别地，SELECT 语句是否看到并发更改取决于运行的 SQLite 版本、数据库文件的模式、是否运行了 ANALYZE，以及查询的详细信息。在某些情况下，还可能取决于数据库文件的内容。没有很好的方法可以知道 SELECT 语句是否会看到由同一数据库连接在 SELECT 语句启动后对数据库所做的更改。因此，开发人员应该认真避免编写基于该情况假设的应用程序。

如果应用程序在单个表上发出类似"*SELECT rowid, * FROM table WHERE ...*"的 SELECT 语句，并开始通过 sqlite3_step()逐步检查该语句的输出并检查每一行，那么应用程序可以安全地删除当前行或任何先前的行，使用"DELETE FROM table WHERE rowid=?"。应用程序也可以安全地（在不损害数据库的意义上）删除预期在查询中稍后出现但尚未出现的行。然而，如果将来的某一行被删除，可能会在随后的 sqlite3_step()之后出现该行，即使它据称已被删除。也可能不会。这种行为是未定义的。应用程序还可以在 SELECT 语句运行时向表中插入新行，但是新行是否出现在后续的 sqlite3_step()查询中是未定义的。应用程序还可以更新当前行或任何先前的行，尽管这样做可能会导致该行在后续的 sqlite3_step()中重新出现。只要应用程序准备好处理这些模糊性，这些操作本身是安全的，不会损害数据库文件。

对于前两段的目的，具有相同的共享缓存并启用 PRAGMA read_uncommitted 的两个数据库连接被视为同一数据库连接。

## 总结

1.  SQLite 中的事务是串行化的。

1.  在提交之前，对一个数据库连接所做的更改对所有其他数据库连接是不可见的。

1.  查询在查询开始之前对同一数据库连接上完成的所有更改都可见，无论这些更改是否已提交。

1.  如果在查询开始运行之后但在查询完成之前对同一数据库连接进行了更改，则不确定查询是否会看到这些更改。

1.  如果在查询开始运行后但在查询完成之前，在同一个数据库连接上发生了更改，那么该查询可能会多次返回已更改的行，或者返回先前已删除的行。

1.  对于前面四条目的目的，使用相同的共享缓存并启用 PRAGMA read_uncommitted 的两个数据库连接被视为同一个数据库连接，而不是分开的数据库连接。
