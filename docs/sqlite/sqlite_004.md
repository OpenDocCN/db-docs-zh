# SQLite 的显著特点

> 原文：[`sqlite.com/different.html`](https://sqlite.com/different.html)

本页面突出了 SQLite 的一些特性，这些特性不同寻常，使得 SQLite 与许多其他 SQL 数据库引擎不同。

**零配置**

> SQLite 在使用前不需要进行“安装”。没有“设置”过程。没有需要启动、停止或配置的服务器进程。没有需要管理员创建新数据库实例或为用户分配访问权限的需要。SQLite 不使用配置文件。系统无需进行任何操作来表明 SQLite 正在运行。在系统崩溃或停电后也无需进行任何恢复操作。没有需要排除故障的内容。
> 
> SQLite 就是这么简单。
> 
> 其他更为熟悉的数据库引擎一旦启动运行起来效果很好。但是进行初始安装和配置可能会非常复杂令人生畏。

**无服务器**

> *(另请参阅 无服务器 文档页面。)*
> 
> 大多数 SQL 数据库引擎都实现为单独的服务器进程。想要访问数据库的程序使用某种进程间通信（通常是 TCP/IP）与服务器通信，发送请求并接收结果。SQLite 不是这样工作的。使用 SQLite，想要访问数据库的进程直接从磁盘上的数据库文件读取和写入。没有中间的服务器进程。
> 
> 无服务器有其优缺点。主要优点是无需安装、设置、配置、初始化、管理和排除故障单独的服务器进程。这也是 SQLite 被称为“零配置”数据库引擎的原因之一。使用 SQLite 的程序在运行之前不需要任何管理员支持来设置数据库引擎。只要能访问磁盘的程序就能使用 SQLite 数据库。
> 
> 另一方面，使用服务器的数据库引擎能更好地防止客户端应用程序中的错误 - 客户端中的杂乱指针无法破坏服务器上的内存。而且因为服务器是单一持久进程，能够更精确地控制数据库访问，实现更细粒度的锁定和更好的并发性。
> 
> 大多数 SQL 数据库引擎是基于客户端/服务器的。在那些无服务器的数据库引擎中，SQLite 是唯一一个允许多个应用程序同时访问同一数据库的引擎（据本文作者所知）。

**单一数据库文件**

> SQLite 数据库是一个普通的单个磁盘文件，可以位于目录层次结构中的任何位置。如果 SQLite 能够读取磁盘文件，则可以读取数据库中的任何内容。如果磁盘文件及其目录具有可写权限，则 SQLite 可以更改数据库中的任何内容。数据库文件可以轻松复制到 USB 存储设备或通过电子邮件进行共享。
> 
> 其他 SQL 数据库引擎往往将数据存储为大量文件的集合。这些文件通常位于只有数据库引擎本身可以访问的标准位置。这使得数据更安全，但也使得访问变得更困难。一些 SQL 数据库引擎提供直接写入磁盘并绕过文件系统的选项。这提供了额外的性能，但增加了相当复杂的设置和维护工作。

**稳定的跨平台数据库文件**

> SQLite 文件格式是跨平台的。在一台机器上写入的数据库文件可以复制到另一台架构不同的机器上并使用。大小端、32 位或 64 位都不重要。所有机器使用相同的文件格式。此外，开发人员承诺保持文件格式的稳定性和向后兼容性，因此新版本的 SQLite 可以读取和写入旧的数据库文件。
> 
> 大多数其他 SQL 数据库引擎在从一个平台移动到另一个平台时，以及经常在升级软件到新版本时，都需要您备份和恢复数据库。

**紧凑**

> 当优化大小时，整个启用了所有功能的 SQLite 库的大小 不到 1MiB（在 ix86 上使用 GNU 编译套件的 "size" 实用程序进行测量）。可以在编译时禁用不需要的功能，以进一步减小库的大小。
> 
> 大多数其他 SQL 数据库引擎比这个要大得多。IBM 自豪地宣称，其最近发布的 CloudScape 数据库引擎仅为 2MiB 的 jar 文件——比 SQLite 压缩后还大一个数量级！Firebird 自称其客户端库只有 350KiB，和 SQLite 一样大，甚至不包含数据库引擎。Oracle 的 Berkeley DB 库为 450KiB，省略了 SQL 支持，仅提供程序员简单的键值对。

**显式类型**

> 大多数 SQL 数据库引擎使用静态类型。每个表列都关联有一个数据类型，只允许存储该特定数据类型的值在列中。SQLite 通过使用显式类型（manifest typing）放宽了这一限制。在显式类型中，数据类型是值本身的属性，而不是存储值的列的属性。因此，SQLite 允许用户将任何数据类型的任何值存储到任何列中，而不管该列的声明类型是什么（当然，也有一些例外：INTEGER PRIMARY KEY 列只能存储整数，并且 SQLite 会在可能时尝试将值强制转换为列的声明数据类型）。
> 
> 据我们所知，SQL 语言规范允许使用显式类型。尽管如此，大多数其他 SQL 数据库引擎是静态类型的，因此一些人认为在 SQLite 中使用显式类型是一个错误。但 SQLite 的作者们非常坚信这是一个特性。SQLite 中使用显式类型是一个经过深思熟虑的设计决策，在实践中已被证明使 SQLite 更可靠、更易于使用，特别是在与动态类型编程语言（如 Tcl 和 Python）结合使用时。

**可变长度记录**

> 大多数其他 SQL 数据库引擎为大多数表中的每一行分配固定大小的磁盘空间。它们会使用特殊技巧来处理可以变化得非常大的 BLOBs 和 CLOBs。但对于大多数表来说，如果您声明一个列为 VARCHAR(100)，则无论您实际存储多少信息，数据库引擎都会分配 100 字节的磁盘空间。
> 
> 相比之下，SQLite 仅使用实际需要的磁盘空间来存储一行中的信息。如果在 VARCHAR(100) 列中存储单个字符，则只消耗一个字节的磁盘空间。（实际上是两个字节 - 每个列开头都有一些开销来记录其数据类型和长度。）
> 
> SQLite 使用可变长度记录具有多个优势。显而易见地，它导致更小的数据库文件。它还使数据库运行更快，因为需要在磁盘之间移动的信息更少。并且，使用可变长度记录使 SQLite 能够使用显式类型而非静态类型。

**可读的源代码**

> SQLite 的源代码设计为可读且对普通程序员易于访问。所有过程和数据结构以及许多自动变量都被仔细注释，提供有关它们功能的有用信息。没有样板式的注释。

**SQL 语句编译为虚拟机代码**

> 每个 SQL 数据库引擎将每个 SQL 语句编译成某种内部数据结构，然后使用该结构执行语句的工作。但在大多数 SQL 引擎中，这种内部数据结构是一组复杂相互关联的结构和对象。在 SQLite 中，语句的编译形式是类似机器语言的短程序。数据库的用户可以通过在查询前加上 EXPLAIN 关键字来查看这种 虚拟机语言。
> 
> 在 SQLite 中使用虚拟机对库的发展有很大好处。虚拟机提供了 SQLite 前端（解析 SQL 语句并生成虚拟机代码的部分）和后端（执行虚拟机代码并计算结果的部分）之间清晰、定义良好的连接。虚拟机使开发人员能够清晰地看到 SQLite 在编译每个语句时试图做什么，这对于调试非常有帮助。根据编译方式的不同，SQLite 还具有追踪虚拟机执行的能力——在执行时打印每个虚拟机指令及其结果。

**公共领域**

> SQLite 的源代码属于公共领域。对核心源代码的任何部分都不声称版权。 （文档和测试代码则是另一回事——部分文档和测试逻辑受开源许可控制。）SQLite 核心软件的所有贡献者都签署了书面声明，明确放弃对代码的任何版权利益。这意味着任何人都可以合法地对 SQLite 源代码做任何他们想做的事情。
> 
> 还有其他具有宽松许可证的 SQL 数据库引擎，允许广泛和自由使用代码。但这些其他引擎仍受版权法管辖。SQLite 与众不同之处在于，版权法根本不适用。
> 
> 其他 SQL 数据库引擎的源代码文件通常以注释开始，描述您查看和复制该文件的法律权利。SQLite 的源代码不包含许可，因为它不受版权管制。SQLite 源代码没有许可证，而是提供了一种祝福：
> 
> > *愿您行善而非恶*
> > 
> > 愿您能够原谅自己并宽恕他人
> > 
> > 愿您自由分享，从不索取比给予更多。*

**SQL 语言扩展**

> SQLite 提供了许多 SQL 语言的增强功能，在其他数据库引擎中通常找不到。已经提到了 EXPLAIN 关键字和显式类型转换。SQLite 还提供了诸如 REPLACE 和 ON CONFLICT 子句等语句，允许对约束冲突的解决增加控制。SQLite 支持 ATTACH 和 DETACH 命令，允许在同一查询中使用多个独立数据库。SQLite 还定义了 API，允许用户添加新的 SQL 函数和排序序列。
