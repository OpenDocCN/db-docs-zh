# -   数据库文件

> 原文：[`sqlite.com/fileformat2.html`](https://sqlite.com/fileformat2.html)

本文档描述和定义了自 SQLite 3.0.0 版本（2004-06-18）以来所有版本使用的磁盘上数据库文件格式。

SQLite 数据库的完整状态通常包含在磁盘上的单个文件中，称为“主数据库文件”。

在事务期间，SQLite 将额外的信息存储在第二个文件中，称为“回滚日志”，或者如果 SQLite 处于 WAL 模式，则是写前日志文件。

## -   热门日志

如果应用程序或主机计算机在事务完成之前崩溃，则回滚日志或写前日志包含恢复主数据库文件到一致状态所需的信息。当回滚日志或写前日志包含恢复数据库状态所需的信息时，它们被称为“热日志”或“热 WAL 文件”。热日志和 WAL 文件仅在错误恢复场景中才是因素，因此并不常见，但它们是 SQLite 数据库状态的一部分，因此不能被忽视。本文档定义了回滚日志和写前日志文件的格式，但重点在于主数据库文件。

## -   页面

主数据库文件由一个或多个页面组成。页面大小是介于 512 和 65536 之间的二的幂。同一数据库中的所有页面大小相同。数据库文件的页面大小由位于距离数据库文件开头 16 字节处的 2 字节整数确定。

页面从 1 开始编号。最大页面编号为 4294967294（2³² - 2）。最小大小的 SQLite 数据库是单个 512 字节页面。最大大小的数据库将是 4294967294 个页面，每个页面大小为 65536 字节，总共约 281,474,976,579,584 字节（约 281 TB）。通常，SQLite 在达到底层文件系统或磁盘硬件的最大文件大小限制之前，会达到自身的内部大小限制。

在常见的使用情况下，SQLite 数据库的大小通常从几千字节到几个千兆字节不等，尽管已知生产中存在大小为 TB 级别的 SQLite 数据库。

在主数据库的任何时间点，每页都有一个单一的用途，可以是以下之一：

+   一个 B 树页

    +   一个表 B 树内部页

    +   一个表 B 树叶页

    +   一个索引 B 树内部页

    +   一个索引 B 树叶页

+   一个自由列表页

    +   一个自由列表干页

    +   一个自由列表叶页

+   一个有效负载溢出页

+   一个指针映射页

+   锁字节页

从主数据库文件中读取和写入的所有操作都从页边界开始，所有写入操作都是页大小的整数倍。读取通常也是页大小的整数倍，但有一个例外：当首次打开数据库时，会读取数据库文件的前 100 字节（数据库文件头）作为子页大小单元。

## 1.3\. 数据库头

数据库文件的前 100 字节包括数据库文件头。数据库文件头按表格显示的字段进行划分。数据库文件头中的所有多字节字段均以最高有效字节在前（大端序）的方式存储。

*数据库头格式*

| 偏移量 | 大小 | 描述 |
| --- | --- | --- |
| 0 | 16 | 头字符串：“SQLite format 3\000” |
| 16 | 2 | 数据库页大小（以字节为单位）。必须是 512 到 32768 之间的二的幂次方，或值为 1，表示页大小为 65536。 |
| 18 | 1 | 文件格式写入版本。对于传统格式为 1；对于 WAL 为 2。 |
| 19 | 1 | 文件格式读取版本。对于传统格式为 1；对于 WAL 为 2。 |
| 20 | 1 | 每页末尾未使用的“保留”空间字节数。通常为 0。 |
| 21 | 1 | 最大嵌入负载分数。必须是 64。 |
| 22 | 1 | 最小嵌入负载分数。必须是 32。 |
| 23 | 1 | 叶负载分数。必须是 32。 |
| 24 | 4 | 文件更改计数器。 |
| 28 | 4 | 数据库文件大小，以页为单位。“头部数据库大小”。 |
| 32 | 4 | 第一个自由列表干页的页码。 |
| 36 | 4 | 空闲列表页的总数。 |
| 40 | 4 | 模式 cookie。 |
| 44 | 4 | 模式格式号。支持的模式格式为 1、2、3 和 4。 |
| 48 | 4 | 默认页面缓存大小。 |
| 52 | 4 | 在自动清理或增量清理模式下，最大根 b 树页的页码；否则为零。 |
| 56 | 4 | 数据库文本编码。值为 1 表示 UTF-8。值为 2 表示 UTF-16le。值为 3 表示 UTF-16be。 |
| 60 | 4 | 由 user_version pragma 读取和设置的“用户版本”。 |
| 64 | 4 | 增量清理模式时为真（非零）。否则为假（零）。 |
| 68 | 4 | 由 PRAGMA application_id 设置的“应用程序 ID”。 |
| 72 | 20 | 用于扩展保留的字段。必须为零。 |
| 92 | 4 | version-valid-for number。 |
| 96 | 4 | SQLITE_VERSION_NUMBER |

### 1.3.1\. 魔术头字符串

每个有效的 SQLite 数据库文件以以下 16 字节（十六进制）开头：53 51 4c 69 74 65 20 66 6f 72 6d 61 74 20 33 00。这个字节序列对应于 UTF-8 字符串“SQLite format 3”，包括末尾的空字符。

### 1.3.2\. 页面大小

从 SQLite 版本 3.7.1（2010-08-23）开始，偏移量 16 处的两字节值确定数据库的页面大小。对于 SQLite 版本 3.7.0.1（2010-08-04）及更早版本，此值被解释为大端整数，并且必须是 512 到 32768 之间的二的幂次方。从 SQLite 版本 3.7.1 开始，支持 65536 字节的页面大小。值 65536 无法用两字节整数表示，因此要指定 65536 字节的页面大小，偏移量 16 处的值为 0x00 0x01。该值可以解释为大端数 1，用来表示 65536 页面大小的魔数。或者可以将两字节字段视为小端数，并说它表示页面大小除以 256。页面大小字段的这两种解释是等效的。

### 1.3.3\. 文件格式版本号

文件格式写入版本和文件格式读取版本在偏移量 18 和 19 处，旨在允许 SQLite 的未来版本中对文件格式进行增强。在当前的 SQLite 版本中，这两个值对于回滚日志模式都是 1，对于 WAL 日志模式是 2。如果一个按照当前文件格式规范编码的 SQLite 版本遇到读取版本为 1 或 2 但写入版本大于 2 的数据库文件，则必须将该数据库文件视为只读。如果遇到读取版本大于 2 的数据库文件，则该数据库无法读取或写入。

### 1.3.4\. 每页保留字节

SQLite 具有在每个页面末尾预留少量额外字节的能力，供扩展使用。例如，SQLite 加密扩展使用这些额外字节存储与每个页面相关的 nonce 和/或密码校验和。偏移量 20 处的 1 字节整数 "保留空间" 大小是每页末尾为扩展预留的字节数。通常此值为 0。该值可以是奇数。

数据库页面的“可用大小”是头部偏移量 16 处指定的页面大小减去头部偏移量 20 处记录的“保留”空间大小。页面的可用大小可能是奇数。但是，可用大小不得少于 480。换句话说，如果页面大小为 512，则保留空间大小不能超过 32。

### 1.3.5\. 负载分数

嵌入式负载分数的最大和最小值以及叶负载分数值必须为 64、32 和 32。这些值最初设计为可调参数，可用于修改 B 树算法的存储格式。然而，此功能未得到支持，未来也没有当前计划添加支持。因此，这三个字节的值被固定为指定的值。

### 1.3.6\. 文件更改计数器

文件更改计数器是一个 4 字节的大端整数，在偏移量 24 处，每当数据库文件在被修改后解锁时递增。当两个或多个进程读取同一数据库文件时，每个进程可以通过监视更改计数器来检测其他进程的数据库更改。一个进程通常会希望在其他进程修改数据库时刷新其数据库页面缓存，因为缓存已经过时。文件更改计数器有助于实现这一点。

在 WAL 模式下，使用 wal-index 检测数据库的更改，因此不需要更改计数器。因此，在 WAL 模式下，更改计数器可能不会在每个事务中递增。

### 1.3.7\. 头部中的数据库大小

数据库文件头部偏移量 28 处的 4 字节大端整数存储数据库文件的页面大小。如果此头部数据大小无效（参见下一段），则通过实际数据库文件的大小来计算数据库大小。较早的 SQLite 版本会忽略头部数据库大小，而仅使用实际文件大小。更新的 SQLite 版本如果可用则使用头部数据库大小，但如果头部数据库大小无效则回退到实际文件大小。

只有当头部数据库大小非零且偏移量 24 处的 4 字节变更计数器与偏移量 92 处的 4 字节适用版本号完全匹配时，头部数据库大小才被视为有效。当仅使用较新版本的 SQLite 进行数据库修改时，头部数据库大小始终有效，从 SQLite 3.7.0（2010-07-21）及更高版本开始。如果使用旧版 SQLite 写入数据库，则无法更新头部数据库大小，因此头部数据库大小可能不正确。但是，旧版 SQLite 也会保持偏移量 92 处的版本号不变，因此它不会与变更计数器匹配。因此，可以通过观察变更计数器与适用版本号不匹配来检测（和忽略）无效的头部数据库大小。

### 1.3.8\. 空闲页列表

数据库文件中未使用的页面存储在空闲列表中。位于偏移量 32 处的 4 字节大端整数存储空闲列表中第一页的页码，如果空闲列表为空则为零。位于偏移量 36 处的 4 字节大端整数存储空闲列表中页面的总数。

### 1.3.9\. Schema cookie

在偏移量为 40 的位置，模式 cookie 是一个 4 字节的大端整数，每当数据库模式发生更改时就会递增。准备语句是针对特定版本的数据库模式编译的。当数据库模式发生更改时，必须重新准备该语句。当准备语句运行时，首先检查模式 cookie 以确保其值与准备语句时相同，如果模式 cookie 发生更改，则该语句要么自动重新准备和重新运行，要么中止并显示 SQLITE_SCHEMA 错误。

### 1.3.10\. 模式格式编号

模式格式编号是一个 4 字节的大端整数，在偏移量 44 处。模式格式编号类似于偏移量 18 和 19 处的文件格式读取和写入版本号，但模式格式编号是高级 SQL 格式而不是低级 B 树格式。目前定义了四种模式格式编号：

1.  格式 1 被所有 SQLite 版本理解，追溯到版本 3.0.0（2004-06-18）。

1.  格式 2 增加了同一表中行可以具有不同列数的能力，以支持 ALTER TABLE ... ADD COLUMN 功能。对格式 2 的读取和写入支持是在 SQLite 版本 3.1.3（2005-02-20）中添加的。

1.  格式 3 增加了由 ALTER TABLE ... ADD COLUMN 添加的额外列具有非 NULL 默认值的能力。此功能是在 SQLite 版本 3.1.4（2005-03-11）中添加的。

1.  格式 4 导致 SQLite 在索引声明中尊重 DESC 关键字。（在格式 1、2 和 3 的索引中，DESC 关键字被忽略。）格式 4 还添加了两个新的布尔记录类型值（串行类型 8 和 9）。支持格式 4 是在 SQLite 3.3.0（2006-01-10）中添加的。

SQLite 默认使用格式 4 创建新的数据库文件。可以使用 legacy_file_format pragma 来使 SQLite 创建格式 1 的新数据库文件。可以通过在编译时设置 SQLITE_DEFAULT_FILE_FORMAT=1 将格式版本号默认设置为 1。

### 1.3.11\. 建议的缓存大小

偏移量为 48 的四字节大端符号整数是数据库文件的建议缓存大小（以页面为单位）。该值仅供参考，SQLite 不承担任何义务来遵循它。整数的绝对值作为建议大小使用。建议的缓存大小可以使用 default_cache_size pragma 设置。

### 1.3.12\. 增量清理设置

偏移量为 52 和 64 的两个四字节大端整数用于管理 auto_vacuum 和 incremental_vacuum 模式。如果偏移量为 52 的整数为零，则数据库文件中省略指针映射（ptrmap）页面，并且不支持自动清理或增量清理。如果偏移量为 52 的整数非零，则它是数据库文件中最大根页面的页号，数据库文件将包含 ptrmap 页面，并且模式必须是自动清理或增量清理。在后一种情况下，偏移量为 64 的整数对于增量清理为真，对于自动清理为假。如果偏移量为 52 的整数为零，则偏移量为 64 的整数也必须为零。

### 1.3.13\. 文本编码

偏移量为 56 的 4 字节大端整数确定数据库中存储的所有文本字符串所使用的编码。值为 1 表示 UTF-8，值为 2 表示 UTF-16le，值为 3 表示 UTF-16be。不允许其他值。sqlite3.h 头文件定义了 C 预处理宏 SQLITE_UTF8 为 1，SQLITE_UTF16LE 为 2，SQLITE_UTF16BE 为 3，用于替代文本编码的数值代码。

### 1.3.14\. 用户版本号

偏移量为 60 的 4 字节大端整数是由 user_version pragma 设置和查询的用户版本。SQLite 不使用用户版本。

### 1.3.15\. 应用程序 ID

偏移量为 68 的 4 字节大端整数是可以通过 PRAGMA application_id 命令设置的“应用程序 ID”，以便识别数据库所属或与特定应用程序相关联。应用程序 ID 用于作为 应用程序文件格式 使用的数据库文件。应用程序 ID 可以被诸如 [file(1)](http://www.darwinsys.com/file/) 的实用程序使用，以确定具体的文件类型，而不仅仅报告“SQLite3 数据库”。可以通过查阅 SQLite 源代码仓库中的 [magic.txt](https://www.sqlite.org/src/artifact?ci=trunk&filename=magic.txt) 文件来查看分配的应用程序 ID 的列表。

### 1.3.16\. 写库版本号和版本有效号码

偏移量为 96 的 4 字节大端整数存储了最近修改数据库文件的 SQLITE_VERSION_NUMBER 值。偏移量为 92 的 4 字节大端整数是版本号存储时的 更改计数器 值。偏移量为 92 的整数指示版本号有效的事务，并有时称为“版本有效号码”。

### 1.3.17\. 头部空间保留用于扩展

数据库文件头的所有其他字节均保留供未来扩展使用，并且必须设置为零。

## 1.4\. 锁字节页

锁字节页是数据库文件中的单个页面，在 1073741824 到 1073742335 之间的偏移量包含字节。文件大小小于或等于 1073741824 字节的数据库文件不包含锁字节页。大于 1073741824 的数据库文件包含恰好一个锁字节页。

锁字节页专门供操作系统特定的 VFS 实现使用，用于实现数据库文件锁定原语。SQLite 不使用锁字节页。SQLite 核心永远不会读取或写入锁字节页，尽管操作系统特定的 VFS 实现可以根据底层系统的需要选择性地读取或写入锁字节页上的字节。内置于 SQLite 的 unix 和 win32VFS 实现不会写入锁字节页，但是针对其他操作系统的第三方 VFS 实现可能会。

锁字节页源于支持 Win95 的需求，当时它是设计此文件格式的主要操作系统，并且仅支持强制文件锁定。我们所知的所有现代操作系统都支持建议性文件锁定，因此锁字节页现在实际上不再需要，但为了向后兼容性而保留。

## 1.5\. 自由列表

数据库文件可能包含一个或多个未处于活动使用状态的页。未使用的页可能是由于从数据库中删除信息而导致的。未使用的页存储在自由列表上，并在需要更多页时进行重用。

自由列表以自由列表主干页的链表形式组织，每个主干页包含零个或多个自由列表叶页的页码。

空闲列表主干页由一个 4 字节大端整数数组组成。数组的大小是尽可能多的整数，以适合页面的可用空间。最小可用空间为 480 字节，因此数组的长度始终至少为 120 个条目。空闲列表主干页的第一个整数是列表中下一个空闲列表主干页的页号，如果这是最后一个空闲列表主干页，则为零。空闲列表主干页的第二个整数是要跟随的叶页指针的数量。将空闲列表主干页上的第二个整数称为 L。如果 L 大于零，则数组索引在 2 到 L+1 之间的整数包含空闲列表叶页的页号。

空闲列表叶页不包含任何信息。SQLite 避免读取或写入空闲列表叶页以减少磁盘 I/O。

在 SQLite 3.6.0（2008-07-16）之前的版本中存在一个 bug，如果空闲列表主干页数组的最后 6 个条目中有任何非零值，将会导致数据库报告为损坏。新版本的 SQLite 没有这个问题。然而，为了使由新版本的 SQLite 创建的数据库文件能够被旧版本的 SQLite 读取，新版本的 SQLite 仍然避免使用空闲列表主干页数组的最后六个条目。

数据库头部存储空闲列表页数，以从文件开始处偏移 36 字节的 4 字节大端整数形式存储。数据库头部还以从文件开始处偏移 32 字节的 4 字节大端整数形式存储第一个空闲列表主干页的页号。

## 1.6\. B-tree 页

B 树算法提供了基于页面的存储设备上的唯一和有序键/数据存储。有关 B 树的背景信息，请参阅 Knuth 的《计算机程序设计艺术》，第 3 卷《排序与搜索》，第 471-479 页。SQLite 使用两种 B 树变体。"表 B 树" 使用 64 位有符号整数键，并在叶子节点中存储所有数据。"索引 B 树" 使用任意键，并且根本不存储数据。

B 树页面可以是内部页面或叶子页面。叶子页面包含键，而在表 B 树的情况下，每个键都有关联数据。内部页面包含 K 个键以及 K+1 个指向子 B 树页面的指针。在内部 B 树页面中，"指针" 只是子页面的 32 位无符号整数页面号。

内部 B 树页面上的键数 K 几乎总是至少为 2，并且通常远远超过 2。唯一的例外是当页面 1 是内部 B 树页面时。由于该页面开头处有数据库头部的存在，页面 1 可用的存储空间少了 100 字节，因此有时（很少情况下），如果页面 1 是内部 B 树页面，则可能只容纳一个单一键。在所有其他情况下，K 都是 2 或更多。K 的上限是页面上能容纳的键的数量。索引 B 树上的大键被分割成 溢出页面，以便没有单个键使用超过页面上四分之一的可用存储空间，因此每个内部页面能够存储至少 4 个键。表 B 树的整数键永远不会太大而需要溢出，因此键溢出仅发生在索引 B 树上。

将叶子 B 树的深度定义为 1，并将任何内部 B 树的深度定义为比其任何子节点的最大深度多 1。在良好形式的数据库中，内部 B 树的所有子节点具有相同的深度。

在内部 B 树页面中，指针和键在逻辑上交替，并且两端都有指针。（前面的句子在概念上理解 - 实际的键和指针布局更加复杂，并将在后续描述。）同一页内的所有键都是唯一的，并且按照从左到右升序逻辑排序。（再次强调，这种顺序是逻辑上的，不是物理上的。键在页面中的实际位置是任意的。）对于任何键 X，指向 X 左侧的指针指向的是所有键小于或等于 X 的 B 树页面。指向 X 右侧的指针指向的是所有键大于 X 的页面。

在内部 B 树页面中，每个键及其左侧的指针被合并成称为“单元”的结构。最右边的指针单独保存。叶 B 树页面没有指针，但仍使用单元结构来保存索引 B 树的键或表 B 树的键和内容。数据也包含在单元中。

每个 B 树页面最多只有一个父 B 树页面。没有父页面的 B 树页面称为根页面。根 B 树页面与其子页面的闭包形成一个完整的 B 树。可能（事实上相当普遍）存在一个完整的 B 树，它由一个既是叶子又是根的单个页面组成。由于存在从父页面到子页面的指针，如果仅知道根页面，则可以定位完整 B 树的每个页面。因此，B 树是由其根页面编号来标识的。

B 树页可以是表 B 树页或索引 B 树页。在每个完整的 B 树中，所有页都是相同类型的：表或索引。数据库文件中每个行 ID 表（包括 sqlite_schema 等系统表）都有一个表 B 树。数据库文件中每个索引（包括由唯一性约束创建的隐式索引）都有一个索引 B 树。与虚拟表无关联的 B 树。特定的虚拟表实现可能使用影子表进行存储，但这些影子表在数据库模式中将有单独的条目。WITHOUT ROWID 表使用索引 B 树而不是表 B 树，因此数据库文件中每个 WITHOUT ROWID 表都有一个索引 B 树。与 sqlite_schema 表对应的 B 树始终是表 B 树，并且始终具有根页为 1。sqlite_schema 表包含数据库文件中每个其他表和索引的根页号。

表 B 树中的每个条目由 64 位有符号整数键和最多 2147483647 字节的任意数据组成。（表 B 树的键对应于 B 树实现的 SQL 表的 rowid。）内部表 B 树仅保存键和指向子节点的指针。所有数据都包含在表 B 树叶页中。

索引 B 树中的每个条目由最多 2147483647 字节长的任意键组成，而没有数据。

定义单元格的“有效载荷”是单元格的任意长度部分。对于索引 B 树，键始终是任意长度的，因此有效载荷即为键。在内部表 B 树页的单元格中没有任意长度的元素，因此这些单元格没有有效载荷。表 B 树叶页包含任意长度的内容，因此对于这些页上的单元格，有效载荷即为内容。

当单元的有效载荷大小超过一定阈值（稍后定义），则仅在 b 树页上存储有效载荷的前几个字节，其余存储在内容溢出页的链接列表中。

b 树页按以下顺序分为各个区域：

1.  100 字节的数据库文件头部（仅在页面 1 上找到）

1.  8 或 12 字节的 b 树页头部。

1.  单元指针数组。

1.  未分配空间。

1.  单元内容区域。

1.  保留区域。

100 字节的数据库文件头部仅在页面 1 上找到，该页面始终是表 b 树页。

保留区域是每页（除了锁定页）末尾未使用空间的区域，用于保存每页信息。保留区域的大小由数据库文件头部偏移量为 20 处的单字节无符号整数确定。保留区域的大小通常为零。

叶页的 b 树页头部大小为 8 字节，内部页为 12 字节。页面头部中的所有多字节值均为大端序。b 树页头部由以下字段组成：

*B 树页头格式*

| Offset | Size | 描述 |
| --- | --- | --- |

| 0 | 1 | 偏移量为 0 的单字节标志，表示 b 树页的类型。

+   值为 2（0x02）表示该页为内部索引 b 树页。

+   值为 5（0x05）表示该页为内部表 b 树页。

+   值为 10（0x0a）表示该页为叶索引 b 树页。

+   值为 13（0x0d）表示该页为叶表 b 树页。

b 树页类型的任何其他值都是错误。 |

| 1 | 2 | 偏移量为 1 的两字节整数，表示页面上第一个空闲块的起始位置，如果没有空闲块则为零。 |
| --- | --- | --- |
| 3 | 2 | 偏移量为 3 的两字节整数，表示页面上的单元数。 |
| 5 | 2 | 偏移量为 5 的两字节整数指定单元格内容区域的起始位置。如果这个整数的值为零，则解释为 65536。 |
| 7 | 1 | 偏移量为 7 的一字节整数给出单元格内容区域内碎片化的空闲字节数。 |
| 8 | 4 | 偏移量为 8 的四字节页码是最右侧指针。该值仅出现在内部 b 树页面的头部，并且在所有其他页面中被省略。 |

b 树页面的单元格指针数组紧随 b 树页面头部之后。设 K 为 b 树上的单元格数。单元格指针数组由 K 个 2 字节整数偏移量组成，指向单元格内容。单元格指针按键顺序排列，最左侧的单元格（具有最小键的单元格）在最前面，最右侧的单元格（具有最大键的单元格）在最后面。

单元格内容存储在 b 树页面的单元格内容区域中。SQLite 努力将单元格尽可能放在 b 树页面的末尾，以便为单元格指针数组的未来增长留出空间。最后一个单元格指针数组条目与第一个单元格的开头之间的区域是未分配区域。

如果一个页面不包含任何单元格（这只可能发生在包含零行的表的根页面上），那么到单元格内容区域的偏移量将等于页面大小减去保留空间的字节数。如果数据库使用的是 65536 字节的页面大小，并且保留空间为零（保留空间的通常值），那么空页面的单元格内容偏移量将是 65536。然而，该整数太大，无法存储在一个 2 字节的无符号整数中，因此使用 0 代替。

自由块是用于标识 B 树页面内未分配空间的结构。自由块按链式组织。自由块的前 2 个字节是一个大端整数，表示链中下一个自由块的偏移量，或者如果自由块是链中的最后一个，则为零。每个自由块的第三和第四个字节组成一个大端整数，表示自由块的字节大小，包括 4 字节的头部。自由块总是按偏移量递增的顺序连接在一起。B 树页面头的第二个字段是第一个自由块的偏移量，如果页面上没有自由块，则为零。在格式良好的 B 树页面中，第一个自由块之前总会有至少一个单元。

一个自由块至少需要 4 个字节的空间。如果在单元内容区域中有一组孤立的 1、2 或 3 个未使用的字节，则这些字节构成一个片段。所有片段中的字节总数存储在 B 树页面头的第五个字段中。在格式良好的 B 树页面中，片段中的字节总数不得超过 60。

B 树页面上的空闲空间总量包括未分配区域的大小、所有自由块的总大小以及片段化的空闲字节数。SQLite 有时会重新组织 B 树页面，以确保没有自由块或片段字节，所有未使用的字节都包含在未分配空间区域中，并且所有单元紧密打包在页面的末尾。这称为“碎片整理”B 树页面。

变长整数或“varint”是 64 位二补数整数的静态哈夫曼编码，对于小正值使用较少空间。Varint 的长度在 1 到 9 字节之间。Varint 由零个或多个设置高位比特的字节组成，后跟一个清除高位比特的单个字节，或者九个字节，以较短者为准。前八个字节的低七位和第九个字节的所有 8 位用于重构 64 位二补数整数。Varint 是大端序的：来自 varint 较早字节的位比来自后续字节的位更重要。

单元的格式取决于单元出现在哪种 B-Tree 页上。下表按照各种 B-Tree 页类型中单元出现的顺序显示了单元的各个元素。

表 B-Tree 叶子单元（头部 0x0d）：

+   负载的总字节数，包括任何溢出，作为 varint

+   整数键的 varint，又称“行 ID”

+   负载的初始部分不会溢出到溢出页面。

+   第一页溢出页列表的 4 字节大端整数页号 - 如果所有负载都适合 B-Tree 页，则省略。

表 B-Tree 内部单元（头部 0x05）：

+   左子指针的 4 字节大端页号。

+   varint 作为整数键

索引 B-Tree 叶子单元（头部 0x0a）：

+   键负载的总字节数，包括任何溢出，作为 varint

+   负载的初始部分不会溢出到溢出页面。

+   第一页溢出页列表的 4 字节大端整数页号 - 如果所有负载都适合 B-Tree 页，则省略。

索引 B-Tree 内部单元（头部 0x02）：

+   左子指针的 4 字节大端页号。

+   键负载的总字节数，包括任何溢出，作为 varint

+   负载的初始部分不会溢出到溢出页面。

+   4 字节大端整数页码，表示溢出页面列表的第一个页面的页码 - 如果所有有效载荷都适合于 B 树页面，则省略。

上述信息可以按以下表格格式重新整理：

*B 树单元格格式*

| 数据类型 | 出现在... | 描述 |
| --- | --- | --- |
| 表叶（0x0d） | 表内部（0x05） | 索引叶（0x0a） | 索引内部（0x02） |
| 4 字节整数 |   | ✔ |   | ✔ | 左子节点的页面编号 |
| varint | ✔ |   | ✔ | ✔ | 有效载荷字节数 |
| varint | ✔ | ✔ |   |   | 行标识符 |
| 字节数组 | ✔ |   | ✔ | ✔ | 有效载荷 |
| 4 字节整数 | ✔ |   | ✔ | ✔ | 第一个溢出页面的页面编号 |

溢出到溢出页面的有效载荷量还取决于页面类型。对于以下计算，让 U 表示数据库页面的可用大小，即每个页面末尾的保留空间减去总页面大小。让 P 表示有效载荷大小。在下文中，符号 X 表示可以直接存储在 B 树页面上的最大有效载荷量，而符号 M 表示必须在允许溢出之前存储在 B 树页面上的最小有效载荷量。

表 B 树叶单元格：

让 X 等于 U-35。如果有效载荷大小 P 小于或等于 X，则整个有效载荷存储在 B 树叶页面上。让 M 等于 ((U-12)*32/255)-23，让 K 等于 M+((P-M)%(U-4))。如果 P 大于 X，则在表 b 树叶页面上存储的字节数为 K，如果 K 小于或等于 X，则为 M。页面上存储的字节数永远不会少于 M。

表 B 树内部单元格：

表 b 树的内部页面没有有效载荷，因此永远不会有需要溢出的有效载荷。

索引 B 树叶或内部单元格：

设 X 为((U-12)*64/255)-23。如果有效载荷大小 P 小于或等于 X，则整个有效载荷存储在 B 树页面上。设 M 为((U-12)*32/255)-23，K 为 M+((P-M)%(U-4))。如果 P 大于 X，则在索引 B 树页面上存储的字节数为 K（如果 K 小于或等于 X），否则为 M。在索引页面上存储的字节数永远不会小于 M。

下面是相同计算的另一种描述：

+   对于表 B 树叶页，X 为 U-35，对于索引页，X 为((U-12)*64/255)-23。

+   M 始终为((U-12)*32/255)-23。

+   设 K 为 M+((P-M)%(U-4))。

+   如果 P<=X，则有效载荷的所有 P 字节直接存储在 B 树页面上，无需溢出。

+   如果 P>X 且 K<=X，则 P 的前 K 字节存储在 B 树页面上，剩余的 P-K 字节存储在溢出页面上。

+   如果 P>X 且 K>X，则 P 的前 M 字节存储在 B 树页面上，剩余的 P-M 字节存储在溢出页面上。

溢出阈值的设计旨在为索引 B 树提供至少 4 个最小扇出，并确保足够的有效负载位于 B 树页面上，以便记录头通常无需查看溢出页面即可访问。事后，SQLite B 树逻辑的设计者意识到这些阈值本可以简化得多。但是，这些计算不能更改，否则将导致不兼容的文件格式。当前的计算方法即使有些复杂，但效果仍然不错。

## 1.7\. 单元载荷溢出页面

当 B 树单元的有效载荷过大无法在 B 树页面上容纳时，剩余部分会溢出到溢出页面上。溢出页面形成一个链表。每个溢出页面的前四个字节是大端整数，表示链中下一页的页码，或者对于链的最后一页为零。从第五个字节到最后一个可用字节用于存储溢出内容。

## 1.8\. 指针映射或 Ptrmap 页面

指针映射或 Ptrmap 页是额外插入数据库的页面，以使 auto_vacuum 和 incremental_vacuum 模式的操作更加高效。数据库中的其他页面类型通常具有从父到子的指针。例如，内部 b 树页包含指向其子 b 树页的指针，溢出链有从链中较早到较晚链接的指针。Ptrmap 页包含相反方向的链接信息，即从子到父。

在数据库文件中，如果偏移量 52 处的数据库头部存在非零的最大根 b 树页值，则必须存在 Ptrmap 页。如果最大根 b 树页值为零，则数据库不得包含 Ptrmap 页。

在具有 Ptrmap 页的数据库中，第一个 Ptrmap 页是第 2 页。Ptrmap 页由一组 5 字节条目组成。设 J 为可用空间中适合的 5 字节条目的数量。（换句话说，J=U/5。）第一个 Ptrmap 页将包含页面 3 到 J+2 的反向指针信息，包括在内。第二个指针映射页将位于页 J+3，并且该 Ptrmap 页将为页面 J+4 到 2*J+3 提供反向指针信息。整个数据库文件也是如此。

在使用 Ptrmap 页的数据库中，所有通过上一段计算确定位置的页面必须是 Ptrmap 页，不能有其他页面是 Ptrmap 页。除非字节锁页恰好落在与 Ptrmap 页相同的页码上，那么对于这种情况，Ptrmap 将移至后续页。

Ptrmap 页上的每个 5 字节条目提供关于紧随指针映射的页面之一的反向链接信息。如果页面 B 是 Ptrmap 页，则第一个条目提供关于页面 B+1 的反向链接信息。第二个条目提供关于页面 B+2 的信息，依此类推。

每个 5 字节的 ptrmap 条目由一字节的“页面类型”信息和随后的 4 字节大端页号组成。识别了五种页面类型：

1.  一个 B 树根页面。页号应为零。

1.  一个空闲列表页面。页号应为零。

1.  单元负载溢出链的第一页。页号是包含溢出单元内容的 B 树页面。

1.  一个溢出链中除第一页外的页面。页号是溢出链的前一页。

1.  一个非根 B 树页面。页号是父 B 树页面。

在任何包含 ptrmap 页面的数据库文件中，所有 B 树根页面必须位于任何非根 B 树页面、单元负载溢出页面或空闲列表页面之前。此限制确保根页面在自动清理或增量清理期间永不移动。自动清理逻辑不知道如何更新 sqlite_schema 表的 root_page 字段，因此有必要在自动清理期间阻止根页面的移动，以保持 sqlite_schema 表的完整性。根页面通过 CREATE TABLE、CREATE INDEX、DROP TABLE 和 DROP INDEX 操作移动到数据库文件的开头。

# 2\. 架构层

前述文本描述了 SQLite 文件格式的低级方面。B 树机制提供了访问大数据集的强大高效手段。本节将描述如何使用低级 B 树层来实现更高级别的 SQL 功能。

## 2.1\. 记录格式

表 B 树叶页的数据和索引 B 树页的键被描述为任意字节序列。前面的讨论提到了一个键小于另一个键，但没有定义“小于”是什么意思。当前章节将解决这些遗漏。

负载，无论是表 B 树数据还是索引 B 树键，始终处于“记录格式”中。 记录格式定义了与表或索引中的列对应的值序列。 记录格式指定了列的数量，每列的数据类型以及每列的内容。  

记录格式广泛使用上述定义的 64 位有符号整数的变长整数或变长整数表示。  

记录包含头部和主体，按顺序排列。 头部以单个变长整数开始，该整数确定头部总字节数。 变长整数的值是头部字节数，包括变长整数本身的大小。 在大小变长整数之后，每列有一个或多个额外的变长整数，每个变长整数对应一个列。 这些额外的变长整数称为“序列类型”号码，并根据以下图表确定每列的数据类型：  

*记录格式的序列类型代码*

| 序列类型 | 内容大小 | 意义 |   |
| --- | --- | --- | --- |
| 0 | 0 | 值为 NULL。   |
| 1 | 1 | 值是 8 位补码整数。   |
| 2 | 2 | 值是大端序的 16 位补码整数。   |
| 3 | 3 | 值是大端序的 24 位补码整数。   |
| 4 | 4 | 值是大端序的 32 位补码整数。   |
| 5 | 6 | 值是大端序的 48 位补码整数。   |
| 6 | 8 | 值是大端序的 64 位补码整数。   |
| 7 | 8 | 值是大端序的 IEEE 754-2008 标准的 64 位浮点数。   |
| 8 | 0 | 值是整数 0。（仅适用于模式格式 4 及更高版本。）   |
| 9 | 0 | 值是整数 1。（仅适用于模式格式 4 及更高版本。）   |
| 10,11 | *variable* | *保留供内部使用。这些序列类型代码不会出现在格式良好的数据库文件中，但它们可能会在 SQLite 为自己使用时生成的瞬时和临时数据库文件中使用。这些代码的含义可能会从一个 SQLite 版本转变到下一个版本。* |
| N≥12 且为偶数 | (N-12)/2 | 值是一个 BLOB，长度为(N-12)/2 字节。 |
| N≥13 且为奇数 | (N-13)/2 | 值是使用 文本编码 的字符串，长度为(N-13)/2 字节。不存储空终止符。 |

头部大小的可变整数和序列类型的可变整数通常只包含一个字节。对于大字符串和 BLOBs 的序列类型可变整数可能会延伸到两到三个字节的可变整数，但这只是例外而非规则。可变整数格式在编码记录头部时非常高效。

记录中每列的值紧跟在头部之后。对于序列类型为 0、8、9、12 和 13 的情况，值的长度为零字节。如果所有列都是这些类型，则记录的正文部分为空。

一个记录可能比相应表中的列数少。例如，在执行 ALTER TABLE ... ADD COLUMN SQL 语句增加表模式中的列数后，表中的预先存在的行未修改的情况下可能发生这种情况。记录末尾的缺失值使用表模式中相应列的 默认值 进行填充。

## 2.2\. 记录排序顺序

索引 B 树中键的顺序由它们所代表的记录的排序顺序决定。记录比较逐列进行。记录的列从左到右进行检查。第一对不相等的列确定了两条记录的相对顺序。各列的排序顺序如下：

1.  NULL 值（序列类型 0）排序最优先。

1.  数值（序列类型 1 到 9）在 NULL 值之后按数值顺序排序。

1.  文本值（奇数序列类型 13 及更大）在数值值之后按照列 排序函数 确定的顺序排序。

1.  BLOB 值（包括序列类型 12 及更大）在排序时排在最后，并且按照 memcmp() 确定的顺序排序。

每个列的 排序函数 都是为了计算文本字段的顺序而必需的。SQLite 定义了三个内置的排序函数：

> | 二进制 | 内置的二进制排序通过使用标准 C 库中的 memcmp() 函数逐字节比较字符串。 |
> | --- | --- |
> | NOCASE | NOCASE 排序与 BINARY 排序类似，但是大写 ASCII 字符（'A' 到 'Z'）在进行比较之前会转换为它们的小写等效字符。只有 ASCII 字符会进行大小写折叠。NOCASE 不实现通用的 Unicode 无大小写比较功能。 |
> | RTRIM | RTRIM 与 BINARY 类似，但是字符串末尾的额外空格不会改变结果。换句话说，只要它们仅在末尾空格数量上有所不同，字符串就会相等。 |

可以使用 sqlite3_create_collation() 接口向 SQLite 添加额外的应用特定排序函数。

所有字符串的默认排序函数都是 BINARY。可以在 CREATE TABLE 语句的 列定义 中使用 COLLATE 子句指定表列的备选排序函数。当列被索引时，默认情况下使用在 CREATE TABLE 语句中指定的相同排序函数作为索引中的列，尽管可以使用 CREATE INDEX 语句中的 COLLATE 子句进行覆盖。

## 2.3\. SQL 表的表示

数据库架构中每个普通的 SQL 表都由一个表 b 树在磁盘上表示。表 b 树中的每个条目对应于 SQL 表的一行。SQL 表的 rowid 是表 b 树中每个条目的 64 位有符号整数键。

每个 SQL 表行的内容首先通过将各列的值组合成记录格式的字节数组，然后将该字节数组作为表 b 树中条目的有效载荷存储在数据库文件中。记录中的值顺序与 SQL 表定义中列的顺序相同。当 SQL 表包括一个 INTEGER PRIMARY KEY 列（别名为 rowid）时，该列在记录中表现为 NULL 值。SQLite 在引用 INTEGER PRIMARY KEY 列时总是使用表 b 树键而不是 NULL 值。

如果列的亲和性为 REAL 并且该列包含的值可以在不丢失信息的情况下转换为整数（如果值不包含小数部分且不太大以至于不能表示为整数），则该列可能作为整数存储在记录中。SQLite 在从记录中提取值时将该值转换回浮点数。

## 2.4\. WITHOUT ROWID 表的表示

如果在其 CREATE TABLE 语句的末尾使用了 "WITHOUT ROWID" 子句来创建 SQL 表，那么该表就是一个无 ROWID 表，并且使用不同的磁盘表示。无 ROWID 表使用索引 B 树而不是表 B 树进行存储。每个无 ROWID B 树中条目的键是由主键列组成的记录，后跟表的所有剩余列。主键列按照它们在主键子句中声明的顺序排列，剩余列按照它们在 CREATE TABLE 语句中出现的顺序排列。

因此，无 ROWID 表的内容编码与普通行 ID 表的内容编码相同，只是列的顺序重新排列，使主键列首先出现，并且内容用作索引 B 树中的键，而不是表 B 树中的数据。具有 REAL 亲和性的列的特殊编码规则也适用于无 ROWID 表，就像它们对行 ID 表一样。

### 2.4.1\. 在无 ROWID 表的主键中抑制冗余列

如果无 ROWID 表的主键使用相同的列和相同的排序顺序超过一次，那么在主键定义中第二次及后续出现的该列会被忽略。例如，以下 CREATE TABLE 语句都指定了相同的表，该表在磁盘上具有完全相同的表示：

> ```sql
> CREATE TABLE t1(a,b,c,d,PRIMARY KEY(a,c)) WITHOUT ROWID;
> CREATE TABLE t1(a,b,c,d,PRIMARY KEY(a,c,a,c)) WITHOUT ROWID;
> CREATE TABLE t1(a,b,c,d,PRIMARY KEY(a,A,a,C)) WITHOUT ROWID;
> CREATE TABLE t1(a,b,c,d,PRIMARY KEY(a,a,a,a,c)) WITHOUT ROWID;
> 
> ```

当然，上述第一个示例是表的首选定义。所有示例都创建了一个无 ROWID 表，其中有两个主键列 "a" 和 "c"，按顺序排列，后跟两个数据列 "b" 和 "d"，同样按顺序排列。

## 2.5\. SQL 索引的表示

每个 SQL 索引，无论是通过 CREATE INDEX 语句显式声明还是由 UNIQUE 或 PRIMARY KEY 约束隐含声明，都对应于数据库文件中的一个索引 B 树。索引 B 树中的每个条目对应于关联 SQL 表中的单个行。索引 B 树的键是由正在索引的列组成，后跟相应表行的键。对于普通表，行键是 rowid，对于 WITHOUT ROWID 表，行键是主键。因为表中的每一行都有唯一的行键，索引中的所有键都是唯一的。

在正常的索引中，表中的行与与该表关联的每个索引中的条目之间存在一对一的映射。但是，在部分索引中，索引 B 树仅包含 CREATE INDEX 语句的 WHERE 子句表达式为 true 的表行对应的条目。索引和表 B 树中的相应行共享相同的 rowid 或主键值，并且对于所有索引列都包含相同的值。

### 2.5.1\. 在 WITHOUT ROWID 次要索引中抑制冗余列

在 WITHOUT ROWID 表的索引中，如果主键的某列也是索引中的列，并且具有匹配的排序序列，那么该索引列在索引记录末尾的表键后缀中不会重复出现。例如，请考虑以下 SQL：

> ```sql
> CREATE TABLE ex25(a,b,c,d,e,PRIMARY KEY(d,c,a)) WITHOUT rowid;
> CREATE INDEX ex25ce ON ex25(c,e);
> CREATE INDEX ex25acde ON ex25(a,c,d,e);
> CREATE INDEX ex25ae ON ex25(a COLLATE nocase,e);
> 
> ```

ex25ce 索引中的每一行都是一个记录，具有以下列：c、e、d、a。前两列是正在索引的列，即 c 和 e。剩余的列是相应表行的主键。通常，主键将是列 d、c 和 a，但由于列 c 已在索引中首次出现，因此在键后缀中被省略。

在索引的列涵盖主键的所有列的极端情况下，索引将仅由索引的列组成。上面的 ex25acde 示例演示了这一点。ex25acde 索引中的每个条目仅由列 a、c、d 和 e 组成，按顺序排列。

ex25ae 中的每一行包含五列：a、e、d、c、a。由于第一次出现的 "a" 列具有 "nocase" 的排序功能，而第二次出现的具有 "binary" 的排序序列，因此 "a" 列被重复。如果 "a" 列不重复，并且表中包含两个或更多具有相同 "e" 值的条目，并且 "a" 只是大小写不同，则所有这些表条目将对应于索引中的一个条目，这将打破表与索引之间的一对一对应关系。

在没有 ROWID 表中，索引条目的键后缀中冗余列的抑制仅发生在普通 ROWID 表中。在普通 ROWID 表中，即使 INTEGER PRIMARY KEY 列是被索引的列之一，索引条目也总是以 ROWID 结束。

## 2.6\. SQL 数据库模式的存储

数据库文件的第一页是保存名为 "sqlite_schema" 的特殊表的表 b-tree 的根页。这个 b-tree 被称为“模式表”，因为它存储了完整的数据库模式。sqlite_schema 表的结构就像是使用以下 SQL 创建的：

> ```sql
> CREATE TABLE sqlite_schema(
>   type text,
>   name text,
>   tbl_name text,
>   rootpage integer,
>   sql text
> );
> 
> ```

sqlite_schema 表中每个表、索引、视图和触发器（统称为“对象”）都有一行记录，但 sqlite_schema 表本身没有条目。除了应用程序和程序员定义的对象外，sqlite_schema 表还包含内部模式对象的条目。

列 `sqlite_schema.type` 将是以下文本字符串之一：'table'、'index'、'view' 或 'trigger'，根据定义的对象类型而定。'table' 字符串用于普通和 virtual tables。

列 `sqlite_schema.name` 将保存对象的名称。对表的 UNIQUE 和 PRIMARY KEY 约束会导致 SQLite 创建形如"sqlite_autoindex_TABLE_N"的内部索引，其中 TABLE 被替换为包含约束的表的名称，N 是从 1 开始逐个递增的整数，每个约束在表定义中都会看到。在 WITHOUT ROWID 表中，没有主键的 sqlite_schema 条目，但"sqlite_autoindex_TABLE_N"名称被保留用于主键，就像 sqlite_schema 条目确实存在一样。这将影响后续 UNIQUE 约束的编号。"sqlite_autoindex_TABLE_N"名称在 INTEGER PRIMARY KEY 中从不分配，无论是在 rowid 表还是 WITHOUT ROWID 表中。

列 `sqlite_schema.tbl_name` 保存对象关联的表或视图的名称。对于表或视图，tbl_name 列是名称列的副本。对于索引，tbl_name 是被索引的表的名称。对于触发器，tbl_name 列存储引发触发器的表或视图的名称。

列 `sqlite_schema.rootpage` 存储表和索引的根 b-tree 页的页码。对于定义视图、触发器和虚拟表的行，rootpage 列为 0 或 NULL。

`sqlite_schema.sql` 列存储描述对象的 SQL 文本。此 SQL 文本是 CREATE TABLE、CREATE VIRTUAL TABLE、CREATE INDEX、CREATE VIEW 或 CREATE TRIGGER 语句，如果在作为 数据库连接 的主数据库时对数据库文件进行评估，则会重新创建对象。该文本通常是用于创建对象的原始语句的副本，但已应用了归一化，以便文本符合以下规则：

+   语句开头的 `CREATE`、`TABLE`、`VIEW`、`TRIGGER` 和 `INDEX` 关键字会转换为大写字母。

+   如果在初始 `CREATE` 关键字之后出现，则移除 `TEMP` 或 `TEMPORARY` 关键字。

+   在创建对象的名称之前出现的任何数据库名称限定符都被移除。

+   移除前导空格。

+   在前两个关键字之后的所有空格都被转换为单个空格。

在 `sqlite_schema.sql` 列中的文本是创建对象的原始 `CREATE` 语句文本的副本，除了按上述方式归一化和后续 ALTER TABLE 语句的修改。对于由 UNIQUE 或 PRIMARY KEY 约束自动创建的 内部索引，`sqlite_schema.sql` 为 `NULL`。

### 2.6.1\. 模式表的备选名称

在文件格式中不会出现名称 "sqlite_schema"。该名称只是数据库实现中使用的约定。出于历史和操作考虑，"sqlite_schema" 表有时也称为以下其中一个别名：

1.  `sqlite_master`

1.  `sqlite_temp_schema`

1.  `sqlite_temp_master`

因为模式表的名称在文件格式中没有出现，所以如果应用程序选择用这些替代名称之一来引用模式表，数据库文件的含义不会改变。

### 2.6.2\. 内部模式对象

除了由应用程序和/或开发者使用 CREATE 语句 SQL 创建的表、索引、视图和触发器外，sqlite_schema 表中可能包含零个或多个*内部模式对象*的条目，这些对象由 SQLite 为其自身的内部使用而创建。内部模式对象的名称始终以"sqlite_"开头，任何以"sqlite_"开头的表、索引、视图或触发器都是内部模式对象。SQLite 禁止应用程序创建名称以"sqlite_"开头的对象。

SQLite 使用的内部模式对象可能包括以下内容：

+   名称为"sqlite_autoindex_TABLE_N"的索引，用于实现普通表上的 UNIQUE 和 PRIMARY KEY 约束。

+   名称为"sqlite_sequence"的表，用于跟踪使用 AUTOINCREMENT 的表的最大历史 INTEGER PRIMARY KEY。

+   名称为"sqlite_statN"（其中 N 是整数）的表。这些表存储由 ANALYZE 命令收集的数据库统计信息，并由查询规划器用于帮助确定每个查询使用的最佳算法。

新的内部模式对象名称，始终以"sqlite_"开头，可能会在将来的 SQLite 文件格式发布中添加。

### 2.6.3\. sqlite_sequence 表

sqlite_sequence 表是一个内部表，用于帮助实现 AUTOINCREMENT。每当创建具有 AUTOINCREMENT 整数主键的任何普通表时，sqlite_sequence 表会自动创建。一旦创建，sqlite_sequence 表将永远存在于 sqlite_schema 表中；它无法被删除。sqlite_sequence 表的模式如下：

> ```sql
> CREATE TABLE sqlite_sequence(name,seq);
> 
> ```

每个使用 AUTOINCREMENT 的普通表在 sqlite_sequence 表中都有一行。表的名称（如在 sqlite_schema.name 中显示的）在 sqlite_sequence.name 字段中，而插入到该表中的最大 INTEGER PRIMARY KEY 在 sqlite_sequence.seq 字段中。为 AUTOINCREMENT 表新生成的整数主键保证大于该表的 sqlite_sequence.seq 字段。如果 AUTOINCREMENT 表的 sqlite_sequence.seq 字段已经达到最大整数值（9223372036854775807），则尝试向该表添加具有自动生成的整数主键的新行将失败，并显示 SQLITE_FULL 错误。如果需要，在插入新条目到 AUTOINCREMENT 表时，sqlite_sequence.seq 字段将自动更新。当删除表时，AUTOINCREMENT 表的 sqlite_sequence 行会被自动删除。如果更新 AUTOINCREMENT 表时 sqlite_sequence 行不存在，则会创建新的 sqlite_sequence 行。如果为 AUTOINCREMENT 表的 sqlite_sequence.seq 值手动设置为非整数，并且随后尝试插入或更新 AUTOINCREMENT 表，则行为未定义。

应用程序代码允许修改 sqlite_sequence 表，添加新行、删除行或修改现有行。但是，如果 sqlite_sequence 表不存在，则应用程序代码不能创建 sqlite_sequence 表。应用程序代码可以删除 sqlite_sequence 表中的所有条目，但不能删除 sqlite_sequence 表。

### 2.6.4\. sqlite_stat1 表

sqlite_stat1 是由 ANALYZE 命令创建的内部表，用于存储关于表和索引的补充信息，查询规划器可以利用这些信息来帮助找到更好的执行查询的方式。应用程序可以更新、删除、插入或删除 sqlite_stat1 表，但不能创建或修改 sqlite_stat1 表。sqlite_stat1 表的架构如下：

> ```sql
> CREATE TABLE sqlite_stat1(tbl,idx,stat);
> 
> ```

每个索引通常有一行，索引由 sqlite_stat1.idx 列中的名称标识。sqlite_stat1.tbl 列是索引所属表的名称。在每一行中，sqlite_stat.stat 列将是一个字符串，由一系列整数和零个或多个参数组成。此列表中的第一个整数是索引中行的大约数量。（索引中的行数与表中的行数相同，除了 部分索引。）第二个整数是索引中具有相同值的第一列的行数的大约数量。第三个整数是索引中具有相同值的前两列的行数。第 N 个整数（对于 N>1）是索引中具有相同值的前 N-1 列的行的估计平均数量。对于 K 列索引，stat 列中将有 K+1 个整数。如果索引是唯一的，则最后一个整数将为 1.

stat 列中的整数列表可以选择地跟随参数，每个参数是一系列非空格字符。所有参数前都有一个单独的空格。未识别的参数将被静默忽略。

如果存在"unordered"参数，则查询规划器假定索引是无序的，并且不会将其用于范围查询或排序。

"sz=NNN"参数（其中 NNN 代表 1 个或多个数字的序列）表示表或索引所有记录的平均行大小为每行 NNN 字节。SQLite 查询规划器可能使用"sz=NNN"标记提供的估计行大小信息，以帮助选择更小的表和索引，从而减少磁盘 I/O。

在索引的 sqlite_stat1.stat 字段上存在"noskipscan"标记，阻止该索引与跳跃扫描优化一起使用。

未来增强 SQLite 时，可以向 stat 列的末尾添加新的文本标记。为了兼容性，stat 列末尾的未识别标记会被静默忽略。

如果 sqlite_stat1.idx 列为 NULL，则 sqlite_stat1.stat 列包含一个单独的整数，该整数是 sqlite_stat1.tbl 标识的表中行的大致数量。如果 sqlite_stat1.idx 列与 sqlite_stat1.tbl 列相同，则该表是无行 ID 表，sqlite_stat1.stat 字段包含实现无行 ID 表的索引 B 树的信息。

### 2.6.5\. sqlite_stat2 表

只有当 SQLite 编译时启用了 SQLITE_ENABLE_STAT2，并且 SQLite 版本号在 3.6.18（2009-09-11）到 3.7.8（2011-09-19）之间时，才会创建并使用 sqlite_stat2。sqlite_stat2 表在 SQLite 3.6.18 之前和 3.7.8 之后的版本中都不会被读取或写入。sqlite_stat2 表包含关于索引内键分布的附加信息。sqlite_stat2 表的模式如下：

> ```sql
> CREATE TABLE sqlite_stat2(tbl,idx,sampleno,sample);
> 
> ```

sqlite_stat2 表中每行的 sqlite_stat2.idx 列和 sqlite_stat2.tbl 列标识由该行描述的索引。每个索引通常在 sqlite_stat2 表中有 10 行。

索引的 sqlite_stat2 条目，其 sqlite_stat2.sampleno 值介于 0 和 9 之间（包括边界值），是在索引上均匀间隔的点上取得的左侧键值的样本。设 C 为索引中的行数。则取样行由以下公式给出：

> rownumber = (i*C*2 + C)/20

前述表达式中的变量 i 的值在 0 和 9 之间变化。在概念上，索引空间被分为 10 个均匀的桶，样本是每个桶中间的行。

sqlite_stat2 的格式在此记录，供遗留参考。SQLite 的最新版本不再支持 sqlite_stat2，如果存在 sqlite_stat2 表，则会被简单地忽略。

### 2.6.6\. sqlite_stat3 表

只有在 SQLite 编译时启用了 SQLITE_ENABLE_STAT3 或 SQLITE_ENABLE_STAT4，并且 SQLite 版本号为 3.7.9（2011-11-01）或更高时，才会使用 sqlite_stat3 表。sqlite_stat3 表在 SQLite 3.7.9 之前的任何版本中既不读也不写。如果使用了 SQLITE_ENABLE_STAT4 编译选项，并且 SQLite 版本号为 3.8.1（2013-10-17）或更高，则可能会读取但不会写入 sqlite_stat3 表。sqlite_stat3 表包含有关索引内键分布的附加信息，查询规划器可以利用这些信息来设计更好更快的查询算法。sqlite_stat3 表的模式如下：

> ```sql
> CREATE TABLE sqlite_stat3(tbl,idx,nEq,nLt,nDLt,sample);
> 
> ```

sqlite_stat3 表中通常会为每个索引存在多个条目。sqlite_stat3.sample 列保存的是由 sqlite_stat3.idx 和 sqlite_stat3.tbl 标识的索引的最左边字段的值。sqlite_stat3.nEq 列保存的是索引中确切匹配样本的条目数的近似值。sqlite_stat3.nLt 列保存的是索引中最左边列小于样本的条目数的近似值。sqlite_stat3.nDLt 列保存的是索引中最左边的唯一条目小于样本的近似不同条目数。

每个索引可以有任意数量的 sqlite_stat3 条目。ANALYZE 命令通常会生成包含分布在键空间中且具有大 nEq 值的 10 到 40 个样本的 sqlite_stat3 表。

在格式良好的 sqlite_stat3 表中，任何单个索引的样本必须按其在索引中出现的顺序出现。换句话说，如果具有最左列 S1 的条目在索引 b 树中早于具有最左列 S2 的条目，则在 sqlite_stat3 表中，样本 S1 必须比样本 S2 的 rowid 小。

### 2.6.7\. sqlite_stat4 表

只有当 SQLite 编译时启用了 SQLITE_ENABLE_STAT4 并且 SQLite 版本号为 3.8.1 (2013-10-17) 或更高时，才会创建并使用 sqlite_stat4 表。sqlite_stat4 表在 SQLite 3.8.1 之前的版本中既不读取也不写入。sqlite_stat4 表包含有关索引内键分布或 WITHOUT ROWID 表主键键分布的附加信息。查询规划器有时可以利用 sqlite_stat4 表中的附加信息来设计更好更快的查询算法。sqlite_stat4 表的模式如下：

> ```sql
> CREATE TABLE sqlite_stat4(tbl,idx,nEq,nLt,nDLt,sample);
> 
> ```

通常对于每个可用统计信息的索引，sqlite_stat4 表中会有 10 到 40 个条目，但这些限制并非硬性限制。sqlite_stat4 表中各列的含义如下：

| tbl: | sqlite_stat4.tbl 列存储了描述的索引所属的表名 |
| --- | --- |
| idx: | sqlite_stat4.idx 列存储了描述的索引名，或者对于 WITHOUT ROWID 表的 sqlite_stat4 条目，存储的是表的名称本身。 |
| sample: | sqlite_stat4.sample 列存储一个 BLOB，以记录格式编码索引列，后跟行 ID（对于 rowid 表）或主键列（对于 WITHOUT ROWID 表）。对于 WITHOUT ROWID 表本身的 sqlite_stat4.sample BLOB，仅包含主键列。设由 sqlite_stat4.sample BLOB 编码的列数为 N。对于普通 rowid 表的索引，N 将比索引列数多一列。对于 WITHOUT ROWID 表的索引，N 将是索引列数加上主键列数。对于 WITHOUT ROWID 表，N 将是主键列数。 |
| nEq: | sqlite_stat4.nEq 列保存了一个包含 N 个整数的列表，其中第 K 个整数是索引中确切匹配样本的 K 个最左列的条目的大约数量。 |
| nLt: | sqlite_stat4.nLt 列保存了一个包含 N 个整数的列表，其中第 K 个整数是索引中条目的大约数量，其 K 个最左列总体小于样本的 K 个最左列。 |
| nDLt: | sqlite_stat4.nDLt 列保存了一个包含 N 个整数的列表，其中第 K 个整数是索引中条目的大约数量，其前 K 列是不同的，并且其 K 个最左列总体小于样本的 K 个最左列。 |

sqlite_stat4 是 sqlite_stat3 表的泛化。sqlite_stat3 表提供了关于索引最左列的信息，而 sqlite_stat4 表提供了关于索引所有列的信息。

每个索引可以有任意数量的 sqlite_stat4 条目。 ANALYZE 命令通常会生成包含分布在键空间中的大约 10 到 40 个样本以及大 nEq 值的 sqlite_stat4 表。

在良好形式的 sqlite_stat4 表中，任何单个索引的样本必须按照它们在索引中出现的顺序出现。换句话说，如果条目 S1 在索引 b 树中比条目 S2 更早出现，那么在 sqlite_stat4 表中，样本 S1 的 rowid 必须比样本 S2 的小。

# 3\. 回滚日志

回滚日志是与每个 SQLite 数据库文件相关联的文件，它保存了在事务进行过程中将数据库文件恢复到初始状态所需的信息。回滚日志文件始终位于与数据库文件相同的目录中，并且具有与数据库文件相同的名称，但附加了字符串`-journal`。给定数据库只能关联一个回滚日志，因此同一时间只能对单个数据库开放一个写事务。

在修改数据库的任何信息页之前，该页的原始未修改内容将被写入回滚日志。如果事务中断并需要回滚，则可以使用回滚日志将数据库恢复到其原始状态。自由列表叶页不包含需要在回滚时恢复的信息，因此它们在修改之前不会写入日志，以减少磁盘 I/O。

如果一个事务因应用程序崩溃、单个操作系统崩溃、硬件断电故障或崩溃而中止，那么主数据库文件可能会留在不一致的状态。下次 SQLite 尝试打开数据库文件时，将检测回滚日志文件的存在，并自动回放日志，将数据库恢复到未完成事务开始时的状态。

只有存在回滚日志文件并包含有效头部时，才认为回滚日志是有效的。因此，事务可以通过以下三种方式提交：

1.  回滚日志文件可以被删除，

1.  回滚日志文件可以被截断为零长度，或者

1.  回滚日志的头部可以被用无效头部文本覆盖（例如，全部为零）。

这三种提交事务的方式分别对应于日志模式控制器的 DELETE、TRUNCATE 和 PERSIST 设置。

一个有效的回滚日志以以下格式的头部开始：

*回滚日志头部格式*

| 偏移量 | 大小 | 描述 |
| --- | --- | --- |
| 0 | 8 | 头字符串：0xd9, 0xd5, 0x05, 0xf9, 0x20, 0xa1, 0x63, 0xd7 |
| 8 | 4 | "页计数" - 下一个日志段中的页面数，或者为-1 表示所有内容直到文件末尾 |
| 12 | 4 | 用于校验和的随机 Nonce 值 |
| 16 | 4 | 数据库初始大小（以页为单位） |
| 20 | 4 | 由写入此日志的进程假定的磁盘扇区大小。 |
| 24 | 4 | 该日志中页面的大小。 |

回滚日志头部用零填充，直到达到一个扇区的大小（由偏移量 20 处的扇区大小整数定义）。该头部位于一个扇区内，因此如果在写入扇区时发生断电，头部之后的信息应该是（希望）不会受损的。

头部和零填充后是零个或多个页面记录。每个页面记录存储了数据库文件中页面在被更改之前的内容的副本。同一页面在单个回滚日志中不得出现多次。要回滚一个不完整的事务，一个进程只需从头到尾读取回滚日志，并将找到的页面写回到数据库文件的适当位置。

设数据库页大小（日志头部偏移量 24 处的整数值）为 N。那么页面记录的格式如下：

*回滚日志页记录格式*

| 偏移量 | 大小 | 描述 |
| --- | --- | --- |
| 0 | 4 | 数据库文件中的页号 |
| 4 | N | 事务开始前数据库页面的原始内容 |
| N+4 | 4 | 校验和 |

校验和是通过以下方式计算的无符号 32 位整数：

1.  将校验和初始化为日志头部偏移量 12 处找到的校验和 Nonce 值。

1.  将索引 X 初始化为 N-200（其中 N 是以字节为单位的数据库页面大小）。

1.  解释位于偏移量 X 处的字节作为一个 8 位无符号整数，并将该整数的值添加到校验和中。

1.  从 X 中减去 200。

1.  如果 X 大于或等于零，则返回步骤 3。

校验和值用于防止在断电后写入不完整的日志页面记录。每次启动事务时都使用不同的随机 nonce，以最小化未写入的扇区可能包含前期日志中同一页面的数据的风险。通过为每个事务更改 nonce，磁盘上的旧数据仍将生成不正确的校验和，并且高概率地检测到。出于性能原因，校验和仅使用数据记录中的稀疏样本的 32 位字 - SQLite 3.0.0 计划阶段的设计研究显示在对整个页面进行校验和时会有显著的性能损失。

让日志头中偏移量为 8 的页面计数值为 M。如果 M 大于零，则在 M 个页面记录后，日志文件可能会被填充为下一个扇区大小的倍数，并且可能会插入另一个日志头。同一日志中的所有日志头必须包含相同的数据库页面大小和扇区大小。

如果初始日志头中的 M 为 -1，则接下来的页面记录数由计算日志文件剩余可用空间中可以容纳多少页面记录来确定。

# 4\. 写前日志

从 版本 3.7.0 (2010-07-21) 开始，SQLite 支持一种新的事务控制机制称为 "写前日志" 或 "WAL"。当数据库处于 WAL 模式时，所有连接到该数据库的连接必须使用 WAL。特定数据库将仅使用回滚日志或 WAL，但不会同时使用两者。WAL 总是位于与数据库文件相同的目录中，并且具有与数据库文件相同但附加字符串 "`-wal`" 的文件名。

## 4.1\. WAL 文件格式

一个 WAL 文件由一个头部和零个或多个“帧”组成。每个帧记录了数据库文件中单个页面的修改内容。所有对数据库的更改都通过将帧写入 WAL 来记录。当写入包含提交标记的帧时，事务即提交。一个单独的 WAL 可以且通常记录多个事务。定期地，WAL 的内容被转移回数据库文件，这个操作称为“检查点”。

一个单独的 WAL 文件可以多次重复使用。换句话说，WAL 可以充满帧，然后被检查点，并且新的帧可以覆盖旧的帧。WAL 总是从开头向末尾增长。附加到每个帧的校验和和计数器用于确定 WAL 内哪些帧是有效的，哪些是前一个检查点遗留的。

WAL 头部大小为 32 字节，包括以下八个大端序的 32 位无符号整数值：

*WAL 头部格式*

| Offset | Size | 描述 |
| --- | --- | --- |
| 0 | 4 | 魔术数。0x377f0682 或 0x377f0683 |
| 4 | 4 | 文件格式版本。当前为 3007000。 |
| 8 | 4 | 数据库页面大小。例如：1024 |
| 12 | 4 | 检查点序列号 |
| 16 | 4 | 盐值-1：随每次检查点增加的随机整数 |
| 20 | 4 | 盐值-2：每个检查点的不同随机数 |
| 24 | 4 | 校验和-1：对头部前 24 字节的第一部分进行校验和 |
| 28 | 4 | 校验和-2：对头部前 24 字节的第二部分进行校验和 |

紧随 WAL 头部之后的是零个或多个帧。每个帧由一个 24 字节的帧头部和*页面大小*字节的页面数据组成。帧头部是六个大端序的 32 位无符号整数值，如下所示：

*WAL 帧头部格式*

| Offset | Size | 描述 |
| --- | --- | --- |
| 0 | 4 | 页面编号 |
| 4 | 4 | 对于提交记录，提交后数据库文件的页面大小。对于所有其他记录，为零。 |
| 8 | 4 | 从 WAL 头部复制的 Salt-1 |
| 12 | 4 | 从 WAL 头部复制的 Salt-2 |
| 16 | 4 | 校验和-1：通过并包括此页的累积校验和 |
| 20 | 4 | 校验和-2：累积校验和的后半部分。 |

当且仅当以下条件为真时，帧才被视为有效：

1.  帧头中的 salt-1 和 salt-2 值与 wal-header 中的 salt 值匹配

1.  帧头最后 8 字节中的校验和值必须与在 WAL 头的前 24 字节和前 8 字节以及包括当前帧在内的所有帧的内容上连续计算的校验和完全匹配。

## 4.2\. 校验和算法

校验和是通过将输入解释为偶数个无符号 32 位整数来计算的：x(0)至 x(N)。如果 WAL 头的前 4 字节中的魔数是 0x377f0683，则 32 位整数为大端序；如果魔数是 0x377f0682，则为小端序。无论使用哪种字节顺序计算校验和，校验和值始终以大端序格式存储在帧头中。

校验和算法仅适用于长度为 8 字节的倍数的内容。换句话说，如果输入为 x(0)至 x(N)，则 N 必须是奇数。校验和算法如下：

> ```sql
>  
> s0 = s1 = 0
> for i from 0 to n-1 step 2:
>    s0 += x(i) + s1;
>    s1 += x(i+1) + s0;
> endfor
> # result in s0 and s1
> 
> ```

输出 s0 和 s1 都是使用逆向斐波那契权重的加权校验和。（序列的第一个元素上具有最大的斐波那契权重。）s1 值跨越序列的所有 32 位整数项，而 s0 省略了最后一个项。

## 4.3\. 检查点算法

在检查点上，首先使用 VFS 的 xSync 方法将 WAL 刷新到持久存储中。然后将 WAL 的有效内容转移到数据库文件中。最后，使用另一个 xSync 方法调用将数据库刷新到持久存储中。xSync 操作作为写障碍 - 在 xSync 之前启动的所有写操作必须在 xSync 之后启动的任何写操作开始之前完成。

一个检查点不需要完全运行。可能会有一些读者仍在使用包含在数据库文件中的旧事务数据。在这种情况下，将新事务的内容从 WAL 文件转移到数据库中会删除仍在使用旧事务的读者的内容。为了避免这种情况，只有当所有读者都在使用 WAL 中的最后一个事务时，检查点才会完全运行。

## 4.4\. WAL 重置

完成检查点后，如果没有其他连接处于使用 WAL 的事务中，那么随后的写事务可以从 WAL 文件的开头重写。这称为"重置 WAL"。在第一个新的写事务开始时，WAL 头部的 salt-1 值会增加，salt-2 值会随机化。这些对盐的更改使得已经被检查点但尚未被覆盖的 WAL 中的旧帧无效，并防止它们再次被检查点。

在重置时，可以选择截断 WAL 文件，但不一定需要这样做。通常情况下，如果不截断 WAL，则性能会略有提高，因为文件系统通常会比增长文件更快地覆盖现有文件。

## 4.5\. 读者算法

要从数据库中读取页面（称为页号 P），读取器首先检查 WAL，以查看是否包含页面 P。如果是，则最后一个有效的页面 P 实例，其后跟一个提交帧或者是提交帧本身，将成为读取的值。如果 WAL 不包含任何有效的页面 P 的副本，或者这些副本是提交帧或者跟随提交帧，则从数据库文件中读取页面 P。

要启动读取事务，读取器记录 WAL 中值帧的数量作为 "mxFrame"。(更多细节) 读取器在所有后续读取操作中使用此记录的 mxFrame 值。可以向 WAL 追加新事务，但只要读取器使用其原始的 mxFrame 值并忽略随后追加的内容，读取器将看到数据库的一致快照从单一时间点。这种技术允许多个并发读取器同时查看数据库内容的不同版本。

前面段落中的读取器算法是正确的，但由于页面 P 的帧可以出现在 WAL 的任何位置，因此读取器必须扫描整个 WAL，以查找页面 P 的帧。如果 WAL 很大（典型情况下是多兆字节），这种扫描可能很慢，读取性能会受到影响。为了解决这个问题，维护了一个名为 wal-index 的单独数据结构，以加快对特定页面帧的搜索。

## 4.6\. WAL-Index 格式

从概念上讲，wal-index 是共享内存，尽管当前的 VFS 实现使用内存映射文件来实现操作系统的可移植性。内存映射文件位于与数据库相同的目录中，并且具有与数据库相同的名称，附加有 "`-shm`" 后缀。由于 wal-index 是共享内存，当客户端位于不同机器上时，SQLite 不支持在网络文件系统上使用 journal_mode=WAL，因为所有数据库的客户端必须能够共享相同的内存。

wal-index 的目的是快速回答这个问题：

> *给定页码 P 和最大 WAL 帧索引 M，返回不超过 M 的页 P 的最大 WAL 帧索引，如果没有超过 M 的帧则返回 NULL。*

前段中的*M*值是在第 4.4 节中定义的“mxFrame”值，在事务开始时读取，并定义了阅读器将使用的 WAL 中的最大帧。

wal-index 是临时的。崩溃后，wal-index 将从原始 WAL 文件重建。当最后一个连接关闭时，VFS 需要截断或清零 wal-index 的标头。由于 wal-index 是临时的，它可以使用特定于体系结构的格式；它不必跨平台。因此，与将所有值存储为大端的数据库和 WAL 文件格式不同，wal-index 将多字节值存储在主机计算机的本机字节顺序中。

本文关注数据库文件的持久状态，由于 wal-index 是一个临时结构，这里不会提供关于 wal-index 格式的更多信息。有关 wal-index 格式的详细信息包含在单独的 WAL 索引文件格式文档中。
