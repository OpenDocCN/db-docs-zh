- en: 1\. Introduction to FTS3 and FTS4
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1\. FTS3 和 FTS4 简介
- en: 原文：[https://sqlite.com/fts3.html](https://sqlite.com/fts3.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://sqlite.com/fts3.html](https://sqlite.com/fts3.html)
- en: Overview
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: FTS3 and FTS4 are SQLite virtual table modules that allows users to perform
    full-text searches on a set of documents. The most common (and effective) way
    to describe full-text searches is "what Google, Yahoo, and Bing do with documents
    placed on the World Wide Web". Users input a term, or series of terms, perhaps
    connected by a binary operator or grouped together into a phrase, and the full-text
    query system finds the set of documents that best matches those terms considering
    the operators and groupings the user has specified. This article describes the
    deployment and usage of FTS3 and FTS4.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: FTS3 和 FTS4 是 SQLite 虚拟表模块，允许用户在一组文档上执行全文搜索。描述全文搜索最常见（也是最有效）的方式是"Google、Yahoo
    和 Bing 对放置在万维网上的文档所做的事情"。用户输入一个术语或一系列术语，可能由二元操作符连接或组合成一个短语，全文查询系统将找到最符合用户指定的操作符和组合的文档集合。本文描述了
    FTS3 和 FTS4 的部署和使用。
- en: FTS1 and FTS2 are obsolete full-text search modules for SQLite. There are known
    issues with these older modules and their use should be avoided. Portions of the
    original FTS3 code were contributed to the SQLite project by Scott Hess of [Google](http://www.google.com).
    It is now developed and maintained as part of SQLite.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: FTS1 和 FTS2 是 SQLite 的过时全文搜索模块。已知这些旧模块存在问题，应避免使用。原始 FTS3 代码的部分是由 [Google](http://www.google.com)
    的 Scott Hess 贡献给 SQLite 项目的。现在它作为 SQLite 的一部分进行开发和维护。
- en: The FTS3 and FTS4 extension modules allows users to create special tables with
    a built-in full-text index (hereafter "FTS tables"). The full-text index allows
    the user to efficiently query the database for all rows that contain one or more
    words (hereafter "tokens"), even if the table contains many large documents.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: FTS3 和 FTS4 扩展模块允许用户创建具有内置全文索引的特殊表（以下简称为 "FTS 表"）。全文索引允许用户高效地查询数据库中包含一个或多个单词（以下简称为
    "标记"）的所有行，即使表中包含许多大型文档。
- en: 'For example, if each of the 517430 documents in the "[Enron E-Mail Dataset](http://www.cs.cmu.edu/~enron/)"
    is inserted into both an FTS table and an ordinary SQLite table created using
    the following SQL script:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果将 "[Enron 电子邮件数据集](http://www.cs.cmu.edu/~enron/)" 中的 517430 个文档中的每个文档都插入到
    FTS 表和使用以下 SQL 脚本创建的普通 SQLite 表中：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Then either of the two queries below may be executed to find the number of documents
    in the database that contain the word "linux" (351). Using one desktop PC hardware
    configuration, the query on the FTS3 table returns in approximately 0.03 seconds,
    versus 22.5 for querying the ordinary table.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来可以执行以下两个查询之一来查找数据库中包含单词 "linux" 的文档数目（351）。在使用一台台式PC硬件配置时，对 FTS3 表的查询返回时间约为
    0.03 秒，而对普通表的查询时间为 22.5 秒。
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Of course, the two queries above are not entirely equivalent. For example the
    LIKE query matches rows that contain terms such as "linuxophobe" or "EnterpriseLinux"
    (as it happens, the Enron E-Mail Dataset does not actually contain any such terms),
    whereas the MATCH query on the FTS3 table selects only those rows that contain
    "linux" as a discrete token. Both searches are case-insensitive. The FTS3 table
    consumes around 2006 MB on disk compared to just 1453 MB for the ordinary table.
    Using the same hardware configuration used to perform the SELECT queries above,
    the FTS3 table took just under 31 minutes to populate, versus 25 for the ordinary
    table.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，上述两个查询并不完全相同。例如，LIKE 查询匹配包含诸如 "linuxophobe" 或 "EnterpriseLinux" 这样的术语的行（事实上，Enron
    电子邮件数据集实际上并不包含任何这类术语），而在 FTS3 表上的 MATCH 查询仅选择包含 "linux" 作为离散标记的行。两种搜索都是大小写不敏感的。与普通表相比，FTS3
    表在磁盘上占用约 2006 MB，而普通表仅占 1453 MB。在使用执行上述 SELECT 查询的相同硬件配置时，FTS3 表的填充时间略低于 31 分钟，而普通表则为
    25 分钟。
- en: 1.1\. Differences between FTS3 and FTS4
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1\. FTS3 和 FTS4 的区别
- en: 'FTS3 and FTS4 are nearly identical. They share most of their code in common,
    and their interfaces are the same. The differences are:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: FTS3 和 FTS4 几乎是相同的。它们大部分代码是共享的，接口也相同。它们的区别在于：
- en: FTS4 contains query performance optimizations that may significantly improve
    the performance of full-text queries that contain terms that are very common (present
    in a large percentage of table rows).
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FTS4 包含查询性能优化，可以显著提高包含非常常见术语（存在于大多数表行中）的全文查询的性能。
- en: FTS4 supports some additional options that may used with the [matchinfo()](fts3.html#matchinfo)
    function.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FTS4 支持一些额外选项，这些选项可以与 [matchinfo()](https://sqlite.com/fts3.html#matchinfo)
    函数一起使用。
- en: Because it stores extra information on disk in two new [shadow tables](fts3.html#*shadowtab)
    in order to support the performance optimizations and extra matchinfo() options,
    FTS4 tables may consume more disk space than the equivalent table created using
    FTS3\. Usually the overhead is 1-2% or less, but may be as high as 10% if the
    documents stored in the FTS table are very small. The overhead may be reduced
    by specifying the directive ["matchinfo=fts3"](fts3.html#fts4matchinfo) as part
    of the FTS4 table declaration, but this comes at the expense of sacrificing some
    of the extra supported matchinfo() options.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为它在磁盘上存储额外的信息在两个新的 [影子表](fts3.html#*shadowtab) 中，以支持性能优化和额外的 matchinfo() 选项，FTS4
    表可能会比使用 FTS3 创建的等效表占用更多的磁盘空间。通常情况下，额外开销为 1-2% 或更少，但如果存储在 FTS 表中的文档非常小，则可能高达 10%。可以通过在
    FTS4 表声明中指定指令 ["matchinfo=fts3"](fts3.html#fts4matchinfo) 来减少额外开销，但这会以牺牲一些额外支持的
    matchinfo() 选项为代价。
- en: FTS4 provides hooks (the compress and uncompress [options](fts3.html#fts4_options))
    allowing data to be stored in a compressed form, reducing disk usage and IO.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FTS4 提供了钩子（压缩和解压缩 [选项](fts3.html#fts4_options)），允许数据以压缩形式存储，从而减少磁盘使用和 IO。
- en: FTS4 is an enhancement to FTS3. FTS3 has been available since SQLite [version
    3.5.0](releaselog/3_5_0.html) (2007-09-04) The enhancements for FTS4 were added
    with SQLite [version 3.7.4](releaselog/3_7_4.html) (2010-12-07).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: FTS4 是 FTS3 的增强版。FTS3 自从 SQLite [版本 3.5.0](releaselog/3_5_0.html)（2007-09-04）起就已经可用了。FTS4
    的增强功能是在 SQLite [版本 3.7.4](releaselog/3_7_4.html)（2010-12-07）中添加的。
- en: Which module, FTS3 or FTS4, should you use in your application? FTS4 is sometimes
    significantly faster than FTS3, even orders of magnitude faster depending on the
    query, though in the common case the performance of the two modules is similar.
    FTS4 also offers the enhanced [matchinfo()](fts3.html#matchinfo) outputs which
    can be useful in ranking the results of a [MATCH](fts3.html#full_text_index_queries)
    operation. On the other hand, in the absence of a [matchinfo=fts3](fts3.html#fts4matchinfo)
    directive FTS4 requires a little more disk space than FTS3, though only a percent
    of two in most cases.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序中应该使用哪个模块，FTS3 还是 FTS4？FTS4 有时比 FTS3 快得多，甚至根据查询可能快几个数量级，尽管在常见情况下，两个模块的性能相似。FTS4
    还提供了增强的 [matchinfo()](fts3.html#matchinfo) 输出，可以在排名 [MATCH](fts3.html#full_text_index_queries)
    操作的结果时非常有用。另一方面，在缺少 [matchinfo=fts3](fts3.html#fts4matchinfo) 指令的情况下，FTS4 需要比
    FTS3 多一些磁盘空间，尽管在大多数情况下只有百分之一或两。
- en: For newer applications, FTS4 is recommended; though if compatibility with older
    versions of SQLite is important, then FTS3 will usually serve just as well.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更新的应用程序，推荐使用 FTS4；尽管如果兼容性与旧版本的 SQLite 重要，则 FTS3 通常也能很好地服务。
- en: 1.2\. Creating and Destroying FTS Tables
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2\. 创建和销毁 FTS 表
- en: Like other virtual table types, new FTS tables are created using a [CREATE VIRTUAL
    TABLE](lang_createvtab.html) statement. The module name, which follows the USING
    keyword, is either "fts3" or "fts4". The virtual table module arguments may be
    left empty, in which case an FTS table with a single user-defined column named
    "content" is created. Alternatively, the module arguments may be passed a list
    of comma separated column names.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 像其他虚拟表类型一样，可以使用 [CREATE VIRTUAL TABLE](lang_createvtab.html) 语句创建新的 FTS 表。模块名称跟在
    USING 关键字之后，可以是 "fts3" 或 "fts4"。虚拟表模块参数可以留空，这样就创建了一个带有单个用户定义列名为 "content" 的 FTS
    表。另外，模块参数也可以传递一个逗号分隔的列名列表。
- en: If column names are explicitly provided for the FTS table as part of the CREATE
    VIRTUAL TABLE statement, then a datatype name may be optionally specified for
    each column. This is pure syntactic sugar, the supplied typenames are not used
    by FTS or the SQLite core for any purpose. The same applies to any constraints
    specified along with an FTS column name - they are parsed but not used or recorded
    by the system in any way.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 CREATE VIRTUAL TABLE 语句中明确提供了 FTS 表的列名，则可以为每列可选地指定数据类型名称。这仅仅是语法糖，提供的类型名称不会被
    FTS 或 SQLite 核心用于任何目的。同样适用于与 FTS 列名一起指定的任何约束 - 它们被解析但不以任何方式被系统使用或记录。
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As well as a list of columns, the module arguments passed to a CREATE VIRTUAL
    TABLE statement used to create an FTS table may be used to specify a [tokenizer](fts3.html#tokenizer).
    This is done by specifying a string of the form "tokenize=<tokenizer name> <tokenizer
    args>" in place of a column name, where <tokenizer name> is the name of the tokenizer
    to use and <tokenizer args> is an optional list of whitespace separated qualifiers
    to pass to the tokenizer implementation. A tokenizer specification may be placed
    anywhere in the column list, but at most one tokenizer declaration is allowed
    for each CREATE VIRTUAL TABLE statement. [See below](fts3.html#tokenizer) for
    a detailed description of using (and, if necessary, implementing) a tokenizer.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除了列列表外，传递给用于创建 FTS 表的 CREATE VIRTUAL TABLE 语句的模块参数还可以用于指定 [tokenizer](fts3.html#tokenizer)。
    这通过在列名的位置指定形式为 "tokenize=<tokenizer name> <tokenizer args>" 的字符串来完成，其中 <tokenizer
    name> 是要使用的分词器的名称，<tokenizer args> 是要传递给分词器实现的可选的空格分隔的限定符列表。 分词器规范可以放置在列列表的任何位置，但每个
    CREATE VIRTUAL TABLE 语句最多只允许一个分词器声明。 有关使用（和必要时实现）分词器的详细描述，请参见下文。
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'FTS tables may be dropped from the database using an ordinary [DROP TABLE](lang_droptable.html)
    statement. For example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: FTS 表可以使用普通的 [DROP TABLE](lang_droptable.html) 语句从数据库中删除。例如：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 1.3\. Populating FTS Tables
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3\. 填充 FTS 表
- en: FTS tables are populated using [INSERT](lang_insert.html), [UPDATE](lang_update.html)
    and [DELETE](lang_delete.html) statements in the same way as ordinary SQLite tables
    are.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: FTS 表使用 [INSERT](lang_insert.html)、[UPDATE](lang_update.html) 和 [DELETE](lang_delete.html)
    语句填充，与普通的 SQLite 表相同。
- en: As well as the columns named by the user (or the "content" column if no module
    arguments were specified as part of the [CREATE VIRTUAL TABLE](lang_createvtab.html)
    statement), each FTS table has a "rowid" column. The rowid of an FTS table behaves
    in the same way as the rowid column of an ordinary SQLite table, except that the
    values stored in the rowid column of an FTS table remain unchanged if the database
    is rebuilt using the [VACUUM](lang_vacuum.html) command. For FTS tables, "docid"
    is allowed as an alias along with the usual "rowid", "oid" and "_oid_" identifiers.
    Attempting to insert or update a row with a docid value that already exists in
    the table is an error, just as it would be with an ordinary SQLite table.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用户指定的列（或者在 [CREATE VIRTUAL TABLE](lang_createvtab.html) 语句中未指定模块参数的情况下的 "content"
    列），每个 FTS 表还有一个 "rowid" 列。 FTS 表的 rowid 的行为方式与普通 SQLite 表的 rowid 列相同，唯一不同的是，如果使用
    [VACUUM](lang_vacuum.html) 命令重建数据库，则 FTS 表的 rowid 列中存储的值保持不变。 对于 FTS 表，“docid”
    与通常的 “rowid”、“oid” 和 “_oid_” 标识符一样被允许作为别名。 尝试插入或更新表中已存在的 docid 值的行是一个错误，就像在普通
    SQLite 表中一样。
- en: There is one other subtle difference between "docid" and the normal SQLite aliases
    for the rowid column. Normally, if an INSERT or UPDATE statement assigns discrete
    values to two or more aliases of the rowid column, SQLite writes the rightmost
    of such values specified in the INSERT or UPDATE statement to the database. However,
    assigning a non-NULL value to both the "docid" and one or more of the SQLite rowid
    aliases when inserting or updating an FTS table is considered an error. See below
    for an example.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个 "docid" 和普通 SQLite 列的 rowid 别名之间的微妙差别。 通常，如果 INSERT 或 UPDATE 语句为 rowid
    列的两个或多个别名分配不同的值，SQLite 将这些值中指定的最右边的值写入数据库。 然而，在插入或更新 FTS 表时，如果将非 NULL 值分配给 "docid"
    和一个或多个 SQLite rowid 别名，将被视为错误。 请参见下面的例子。
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To support full-text queries, FTS maintains an inverted index that maps from
    each unique term or word that appears in the dataset to the locations in which
    it appears within the table contents. For the curious, a complete description
    of the [data structure](fts3.html#data_structures) used to store this index within
    the database file appears below. A feature of this data structure is that at any
    time the database may contain not one index b-tree, but several different b-trees
    that are incrementally merged as rows are inserted, updated and deleted. This
    technique improves performance when writing to an FTS table, but causes some overhead
    for full-text queries that use the index. Evaluating the special ["optimize" command](fts3.html#*fts4optcmd),
    an SQL statement of the form "INSERT INTO <fts-table>(<fts-table>) VALUES('optimize')",
    causes FTS to merge all existing index b-trees into a single large b-tree containing
    the entire index. This can be an expensive operation, but may speed up future
    queries.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持全文查询，FTS 维护了一个反向索引，将数据集中出现的每个唯一术语或单词映射到表内容中出现的位置。对于那些好奇的人，有关用于在数据库文件中存储此索引的[数据结构](fts3.html#data_structures)的完整描述如下。这种数据结构的一个特点是，在任何时候，数据库可能包含不止一个索引
    b 树，而是几个不同的 b 树，随着行的插入、更新和删除而逐步合并。这种技术提高了写入 FTS 表时的性能，但对使用索引的全文查询造成了一些开销。评估特殊的["optimize"
    命令](fts3.html#*fts4optcmd)，一个形如 "INSERT INTO <fts-table>(<fts-table>) VALUES('optimize')"
    的 SQL 语句，会导致 FTS 将所有现有的索引 b 树合并为一个包含整个索引的单个大 b 树。这可能是一项昂贵的操作，但可以加快未来的查询速度。
- en: 'For example, to optimize the full-text index for an FTS table named "docs":'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要优化名为 "docs" 的 FTS 表的全文索引：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The statement above may appear syntactically incorrect to some. Refer to the
    section describing the [simple fts queries](fts3.html#simple_fts_queries) for
    an explanation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些人来说，上述语句在语法上可能是不正确的。参考描述[简单 FTS 查询](fts3.html#simple_fts_queries)的部分以获取解释。
- en: There is another, deprecated, method for invoking the optimize operation using
    a SELECT statement. New code should use statements similar to the INSERT above
    to optimize FTS structures.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种已弃用的方法，可以使用 SELECT 语句来调用优化操作。新代码应该使用类似上面 INSERT 的语句来优化 FTS 结构。
- en: 1.4\. Simple FTS Queries
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4\. 简单 FTS 查询
- en: As for all other SQLite tables, virtual or otherwise, data is retrieved from
    FTS tables using a [SELECT](lang_select.html) statement.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有其他 SQLite 表一样，无论是虚拟的还是其他类型的表，都可以使用 [SELECT](lang_select.html) 语句从 FTS 表中检索数据。
- en: 'FTS tables can be queried efficiently using SELECT statements of two different
    forms:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用两种不同形式的 SELECT 语句有效地查询 FTS 表：
- en: '**Query by rowid**. If the WHERE clause of the SELECT statement contains a
    sub-clause of the form "rowid = ?", where ? is an SQL expression, FTS is able
    to retrieve the requested row directly using the equivalent of an SQLite [INTEGER
    PRIMARY KEY](lang_createtable.html#rowid) index.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按 rowid 查询**。如果 SELECT 语句的 WHERE 子句包含形式为 "rowid = ?" 的子句，其中 ? 是一个 SQL 表达式，则
    FTS 能够直接检索请求的行，使用相当于 SQLite [INTEGER PRIMARY KEY](lang_createtable.html#rowid)
    索引。'
- en: '**Full-text query**. If the WHERE clause of the SELECT statement contains a
    sub-clause of the form "<column> MATCH ?", FTS is able to use the built-in full-text
    index to restrict the search to those documents that match the full-text query
    string specified as the right-hand operand of the MATCH clause.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全文查询**。如果 SELECT 语句的 WHERE 子句包含形式为 "<column> MATCH ?" 的子句，则 FTS 能够使用内置的全文索引将搜索限制为与
    MATCH 子句指定的全文查询字符串匹配的那些文档。'
- en: If neither of these two query strategies can be used, all queries on FTS tables
    are implemented using a linear scan of the entire table. If the table contains
    large amounts of data, this may be an impractical approach (the first example
    on this page shows that a linear scan of 1.5 GB of data takes around 30 seconds
    using a modern PC).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这两种查询策略都不能使用，所有 FTS 表上的查询都将使用对整个表进行线性扫描的方式来实现。如果表包含大量数据，这可能是一种不切实际的方法（本页上的第一个示例显示，使用现代
    PC 对 1.5 GB 数据进行线性扫描大约需要 30 秒）。
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In all of the full-text queries above, the right-hand operand of the MATCH operator
    is a string consisting of a single term. In this case, the MATCH expression evaluates
    to true for all documents that contain one or more instances of the specified
    word ("sqlite", "search" or "database", depending on which example you look at).
    Specifying a single term as the right-hand operand of the MATCH operator results
    in the simplest and most common type of full-text query possible. However more
    complicated queries are possible, including phrase searches, term-prefix searches
    and searches for documents containing combinations of terms occurring within a
    defined proximity of each other. The various ways in which the full-text index
    may be queried are [described below](fts3.html#full_text_index_queries).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述所有的全文查询中，MATCH 操作符的右操作数是一个由单个术语组成的字符串。在这种情况下，MATCH 表达式对所有包含指定单词（"sqlite"、"search"
    或 "database"，取决于您查看的示例）的文档都会评估为 true。将单个术语指定为 MATCH 操作符的右操作数会导致可能的最简单和最常见类型的全文查询。但是，还可以执行更复杂的查询，包括短语搜索、术语前缀搜索以及搜索包含在指定距离内的术语组合的文档。可以在[下面的描述](fts3.html#full_text_index_queries)中找到可以查询全文索引的各种方式。
- en: Normally, full-text queries are case-insensitive. However, this is dependent
    on the specific [tokenizer](fts3.html#tokenizer) used by the FTS table being queried.
    Refer to the section on [tokenizers](fts3.html#tokenizer) for details.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，全文查询是不区分大小写的。但是，这取决于正在查询的 FTS 表使用的具体[分词器](fts3.html#tokenizer)。有关详细信息，请参阅关于[分词器](fts3.html#tokenizer)的部分。
- en: 'The paragraph above notes that a MATCH operator with a simple term as the right-hand
    operand evaluates to true for all documents that contain the specified term. In
    this context, the "document" may refer to either the data stored in a single column
    of a row of an FTS table, or to the contents of all columns in a single row, depending
    on the identifier used as the left-hand operand to the MATCH operator. If the
    identifier specified as the left-hand operand of the MATCH operator is an FTS
    table column name, then the document that the search term must be contained in
    is the value stored in the specified column. However, if the identifier is the
    name of the FTS *table* itself, then the MATCH operator evaluates to true for
    each row of the FTS table for which any column contains the search term. The following
    example demonstrates this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 上文指出，将一个简单术语作为右操作数的 MATCH 操作符评估为 true 的所有包含指定术语的文档。在此上下文中，“文档”可以是指存储在 FTS 表的行的单个列中的数据，也可以是指单个行中所有列的内容，这取决于作为
    MATCH 操作符左操作数的标识符。如果指定为 MATCH 操作符左操作数的标识符是 FTS 表列名，则搜索术语必须包含在指定列中存储的值中的文档。但是，如果标识符是
    FTS *表*本身的名称，则 MATCH 操作符对 FTS 表的每一行评估为 true，只要任何列包含搜索术语。下面的示例演示了这一点：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: At first glance, the final two full-text queries in the example above seem to
    be syntactically incorrect, as there is a table name ("mail") used as an SQL expression.
    The reason this is acceptable is that each FTS table actually has a [HIDDEN](c3ref/declare_vtab.html)
    column with the same name as the table itself (in this case, "mail"). The value
    stored in this column is not meaningful to the application, but can be used as
    the left-hand operand to a MATCH operator. This special column may also be passed
    as an argument to the [FTS auxiliary functions](fts3.html#snippet).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，上面示例中的最后两个全文查询似乎在语法上是不正确的，因为存在作为 SQL 表达式使用的表名 ("mail")。之所以可以接受这种情况是因为每个
    FTS 表实际上都有一个与表本身相同的[HIDDEN](c3ref/declare_vtab.html)列（在本例中为 "mail"）。存储在此列中的值对应用程序无意义，但可以用作
    MATCH 操作符的左操作数。此特殊列也可以作为[FTS 辅助函数](fts3.html#snippet)的参数传递。
- en: The following example illustrates the above. The expressions "docs", "docs.docs"
    and "main.docs.docs" all refer to column "docs". However, the expression "main.docs"
    does not refer to any column. It could be used to refer to a table, but a table
    name is not allowed in the context in which it is used below.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例说明了上述内容。表达式 "docs"、"docs.docs" 和 "main.docs.docs" 都指代列 "docs"。但是，表达式 "main.docs"
    并不指代任何列。它可以用来指代表，但是在下文使用的上下文中不允许使用表名。
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 1.5\. Summary
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.5\. 摘要
- en: 'From the users point of view, FTS tables are similar to ordinary SQLite tables
    in many ways. Data may be added to, modified within and removed from FTS tables
    using the INSERT, UPDATE and DELETE commands just as it may be with ordinary tables.
    Similarly, the SELECT command may be used to query data. The following list summarizes
    the differences between FTS and ordinary tables:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户角度看，FTS表在许多方面与普通SQLite表类似。数据可以通过INSERT、UPDATE和DELETE命令添加到FTS表中，也可以从中修改和删除，就像操作普通表一样。类似地，可以使用SELECT命令查询数据。以下列表总结了FTS和普通表之间的区别：
- en: As with all virtual table types, it is not possible to create indices or triggers
    attached to FTS tables. Nor is it possible to use the ALTER TABLE command to add
    extra columns to FTS tables (although it is possible to use ALTER TABLE to rename
    an FTS table).
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与所有虚拟表类型一样，不可能为FTS表创建索引或触发器。也不可能使用ALTER TABLE命令向FTS表添加额外的列（尽管可以使用ALTER TABLE命令重命名FTS表）。
- en: Data-types specified as part of the "CREATE VIRTUAL TABLE" statement used to
    create an FTS table are ignored completely. Instead of the normal rules for applying
    type [affinity](datatype3.html#affinity) to inserted values, all values inserted
    into FTS table columns (except the special rowid column) are converted to type
    TEXT before being stored.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在用于创建FTS表的"CREATE VIRTUAL TABLE"语句中指定的数据类型完全被忽略。与将类型[亲和性](datatype3.html#affinity)应用于插入值的常规规则不同，所有插入到FTS表列中的值（除了特殊的rowid列）在存储之前都会被转换为TEXT类型。
- en: FTS tables permit the special alias "docid" to be used to refer to the rowid
    column supported by all [virtual tables](vtab.html).
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FTS表允许使用特殊的别名"docid"来引用所有[虚拟表](vtab.html)支持的rowid列。
- en: The [FTS MATCH](fts3.html#full_text_index_queries) operator is supported for
    queries based on the built-in full-text index.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内置全文索引支持基于[FTS MATCH](fts3.html#full_text_index_queries)运算符的查询。
- en: The [FTS auxiliary functions](fts3.html#snippet), [snippet()](fts3.html#snippet),
    [offsets()](fts3.html#offsets), and [matchinfo()](fts3.html#matchinfo) are available
    to support full-text queries.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 支持全文查询的辅助函数[FTS辅助功能](fts3.html#snippet)，[snippet()](fts3.html#snippet)，[offsets()](fts3.html#offsets)和[matchinfo()](fts3.html#matchinfo)可用于支持全文查询。
- en: Every FTS table has a [hidden column](vtab.html#hiddencol) with the same name
    as the table itself. The value contained in each row for the hidden column is
    a blob that is only useful as the left operand of a [MATCH](fts3.html#full_text_index_queries)
    operator, or as the left-most argument to one of the [FTS auxiliary functions](fts3.html#snippet).
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个FTS表都有一个[隐藏列](vtab.html#hiddencol)，其列名与表名相同。每行隐藏列中包含的值是一个blob，仅在作为[MATCH](fts3.html#full_text_index_queries)运算符的左操作数或作为[FTS辅助功能](fts3.html#snippet)的最左参数时才有用。
- en: 2\. Compiling and Enabling FTS3 and FTS4
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2\. 编译和启用FTS3和FTS4
- en: 'Although FTS3 and FTS4 are included with the SQLite core source code, they
    are not enabled by default. To build SQLite with FTS functionality enabled, define
    the preprocessor macro [SQLITE_ENABLE_FTS3](compile.html#enable_fts3) when compiling.
    New applications should also define the [SQLITE_ENABLE_FTS3_PARENTHESIS](compile.html#enable_fts3_parenthesis)
    macro to enable the [enhanced query syntax](fts3.html#_set_operations_using_the_enhanced_query_syntax)
    (see below). Usually, this is done by adding the following two switches to the
    compiler command line:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然FTS3和FTS4包含在SQLite核心源代码中，但它们默认未启用。要构建启用FTS功能的SQLite，请在编译时定义预处理器宏[SQLITE_ENABLE_FTS3](compile.html#enable_fts3)。新应用程序还应定义[SQLITE_ENABLE_FTS3_PARENTHESIS](compile.html#enable_fts3_parenthesis)宏以启用[增强的查询语法](fts3.html#_set_operations_using_the_enhanced_query_syntax)（见下文）。通常，通过将以下两个开关添加到编译器命令行来完成此操作：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that enabling FTS3 also makes FTS4 available. There is not a separate SQLITE_ENABLE_FTS4
    compile-time option. A build of SQLite either supports both FTS3 and FTS4 or it
    supports neither.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，启用FTS3也会使FTS4可用。没有单独的SQLITE_ENABLE_FTS4编译时选项。SQLite的构建要么同时支持FTS3和FTS4，要么两者都不支持。
- en: 'If using the amalgamation autoconf based build system, setting the CPPFLAGS
    environment variable while running the ''configure'' script is an easy way to
    set these macros. For example, the following command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用集成的基于autoconf的构建系统，可以在运行'configure'脚本时通过设置CPPFLAGS环境变量来轻松设置这些宏。例如，以下命令：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: where *<configure options>* are those options normally passed to the configure
    script, if any.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*<configure options>*是通常传递给配置脚本的选项（如果有）。
- en: Because FTS3 and FTS4 are virtual tables, The [SQLITE_ENABLE_FTS3](compile.html#enable_fts3)
    compile-time option is incompatible with the [SQLITE_OMIT_VIRTUALTABLE](compile.html#omit_virtualtable)
    option.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 FTS3 和 FTS4 是虚拟表，因此 [SQLITE_ENABLE_FTS3](compile.html#enable_fts3) 编译时选项与
    [SQLITE_OMIT_VIRTUALTABLE](compile.html#omit_virtualtable) 选项不兼容。
- en: 'If a build of SQLite does not include the FTS modules, then any attempt to
    prepare an SQL statement to create an FTS3 or FTS4 table or to drop or access
    an existing FTS table in any way will fail. The error message returned will be
    similar to "no such module: ftsN" (where N is either 3 or 4).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 SQLite 的构建不包括 FTS 模块，则任何尝试准备 SQL 语句来创建 FTS3 或 FTS4 表，或者以任何方式删除或访问现有 FTS
    表都将失败。返回的错误消息将类似于 "no such module: ftsN"（其中 N 为 3 或 4）。'
- en: If the C version of the [ICU library](https://icu.unicode.org) is available,
    then FTS may also be compiled with the SQLITE_ENABLE_ICU pre-processor macro defined.
    Compiling with this macro enables an FTS [tokenizer](fts3.html#tokenizer) that
    uses the ICU library to split a document into terms (words) using the conventions
    for a specified language and locale.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 C 版本的 [ICU 库](https://icu.unicode.org) 可用，则 FTS 也可以编译时使用定义了 SQLITE_ENABLE_ICU
    预处理宏。使用此宏编译可以启用使用 ICU 库将文档拆分为术语（单词）的 FTS [分词器](fts3.html#tokenizer)，使用指定语言和区域设置的约定。
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 3\. Full-text Index Queries
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3\. 全文索引查询
- en: The most useful thing about FTS tables is the queries that may be performed
    using the built-in full-text index. Full-text queries are performed by specifying
    a clause of the form "<column> MATCH <full-text query expression>" as part of
    the WHERE clause of a SELECT statement that reads data from an FTS table. [Simple
    FTS queries](fts3.html#simple_fts_queries) that return all documents that contain
    a given term are described above. In that discussion the right-hand operand of
    the MATCH operator was assumed to be a string consisting of a single term. This
    section describes the more complex query types supported by FTS tables, and how
    they may be utilized by specifying a more complex query expression as the right-hand
    operand of a MATCH operator.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: FTS 表最有用的是可以使用内置全文索引执行的查询。通过在 SELECT 语句的 WHERE 子句中作为 "<column> MATCH <full-text
    query expression>" 形式的子句指定来执行全文查询，该子句从 FTS 表中读取数据。如上述[简单 FTS 查询](fts3.html#simple_fts_queries)返回包含给定术语的所有文档。在该讨论中，MATCH
    运算符的右操作数假定为由单个术语组成的字符串。本节描述了 FTS 表支持的更复杂查询类型，并说明可以通过将更复杂的查询表达式指定为 MATCH 运算符的右操作数来利用它们。
- en: 'FTS tables support three basic query types:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: FTS 表支持三种基本的查询类型：
- en: '**Token or token prefix queries**. An FTS table may be queried for all documents
    that contain a specified term (the [simple case](fts3.html#simple_fts_queries)
    described above), or for all documents that contain a term with a specified prefix.
    As we have seen, the query expression for a specific term is simply the term itself.
    The query expression used to search for a term prefix is the prefix itself with
    a ''*'' character appended to it. For example:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**令牌或令牌前缀查询**。可以查询 FTS 表以获取包含指定术语的所有文档（如上述的[简单情况](fts3.html#simple_fts_queries)所述），或者包含具有指定前缀的术语的所有文档。正如我们所见，用于特定术语的查询表达式只是术语本身。用于搜索术语前缀的查询表达式是前缀本身，并附加
    ''*'' 字符。例如：'
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Normally, a token or token prefix query is matched against the FTS table column
    specified as the left-hand side of the MATCH operator. Or, if the special column
    with the same name as the FTS table itself is specified, against all columns.
    This may be overridden by specifying a column-name followed by a ":" character
    before a basic term query. There may be space between the ":" and the term to
    query for, but not between the column-name and the ":" character. For example:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，令牌或令牌前缀查询与 MATCH 运算符的左侧指定的 FTS 表列匹配。或者，如果指定了具有与 FTS 表本身相同名称的特殊列，则与所有列匹配。这可以通过在基本术语查询之前指定列名后跟
    ":" 字符来覆盖。可以在 ":" 和要查询的术语之间留有空格，但不能在列名和 ":" 字符之间留有空格。例如：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If the FTS table is an FTS4 table (not FTS3), a token may also be prefixed
    with a "^" character. In this case, in order to match the token must appear as
    the very first token in any column of the matching row. Examples:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 FTS 表是 FTS4 表（而非 FTS3），则令牌还可以以 "^" 字符为前缀。在这种情况下，为了匹配，令牌必须作为匹配行中任何列的第一个令牌出现。示例：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Phrase queries**. A phrase query is a query that retrieves all documents
    that contain a nominated set of terms or term prefixes in a specified order with
    no intervening tokens. Phrase queries are specified by enclosing a space separated
    sequence of terms or term prefixes in double quotes ("). For example:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**短语查询**。短语查询是一种检索包含指定顺序中没有介入标记的所有术语或术语前缀集合的文档的查询。短语查询通过在双引号（"）中包含以空格分隔的术语或术语前缀序列来指定。例如：'
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**NEAR queries**. A NEAR query is a query that returns documents that contain
    a two or more nominated terms or phrases within a specified proximity of each
    other (by default with 10 or less intervening terms). A NEAR query is specified
    by putting the keyword "NEAR" between two phrase, token or token prefix queries.
    To specify a proximity other than the default, an operator of the form "NEAR/*<N>*"
    may be used, where *<N>* is the maximum number of intervening terms allowed. For
    example:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NEAR 查询**。NEAR 查询是一种查询，返回包含在指定接近范围内（默认为 10 个或更少的间隔项）的两个或多个指定术语或短语的文档。通过在两个短语、标记或标记前缀查询之间放置关键词“NEAR”来指定
    NEAR 查询。要指定除默认值以外的接近度，可以使用形式为“NEAR/*<N>*”的操作符，其中 *<N>* 是允许的最大间隔项数。例如：'
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'More than one NEAR operator may appear in a single query. In this case each
    pair of terms or phrases separated by a NEAR operator must appear within the specified
    proximity of each other in the document. Using the same table and data as in the
    block of examples above:'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个查询中可以出现多个 NEAR 操作符。在这种情况下，由 NEAR 操作符分隔的每对术语或短语必须在文档中指定的接近范围内出现。与上面示例块中的相同表格和数据一样：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Phrase and NEAR queries may not span multiple columns within a row.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 短语和 NEAR 查询不能跨越行中的多个列。
- en: 'The three basic query types described above may be used to query the full-text
    index for the set of documents that match the specified criteria. Using the FTS
    query expression language it is possible to perform various set operations on
    the results of basic queries. There are currently three supported operations:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 上述描述的三种基本查询类型可用于查询满足指定条件的全文索引文档集合。使用 FTS 查询表达语言，可以对基本查询结果执行各种集合操作。目前支持三种操作：
- en: The AND operator determines the **intersection** of two sets of documents.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AND 操作符确定两个文档集合的**交集**。
- en: The OR operator calculates the **union** of two sets of documents.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OR 操作符计算两个文档集合的**并集**。
- en: The NOT operator (or, if using the standard syntax, a unary "-" operator) may
    be used to compute the **relative complement** of one set of documents with respect
    to another.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准语法，NOT 操作符（或者使用一元"-"运算符）可以计算一个文档集合对另一个文档集合的**相对补集**。
- en: The FTS modules may be compiled to use one of two slightly different versions
    of the full-text query syntax, the "standard" query syntax and the "enhanced"
    query syntax. The basic term, term-prefix, phrase and NEAR queries described above
    are the same in both versions of the syntax. The way in which set operations are
    specified is slightly different. The following two sub-sections describe the part
    of the two query syntaxes that pertains to set operations. Refer to the description
    of how to [compile fts](fts3.html#compiling_and_enabling_fts3_and_fts4) for compilation
    notes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: FTS 模块可以编译成使用两种稍微不同的全文查询语法版本之一，即“标准”查询语法和“增强”查询语法。上述的基本术语、术语前缀、短语和NEAR查询在这两个版本中都是相同的。指定集合操作的方式略有不同。下面的两个子部分描述了与集合操作相关的两个查询语法部分。有关如何[编译
    FTS](fts3.html#compiling_and_enabling_fts3_and_fts4)的详细说明，请参考编译注意事项。
- en: 3.1\. Set Operations Using The Enhanced Query Syntax
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1\. 使用增强查询语法进行集合操作
- en: The enhanced query syntax supports the AND, OR and NOT binary set operators.
    Each of the two operands to an operator may be a basic FTS query, or the result
    of another AND, OR or NOT set operation. Operators must be entered using capital
    letters. Otherwise, they are interpreted as basic term queries instead of set
    operators.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 增强查询语法支持 AND、OR 和 NOT 二元集合操作符。操作符的每个操作数可以是基本的 FTS 查询，或者是另一个 AND、OR 或 NOT 集合操作的结果。操作符必须使用大写字母输入，否则它们将被解释为基本术语查询，而不是集合操作符。
- en: The AND operator may be implicitly specified. If two basic queries appear with
    no operator separating them in an FTS query string, the results are the same as
    if the two basic queries were separated by an AND operator. For example, the query
    expression "implicit operator" is a more succinct version of "implicit AND operator".
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: AND 操作符可以隐式指定。如果两个基本查询在 FTS 查询字符串中没有分隔符分隔，结果与两个基本查询之间隔开的 AND 操作符一样。例如，查询表达式
    "implicit operator" 是 "implicit AND operator" 的更简洁版本。
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The examples above all use basic full-text term queries as both operands of
    the set operations demonstrated. Phrase and NEAR queries may also be used, as
    may the results of other set operations. When more than one set operation is present
    in an FTS query, the precedence of operators is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例中均使用基本的全文术语查询作为展示集合操作的操作数。还可以使用短语查询和 NEAR 查询，以及其他集合操作的结果。在一个 FTS 查询中存在多个集合操作时，操作符的优先级如下：
- en: '| Operator | Enhanced Query Syntax Precedence |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 操作符 | 增强查询语法优先级 |'
- en: '| NOT | Highest precedence (tightest grouping). |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| NOT | 最高优先级（最紧密分组）。 |'
- en: '| AND |  |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| AND |  |'
- en: '| OR | Lowest precedence (loosest grouping). |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| OR | 最低优先级（最宽松分组）。 |'
- en: 'When using the enhanced query syntax, parenthesis may be used to override the
    default precedence of the various operators. For example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用增强查询语法时，括号可以用来覆盖各种操作符的默认优先级。例如：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 3.2\. Set Operations Using The Standard Query Syntax
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2\. 使用标准查询语法进行集合操作
- en: 'FTS query set operations using the standard query syntax are similar, but not
    identical, to set operations with the enhanced query syntax. There are four differences,
    as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准查询语法的 FTS 查询集合操作与增强查询语法的集合操作类似，但不完全相同。以下有四个差异：
- en: Only the implicit version of the AND operator is supported. Specifying the string
    "AND" as part of a standard query syntax query is interpreted as a term query
    for the set of documents containing the term "and".
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅支持 AND 操作符的隐式版本。在标准查询语法查询中，指定字符串 "AND" 作为文档集合中包含术语 "and" 的术语查询的解释是一个术语查询。
- en: Parenthesis are not supported.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不支持括号。
- en: The NOT operator is not supported. Instead of the NOT operator, the standard
    query syntax supports a unary "-" operator that may be applied to basic term and
    term-prefix queries (but not to phrase or NEAR queries). A term or term-prefix
    that has a unary "-" operator attached to it may not appear as an operand to an
    OR operator. An FTS query may not consist entirely of terms or term-prefix queries
    with unary "-" operators attached to them.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不支持 NOT 操作符。标准查询语法支持一个一元 "-" 操作符，可以应用于基本术语和术语前缀查询（但不能应用于短语或 NEAR 查询）。附有一元 "-"
    操作符的术语或术语前缀不能作为 OR 操作符的操作数。FTS 查询不能完全由附有一元 "-" 操作符的术语或术语前缀查询组成。
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The relative precedence of the set operations is different. In particular,
    using the standard query syntax the "OR" operator has a higher precedence than
    "AND". The precedence of operators when using the standard query syntax is:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集合操作的相对优先级不同。特别是使用标准查询语法时，"OR" 操作符的优先级高于 "AND"。在使用标准查询语法时，操作符的优先级如下：
- en: '| Operator | Standard Query Syntax Precedence |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 操作符 | 标准查询语法优先级 |'
- en: '| Unary "-" | Highest precedence (tightest grouping). |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| Unary "-" | 最高优先级（最紧密分组）。 |'
- en: '| OR |  |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| OR |  |'
- en: '| AND | Lowest precedence (loosest grouping). |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| AND | 最低优先级（最宽松分组）。 |'
- en: 'The following example illustrates precedence of operators using the standard
    query syntax:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下示例说明了使用标准查询语法的操作符优先级：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 4\. Auxiliary Functions - Snippet, Offsets and Matchinfo
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4\. 辅助函数 - Snippet、Offsets 和 Matchinfo
- en: 'The FTS3 and FTS4 modules provide three special SQL scalar functions that may
    be useful to the developers of full-text query systems: "snippet", "offsets" and
    "matchinfo". The purpose of the "snippet" and "offsets" functions is to allow
    the user to identify the location of queried terms in the returned documents.
    The "matchinfo" function provides the user with metrics that may be useful for
    filtering or sorting query results according to relevance.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: FTS3 和 FTS4 模块提供了三个特殊的 SQL 标量函数，对于全文查询系统的开发者可能会很有用："snippet"、"offsets" 和 "matchinfo"。"snippet"
    和 "offsets" 函数的目的是允许用户确定返回文档中查询词的位置。"matchinfo" 函数提供了一些指标，这些指标可能对根据相关性过滤或排序查询结果很有用。
- en: 'The first argument to all three special SQL scalar functions must be the [FTS
    hidden column](fts3.html#hiddencol) of the FTS table that the function is applied
    to. The [FTS hidden column](fts3.html#hiddencol) is an automatically-generated
    column found on all FTS tables that has the same name as the FTS table itself.
    For example, given an FTS table named "mail":'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个特殊的SQL标量函数的第一个参数必须是适用于该函数的FTS表的[FTS隐藏列](fts3.html#hiddencol)。[FTS隐藏列](fts3.html#hiddencol)是在所有FTS表上找到的一个自动生成的列，其名称与FTS表本身相同。例如，给定一个名为“mail”的FTS表：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The three auxiliary functions are only useful within a SELECT statement that
    uses the FTS table's full-text index. If used within a SELECT that uses the "query
    by rowid" or "linear scan" strategies, then the snippet and offsets both return
    an empty string, and the matchinfo function returns a blob value zero bytes in
    size.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 三个辅助函数仅在使用了FTS表的全文索引的SELECT语句内有用。如果在使用了“按行号查询”或“线性扫描”策略的SELECT中使用，则片段和偏移都返回一个空字符串，并且matchinfo函数返回一个大小为零字节的blob值。
- en: All three auxiliary functions extract a set of "matchable phrases" from the
    FTS query expression to work with. The set of matchable phrases for a given query
    consists of all phrases (including unquoted tokens and token prefixes) in the
    expression except those that are prefixed with a unary "-" operator (standard
    syntax) or are part of a sub-expression that is used as the right-hand operand
    of a NOT operator.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个辅助函数从FTS查询表达式中提取一组“可匹配短语”以便处理。对于给定查询的可匹配短语集合包括表达式中所有短语（包括未引用的标记和标记前缀），除了那些以一元“-”运算符作为前缀（标准语法）或者是作为NOT运算符的右操作数使用的子表达式的部分。
- en: 'With the following provisos, each series of tokens in the FTS table that matches
    one of the matchable phrases in the query expression is known as a "phrase match":'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下，FTS表中与查询表达式中的可匹配短语之一匹配的一系列标记被称为“短语匹配”：
- en: If a matchable phrase is part of a series of phrases connected by NEAR operators
    in the FTS query expression, then each phrase match must be sufficiently close
    to other phrase matches of the relevant types to satisfy the NEAR condition.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果可匹配短语是FTS查询表达式中由NEAR运算符连接的一系列短语的一部分，那么每个短语匹配都必须与相关类型的其他短语匹配足够接近以满足NEAR条件。
- en: If the matchable phrase in the FTS query is restricted to matching data in a
    specified FTS table column, then only phrase matches that occur within that column
    are considered.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果FTS查询中的可匹配短语受限于匹配特定FTS表列中的数据，则只有出现在该列中的短语匹配会被考虑。
- en: 4.1\. The Offsets Function
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1\. 偏移函数
- en: 'For a SELECT query that uses the full-text index, the offsets() function returns
    a text value containing a series of space-separated integers. For each term in
    each [phrase match](#matchable) of the current row, there are four integers in
    the returned list. Each set of four integers is interpreted as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用全文索引的SELECT查询，offsets()函数返回一个包含一系列以空格分隔的整数的文本值。对于当前行的每个[短语匹配](#matchable)中的每个项，返回的列表中有四个整数。每组四个整数的解释如下：
- en: '| Integer | Interpretation |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 整数 | 解释 |'
- en: '| 0 | The column number that the term instance occurs in (0 for the leftmost
    column of the FTS table, 1 for the next leftmost, etc.). |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 项实例出现的列编号（FTS表最左边的列为0，依次类推）。|'
- en: '| 1 | The term number of the matching term within the full-text query expression.
    Terms within a query expression are numbered starting from 0 in the order that
    they occur. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 完整文本查询表达式中匹配项的项编号。查询表达式中的项按它们出现的顺序从0开始编号。|'
- en: '| 2 | The byte offset of the matching term within the column. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 列中匹配项的字节偏移。|'
- en: '| 3 | The size of the matching term in bytes. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 匹配项的字节大小。|'
- en: The following block contains examples that use the offsets function.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下块包含使用offsets函数的示例。
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 4.2\. The Snippet Function
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2\. 片段函数
- en: 'The snippet function is used to create formatted fragments of document text
    for display as part of a full-text query results report. The snippet function
    may be passed between one and six arguments, as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 片段函数用于为全文查询结果报告的显示创建格式化的文档文本片段。片段函数可以传递一个到六个参数，如下：
- en: '| Argument | Default Value | Description |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 默认值 | 描述 |'
- en: '| 0 | N/A | The first argument to the snippet function must always be the [FTS
    hidden column](fts3.html#hiddencol) of the FTS table being queried and from which
    the snippet is to be taken. The [FTS hidden column](fts3.html#hiddencol) is an
    automatically generated column with the same name as the FTS table itself. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 0 | N/A | 碎片函数的第一个参数必须始终是查询的 [FTS 隐藏列](fts3.html#hiddencol)，并且从中获取碎片的 FTS
    表。[FTS 隐藏列](fts3.html#hiddencol) 是一个与 FTS 表同名的自动生成列。 '
- en: '| 1 | "<b>" | The "start match" text. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 1 | "<b>" | "开始匹配" 文本。 '
- en: '| 2 | "</b>" | The "end match" text. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 2 | "</b>" | "结束匹配" 文本。 '
- en: '| 3 | "<b>...</b>" | The "ellipses" text. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 3 | "<b>...</b>" | "省略号" 文本。 '
- en: '| 4 | -1 | The FTS table column number to extract the returned fragments of
    text from. Columns are numbered from left to right starting with zero. A negative
    value indicates that the text may be extracted from any column. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 4 | -1 | 要从中提取返回文本片段的 FTS 表列号。列从左到右编号，从零开始。负值表示文本可能从任意列提取。 '
- en: '| 5 | -15 | The absolute value of this integer argument is used as the (approximate)
    number of tokens to include in the returned text value. The maximum allowable
    absolute value is 64\. The value of this argument is referred to as *N* in the
    discussion below. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 5 | -15 | 此整数参数的绝对值用作返回文本值中包含的标记数（大约）。允许的最大绝对值为 64。在下面的讨论中，此参数的值称为 *N*。'
- en: The snippet function first attempts to find a fragment of text consisting of
    *|N|* tokens within the current row that contains at least one phrase match for
    each matchable phrase matched somewhere in the current row, where *|N|* is the
    absolute value of the sixth argument passed to the snippet function. If the text
    stored in a single column contains less than *|N|* tokens, then the entire column
    value is considered. Text fragments may not span multiple columns.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 碎片函数首先尝试在当前行内找到由 *|N|* 个标记组成的文本片段，该片段至少包含当前行某处匹配的每个可匹配短语。这里的 *|N|* 是传递给碎片函数的第六个参数的绝对值。如果存储在单列中的文本包含的标记少于
    *|N|*，则整个列值被视为一个文本片段。文本片段不可跨越多列。
- en: 'If such a text fragment can be found, it is returned with the following modifications:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到这样的文本片段，则会返回带有以下修改的文本：
- en: If the text fragment does not begin at the start of a column value, the "ellipses"
    text is prepended to it.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文本片段不是从列值的开头开始，则将 "省略号" 文本前置到其前面。
- en: If the text fragment does not finish at the end of a column value, the "ellipses"
    text is appended to it.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文本片段未在列值结束时完成，则将 "省略号" 文本附加到其后。
- en: For each token in the text fragment that is part of a phrase match, the "start
    match" text is inserted into the fragment before the token, and the "end match"
    text is inserted immediately after it.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于文本片段中的每个作为短语匹配一部分的标记，在该标记之前插入 "开始匹配" 文本，并在其后立即插入 "结束匹配" 文本。
- en: If more than one such fragment can be found, then fragments that contain a larger
    number of "extra" phrase matches are favored. The start of the selected text fragment
    may be moved a few tokens forward or backward to attempt to concentrate the phrase
    matches toward the center of the fragment.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以找到多个这样的片段，则优先选择包含较多 "额外" 短语匹配的片段。所选文本片段的开始可能向前或向后移动几个标记，以尝试将短语匹配集中在片段的中心。
- en: Assuming *N* is a positive value, if no fragments can be found that contain
    a phrase match corresponding to each matchable phrase, the snippet function attempts
    to find two fragments of approximately *N*/2 tokens that between them contain
    at least one phrase match for each matchable phrase matched by the current row.
    If this fails, attempts are made to find three fragments of *N*/3 tokens each
    and finally four *N*/4 token fragments. If a set of four fragments cannot be found
    that encompasses the required phrase matches, the four fragments of *N*/4 tokens
    that provide the best coverage are selected.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 *N* 是正值，如果找不到包含每个可匹配短语的短语匹配的文本片段，则碎片函数尝试找到大约 *N*/2 个标记的两个文本片段，它们之间至少包含当前行匹配的每个可匹配短语的一个短语匹配。如果失败，则尝试找到三个
    *N*/3 标记的文本片段，最后四个 *N*/4 标记的文本片段。如果找不到包含所需短语匹配的四个片段，则选择提供最佳覆盖率的四个 *N*/4 标记片段。
- en: If *N* is a negative value, and no single fragment can be found containing the
    required phrase matches, the snippet function searches for two fragments of *|N|*
    tokens each, then three, then four. In other words, if the specified value of
    *N* is negative, the sizes of the fragments is not decreased if more than one
    fragment is required to provide the desired phrase match coverage.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*N*是负值，并且找不到包含所需短语匹配的单个片段，则snippet函数搜索两个每个有*N*标记的片段，然后三个，然后四个。换句话说，如果指定的*N*值是负数，则如果需要多个片段来提供所需的短语匹配覆盖范围，则片段的大小不会减小。
- en: After the *M* fragments have been located, where *M* is between two and four
    as described in the paragraphs above, they are joined together in sorted order
    with the "ellipses" text separating them. The three modifications enumerated earlier
    are performed on the text before it is returned.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在*找到*的*M*片段之后，其中*M*介于两个和四个之间，正如前面的段落所描述的，它们按照排序顺序连接在一起，用"省略号"文本分隔它们。在返回之前，执行前面列举的三种修改。
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 4.3\. The Matchinfo Function
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3\. 匹配信息函数
- en: The matchinfo function returns a blob value. If it is used within a query that
    does not use the full-text index (a "query by rowid" or "linear scan"), then the
    blob is zero bytes in size. Otherwise, the blob consists of zero or more 32-bit
    unsigned integers in machine byte-order. The exact number of integers in the returned
    array depends on both the query and the value of the second argument (if any)
    passed to the matchinfo function.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: matchinfo函数返回一个blob值。如果它用于一个不使用全文本索引的查询（"按行id查询"或"线性扫描"），那么blob的大小为零字节。否则，该blob由零个或多个机器字节顺序的32位无符号整数组成。返回的数组中确切的整数数量取决于查询和传递给matchinfo函数的第二个参数（如果有的话）的值。
- en: The matchinfo function is called with either one or two arguments. As for all
    auxiliary functions, the first argument must be the special [FTS hidden column](fts3.html#hiddencol).
    The second argument, if it is specified, must be a text value comprised only of
    the characters 'p', 'c', 'n', 'a', 'l', 's', 'x', 'y' and 'b'. If no second argument
    is explicitly supplied, it defaults to "pcx". The second argument is referred
    to as the "format string" below.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: matchinfo函数被调用时，参数可以是一个或两个。和其他所有辅助函数一样，第一个参数必须是特殊的[FTS隐藏列](fts3.html#hiddencol)。如果指定了第二个参数，它必须是一个仅由字符'p'、'c'、'n'、'a'、'l'、's'、'x'、'y'和'b'组成的文本值。如果没有显式提供第二个参数，则默认为"pcx"。下面我们称第二个参数为"格式字符串"。
- en: Characters in the matchinfo format string are processed from left to right.
    Each character in the format string causes one or more 32-bit unsigned integer
    values to be added to the returned array. The "values" column in the following
    table contains the number of integer values appended to the output buffer for
    each supported format string character. In the formula given, *cols* is the number
    of columns in the FTS table, and *phrases* is the number of [matchable phrases](#matchable)
    in the query.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: matchinfo格式字符串中的字符从左到右进行处理。格式字符串中的每个字符会导致一个或多个32位无符号整数值被添加到返回的数组中。下表中的"值"列包含了对每个支持的格式字符串字符追加到输出缓冲区的整数值的数量。在给定的公式中，*cols*是FTS表中的列数，*phrases*是查询中的[可匹配短语](#matchable)的数量。
- en: '| Character | Values | Description |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 字符 | 值 | 描述 |'
- en: '| p | 1 | The number of matchable phrases in the query. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| p | 1 | 查询中可匹配短语的数量。 |'
- en: '| c | 1 | The number of user defined columns in the FTS table (i.e. not including
    the docid or the [FTS hidden column](fts3.html#hiddencol)). |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| c | 1 | FTS表中用户定义列的数量（即不包括docid或[FTS隐藏列](fts3.html#hiddencol)）。 |'
- en: '| x | 3 * *cols* * *phrases* | For each distinct combination of a phrase and
    table column, the following three values:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '| x | 3 * *cols* * *phrases* | 对于每个短语和表列的不同组合，以下三个值：'
- en: In the current row, the number of times the phrase appears in the column.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在当前行，短语在列中出现的次数。
- en: The total number of times the phrase appears in the column in all rows in the
    FTS table.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在FTS表中，短语在所有行中出现的总次数。
- en: The total number of rows in the FTS table for which the column contains at least
    one instance of the phrase.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FTS表中的行数的总和，其中该列至少包含短语的一个实例。
- en: 'The first set of three values corresponds to the left-most column of the table
    (column 0) and the left-most matchable phrase in the query (phrase 0). If the
    table has more than one column, the second set of three values in the output array
    correspond to phrase 0 and column 1\. Followed by phrase 0, column 2 and so on
    for all columns of the table. And so on for phrase 1, column 0, then phrase 1,
    column 1 etc. In other words, the data for occurrences of phrase *p* in column
    *c* may be found using the following formula:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组三个值对应表的最左列（列0）和查询中最左可匹配短语（短语0）。如果表有多个列，则输出数组中的第二组三个值对应短语0和列1。然后是短语0，列2，依此类推直至表的所有列。以此类推，对于短语1，列0，然后是短语1，列1等。换句话说，可在以下公式中找到列*c*中短语*p*出现的数据：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| y | *cols* * *phrases* | For each distinct combination of a phrase and table
    column, the number of usable phrase matches that appear in the column. This is
    usually identical to the first value in each set of three returned by the [matchinfo
    ''x'' flag](fts3.html#matchinfo-x). However, the number of hits reported by the
    ''y'' flag is zero for any phrase that is part of a sub-expression that does not
    match the current row. This makes a difference for expressions that contain AND
    operators that are descendants of OR operators. For example, consider the expression:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '| y | *列* * *短语* | 对于短语和表列的每个不同组合，出现在该列中的可用短语匹配数量。这通常与[匹配信息 ''x'' 标志](fts3.html#matchinfo-x)返回的每组三个值的第一个值相同。然而，对于任何短语是不匹配当前行的子表达式的情况，''y''标志报告的命中次数为零。这对包含AND运算符的表达式产生差异，这些AND运算符是OR运算符的后代。例如，考虑以下表达式：'
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'and the document:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 和文档：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The [matchinfo ''x'' flag](fts3.html#matchinfo-x) would report a single hit
    for the phrases "a" and "c". However, the ''y'' directive reports the number of
    hits for "c" as zero, as it is part of a sub-expression that does not match the
    document - (b AND c). For queries that do not contain AND operators descended
    from OR operators, the result values returned by ''y'' are always the same as
    those returned by ''x''.The first value in the array of integer values corresponds
    to the leftmost column of the table (column 0) and the first phrase in the query
    (phrase 0). The values corresponding to other column/phrase combinations may be
    located using the following formula:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[匹配信息 ''x'' 标志](fts3.html#matchinfo-x)会报告短语"a"和"c"的一次命中。然而，''y''指令报告"c"的命中次数为零，因为它是一个不匹配文档的子表达式的一部分
    - (b AND c)。对于不包含从OR运算符派生的AND运算符的查询，''y''返回的结果值始终与''x''返回的结果值相同。整数值数组中的第一个值对应表的最左列（列0）和查询中的第一个短语（短语0）。可使用以下公式找到对应于其他列/短语组合的值：'
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: For queries that use OR expressions, or those that use LIMIT or return many
    rows, the 'y' matchinfo option may be faster than 'x'. |
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用OR表达式的查询，或者使用LIMIT或返回许多行的查询，'y'匹配信息选项可能比'x'更快。 |
- en: '| b | *((cols+31)/32)* * *phrases* | The matchinfo ''b'' flag provides similar
    information to the [matchinfo ''y'' flag](fts3.html#matchinfo-y), but in a more
    compact form. Instead of the precise number of hits, ''b'' provides a single boolean
    flag for each phrase/column combination. If the phrase is present in the column
    at least once (i.e. if the corresponding integer output of ''y'' would be non-zero),
    the corresponding flag is set. Otherwise cleared.If the table has 32 or fewer
    columns, a single unsigned integer is output for each phrase in the query. The
    least significant bit of the integer is set if the phrase appears at least once
    in column 0\. The second least significant bit is set if the phrase appears once
    or more in column 1\. And so on.If the table has more than 32 columns, an extra
    integer is added to the output of each phrase for each extra 32 columns or part
    thereof. Integers corresponding to the same phrase are clumped together. For example,
    if a table with 45 columns is queried for two phrases, 4 integers are output.
    The first corresponds to phrase 0 and columns 0-31 of the table. The second integer
    contains data for phrase 0 and columns 32-44, and so on.For example, if nCol is
    the number of columns in the table, to determine if phrase p is present in column
    c:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '| b | *((cols+31)/32)* * *phrases* | matchinfo中的''b''标志提供与[matchinfo中的''y''标志](fts3.html#matchinfo-y)类似的信息，但形式更紧凑。与精确的命中次数不同，''b''为每个短语/列组合提供单一的布尔标志。如果短语至少在列中出现一次（即''y''的相应整数输出非零），则设置相应的标志，否则清除。如果表具有32列或更少，则每个查询短语的输出都是一个无符号整数。整数的最低有效位设置为短语至少出现在列0中一次。第二最低有效位设置为短语在列1中至少出现一次，依此类推。如果表的列数超过32，则为每32列或其部分额外添加一个整数到每个短语的输出中。相同短语的整数被聚合在一起。例如，如果查询具有45列的表中的两个短语，则会输出4个整数。第一个对应于短语0和表的列0-31。第二个整数包含短语0和列32-44的数据，依此类推。例如，如果nCol是表中列的数量，则要确定短语p是否存在于列c中：'
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '|'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| n | 1 | The number of rows in the FTS4 table. This value is only available
    when querying FTS4 tables, not FTS3. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| n | 1 | FTS4表中的行数。仅当查询FTS4表时才可用此值，而不是FTS3。 |'
- en: '| a | *cols* | For each column, the average number of tokens in the text values
    stored in the column (considering all rows in the FTS4 table). This value is only
    available when querying FTS4 tables, not FTS3. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| a | *cols* | 对于每一列，在存储在列中的文本值中的标记平均数量（考虑FTS4表中的所有行）。仅当查询FTS4表时才可用此值，而不是FTS3。
    |'
- en: '| l | *cols* | For each column, the length of the value stored in the current
    row of the FTS4 table, in tokens. This value is only available when querying FTS4
    tables, not FTS3\. And only if the "matchinfo=fts3" directive was not specified
    as part of the "CREATE VIRTUAL TABLE" statement used to create the FTS4 table.
    |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| l | *cols* | 对于每一列，在当前行的FTS4表中存储的值的长度，以标记为单位。仅当查询FTS4表时才可用此值，而不是FTS3。只有在创建FTS4表的"CREATE
    VIRTUAL TABLE"语句中未指定"matchinfo=fts3"指令时才可用。 |'
- en: '| s | *cols* | For each column, the length of the longest subsequence of phrase
    matches that the column value has in common with the query text. For example,
    if a table column contains the text ''a b c d e'' and the query is ''a c "d e"'',
    then the length of the longest common subsequence is 2 (phrase "c" followed by
    phrase "d e"). |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| s | *cols* | 对于每一列，与查询文本共享的短语匹配的最长子序列的长度。例如，如果表列包含文本''a b c d e''，并且查询是''a
    c "d e"''，则最长公共子序列的长度为2（短语"c"后跟短语"d e"）。'
- en: 'For example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The matchinfo function is much faster than either the snippet or offsets functions.
    This is because the implementation of both snippet and offsets is required to
    retrieve the documents being analyzed from disk, whereas all data required by
    matchinfo is available as part of the same portions of the full-text index that
    are required to implement the full-text query itself. This means that of the following
    two queries, the first may be an order of magnitude faster than the second:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: matchinfo函数比摘要或偏移函数快得多。这是因为必须从磁盘检索进行分析的文档来实现摘要和偏移的实现，而matchinfo所需的所有数据都作为全文索引的一部分可用，这些全文索引必须实现全文查询本身。这意味着在以下两个查询中，第一个查询可能比第二个查询快一个数量级：
- en: '[PRE32]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The matchinfo function provides all the information required to calculate probabilistic
    "bag-of-words" relevancy scores such as [Okapi BM25/BM25F](http://en.wikipedia.org/wiki/Okapi_BM25)
    that may be used to order results in a full-text search application. Appendix
    A of this document, "[search application tips](fts3.html#appendix_a)", contains
    an example of using the matchinfo() function efficiently.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: matchinfo 函数提供了计算概率“词袋”相关性分数（例如 [Okapi BM25/BM25F](http://en.wikipedia.org/wiki/Okapi_BM25)）所需的所有信息，这些分数可用于在全文搜索应用程序中排序结果。本文档的附录
    A，“[搜索应用程序提示](fts3.html#appendix_a)”包含了有效使用 matchinfo() 函数的示例。
- en: 5\. Fts4aux - Direct Access to the Full-Text Index
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5\. Fts4aux - 直接访问全文索引
- en: As of [version 3.7.6](releaselog/3_7_6.html) (2011-04-12), SQLite includes a
    new virtual table module called "fts4aux", which can be used to inspect the full-text
    index of an existing FTS table directly. Despite its name, fts4aux works just
    as well with FTS3 tables as it does with FTS4 tables. Fts4aux tables are read-only.
    The only way to modify the contents of an fts4aux table is by modifying the contents
    of the associated FTS table. The fts4aux module is automatically included in all
    [builds that include FTS](fts3.html#compiling_and_enabling_fts3_and_fts4).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [3.7.6 版本](releaselog/3_7_6.html)（2011-04-12）开始，SQLite 包含一个名为“fts4aux”的新虚拟表模块，可直接用于检查现有
    FTS 表的全文索引。尽管其名称如此，fts4aux 在 FTS3 表和 FTS4 表上同样有效。fts4aux 表是只读的。修改 fts4aux 表内容的唯一方式是修改关联的
    FTS 表内容。fts4aux 模块自动包含在所有包含 FTS 的[构建中](fts3.html#compiling_and_enabling_fts3_and_fts4)。
- en: 'An fts4aux virtual table is constructed with one or two arguments. When used
    with a single argument, that argument is the unqualified name of the FTS table
    that it will be used to access. To access a table in a different database (for
    example, to create a TEMP fts4aux table that will access an FTS3 table in the
    MAIN database) use the two-argument form and give the name of the target database
    (ex: "main") in the first argument and the name of the FTS3/4 table as the second
    argument. (The two-argument form of fts4aux was added for SQLite [version 3.7.17](releaselog/3_7_17.html)
    (2013-05-20) and will throw an error in prior releases.) For example:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: fts4aux 虚拟表由一个或两个参数构建。当使用单个参数时，该参数是将用于访问的 FTS 表的未限定名称。要访问不同数据库中的表（例如，创建将访问 MAIN
    数据库中 FTS3 表的 TEMP fts4aux 表），请使用两参数形式，第一个参数中给出目标数据库的名称（例如“main”），第二个参数给出 FTS3/4
    表的名称。（fts4aux 的两参数形式添加于 SQLite [3.7.17 版本](releaselog/3_7_17.html)（2013-05-20），在此之前的版本中会抛出错误。）例如：
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'For each term present in the FTS table, there are between 2 and N+1 rows in
    the fts4aux table, where N is the number of user-defined columns in the associated
    FTS table. An fts4aux table always has the same four columns, as follows, from
    left to right:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个出现在 FTS 表中的术语，在 fts4aux 表中都会有 2 到 N+1 行，其中 N 是关联 FTS 表中用户定义列的数量。fts4aux
    表始终具有相同的四列，从左到右如下：
- en: '| Column Name | Column Contents |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| Column Name | Column Contents |'
- en: '| term | Contains the text of the term for this row. |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| term | 包含此行的术语文本。 |'
- en: '| col | This column may contain either the text value ''*'' (i.e. a single
    character, U+002a) or an integer between 0 and N-1, where N is again the number
    of user-defined columns in the corresponding FTS table. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| col | 此列可能包含文本值 ''*''（即一个字符，U+002a）或介于 0 和 N-1 之间的整数，其中 N 再次是对应 FTS 表中用户定义列的数量。
    |'
- en: '| documents | This column always contains an integer value greater than zero.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '| documents | 此列始终包含大于零的整数值。 |'
- en: If the "col" column contains the value '*', then this column contains the number
    of rows of the FTS table that contain at least one instance of the term (in any
    column). If col contains an integer value, then this column contains the number
    of rows of the FTS table that contain at least one instance of the term in the
    column identified by the col value. As usual, the columns of the FTS table are
    numbered from left to right, starting with zero. |
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果“col”列包含值 '*'，则此列包含至少在一个列中包含该术语实例的 FTS 表行数。如果 col 包含整数值，则此列包含在由 col 值标识的列中包含该术语实例的
    FTS 表行数。通常情况下，FTS 表的列从左到右编号，从零开始。
- en: '| occurrences | This column also always contains an integer value greater than
    zero.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '| occurrences | 此列始终包含大于零的整数值。 |'
- en: If the "col" column contains the value '*', then this column contains the total
    number of instances of the term in all rows of the FTS table (in any column).
    Otherwise, if col contains an integer value, then this column contains the total
    number of instances of the term that appear in the FTS table column identified
    by the col value. |
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果“col”列包含值‘*’，则该列包含FTS表所有行中术语实例的总数（在任何列中）。否则，如果col包含整数值，则该列包含出现在由col值标识的FTS表列中的术语实例的总数。
- en: '| languageid *(hidden)* | This column determines which [languageid](fts3.html#*fts4languageid)
    is used to extract vocabulary from the FTS3/4 table.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '| languageid *(hidden)* | 该列确定从FTS3/4表中提取词汇时使用的[languageid](fts3.html#*fts4languageid)。'
- en: The default value for languageid is 0\. If an alternative language is specified
    in WHERE clause constraints, then that alternative is used instead of 0\. There
    can only be a single languageid per query. In other words, the WHERE clause cannot
    contain a range constraint or IN operator on the languageid. |
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: languageid的默认值为0。如果在WHERE子句约束中指定了替代语言，则将使用该替代语言而不是0。每个查询只能有一个languageid。换句话说，WHERE子句不能在languageid上包含范围约束或IN操作符。
- en: 'For example, using the tables created above:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用上面创建的表格：
- en: '[PRE34]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the example, the values in the "term" column are all lower case, even though
    they were inserted into table "ft" in mixed case. This is because an fts4aux table
    contains the terms as extracted from the document text by the [tokenizer](fts3.html#tokenizer).
    In this case, since table "ft" uses the [simple tokenizer](fts3.html#tokenizer),
    this means all terms have been folded to lower case. Also, there is (for example)
    no row with column "term" set to "apple" and column "col" set to 1\. Since there
    are no instances of the term "apple" in column 1, no row is present in the fts4aux
    table.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在例子中，“term”列中的值全为小写，尽管它们在混合大小写插入到“ft”表中。这是因为fts4aux表包含从文档文本中由[分词器](fts3.html#tokenizer)提取的术语。在这种情况下，由于“ft”表使用[简单分词器](fts3.html#tokenizer)，这意味着所有术语都已折叠为小写。此外，例如，在列“term”设置为“apple”且列“col”设置为1的行不存在。由于在列1中没有术语“apple”的实例，fts4aux表中也不存在相应的行。
- en: During a transaction, some of the data written to an FTS table may be cached
    in memory and written to the database only when the transaction is committed.
    However the implementation of the fts4aux module is only able to read data from
    the database. In practice this means that if an fts4aux table is queried from
    within a transaction in which the associated FTS table has been modified, the
    results of the query are likely to reflect only a (possibly empty) subset of the
    changes made.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在事务期间，写入FTS表的某些数据可能会被缓存在内存中，并且只有在提交事务时才会写入数据库。但是，fts4aux模块的实现仅能从数据库中读取数据。实际上，这意味着如果在已修改相关FTS表的事务中查询fts4aux表，则查询的结果可能仅反映所做更改的（可能为空的）子集。
- en: 6\. FTS4 Options
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6\. FTS4选项
- en: 'If the "CREATE VIRTUAL TABLE" statement specifies module FTS4 (not FTS3), then
    special directives - FTS4 options - similar to the "tokenize=*" option may also
    appear in place of column names. An FTS4 option consists of the option name, followed
    by an "=" character, followed by the option value. The option value may optionally
    be enclosed in single or double quotes, with embedded quote characters escaped
    in the same way as for SQL literals. There may not be whitespace on either side
    of the "=" character. For example, to create an FTS4 table with the value of option
    "matchinfo" set to "fts3":'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果“CREATE VIRTUAL TABLE”语句指定了FTS4模块（而不是FTS3），那么类似于“tokenize=*”选项的特殊指令 - FTS4选项
    - 也可能出现在列名的位置。FTS4选项由选项名称、后跟“=”字符、后跟选项值组成。选项值可以选择用单引号或双引号括起来，并且可以像SQL文字值一样转义嵌入的引号字符。在“=”字符两侧不能有空格。例如，要创建一个FTS4表，其中选项“matchinfo”的值设置为“fts3”：
- en: '[PRE35]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'FTS4 currently supports the following options:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 目前FTS4支持以下选项：
- en: '| Option | Interpretation |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| Option | 解释 |'
- en: '| compress | The compress option is used to specify the compress function.
    It is an error to specify a compress function without also specifying an uncompress
    function. [See below](fts3.html#the_compress_and_uncompress_options) for details.
    |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| compress | compress选项用于指定压缩函数。未指定解压函数的情况下指定压缩函数将引发错误。有关详细信息，请参见[下文](fts3.html#the_compress_and_uncompress_options)。'
- en: '| content | The content allows the text being indexed to be stored in a separate
    table distinct from the FTS4 table, or even outside of SQLite. |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| content | content允许索引的文本存储在与FTS4表不同的单独表中，甚至可以存储在SQLite之外。'
- en: '| languageid | The languageid option causes the FTS4 table to have an additional
    hidden integer column that identifies the language of the text contained in each
    row. The use of the languageid option allows the same FTS4 table to hold text
    in multiple languages or scripts, each with different tokenizer rules, and to
    query each language independently of the others. |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| languageid | languageid 选项使 FTS4 表具有额外的隐藏整数列，用于标识每行中包含的文本的语言。使用 languageid
    选项允许同一个 FTS4 表中包含多种语言或脚本的文本，每种语言使用不同的分词器规则进行查询。 |'
- en: '| matchinfo | When set to the value "fts3", the matchinfo option reduces the
    amount of information stored by FTS4 with the consequence that the "l" option
    of [matchinfo()](fts3.html#matchinfo) is no longer available. |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| matchinfo | 当设置为值 "fts3" 时，matchinfo 选项减少了 FTS4 存储的信息量，导致[matchinfo()](fts3.html#matchinfo)的
    "l" 选项不再可用。 |'
- en: '| notindexed | This option is used to specify the name of a column for which
    data is not indexed. Values stored in columns that are not indexed are not matched
    by MATCH queries. Nor are they recognized by auxiliary functions. A single CREATE
    VIRTUAL TABLE statement may have any number of notindexed options. |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| notindexed | 这个选项用于指定不索引数据的列名。未索引的列中存储的值不会被 MATCH 查询匹配，也不会被辅助函数识别。一个 CREATE
    VIRTUAL TABLE 语句可以有任意数量的 notindexed 选项。 |'
- en: '| order | The "order" option may be set to either "DESC" or "ASC" (in upper
    or lower case). If it is set to "DESC", then FTS4 stores its data in such a way
    as to optimize returning results in descending order by docid. If it is set to
    "ASC" (the default), then the data structures are optimized for returning results
    in ascending order by docid. In other words, if many of the queries run against
    the FTS4 table use "ORDER BY docid DESC", then it may improve performance to add
    the "order=desc" option to the CREATE VIRTUAL TABLE statement. |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| order | "order" 选项可以设置为 "DESC" 或 "ASC"（不区分大小写）。如果设置为 "DESC"，则 FTS4 存储数据以优化按
    docid 降序返回结果。如果设置为 "ASC"（默认值），则数据结构优化为按 docid 升序返回结果。换句话说，如果针对 FTS4 表的查询中有很多使用
    "ORDER BY docid DESC"，则将 "order=desc" 选项添加到 CREATE VIRTUAL TABLE 语句中可能会提高性能。 |'
- en: '| prefix | This option may be set to a comma-separated list of positive non-zero
    integers. For each integer N in the list, a separate index is created in the database
    file to optimize [prefix queries](fts3.html#termprefix) where the query term is
    N bytes in length, not including the ''*'' character, when encoded using UTF-8\.
    [See below](fts3.html#the_prefix_option) for details. |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| prefix | 这个选项可以设置为正整数的逗号分隔列表。列表中的每个整数 N 都会在数据库文件中创建一个单独的索引，以优化[前缀查询](fts3.html#termprefix)，其中查询项长度为
    N 个字节（不包括 ''*'' 字符），使用 UTF-8 编码。详细信息请参见[下文](fts3.html#the_prefix_option)。 |'
- en: '| uncompress | This option is used to specify the uncompress function. It is
    an error to specify an uncompress function without also specifying a compress
    function. [See below](fts3.html#the_compress_and_uncompress_options) for details.
    |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| uncompress | 这个选项用于指定解压函数。指定解压函数而没有指定压缩函数是错误的。详细信息请参见[下文](fts3.html#the_compress_and_uncompress_options)。
    |'
- en: 'When using FTS4, specifying a column name that contains an "=" character and
    is not either a "tokenize=*" specification or a recognized FTS4 option is an error.
    With FTS3, the first token in the unrecognized directive is interpreted as a column
    name. Similarly, specifying multiple "tokenize=*" directives in a single table
    declaration is an error when using FTS4, whereas the second and subsequent "tokenize=*"
    directives are interpreted as column names by FTS3\. For example:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 FTS4 时，指定包含 "=" 字符且不是 "tokenize=*" 规范或已识别的 FTS4 选项的列名是错误的。对于 FTS3，未识别指令中的第一个标记被解释为列名。类似地，当使用
    FTS4 时，在单个表声明中指定多个 "tokenize=*" 指令是错误的，而第二个及后续的 "tokenize=*" 指令被 FTS3 解释为列名。例如：
- en: '[PRE36]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 6.1\. The compress= and uncompress= options
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1\. 压缩（compress=）和解压缩（uncompress=）选项
- en: The compress and uncompress options allow FTS4 content to be stored in the database
    in a compressed form. Both options should be set to the name of an SQL scalar
    function registered using [sqlite3_create_function()](c3ref/create_function.html)
    that accepts a single argument.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩和解压缩选项允许以压缩形式存储在数据库中的 FTS4 内容。两个选项都应设置为使用[sqlite3_create_function()](c3ref/create_function.html)注册的单参数
    SQL 标量函数的名称。
- en: The compress function should return a compressed version of the value passed
    to it as an argument. Each time data is written to the FTS4 table, each column
    value is passed to the compress function and the result value stored in the database.
    The compress function may return any type of SQLite value (blob, text, real, integer
    or null).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: compress 函数应返回传递给它的值的压缩版本。每次向 FTS4 表写入数据时，将每个列值传递给 compress 函数，并将结果值存储在数据库中。compress
    函数可以返回任何类型的 SQLite 值（blob、text、real、integer 或 null）。
- en: The uncompress function should uncompress data previously compressed by the
    compress function. In other words, for all SQLite values X, it should be true
    that uncompress(compress(X)) equals X. When data that has been compressed by the
    compress function is read from the database by FTS4, it is passed to the uncompress
    function before it is used.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: uncompress 函数应该解压之前由 compress 函数压缩的数据。换句话说，对于所有的 SQLite 值 X，uncompress(compress(X))
    应该等于 X。当由 FTS4 从数据库读取由 compress 函数压缩过的数据时，在使用之前会先经过 uncompress 函数处理。
- en: If the specified compress or uncompress functions do not exist, the table may
    still be created. An error is not returned until the FTS4 table is read (if the
    uncompress function does not exist) or written (if it is the compress function
    that does not exist).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定的 compress 或 uncompress 函数不存在，表仍然可以创建。直到读取 FTS4 表时（如果 uncompress 函数不存在），或者写入时（如果
    compress 函数不存在），才会返回错误。
- en: '[PRE37]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When implementing the compress and uncompress functions it is important to pay
    attention to data types. Specifically, when a user reads a value from a compressed
    FTS table, the value returned by FTS is exactly the same as the value returned
    by the uncompress function, including the data type. If that data type is not
    the same as the data type of the original value as passed to the compress function
    (for example if the uncompress function is returning BLOB when compress was originally
    passed TEXT), then the users query may not function as expected.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现 compress 和 uncompress 函数时，重要的是要注意数据类型。特别是当用户从压缩的 FTS 表读取值时，FTS 返回的值与 uncompress
    函数返回的值完全相同，包括数据类型。如果该数据类型与最初传递给 compress 函数的原始值的数据类型不同（例如，如果 uncompress 函数返回的是
    BLOB，而最初传递给 compress 的是 TEXT），则用户的查询可能不会按预期工作。
- en: 6.2\. The content= option
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2\. content= 选项
- en: 'The content option allows FTS4 to forego storing the text being indexed. The
    content option can be used in two ways:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: content 选项允许 FTS4 不存储正在索引的文本。content 选项可以以两种方式使用：
- en: The indexed documents are not stored within the SQLite database at all (a "contentless"
    FTS4 table), or
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引文档根本不存储在 SQLite 数据库中（一个“无内容” FTS4 表），或者
- en: The indexed documents are stored in a database table created and managed by
    the user (an "external content" FTS4 table).
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引文档存储在用户创建和管理的数据库表中（一个“外部内容” FTS4 表）。
- en: Because the indexed documents themselves are usually much larger than the full-text
    index, the content option can be used to achieve significant space savings.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 因为索引文档本身通常比全文索引要大得多，所以 content 选项可以用来实现显著的空间节省。
- en: 6.2.1\. Contentless FTS4 Tables
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.1\. 无内容的 FTS4 表
- en: 'In order to create an FTS4 table that does not store a copy of the indexed
    documents at all, the content option should be set to an empty string. For example,
    the following SQL creates such an FTS4 table with three columns - "a", "b", and
    "c":'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个完全不存储索引文档副本的 FTS4 表，content 选项应设置为空字符串。例如，以下 SQL 创建了一个具有三列 - "a"、"b" 和
    "c" 的这样的 FTS4 表：
- en: '[PRE38]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Data can be inserted into such an FTS4 table using an INSERT statements. However,
    unlike ordinary FTS4 tables, the user must supply an explicit integer docid value.
    For example:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 INSERT 语句将数据插入这样的 FTS4 表。但与普通的 FTS4 表不同，用户必须提供显式的整数 docid 值。例如：
- en: '[PRE39]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It is not possible to UPDATE or DELETE a row stored in a contentless FTS4 table.
    Attempting to do so is an error.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 不可能更新或删除存储在无内容的 FTS4 表中的行。试图这样做会导致错误。
- en: 'Contentless FTS4 tables also support SELECT statements. However, it is an error
    to attempt to retrieve the value of any table column other than the docid column.
    The auxiliary function matchinfo() may be used, but snippet() and offsets() may
    not. For example:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 无内容的 FTS4 表也支持 SELECT 语句。但是，试图检索除 docid 列之外的任何表列的值是错误的。辅助函数 matchinfo() 可以使用，但
    snippet() 和 offsets() 不行。例如：
- en: '[PRE40]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Errors related to attempting to retrieve column values other than docid are
    runtime errors that occur within sqlite3_step(). In some cases, for example if
    the MATCH expression in a SELECT query matches zero rows, there may be no error
    at all even if a statement does refer to column values other than docid.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试检索除 docid 外的列值相关的错误是运行时错误，发生在 sqlite3_step() 内。在某些情况下，例如如果 SELECT 查询中的 MATCH
    表达式不匹配任何行，则可能根本没有错误，即使语句确实引用了除 docid 外的列值。
- en: 6.2.2\. External Content FTS4 Tables
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.2\. 外部内容 FTS4 表
- en: An "external content" FTS4 table is similar to a contentless table, except that
    if evaluation of a query requires the value of a column other than docid, FTS4
    attempts to retrieve that value from a table (or view, or virtual table) nominated
    by the user (hereafter referred to as the "content table"). The FTS4 module never
    writes to the content table, and writing to the content table does not affect
    the full-text index. It is the responsibility of the user to ensure that the content
    table and the full-text index are consistent.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '"外部内容" FTS4 表类似于无内容表，不同之处在于，如果查询需要除 docid 外的列的值，FTS4 尝试从用户指定的表（或视图、虚拟表，以下简称为“内容表”）中检索该值。FTS4
    模块从不向内容表写入，并且向内容表写入不会影响全文索引。用户有责任确保内容表和全文索引保持一致。'
- en: 'An external content FTS4 table is created by setting the content option to
    the name of a table (or view, or virtual table) that may be queried by FTS4 to
    retrieve column values when required. If the nominated table does not exist, then
    an external content table behaves in the same way as a contentless table. For
    example:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 content 选项设置为在需要时 FTS4 可以查询以检索列值的表（或视图、虚拟表）的名称来创建外部内容 FTS4 表。如果提名的表不存在，则外部内容表的行为与无内容表相同。例如：
- en: '[PRE41]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Assuming the nominated table does exist, then its columns must be the same as
    or a superset of those defined for the FTS table. The external table must also
    be in the same database file as the FTS table. In other words, The external table
    cannot be in a different database file connected using [ATTACH](lang_attach.html)
    nor may one of the FTS table and the external content be in the TEMP database
    when the other is in a persistent database file such as MAIN.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 假设提名的表确实存在，则其列必须与为 FTS 表定义的列相同或是其超集。外部表还必须位于与 FTS 表相同的数据库文件中。换句话说，当一个是持久数据库文件（如
    MAIN）中的 FTS 表时，外部表不能位于使用 [ATTACH](lang_attach.html) 连接的不同数据库文件中，也不能位于 TEMP 数据库中。
- en: 'When a users query on the FTS table requires a column value other than docid,
    FTS attempts to read the requested value from the corresponding column of the
    row in the content table with a rowid value equal to the current FTS docid. Only
    the subset of content-table columns duplicated in the FTS/34 table declaration
    can be queried for - to retrieve values from any other columns the content table
    must be queried directly. Or, if such a row cannot be found in the content table,
    a NULL value is used instead. For example:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在 FTS 表上查询时，如果需要除 docid 外的列值，FTS 尝试从内容表中的与当前 FTS docid 相等的行的对应列中读取请求的值。只能查询在
    FTS/34 表声明中重复的内容表列的子集，要从其他列检索值，必须直接查询内容表。或者，如果在内容表中找不到这样的行，则使用 NULL 值。例如：
- en: '[PRE42]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: When a row is deleted from an external content FTS4 table, FTS4 needs to retrieve
    the column values of the row being deleted from the content table. This is so
    that FTS4 can update the full-text index entries for each token that occurs within
    the deleted row to indicate that row has been deleted. If the content table row
    cannot be found, or if it contains values inconsistent with the contents of the
    FTS index, the results can be difficult to predict. The FTS index may be left
    containing entries corresponding to the deleted row, which can lead to seemingly
    nonsensical results being returned by subsequent SELECT queries. The same applies
    when a row is updated, as internally an UPDATE is the same as a DELETE followed
    by an INSERT.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当从外部内容 FTS4 表中删除行时，FTS4 需要从内容表中检索正在删除的行的列值。这样，FTS4 可以更新每个出现在删除行内的标记的全文索引条目，以指示该行已删除。如果找不到内容表行，或者它包含与
    FTS 索引内容不一致的值，则结果可能难以预测。FTS 索引可能保留与已删除行对应的条目，这可能导致后续 SELECT 查询返回看似荒谬的结果。在更新行时情况类似，因为在内部，UPDATE
    与 DELETE 后跟 INSERT 是相同的。
- en: 'This means that in order to keep an FTS in sync with an external content table,
    any UPDATE or DELETE operations must be applied first to the FTS table, and then
    to the external content table. For example:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着为了使FTS与外部内容表保持同步，任何UPDATE或DELETE操作必须首先应用于FTS表，然后再应用于外部内容表。例如：
- en: '[PRE43]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Instead of writing separately to the full-text index and the content table,
    some users may wish to use database triggers to keep the full-text index up to
    date with respect to the set of documents stored in the content table. For example,
    using the tables from earlier examples:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 有些用户可能希望使用数据库触发器，而不是分别向全文索引和内容表写入，以便将全文索引与存储在内容表中的文档集合保持最新。例如，使用之前的表：
- en: '[PRE44]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The DELETE trigger must be fired before the actual delete takes place on the
    content table. This is so that FTS4 can still retrieve the original values in
    order to update the full-text index. And the INSERT trigger must be fired after
    the new row is inserted, so as to handle the case where the rowid is assigned
    automatically within the system. The UPDATE trigger must be split into two parts,
    one fired before and one after the update of the content table, for the same reasons.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: DELETE触发器必须在内容表上实际执行删除操作之前触发。这样FTS4才能仍然检索到原始值，以便更新全文索引。INSERT触发器必须在插入新行后触发，以处理系统内自动分配行ID的情况。UPDATE触发器必须分为两部分，一部分在内容表更新之前触发，另一部分在更新之后触发，原因相同。
- en: 'The [FTS4 "rebuild" command](fts3.html#*fts4rebuidcmd) deletes the entire full-text
    index and rebuilds it based on the current set of documents in the content table.
    Assuming again that "t3" is the name of the external content FTS4 table, the rebuild
    command looks like this:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[FTS4 "rebuild" command](fts3.html#*fts4rebuidcmd)会删除整个全文索引，并基于内容表中当前文档集重新构建。再次假设"t3"是外部内容FTS4表的名称，则重建命令如下：'
- en: '[PRE45]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This command may also be used with ordinary FTS4 tables, for example if the
    implementation of the tokenizer changes. It is an error to attempt to rebuild
    the full-text index maintained by a contentless FTS4 table, since no content will
    be available to do the rebuilding.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果令牌化器的实现更改，则此命令也可以用于普通的FTS4表。尝试重新构建由无内容FTS4表维护的全文索引是错误的，因为没有可用的内容来进行重建。
- en: 6.3\. The languageid= option
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3\. languageid= 选项
- en: 'When the languageid option is present, it specifies the name of another [hidden
    column](vtab.html#hiddencol) that is added to the FTS4 table and which is used
    to specify the language stored in each row of the FTS4 table. The name of the
    languageid hidden column must be distinct from all other column names in the FTS4
    table. Example:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在languageid选项时，它指定要添加到FTS4表中的另一个[隐藏列](vtab.html#hiddencol)，该列用于指定FTS4表中每行存储的语言。languageid隐藏列的名称必须与FTS4表中的所有其他列名称不同。例如：
- en: '[PRE46]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The default value of a languageid column is 0\. Any value inserted into a languageid
    column is converted to a 32-bit (not 64) signed integer.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的语言ID列的值是0。任何插入语言ID列的值都会转换为32位（而非64位）有符号整数。
- en: By default, FTS queries (those that use the MATCH operator) consider only those
    rows with the languageid column set to 0\. To query for rows with other languageid
    values, a constraint of the form "
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，FTS查询（使用MATCH操作符的查询）仅考虑languageid列设置为0的行。要查询具有其他languageid值的行，需要使用形式为"
- en: '<language-id>= <integer>" must be added to the queries WHERE clause. For example:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 必须在查询的WHERE子句中添加"<language-id>= <integer>"。例如：
- en: '[PRE47]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: It is not possible for a single FTS query to return rows with different languageid
    values. The results of adding WHERE clauses that use other operators (e.g. lid!=5,
    or lid<=5) are undefined.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单独的FTS查询不可能返回具有不同languageid值的行。使用其他操作符（例如lid!=5或lid<=5）添加WHERE子句的结果是未定义的。
- en: If the content option is used along with the languageid option, then the named
    languageid column must exist in the content= table (subject to the usual rules
    - if a query never needs to read the content table then this restriction does
    not apply).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在content选项与languageid选项一起使用，则内容表中必须存在名为languageid的列（受常规规则约束 - 如果查询从不需要读取内容表，则此限制不适用）。
- en: When the languageid option is used, SQLite invokes the xLanguageid() on the
    sqlite3_tokenizer_module object immediately after the object is created in order
    to pass in the language id that the tokenizer should use. The xLanguageid() method
    will never be called more than once for any single tokenizer object. The fact
    that different languages might be tokenized differently is one reason why no single
    FTS query can return rows with different languageid values.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使用languageid选项时，SQLite在创建sqlite3_tokenizer_module对象后立即调用xLanguageid()方法，以传递分词器应使用的语言ID。对于任何单个分词器对象，xLanguageid()方法最多只会调用一次。不同语言可能以不同方式进行标记化是为什么没有单个FTS查询可以返回具有不同languageid值的行的一个原因。
- en: 6.4\. The matchinfo= option
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4\. matchinfo=选项
- en: The matchinfo option may only be set to the value "fts3". Attempting to set
    matchinfo to anything other than "fts3" is an error. If this option is specified,
    then some of the extra information stored by FTS4 is omitted. This reduces the
    amount of disk space consumed by an FTS4 table until it is almost the same as
    the amount that would be used by the equivalent FTS3 table, but also means that
    the data accessed by passing the 'l' flag to the [matchinfo()](fts3.html#matchinfo)
    function is not available.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 选项`matchinfo`只能设置为值"fts3"。尝试将matchinfo设置为除"fts3"以外的任何值都会引发错误。如果指定了此选项，则FTS4存储的一些额外信息会被省略。这样可以减少FTS4表占用的磁盘空间，使其几乎与等效的FTS3表使用的空间相同。但这也意味着通过将'l'标志传递给[matchinfo()](fts3.html#matchinfo)函数访问的数据不可用。
- en: 6.5\. The notindexed= option
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5\. notindexed=选项
- en: 'Normally, the FTS module maintains an inverted index of all terms in all columns
    of the table. This option is used to specify the name of a column for which entries
    should not be added to the index. Multiple "notindexed" options may be used to
    specify that multiple columns should be omitted from the index. For example:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，FTS模块会维护表的所有列中所有术语的倒排索引。此选项用于指定不应将条目添加到索引中的列的名称。可以使用多个"notindexed"选项来指定应从索引中省略的多个列。例如：
- en: '[PRE48]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Values stored in unindexed columns are not eligible to match MATCH operators.
    They do not influence the results of the offsets() or matchinfo() auxiliary functions.
    Nor will the snippet() function ever return a snippet based on a value stored
    in an unindexed column.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在未索引列中的值不符合MATCH运算符的条件。它们不影响offsets()或matchinfo()辅助函数的结果。也不会有snippet()函数基于存储在未索引列中的值返回片段。
- en: 6.6\. The prefix= option
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6\. prefix=选项
- en: The FTS4 prefix option causes FTS to index term prefixes of specified lengths
    in the same way that it always indexes complete terms. The prefix option must
    be set to a comma separated list of positive non-zero integers. For each value
    N in the list, prefixes of length N bytes (when encoded using UTF-8) are indexed.
    FTS4 uses term prefix indexes to speed up [prefix queries](fts3.html#termprefix).
    The cost, of course, is that indexing term prefixes as well as complete terms
    increases the database size and slows down write operations on the FTS4 table.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: FTS4前缀选项使FTS以与始终索引完整术语相同的方式索引术语前缀。前缀选项必须设置为逗号分隔的正整数列表。对于列表中的每个值N，将编码为UTF-8时长度为N字节的前缀被索引。FTS4使用术语前缀索引加速[前缀查询](fts3.html#termprefix)。当然，代价是索引术语前缀以及完整术语会增加数据库大小，并减慢对FTS4表的写入操作。
- en: Prefix indexes may be used to optimize [prefix queries](fts3.html#termprefix)
    in two cases. If the query is for a prefix of N bytes, then a prefix index created
    with "prefix=N" provides the best optimization. Or, if no "prefix=N" index is
    available, a "prefix=N+1" index may be used instead. Using a "prefix=N+1" index
    is less efficient than a "prefix=N" index, but is better than no prefix index
    at all.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀索引可以用来优化[前缀查询](fts3.html#termprefix)的两种情况。如果查询是N字节的前缀，则使用"prefix=N"创建的前缀索引提供最佳优化。或者，如果没有可用的"prefix=N"索引，则可以改用"prefix=N+1"索引。使用"prefix=N+1"索引比"prefix=N"索引效率低，但比根本没有前缀索引要好。
- en: '[PRE49]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 7\. Special Commands For FTS3 and FTS4
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7\. FTS3和FTS4的特殊命令
- en: 'Special INSERT operates can be used to issue commands to FTS3 and FTS4 tables.
    Every FTS3 and FTS4 has a hidden, read-only column which is the same name as the
    table itself. INSERTs into this hidden column are interpreted as commands to the
    FTS3/4 table. For a table with the name "xyz" the following commands are supported:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用特殊的INSERT操作来向FTS3和FTS4表发出命令。每个FTS3和FTS4都有一个隐藏的只读列，其名称与表本身相同。对此隐藏列的INSERT被解释为FTS3/4表的命令。对于名称为"xyz"的表，支持以下命令：
- en: INSERT INTO xyz(xyz) VALUES('optimize');
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: INSERT INTO xyz(xyz) VALUES('optimize');
- en: INSERT INTO xyz(xyz) VALUES('rebuild');
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: INSERT INTO xyz(xyz) VALUES('rebuild');
- en: INSERT INTO xyz(xyz) VALUES('integrity-check');
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: INSERT INTO xyz(xyz) VALUES('integrity-check');
- en: INSERT INTO xyz(xyz) VALUES('merge=X,Y');
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: INSERT INTO xyz(xyz) VALUES('merge=X,Y');
- en: INSERT INTO xyz(xyz) VALUES('automerge=N');
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: INSERT INTO xyz(xyz) VALUES('automerge=N');
- en: 7.1\. The "optimize" command
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1\. "optimize" 命令
- en: The "optimize" command causes FTS3/4 to merge together all of its inverted index
    b-trees into one large and complete b-tree. Doing an optimize will make subsequent
    queries run faster since there are fewer b-trees to search, and it may reduce
    disk usage by coalescing redundant entries. However, for a large FTS table, running
    optimize can be as expensive as running [VACUUM](lang_vacuum.html). The optimize
    command essentially has to read and write the entire FTS table, resulting in a
    large transaction.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '"optimize" 命令使 FTS3/4 将其所有反向索引 B 树合并为一个大而完整的 B 树。优化将使后续查询运行更快，因为需要搜索的 B 树更少，并且通过合并冗余条目可以减少磁盘使用量。然而，对于大型
    FTS 表，运行 optimize 可能会与运行 [VACUUM](lang_vacuum.html) 一样昂贵。optimize 命令本质上需要读取和写入整个
    FTS 表，导致大型事务。'
- en: In batch-mode operation, where an FTS table is initially built up using a large
    number of INSERT operations, then queried repeatedly without further changes,
    it is often a good idea to run "optimize" after the last INSERT and before the
    first query.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在批处理模式下，首先使用大量 INSERT 操作构建 FTS 表，然后在没有进一步更改的情况下重复查询时，建议在最后一次 INSERT 之后和第一次查询之前运行
    "optimize"。
- en: 7.2\. The "rebuild" command
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2\. "rebuild" 命令
- en: The "rebuild" command causes SQLite to discard the entire FTS3/4 table and then
    rebuild it again from original text. The concept is similar to [REINDEX](lang_reindex.html),
    only that it applies to an FTS3/4 table instead of an ordinary index.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '"rebuild" 命令导致 SQLite 丢弃整个 FTS3/4 表，然后从原始文本重新构建它。这个概念类似于 [REINDEX](lang_reindex.html)，只是它适用于
    FTS3/4 表而不是普通索引。'
- en: The "rebuild" command should be run whenever the implementation of a custom
    tokenizer changes, so that all content can be retokenized. The "rebuild" command
    is also useful when using the [FTS4 content option](fts3.html#*fts4content) after
    changes have been made to the original content table.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当自定义分词器的实现发生更改时，应运行 "rebuild" 命令，以便重新标记所有内容。当使用 [FTS4 content option](fts3.html#*fts4content)
    并在原始内容表进行更改后，"rebuild" 命令也很有用。
- en: 7.3\. The "integrity-check" command
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3\. "integrity-check" 命令
- en: The "integrity-check" command causes SQLite to read and verify the accuracy
    of all inverted indices in an FTS3/4 table by comparing those inverted indices
    against the original content. The "integrity-check" command silently succeeds
    if the inverted indices are all ok, but will fail with an SQLITE_CORRUPT error
    if any problems are found.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '"integrity-check" 命令导致 SQLite 通过将反向索引与原始内容进行比较来读取和验证 FTS3/4 表中所有反向索引的准确性。如果所有反向索引都正常，"integrity-check"
    命令将默默成功，但如果发现任何问题，将会失败并显示 SQLITE_CORRUPT 错误。'
- en: 'The "integrity-check" command is similar in concept to [PRAGMA integrity_check](pragma.html#pragma_integrity_check).
    In a working system, the "integrity-command" should always be successful. Possible
    causes of integrity-check failures include:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '"integrity-check" 命令在概念上类似于 [PRAGMA integrity_check](pragma.html#pragma_integrity_check)。在工作系统中，"integrity-command"
    应始终成功。导致 integrity-check 失败的可能原因包括：'
- en: The application has made changes to the [FTS shadow tables](fts3.html#*shadowtab)
    directly, without using the FTS3/4 virtual table, causing the shadow tables to
    become out of sync with each other.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序直接对 [FTS shadow tables](fts3.html#*shadowtab) 进行更改，而不使用 FTS3/4 虚拟表，导致影子表与彼此不同步。
- en: Using the [FTS4 content option](fts3.html#*fts4content) and failing to manually
    keep the content in sync with the FTS4 inverted indices.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 [FTS4 content option](fts3.html#*fts4content) 并未手动保持内容与 FTS4 反向索引同步。
- en: Bugs in the FTS3/4 virtual table. (The "integrity-check" command was original
    conceived as part of the test suite for FTS3/4.)
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FTS3/4 虚拟表中的错误。（"integrity-check" 命令最初是作为 FTS3/4 的测试套件的一部分提出的。）
- en: Corruption to the underlying SQLite database file. (See documentation on [how
    to corrupt](howtocorrupt.html) and SQLite database for additional information.)
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 底层 SQLite 数据库文件损坏。（有关如何损坏和 SQLite 数据库的额外信息，请参阅 [how to corrupt](howtocorrupt.html)
    文档。）
- en: 7.4\. The "merge=X,Y" command
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4\. "merge=X,Y" 命令
- en: The "merge=X,Y" command (where X and Y are integers) causes SQLite to do a limited
    amount of work toward merging the various inverted index b-trees of an FTS3/4
    table together into one large b-tree. The X value is the target number of "blocks"
    to be merged, and Y is the minimum number of b-tree segments on a level required
    before merging will be applied to that level. The value of Y should be between
    2 and 16 with a recommended value of 8\. The value of X can be any positive integer
    but values on the order of 100 to 300 are recommended.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '"merge=X,Y" 命令（其中 X 和 Y 是整数）导致 SQLite 对 FTS3/4 表的各种倒排索引 b 树进行有限量的合并工作，将它们合并为一个大的
    b 树。X 值是要合并的"块"的目标数，Y 是必须具有的级别上的最小 b 树段数，在该级别上才会应用合并。Y 的值应该在 2 到 16 之间，推荐值为 8。X
    的值可以是任何正整数，但推荐值约为 100 到 300。'
- en: When an FTS table accumulates 16 b-tree segments at the same level, the next
    INSERT into that table will cause all 16 segments to be merged into a single b-tree
    segment at the next higher level. The effect of these level merges is that most
    INSERTs into an FTS table are very fast and take minimal memory, but an occasional
    INSERT is slow and generates a large transaction because of the need to do merging.
    This results in "spiky" performance of INSERTs.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个 FTS 表在同一级别上积累了 16 个 b 树段时，下一个插入操作将导致所有 16 个段被合并成一个大的 b 树段，位于下一个更高的级别。这些级别合并的效果是，大多数插入操作到
    FTS 表都非常快速且占用很少的内存，但由于需要进行合并，偶尔的插入操作会变慢并生成一个大的事务。这导致插入操作的性能出现"波动"。
- en: To avoid spiky INSERT performance, an application can run the "merge=X,Y" command
    periodically, possibly in an idle thread or idle process, to ensure that the FTS
    table never accumulates too many b-tree segments at the same level. INSERT performance
    spikes can generally be avoided, and performance of FTS3/4 can be maximized, by
    running "merge=X,Y" after every few thousand document inserts. Each "merge=X,Y"
    command will run in a separate transaction (unless they are grouped together using
    [BEGIN](lang_transaction.html)...[COMMIT](lang_transaction.html), of course).
    The transactions can be kept small by choosing a value for X in the range of 100
    to 300\. The idle thread that is running the merge commands can know when it is
    done by checking the difference in [sqlite3_total_changes()](c3ref/total_changes.html)
    before and after each "merge=X,Y" command and stopping the loop when the difference
    drops below two.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免突发的插入性能下降，应用程序可以定期运行"merge=X,Y"命令，可能在空闲线程或空闲进程中运行，以确保 FTS 表在同一级别上不会积累过多的
    b 树段。通常可以通过每隔几千次文档插入后运行"merge=X,Y"来避免插入性能的波动，并最大化 FTS3/4 的性能。每个"merge=X,Y"命令将在单独的事务中运行（当然，如果它们使用
    [BEGIN](lang_transaction.html)...[COMMIT](lang_transaction.html) 进行了分组的话）。事务可以通过在范围为
    100 到 300 的 X 值中选择一个来保持较小。运行 merge 命令的空闲线程可以通过检查每个"merge=X,Y"命令前后的 [sqlite3_total_changes()](c3ref/total_changes.html)
    的差异来知道何时完成，当差异减少到两个以下时停止循环。
- en: 7.5\. The "automerge=N" command
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5\. "automerge=N" 命令
- en: The "automerge=N" command (where N is an integer between 0 and 15, inclusive)
    is used to configure an FTS3/4 tables "automerge" parameter, which controls automatic
    incremental inverted index merging. The default automerge value for new tables
    is 0, meaning that automatic incremental merging is completely disabled. If the
    value of the automerge parameter is modified using the "automerge=N" command,
    the new parameter value is stored persistently in the database and is used by
    all subsequently established database connections.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '"automerge=N" 命令（其中 N 是一个介于 0 到 15 之间的整数）用于配置 FTS3/4 表的"automerge"参数，该参数控制自动增量倒排索引合并。新表的默认
    automerge 值为 0，意味着完全禁用自动增量合并。如果使用"automerge=N"命令修改 automerge 参数的值，则新参数值将持久存储在数据库中，并被所有随后建立的数据库连接使用。'
- en: Setting the automerge parameter to a non-zero value enables automatic incremental
    merging. This causes SQLite to do a small amount of inverted index merging after
    every INSERT operation. The amount of merging performed is designed so that the
    FTS3/4 table never reaches a point where it has 16 segments at the same level
    and hence has to do a large merge in order to complete an insert. In other words,
    automatic incremental merging is designed to prevent spiky INSERT performance.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 将 automerge 参数设置为非零值可以启用自动增量合并。这会导致 SQLite 在每次插入操作后执行少量的倒排索引合并。执行的合并量设计得使得 FTS3/4
    表永远不会达到一个有 16 个段的级别，因此必须进行大规模合并才能完成插入操作。换句话说，自动增量合并旨在防止插入性能的突发波动。
- en: The downside of automatic incremental merging is that it makes every INSERT,
    UPDATE, and DELETE operation on an FTS3/4 table run a little slower, since extra
    time must be used to do the incremental merge. For maximum performance, it is
    recommended that applications disable automatic incremental merge and instead
    use the ["merge" command](fts3.html#*fts4mergecmd) in an idle process to keep
    the inverted indices well merged. But if the structure of an application does
    not easily allow for idle processes, the use of automatic incremental merge is
    a very reasonable fallback solution.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 自动增量合并的缺点是使得对FTS3/4表上的每个INSERT、UPDATE和DELETE操作稍微变慢，因为必须使用额外的时间来进行增量合并。为了最大性能，建议应用程序禁用自动增量合并，而是在空闲进程中使用["merge"命令](fts3.html#*fts4mergecmd)来保持反向索引的良好合并状态。但是，如果应用程序的结构不容易允许空闲进程，则使用自动增量合并是一个非常合理的后备解决方案。
- en: The actual value of the automerge parameter determines the number of index segments
    merged simultaneously by an automatic inverted index merge. If the value is set
    to N, the system waits until there are at least N segments on a single level before
    beginning to incrementally merge them. Setting a lower value of N causes segments
    to be merged more quickly, which may speed up full-text queries and, if the workload
    contains UPDATE or DELETE operations as well as INSERTs, reduce the space on disk
    consumed by the full-text index. However, it also increases the amount of data
    written to disk.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 自动合并参数的实际值确定了自动反向索引合并同时合并的索引段数。如果将该值设置为N，则系统将等待单个级别上至少有N个段，然后开始逐步合并它们。将N的值设置得较低会导致段更快地合并，这可能加快全文查询速度，并且如果工作量同时包含UPDATE或DELETE操作以及INSERT，还会减少磁盘上消耗的全文索引空间。但是，这也会增加写入磁盘的数据量。
- en: For general use in cases where the workload contains few UPDATE or DELETE operations,
    a good choice for automerge is 8\. If the workload contains many UPDATE or DELETE
    commands, or if query speed is a concern, it may be advantageous to reduce automerge
    to 2.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 当工作量中包含较少的UPDATE或DELETE操作时，自动合并的良好选择是8。如果工作量包含许多UPDATE或DELETE命令，或者如果查询速度是一个问题，减少自动合并到2可能是有利的。
- en: For reasons of backwards compatibility, the "automerge=1" command sets the automerge
    parameter to 8, not 1 (a value of 1 would make no sense anyway, as merging data
    from a single segment is a no-op).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向后兼容的原因，“automerge=1”命令将自动合并参数设置为8，而不是1（值为1的设置实际上没有意义，因为从单个段合并数据是一个无操作）。
- en: 8\. Tokenizers
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8\. 分词器
- en: An FTS tokenizer is a set of rules for extracting terms from a document or basic
    FTS full-text query.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: FTS分词器是从文档或基本FTS全文查询中提取术语的一组规则。
- en: 'Unless a specific tokenizer is specified as part of the CREATE VIRTUAL TABLE
    statement used to create the FTS table, the default tokenizer, "simple", is used.
    The simple tokenizer extracts tokens from a document or basic FTS full-text query
    according to the following rules:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 除非在用于创建FTS表的CREATE VIRTUAL TABLE语句的一部分中明确指定了特定的分词器，否则将使用默认分词器“simple”。简单分词器根据以下规则从文档或基本FTS全文查询中提取标记。
- en: A term is a contiguous sequence of eligible characters, where eligible characters
    are all alphanumeric characters and all characters with Unicode codepoint values
    greater than or equal to 128. All other characters are discarded when splitting
    a document into terms. Their only contribution is to separate adjacent terms.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 术语是一系列符合条件的连续字符，其中符合条件的字符包括所有字母数字字符和所有Unicode码点值大于或等于128的字符。在将文档拆分为术语时，所有其他字符都将被丢弃。它们的唯一贡献是分隔相邻的术语。
- en: All uppercase characters within the ASCII range (Unicode codepoints less than
    128), are transformed to their lowercase equivalents as part of the tokenization
    process. Thus, full-text queries are case-insensitive when using the simple tokenizer.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在ASCII范围内的所有大写字符（Unicode码点小于128）在标记化过程中都转换为它们的小写等效字符。因此，使用简单分词器时，全文查询是不区分大小写的。
- en: For example, when a document containing the text "Right now, they're very frustrated.",
    the terms extracted from the document and added to the full-text index are, in
    order, "right now they re very frustrated". Such a document would match a full-text
    query such as "MATCH 'Frustrated'", as the simple tokenizer transforms the term
    in the query to lowercase before searching the full-text index.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当文档包含文本“Right now, they're very frustrated.”时，从文档中提取的术语并添加到全文索引中的顺序为“right
    now they re very frustrated”。这样的文档将匹配全文查询，例如“MATCH 'Frustrated'”，因为简单分词器在搜索全文索引之前会将查询中的术语转换为小写。
- en: 'As well as the "simple" tokenizer, the FTS source code features a tokenizer
    that uses the [Porter Stemming algorithm](http://tartarus.org/~martin/PorterStemmer/).
    This tokenizer uses the same rules to separate the input document into terms including
    folding all terms into lower case, but also uses the Porter Stemming algorithm
    to reduce related English language words to a common root. For example, using
    the same input document as in the paragraph above, the porter tokenizer extracts
    the following tokens: "right now thei veri frustrat". Even though some of these
    terms are not even English words, in some cases using them to build the full-text
    index is more useful than the more intelligible output produced by the simple
    tokenizer. Using the porter tokenizer, the document not only matches full-text
    queries such as "MATCH ''Frustrated''", but also queries such as "MATCH ''Frustration''",
    as the term "Frustration" is reduced by the Porter stemmer algorithm to "frustrat"
    - just as "Frustrated" is. So, when using the porter tokenizer, FTS is able to
    find not just exact matches for queried terms, but matches against similar English
    language terms. For more information on the Porter Stemmer algorithm, please refer
    to the page linked above.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 除了“简单”分词器外，FTS源代码还包括使用[波特词干算法](http://tartarus.org/~martin/PorterStemmer/)的分词器。该分词器使用相同的规则将输入文档分割为术语，包括将所有术语折叠为小写，但还使用波特词干算法将相关的英语单词减少到共同的根。例如，使用与上文段落中相同的输入文档，波特分词器提取以下标记：“right
    now thei veri frustrat”。尽管其中一些术语甚至不是英语单词，在某些情况下，使用它们构建全文索引比简单分词器产生的更易理解的输出更有用。使用波特分词器时，文档不仅匹配全文查询，例如“MATCH
    'Frustrated'”，还匹配诸如“MATCH 'Frustration'”之类的查询，因为波特词干算法将术语“Frustration”减少为“frustrat”，就像“Frustrated”一样。因此，使用波特分词器时，FTS不仅能找到查询术语的精确匹配，还能匹配类似的英语术语。有关波特词干算法的更多信息，请参阅上面链接的页面。
- en: 'Example illustrating the difference between the "simple" and "porter" tokenizers:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是说明“简单”和“波特”分词器差异的示例：
- en: '[PRE50]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If this extension is compiled with the SQLITE_ENABLE_ICU pre-processor symbol
    defined, then there exists a built-in tokenizer named "icu" implemented using
    the ICU library. The first argument passed to the xCreate() method (see fts3_tokenizer.h)
    of this tokenizer may be an ICU locale identifier. For example "tr_TR" for Turkish
    as used in Turkey, or "en_AU" for English as used in Australia. For example:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此扩展使用已定义SQLITE_ENABLE_ICU预处理器符号进行编译，则存在一个名为“icu”的内置分词器，使用ICU库实现。传递给此分词器的xCreate()方法的第一个参数（参见fts3_tokenizer.h）可以是ICU语言环境标识符。例如，“tr_TR”表示土耳其语，用于土耳其，或“en_AU”表示英语，用于澳大利亚。例如：
- en: '[PRE51]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The ICU tokenizer implementation is very simple. It splits the input text according
    to the ICU rules for finding word boundaries and discards any tokens that consist
    entirely of white-space. This may be suitable for some applications in some locales,
    but not all. If more complex processing is required, for example to implement
    stemming or discard punctuation, this can be done by creating a tokenizer implementation
    that uses the ICU tokenizer as part of its implementation.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: ICU分词器的实现非常简单。它根据ICU的单词边界查找规则拆分输入文本，并丢弃任何完全由空白字符组成的标记。这可能适合某些地区的某些应用程序，但并非所有应用程序都适用。如果需要更复杂的处理，例如实现词干化或丢弃标点符号，则可以创建使用ICU分词器作为其实现一部分的分词器实现。
- en: The "unicode61" tokenizer is available beginning with SQLite [version 3.7.13](releaselog/3_7_13.html)
    (2012-06-11). Unicode61 works very much like "simple" except that it does simple
    unicode case folding according to rules in Unicode Version 6.1 and it recognizes
    unicode space and punctuation characters and uses those to separate tokens. The
    simple tokenizer only does case folding of ASCII characters and only recognizes
    ASCII space and punctuation characters as token separators.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: “unicode61”分词器从SQLite [版本3.7.13](releaselog/3_7_13.html)（2012-06-11）开始提供。Unicode61的工作方式类似于“simple”，但根据Unicode版本6.1中的规则进行简单的Unicode大小写折叠，并识别Unicode空格和标点字符，并使用它们来分隔标记。简单分词器仅对ASCII字符进行大小写折叠，并仅识别ASCII空格和标点字符作为标记分隔符。
- en: 'By default, "unicode61" attempts to remove diacritics from Latin script characters.
    This behaviour can be overridden by adding the tokenizer argument "remove_diacritics=0".
    For example:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，“unicode61”尝试从拉丁文字母中删除变音符号。可以通过添加分词器参数“remove_diacritics=0”来覆盖此行为。例如：
- en: '[PRE52]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The remove_diacritics option may be set to "0", "1" or "2". The default value
    is "1". If it is set to "1" or "2", then diacritics are removed from Latin script
    characters as described above. However, if it is set to "1", then diacritics are
    not removed in the fairly uncommon case where a single unicode codepoint is used
    to represent a character with more that one diacritic. For example, diacritics
    are not removed from codepoint 0x1ED9 ("LATIN SMALL LETTER O WITH CIRCUMFLEX AND
    DOT BELOW"). This is technically a bug, but cannot be fixed without creating backwards
    compatibility problems. If this option is set to "2", then diacritics are correctly
    removed from all Latin characters.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将remove_diacritics选项设置为"0"、"1"或"2"。默认值为"1"。如果设置为"1"或"2"，则从拉丁文字母中删除变音符，如上所述。但是，如果设置为"1"，则在使用单个unicode代码点表示具有多个变音符的字符的相当罕见情况下，不会删除变音符。例如，不会从代码点0x1ED9（"带有环折和下圆点的小写拉丁字母O"）中删除变音符。这在技术上是一个错误，但不能修复而不会造成向后兼容性问题。如果将此选项设置为"2"，则所有拉丁字符的变音符都将被正确地删除。
- en: 'It is also possible to customize the set of codepoints that unicode61 treats
    as separator characters. The "separators=" option may be used to specify one or
    more extra characters that should be treated as separator characters, and the
    "tokenchars=" option may be used to specify one or more extra characters that
    should be treated as part of tokens instead of as separator characters. For example:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以自定义unicode61将作为分隔符字符对待的代码点集合。"separators="选项可用于指定应作为分隔符字符处理的一个或多个额外字符，而"tokenchars="选项可用于指定应作为标记的一部分而不是作为分隔符字符处理的一个或多个额外字符。例如：
- en: '[PRE53]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If a character specified as part of the argument to "tokenchars=" is considered
    to be a token character by default, it is ignored. This is true even if it has
    been marked as a separator by an earlier "separators=" option. Similarly, if a
    character specified as part of a "separators=" option is treated as a separator
    character by default, it is ignored. If multiple "tokenchars=" or "separators="
    options are specified, all are processed. For example:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果作为"tokenchars="参数的一部分指定的字符默认被视为默认的标记字符，则会被忽略。即使它已被较早的"separators="选项标记为分隔符也是如此。同样，如果作为"separators="选项的一部分指定的字符默认被视为默认的分隔符字符，则会被忽略。如果指定了多个"tokenchars="或"separators="选项，则会全部处理。例如：
- en: '[PRE54]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The arguments passed to the "tokenchars=" or "separators=" options are case-sensitive.
    In the example above, specifying that "X" is a separator character does not affect
    the way "x" is handled.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给"tokenchars="或"separators="选项的参数是区分大小写的。在上述示例中，指定"X"是分隔符字符不会影响处理"x"的方式。
- en: 8.1\. Custom (Application Defined) Tokenizers
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1\. 自定义（应用程序定义）分词器
- en: In addition to providing built-in "simple", "porter" and (possibly) "icu" and
    "unicode61" tokenizers, FTS provides an interface for applications to implement
    and register custom tokenizers written in C. The interface used to create a new
    tokenizer is defined and described in the fts3_tokenizer.h source file.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供内置的"simple"、"porter"和（可能的）"icu"和"unicode61"分词器外，FTS还提供了一个接口，供应用程序编写的自定义分词器在C语言中实现并注册。创建新分词器的接口在fts3_tokenizer.h源文件中定义和描述。
- en: Registering a new FTS tokenizer is similar to registering a new virtual table
    module with SQLite. The user passes a pointer to a structure containing pointers
    to various callback functions that make up the implementation of the new tokenizer
    type. For tokenizers, the structure (defined in fts3_tokenizer.h) is called "sqlite3_tokenizer_module".
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 注册新的FTS分词器类似于在SQLite中注册新的虚拟表模块。用户传递一个指向包含组成新分词器类型实现的各种回调函数指针的结构体指针。对于分词器，结构体（在fts3_tokenizer.h中定义）称为"sqlite3_tokenizer_module"。
- en: 'FTS does not expose a C-function that users call to register new tokenizer
    types with a database handle. Instead, the pointer must be encoded as an SQL blob
    value and passed to FTS through the SQL engine by evaluating a special scalar
    function, "fts3_tokenizer()". The fts3_tokenizer() function may be called with
    one or two arguments, as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: FTS不会公开一个用户调用的C函数来注册带有数据库句柄的新分词器类型。而是，必须将指针编码为SQL blob值并通过评估特殊标量函数"fts3_tokenizer()"将其传递给FTS通过SQL引擎。fts3_tokenizer()函数可以带有一个或两个参数，如下所示：
- en: '[PRE55]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Where <tokenizer-name> is [parameter](lang_expr.html#varparam) to which a string
    is bound using [sqlite3_bind_text()](c3ref/bind_blob.html) where the string identifies
    the tokenizer and <sqlite3_tokenizer_module ptr> is a [parameter](lang_expr.html#varparam)
    to which a BLOB is bound using [sqlite3_bind_blob()](c3ref/bind_blob.html) where
    the value of the BLOB is a pointer to an sqlite3_tokenizer_module structure. If
    the second argument is present, it is registered as tokenizer <tokenizer-name>
    and a copy of it returned. If only one argument is passed, a pointer to the tokenizer
    implementation currently registered as <tokenizer-name> is returned, encoded as
    a blob. Or, if no such tokenizer exists, an SQL exception (error) is raised.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: Where `<tokenizer-name>` 是使用 [sqlite3_bind_text()](c3ref/bind_blob.html) 绑定字符串的参数，该字符串标识分词器，而
    `<sqlite3_tokenizer_module ptr>` 是使用 [sqlite3_bind_blob()](c3ref/bind_blob.html)
    绑定 BLOB 的参数，BLOB 的值是指向 sqlite3_tokenizer_module 结构体的指针。如果第二个参数存在，则将其注册为分词器 `<tokenizer-name>`
    并返回其副本。如果只传递一个参数，则返回当前注册为 `<tokenizer-name>` 的分词器实现的指针，以 BLOB 编码。如果不存在这样的分词器，则会引发
    SQL 异常（错误）。
- en: Prior to SQLite [version 3.11.0](releaselog/3_11_0.html) (2016-02-15), the arguments
    to fts3_tokenizer() could be literal strings or BLOBs. They did not have to be
    [bound parameters](lang_expr.html#varparam). But that could lead to security problems
    in the event of an SQL injection. Hence, the legacy behavior is now disabled by
    default. But the old legacy behavior can be enabled, for backwards compatibility
    in applications that really need it, by calling [sqlite3_db_config](c3ref/db_config.html)(db,[SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER](c3ref/c_dbconfig_defensive.html#sqlitedbconfigenablefts3tokenizer),1,0).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLite [版本 3.11.0](releaselog/3_11_0.html)（2016-02-15）之前，fts3_tokenizer()
    的参数可以是字面字符串或 BLOB。它们不必是 [绑定参数](lang_expr.html#varparam)。但这可能会在发生 SQL 注入时导致安全问题。因此，默认情况下禁用了旧的遗留行为。但可以通过调用
    [sqlite3_db_config](c3ref/db_config.html)(db, [SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER](c3ref/c_dbconfig_defensive.html#sqlitedbconfigenablefts3tokenizer),
    1, 0) 来启用旧的遗留行为，以便在确实需要时向后兼容应用程序。
- en: 'The following block contains an example of calling the fts3_tokenizer() function
    from C code:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块展示了如何从 C 代码中调用 fts3_tokenizer() 函数的示例：
- en: '[PRE56]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 8.2\. Querying Tokenizers
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2\. 查询分词器
- en: 'The "fts3tokenize" virtual table can be used to directly access any tokenizer.
    The following SQL demonstrates how to create an instance of the fts3tokenize virtual
    table:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '"fts3tokenize" 虚拟表可用于直接访问任何分词器。以下 SQL 示范如何创建 fts3tokenize 虚拟表的实例：'
- en: '[PRE57]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The name of the desired tokenizer should be substituted in place of ''porter''
    in the example, of course. If the tokenizer requires one or more arguments, they
    should be separated by commas in the fts3tokenize declaration (even though they
    are separated by spaces in declarations of regular fts4 tables). The following
    creates fts4 and fts3tokenize tables that use the same tokenizer:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，“porter”的位置应替换为所需分词器的名称。如果分词器需要一个或多个参数，则应在 fts3tokenize 声明中用逗号分隔它们（即使在常规
    fts4 表的声明中它们用空格分隔）。以下创建了使用相同分词器的 fts4 和 fts3tokenize 表：
- en: '[PRE58]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Once the virtual table is created, it can be queried as follows:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 创建虚拟表后，可以按以下方式查询它：
- en: '[PRE59]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The virtual table will return one row of output for each token in the input
    string. The "token" column is the text of the token. The "start" and "end" columns
    are the byte offset to the beginning and end of the token in the original input
    string. The "position" column is the sequence number of the token in the original
    input string. There is also an "input" column which is simply a copy of the input
    string that is specified in the WHERE clause. Note that a constraint of the form
    "input=?" must appear in the WHERE clause or else the virtual table will have
    no input to tokenize and will return no rows. The example above generates the
    following output:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟表将为输入字符串中的每个标记返回一行输出。"token" 列是标记的文本。"start" 和 "end" 列是标记在原始输入字符串中的起始和结束字节偏移量。"position"
    列是标记在原始输入字符串中的序列号。还有一个 "input" 列，它只是 WHERE 子句中指定的输入字符串的副本。请注意，WHERE 子句必须出现形如 "input=?"
    的约束，否则虚拟表将没有输入可分词并返回零行。上面的示例生成以下输出：
- en: '[PRE60]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Notice that the tokens in the result set from the fts3tokenize virtual table
    have been transformed according to the rules of the tokenizer. Since this example
    used the "porter" tokenizer, the "This" token was converted into "thi". If the
    original text of the token is desired, it can be retrieved using the "start" and
    "end" columns with the [substr()](lang_corefunc.html#substr) function. For example:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，从 fts3tokenize 虚拟表结果集中的标记已根据标记化器的规则进行了转换。由于此示例使用了 "porter" 标记化器，"This" 标记被转换为
    "thi"。如果需要标记的原始文本，则可以使用 "start" 和 "end" 列与 [substr()](lang_corefunc.html#substr)
    函数检索。例如：
- en: '[PRE61]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The fts3tokenize virtual table can be used on any tokenizer, regardless of whether
    or not there exists an FTS3 or FTS4 table that actually uses that tokenizer.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: fts3tokenize 虚拟表可以在任何标记化器上使用，无论是否存在实际使用该标记化器的 FTS3 或 FTS4 表。
- en: 9\. Data Structures
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9\. 数据结构
- en: This section describes at a high-level the way the FTS module stores its index
    and content in the database. It is **not necessary to read or understand the material
    in this section in order to use FTS** in an application. However, it may be useful
    to application developers attempting to analyze and understand FTS performance
    characteristics, or to developers contemplating enhancements to the existing FTS
    feature set.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 此部分概述了 FTS 模块在数据库中存储其索引和内容的方式。**阅读或理解本节的材料对于在应用中使用 FTS 是不必要的**。然而，对于试图分析和理解
    FTS 性能特征的应用程序开发人员，或者考虑增强现有 FTS 功能集的开发人员来说，可能是有用的。
- en: 9.1\. Shadow Tables
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1\. 影子表
- en: For each FTS virtual table in a database, three to five real (non-virtual) tables
    are created to store the underlying data. These real tables are called "shadow
    tables". The real tables are named "%_content", "%_segdir", "%_segments", "%_stat",
    and "%_docsize", where "%" is replaced by the name of the FTS virtual table.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据库中的每个 FTS 虚拟表，会创建三到五个真实（非虚拟）表来存储底层数据。这些真实表称为 "影子表"。这些真实表的名称分别为 "%_content"、"%_segdir"、"%_segments"、"%_stat"
    和 "%_docsize"，其中 "%" 被替换为 FTS 虚拟表的名称。
- en: 'The leftmost column of the "%_content" table is an INTEGER PRIMARY KEY field
    named "docid". Following this is one column for each column of the FTS virtual
    table as declared by the user, named by prepending the column name supplied by
    the user with "c*N*", where *N* is the index of the column within the table, numbered
    from left to right starting with 0\. Data types supplied as part of the virtual
    table declaration are not used as part of the %_content table declaration. For
    example:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '"%_content" 表的最左列是一个 INTEGER PRIMARY KEY 字段，命名为 "docid"。随后是由用户声明的 FTS 虚拟表的每一列，列名为用户提供的列名前加上
    "c*N*"，其中 *N* 是列在表中的索引，从左到右依次从 0 开始编号。虚拟表声明中提供的数据类型不作为 %_content 表声明的一部分。例如：'
- en: '[PRE62]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The %_content table contains the unadulterated data inserted by the user into
    the FTS virtual table by the user. If the user does not explicitly supply a "docid"
    value when inserting records, one is selected automatically by the system.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '%_content 表包含用户插入到 FTS 虚拟表中的未经修改的数据。如果用户在插入记录时没有显式提供 "docid" 值，则系统会自动选择一个。'
- en: 'The %_stat and %_docsize tables are only created if the FTS table uses the
    FTS4 module, not FTS3\. Furthermore, the %_docsize table is omitted if the FTS4
    table is created with the ["matchinfo=fts3"](fts3.html#fts4matchinfo) directive
    specified as part of the CREATE VIRTUAL TABLE statement. If they are created,
    the schema of the two tables is as follows:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 只有 FTS 表使用 FTS4 模块时才会创建 %_stat 和 %_docsize 表，而不是 FTS3。此外，如果创建 FTS4 表时指定了 ["matchinfo=fts3"](fts3.html#fts4matchinfo)
    指令作为 CREATE VIRTUAL TABLE 语句的一部分，则会省略 %_docsize 表。如果创建了这些表，则两个表的模式如下：
- en: '[PRE63]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: For each row in the FTS table, the %_docsize table contains a corresponding
    row with the same "docid" value. The "size" field contains a blob consisting of
    *N* FTS varints, where *N* is the number of user-defined columns in the table.
    Each varint in the "size" blob is the number of tokens in the corresponding column
    of the associated row in the FTS table. The %_stat table always contains a single
    row with the "id" column set to 0\. The "value" column contains a blob consisting
    of *N+1* FTS varints, where *N* is again the number of user-defined columns in
    the FTS table. The first varint in the blob is set to the total number of rows
    in the FTS table. The second and subsequent varints contain the total number of
    tokens stored in the corresponding column for all rows of the FTS table.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 对于FTS表中的每一行，%_docsize 表包含一个具有相同“docid”值的对应行。字段“size”包含一个由*N*个FTS varints组成的blob，其中*N*是表中用户定义列的数量。在“size”
    blob中的每个varint是FTS表中相应行的每列中的令牌数。%_stat 表始终包含一个将“id”列设置为0的单行。字段“value”包含一个由*N+1*个FTS
    varints组成的blob，其中*N*再次是FTS表中用户定义列的数量。blob中的第一个varint设置为FTS表中的总行数。blob中的第二个及后续varint包含FTS表中所有行的相应列中存储的令牌总数。
- en: 'The two remaining tables, %_segments and %_segdir, are used to store the full-text
    index. Conceptually, this index is a lookup table that maps each term (word) to
    the set of docid values corresponding to records in the %_content table that contain
    one or more occurrences of the term. To retrieve all documents that contain a
    specified term, the FTS module queries this index to determine the set of docid
    values for records that contain the term, then retrieves the required documents
    from the %_content table. Regardless of the schema of the FTS virtual table, the
    %_segments and %_segdir tables are always created as follows:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 余下的两个表，%_segments 和 %_segdir，用于存储全文索引。从概念上讲，此索引是一个查找表，将每个术语（单词）映射到包含该术语一次或多次出现的%_content
    表中记录的文档ID值集合。为了检索包含指定术语的所有文档，FTS模块查询此索引以确定包含该术语的记录的文档ID值集合，然后从%_content 表中检索所需文档。无论FTS虚拟表的架构如何，%_segments
    和 %_segdir 表始终按以下方式创建：
- en: '[PRE64]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The schema depicted above is not designed to store the full-text index directly.
    Instead, it is used to store one or more b-tree structures. There is one b-tree
    for each row in the %_segdir table. The %_segdir table row contains the root node
    and various meta-data associated with the b-tree structure, and the %_segments
    table contains all other (non-root) b-tree nodes. Each b-tree is referred to as
    a "segment". Once it has been created, a segment b-tree is never updated (although
    it may be deleted altogether).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 上述所示的模式并非旨在直接存储全文索引。相反，它用于存储一个或多个B树结构。每个%_segdir 表中的行对应一个B树，该行包含根节点和与B树结构相关的各种元数据，而%_segments
    表则包含所有其他（非根）B树节点。每个B树称为“段”。创建后，段B树永不更新（尽管可以完全删除）。
- en: 'The keys used by each segment b-tree are terms (words). As well as the key,
    each segment b-tree entry has an associated "doclist" (document list). A doclist
    consists of zero or more entries, where each entry consists of:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 每个段B树使用的键是术语（单词）。除了键外，每个段B树条目还有一个关联的“文档列表”（document list）。文档列表由零个或多个条目组成，每个条目包含：
- en: A docid (document id), and
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档ID（文档ID），以及
- en: A list of term offsets, one for each occurrence of the term within the document.
    A term offset indicates the number of tokens (words) that occur before the term
    in question, not the number of characters or bytes. For example, the term offset
    of the term "war" in the phrase "Ancestral voices prophesying war!" is 3.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个术语偏移列表，每个术语在文档内出现一次。术语偏移指示在问题术语之前出现的令牌（单词）数，而不是字符或字节数。例如，在短语“祖先的声音预言战争！”中术语“战争”的术语偏移为3。
- en: Entries within a doclist are sorted by docid. Positions within a doclist entry
    are stored in ascending order.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 文档列表中的条目按照文档ID排序。文档列表条目内部按升序存储位置。
- en: The contents of the logical full-text index is found by merging the contents
    of all segment b-trees. If a term is present in more than one segment b-tree,
    then it maps to the union of each individual doclist. If, for a single term, the
    same docid occurs in more than one doclist, then only the doclist that is part
    of the most recently created segment b-tree is considered valid.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑全文索引的内容通过合并所有段B树的内容来找到。如果一个术语出现在多个段B树中，则将其映射到每个单独文档列表的并集。如果对于单个术语，同一文档ID出现在多个文档列表中，则仅考虑最近创建的段B树的文档列表为有效。
- en: Multiple b-tree structures are used instead of a single b-tree to reduce the
    cost of inserting records into FTS tables. When a new record is inserted into
    an FTS table that already contains a lot of data, it is likely that many of the
    terms in the new record are already present in a large number of existing records.
    If a single b-tree were used, then large doclist structures would have to be loaded
    from the database, amended to include the new docid and term-offset list, then
    written back to the database. Using multiple b-tree tables allows this to be avoided
    by creating a new b-tree which can be merged with the existing b-tree (or b-trees)
    later on. Merging of b-tree structures can be performed as a background task,
    or once a certain number of separate b-tree structures have been accumulated.
    Of course, this scheme makes queries more expensive (as the FTS code may have
    to look up individual terms in more than one b-tree and merge the results), but
    it has been found that in practice this overhead is often negligible.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少向 FTS 表中插入记录的成本，使用多个 b 树结构而不是单个 b 树。当向已包含大量数据的 FTS 表插入新记录时，新记录中的许多术语可能已经存在于大量现有记录中。如果使用单个
    b 树，则必须从数据库加载大型文档列表结构，修改以包含新的文档标识符和术语偏移列表，然后将其写回到数据库中。使用多个 b 树表可以避免这种情况，方法是创建一个新的
    b 树，稍后可以与现有的 b 树（或多个 b 树）合并。可以将 b 树结构的合并作为后台任务执行，或者在累积了一定数量的单独 b 树结构后执行。当然，这种方案会使查询变得更加昂贵（因为
    FTS 代码可能需要在多个 b 树中查找单个术语并合并结果），但实践中发现，这种额外开销通常是可以忽略的。
- en: 9.2\. Variable Length Integer (varint) Format
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2\. 变长整数（varint）格式
- en: Integer values stored as part of segment b-tree nodes are encoded using the
    FTS varint format. This encoding is similar, but **not identical**, to the [SQLite
    varint format](fileformat2.html#varint).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 作为段 b 树节点的一部分存储的整数值使用 FTS 变长整数格式进行编码。此编码与 [SQLite 变长整数格式](fileformat2.html#varint)
    类似，但**并非完全相同**。
- en: An encoded FTS varint consumes between one and ten bytes of space. The number
    of bytes required is determined by the sign and magnitude of the integer value
    encoded. More accurately, the number of bytes used to store the encoded integer
    depends on the position of the most significant set bit in the 64-bit twos-complement
    representation of the integer value. Negative values always have the most significant
    bit set (the sign bit), and so are always stored using the full ten bytes. Positive
    integer values may be stored using less space.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: FTS 变长整数编码使用一到十个字节的空间。编码所需的字节数取决于所编码整数值的符号和大小。更准确地说，存储编码整数所需的字节数取决于整数值在64位二进制补码表示中最高有效位的位置。负值总是具有最高有效位设置（符号位），因此总是使用全部十个字节进行存储。正整数值可能使用更少的空间进行存储。
- en: 'The final byte of an encoded FTS varint has its most significant bit cleared.
    All preceding bytes have the most significant bit set. Data is stored in the remaining
    seven least significant bits of each byte. The first byte of the encoded representation
    contains the least significant seven bits of the encoded integer value. The second
    byte of the encoded representation, if it is present, contains the seven next
    least significant bits of the integer value, and so on. The following table contains
    examples of encoded integer values:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 编码 FTS 变长整数的最后一个字节其最高有效位被清除。所有前导字节的最高有效位被设置。数据存储在每个字节的剩余七个最低有效位中。编码表示的第一个字节包含编码整数值的最低有效七位。如果存在第二个字节，则该字节包含整数值的接下来七个次低有效位，依此类推。以下表格包含编码整数值的示例：
- en: '| Decimal | Hexadecimal | Encoded Representation |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| 十进制 | 十六进制 | 编码表示 |'
- en: '| 43 | 0x000000000000002B | 0x2B |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| 43 | 0x000000000000002B | 0x2B |'
- en: '| 200815 | 0x000000000003106F | 0xEF 0xA0 0x0C |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| 200815 | 0x000000000003106F | 0xEF 0xA0 0x0C |'
- en: '| -1 | 0xFFFFFFFFFFFFFFFF | 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0x01
    |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| -1 | 0xFFFFFFFFFFFFFFFF | 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0x01
    |'
- en: 9.3\. Segment B-Tree Format
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3\. 段 b 树格式
- en: 'Segment b-trees are prefix-compressed b+-trees. There is one segment b-tree
    for each row in the %_segdir table (see above). The root node of the segment b-tree
    is stored as a blob in the "root" field of the corresponding row of the %_segdir
    table. All other nodes (if any exist) are stored in the "blob" column of the %_segments
    table. Nodes within the %_segments table are identified by the integer value in
    the blockid field of the corresponding row. The following table describes the
    fields of the %_segdir table:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 段B树是前缀压缩的B+树。每个%_segdir表中的行对应一个段B树（见上文）。段B树的根节点存储为%_segdir表相应行的“root”字段中的Blob。所有其他节点（如果存在）存储在%_segments表的“blob”列中。%_segments表中的节点由相应行的blockid字段中的整数值标识。以下表格描述了%_segdir表的字段：
- en: '| Column | Interpretation |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| 列 | 解释 |'
- en: '| level | Between them, the contents of the "level" and "idx" fields define
    the relative age of the segment b-tree. The smaller the value stored in the "level"
    field, the more recently the segment b-tree was created. If two segment b-trees
    are of the same "level", the segment with the larger value stored in the "idx"
    column is more recent. The PRIMARY KEY constraint on the %_segdir table prevents
    any two segments from having the same value for both the "level" and "idx" fields.
    |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| level | 在“level”和“idx”字段的内容之间，定义段B树的相对年龄。存储在“level”字段中的值越小，段B树创建时间越近。如果两个段B树的“level”相同，则在“idx”列中存储的较大值的段更近。%_segdir表上的PRIMARY
    KEY约束阻止任何两个段具有相同的“level”和“idx”字段值。 |'
- en: '| idx | See above. |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| idx | 见上文。 |'
- en: '| start_block | The blockid that corresponds to the node with the smallest
    blockid that belongs to this segment b-tree. Or zero if the entire segment b-tree
    fits on the root node. If it exists, this node is always a leaf node. |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| start_block | 对应于属于该段B树的具有最小块ID的节点的块ID。如果整个段B树适合根节点，则为零。如果存在，此节点始终为叶节点。 |'
- en: '| leaves_end_block | The blockid that corresponds to the leaf node with the
    largest blockid that belongs to this segment b-tree. Or zero if the entire segment
    b-tree fits on the root node. |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| leaves_end_block | 对应于具有属于该段B树的最大块ID的叶节点的块ID。如果整个段B树适合根节点，则为零。 |'
- en: '| end_block | This field may contain either an integer or a text field consisting
    of two integers separated by a space character (unicode codepoint 0x20).The first,
    or only, integer is the blockid that corresponds to the interior node with the
    largest blockid that belongs to this segment b-tree. Or zero if the entire segment
    b-tree fits on the root node. If it exists, this node is always an interior node.The
    second integer, if it is present, is the aggregate size of all data stored on
    leaf pages in bytes. If the value is negative, then the segment is the output
    of an unfinished incremental-merge operation, and the absolute value is current
    size in bytes. |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| end_block | 该字段可以包含整数或由空格字符（unicode codepoint 0x20）分隔的两个整数组成的文本字段。第一个或唯一的整数是对应于属于该段B树的具有最大块ID的内部节点的块ID。如果整个段B树适合根节点，则为零。如果存在，此节点始终为内部节点。第二个整数（如果存在）是以字节为单位存储在叶页上的所有数据的聚合大小。如果该值为负数，则段是未完成的增量合并操作的输出，其绝对值为当前以字节为单位的大小。
    |'
- en: '| root | Blob containing the root node of the segment b-tree. |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| root | 包含段B树根节点的Blob。 |'
- en: Apart from the root node, the nodes that make up a single segment b-tree are
    always stored using a contiguous sequence of blockids. Furthermore, the nodes
    that make up a single level of the b-tree are themselves stored as a contiguous
    block, in b-tree order. The contiguous sequence of blockids used to store the
    b-tree leaves are allocated starting with the blockid value stored in the "start_block"
    column of the corresponding %_segdir row, and finishing at the blockid value stored
    in the "leaves_end_block" field of the same row. It is therefore possible to iterate
    through all the leaves of a segment b-tree, in key order, by traversing the %_segments
    table in blockid order from "start_block" to "leaves_end_block".
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 除了根节点外，组成单个段B树的节点始终使用连续的块ID序列存储。此外，组成B树单个级别的节点本身按B树顺序存储为连续块。用于存储B树叶子的连续块ID序列是从相应%_segdir行的“start_block”列中存储的块ID值开始分配的，并在同一行的“leaves_end_block”字段中存储的块ID值结束。因此，通过按块ID顺序从“start_block”到“leaves_end_block”遍历%_segments表，可以按键顺序迭代访问段B树的所有叶子。
- en: 9.3.1\. Segment B-Tree Leaf Nodes
  id: totrans-386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.1\. 段B树叶节点
- en: The following diagram depicts the format of a segment b-tree leaf node.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 下图描述了段落 B 树叶节点的格式。
- en: '![](../Images/3569763fbfe879eb171b338fc76bf4d6.png)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3569763fbfe879eb171b338fc76bf4d6.png)'
- en: Segment B-Tree Leaf Node Format
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 段落 B 树叶节点格式
- en: The first term stored on each node ("Term 1" in the figure above) is stored
    verbatim. Each subsequent term is prefix-compressed with respect to its predecessor.
    Terms are stored within a page in sorted (memcmp) order.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点上存储的第一个术语（上图中的 "术语 1"）保持原样。每个后续术语都相对于其前任进行了前缀压缩。术语按照页面内的排序（memcmp）存储。
- en: 9.3.2\. Segment B-Tree Interior Nodes
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.2\. 段落 B 树内部节点
- en: The following diagram depicts the format of a segment b-tree interior (non-leaf)
    node.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 下图描述了段落 B 树内部（非叶子）节点的格式。
- en: '![](../Images/b1ff44614c88bafdffa674afdb56fed0.png)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b1ff44614c88bafdffa674afdb56fed0.png)'
- en: Segment B-Tree Interior Node Format
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 段落 B 树内部节点格式
- en: 9.4\. Doclist Format
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4\. 文档列表格式
- en: 'A doclist consists of an array of 64-bit signed integers, serialized using
    the FTS varint format. Each doclist entry is made up of a series of two or more
    integers, as follows:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 文档列表由使用 FTS 变长整数格式序列化的 64 位有符号整数数组组成。每个文档列表条目由两个或更多整数组成，如下所示：
- en: The docid value. The first entry in a doclist contains the literal docid value.
    The first field of each subsequent doclist entry contains the difference between
    the new docid and the previous one (always a positive number).
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文档 ID 值。文档列表中的第一条目包含字面上的文档 ID 值。每个后续文档列表条目的第一个字段包含新文档 ID 与前一个文档 ID 的差值（始终为正数）。
- en: 'Zero or more term-offset lists. A term-offset list is present for each column
    of the FTS virtual table that contains the term. A term-offset list consists of
    the following:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FTS 虚拟表中每列包含一个术语时，会有零个或多个术语偏移列表。每个术语偏移列表包括以下内容：
- en: Constant value 1\. This field is omitted for any term-offset list associated
    with column 0.
  id: totrans-399
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 常量值 1。对于与列 0 关联的任何术语偏移列表，此字段被省略。
- en: The column number (1 for the second leftmost column, etc.). This field is omitted
    for any term-offset list associated with column 0.
  id: totrans-400
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列号（第二左起的列为1，依此类推）。对于与列 0 关联的任何术语偏移列表，此字段被省略。
- en: A list of term-offsets, sorted from smallest to largest. Instead of storing
    the term-offset value literally, each integer stored is the difference between
    the current term-offset and the previous one (or zero if the current term-offset
    is the first), plus 2.
  id: totrans-401
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 术语偏移列表，从最小到最大排序。而不是直接存储术语偏移值，每个存储的整数是当前术语偏移与前一个术语偏移之间的差值（如果当前术语偏移是第一个，则为零），再加
    2。
- en: Constant value 0.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 常量值 0。
- en: '![](../Images/8bb73ce4f82564c8acfe7a618932bae0.png)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8bb73ce4f82564c8acfe7a618932bae0.png)'
- en: FTS3 Doclist Format
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: FTS3 文档列表格式
- en: '![](../Images/8939947ade48c28fa4744a6e5363ee12.png)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8939947ade48c28fa4744a6e5363ee12.png)'
- en: FTS Doclist Entry Format
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: FTS 文档列表条目格式
- en: For doclists for which the term appears in more than one column of the FTS virtual
    table, term-offset lists within the doclist are stored in column number order.
    This ensures that the term-offset list associated with column 0 (if any) is always
    first, allowing the first two fields of the term-offset list to be omitted in
    this case.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 对于术语同时出现在 FTS 虚拟表的多个列中的文档列表，文档列表中的术语偏移列表按列号顺序存储。这确保了与列 0 关联的术语偏移列表（如果有）始终位于首位，在这种情况下可以省略术语偏移列表的前两个字段。
- en: 10\. Limitations
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10\. 限制
- en: 10.1\. UTF-16 byte-order-mark problem
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1\. UTF-16 字节顺序标记问题
- en: 'For UTF-16 databases, when using the "simple" tokenizer, it is possible to
    use malformed unicode strings to cause the [integrity-check special command](#integcheck)
    to falsely report corruption, or for [auxiliary functions](#snippet) to return
    incorrect results. More specifically, the bug can be triggered by any of the following:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 UTF-16 数据库，使用 "simple" 分词器时，可以使用格式不正确的 Unicode 字符串来导致 [integrity-check 特殊命令](#integcheck)
    错误报告损坏，或者导致 [辅助函数](#snippet) 返回不正确的结果。具体来说，此错误可能由以下任一情况触发：
- en: 'A UTF-16 byte-order-mark (BOM) is embedded at the beginning of an SQL string
    literal value inserted into an FTS3 table. For example:'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在插入到 FTS3 表中的 SQL 字符串文字值的开头嵌入了一个 UTF-16 字节顺序标记（BOM）。例如：
- en: '[PRE65]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Malformed UTF-8 that SQLite converts to a UTF-16 byte-order-mark is embedded
    at the beginning of an SQL string literal value inserted into an FTS3 table.
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite 转换为 UTF-16 字节顺序标记的格式不正确的 UTF-8 嵌入在插入到 FTS3 表中的 SQL 字符串文字值的开头。
- en: 'A text value created by casting a blob that begins with the two bytes 0xFF
    and 0xFE, in either possible order, is inserted into an FTS3 table. For example:'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将以 0xFF 和 0xFE 开头的 blob 转换为文本值，将其插入到 FTS3 表中。例如：
- en: '[PRE66]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Everything works correctly if any of the following are true:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以下任一条件为真，则一切正常运行：
- en: The [database encoding](pragma.html#pragma_encoding) is UTF-8.
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库编码为UTF-8。
- en: All text strings are insert using one of the [sqlite3_bind_text()](c3ref/bind_blob.html)
    family of functions.
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有文本字符串都是使用[sqlite3_bind_text()](c3ref/bind_blob.html)函数族中的一个插入的。
- en: Literal strings contain no byte-order-marks.
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字面字符串不包含字节顺序标记。
- en: A tokenizer is used that recognizes byte-order-marks as whitespace. (The default
    "simple" tokenizer for FTS3/4 does not think that BOMs are whitespace, but the
    unicode tokenizer does.)
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个能识别字节顺序标记作为空格的分词器。（默认的FTS3/4的“simple”分词器认为BOM不是空格，但unicode分词器认为是。）
- en: All of the above conditions must be false in order for problems to occur. And
    even if all of the conditiona above are false, most things will still operator
    correctly. Only the [integrity-check](#integcheck) command and the [auxiliary
    functions](#snippet) might given unexpected results.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 所有上述条件必须为假，才会出现问题。即使所有上述条件都为假，大多数情况仍将正常运行。只有[integrity-check](#integcheck)命令和[辅助功能](#snippet)可能会导致意外结果。
- en: 'Appendix A: Search Application Tips'
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录A：搜索应用技巧
- en: FTS is primarily designed to support Boolean full-text queries - queries to
    find the set of documents that match a specified criteria. However, many (most?)
    search applications require that results are somehow ranked in order of "relevance",
    where "relevance" is defined as the likelihood that the user who performed the
    search is interested in a specific element of the returned set of documents. When
    using a search engine to find documents on the world wide web, the user expects
    that the most useful, or "relevant", documents will be returned as the first page
    of results, and that each subsequent page contains progressively less relevant
    results. Exactly how a machine can determine document relevance based on a users
    query is a complicated problem and the subject of much ongoing research.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: FTS主要设计用于支持布尔全文查询 - 即查找与指定条件匹配的文档集。然而，许多（大多数？）搜索应用程序要求结果以“相关性”排序，其中“相关性”定义为执行搜索的用户对返回的文档集中特定元素感兴趣的可能性。当使用搜索引擎在全球网络上查找文档时，用户期望最有用或“相关”的文档将作为结果的第一页返回，而每个后续页面包含的结果则越来越不相关。如何根据用户查询确定文档相关性是一个复杂的问题，并且是许多正在进行研究的主题。
- en: 'One very simple scheme might be to count the number of instances of the users
    search terms in each result document. Those documents that contain many instances
    of the terms are considered more relevant than those with a small number of instances
    of each term. In an FTS application, the number of term instances in each result
    could be determined by counting the number of integers in the return value of
    the [offsets](fts3.html#offsets) function. The following example shows a query
    that could be used to obtain the ten most relevant results for a query entered
    by the user:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常简单的方案是计算每个结果文档中用户搜索词实例的数量。包含许多搜索词实例的文档比每个搜索词实例数量较少的文档被认为更相关。在一个FTS应用程序中，可以通过计算[offsets](fts3.html#offsets)函数返回值中整数的数量来确定每个结果中的词项实例数。以下示例显示了一个可以用来获取用户输入查询的十个最相关结果的查询：
- en: '[PRE67]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The query above could be made to run faster by using the FTS [matchinfo](fts3.html#matchinfo)
    function to determine the number of query term instances that appear in each result.
    The matchinfo function is much more efficient than the offsets function. Furthermore,
    the matchinfo function provides extra information regarding the overall number
    of occurrences of each query term in the entire document set (not just the current
    row) and the number of documents in which each query term appears. This may be
    used (for example) to attach a higher weight to less common terms which may increase
    the overall computed relevancy of those results the user considers more interesting.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用FTS的[matchinfo](fts3.html#matchinfo)函数确定每个结果中出现的查询项实例数量，可以使上述查询运行得更快。matchinfo函数比offsets函数更有效率。此外，matchinfo函数提供额外的信息，包括每个查询项在整个文档集中（而不仅仅是当前行）的总出现次数以及每个查询项出现在多少个文档中。这些信息可以（例如）用于给较不常见的项附加更高的权重，从而增加用户认为更有趣的结果的整体计算相关性。
- en: '[PRE68]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The SQL query in the example above uses less CPU than the first example in this
    section, but still has a non-obvious performance problem. SQLite satisfies this
    query by retrieving the value of the "title" column and matchinfo data from the
    FTS module for every row matched by the users query before it sorts and limits
    the results. Because of the way SQLite's virtual table interface works, retrieving
    the value of the "title" column requires loading the entire row from disk (including
    the "content" field, which may be quite large). This means that if the users query
    matches several thousand documents, many megabytes of "title" and "content" data
    may be loaded from disk into memory even though they will never be used for any
    purpose.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 上面示例中的SQL查询比本节第一个示例使用的CPU更少，但仍存在一个不明显的性能问题。SQLite通过检索与用户查询匹配的每一行的“title”列的值和FTS模块的matchinfo数据来满足此查询，然后对结果进行排序和限制。由于SQLite虚拟表接口的工作方式，检索“title”列的值需要从磁盘加载整行（包括可能非常大的“content”字段）。这意味着，如果用户查询匹配数千个文档，那么可能会从磁盘加载许多兆字节的“title”和“content”数据到内存中，尽管它们将永远不会被用于任何目的。
- en: The SQL query in the following example block is one solution to this problem.
    In SQLite, when a [sub-query used in a join contains a LIMIT clause](optoverview.html#flattening),
    the results of the sub-query are calculated and stored in temporary table before
    the main query is executed. This means that SQLite will load only the docid and
    matchinfo data for each row matching the users query into memory, determine the
    docid values corresponding to the ten most relevant documents, then load only
    the title and content information for those 10 documents only. Because both the
    matchinfo and docid values are gleaned entirely from the full-text index, this
    results in dramatically less data being loaded from the database into memory.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 下面示例块中的SQL查询是这个问题的一个解决方案。在SQLite中，当一个join中使用的子查询包含一个LIMIT子句时，子查询的结果会被计算并存储在临时表中，然后再执行主查询。这意味着SQLite仅会将与用户查询匹配的每一行的docid和matchinfo数据加载到内存中，确定对应于十个最相关文档的docid值，然后仅加载这10个文档的title和content信息。由于matchinfo和docid值完全来自全文索引，这导致从数据库加载到内存中的数据大大减少。
- en: '[PRE69]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The next block of SQL enhances the query with solutions to two other problems
    that may arise in developing search applications using FTS:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个SQL块通过解决两个可能在开发使用FTS的搜索应用程序时出现的问题，增强了查询功能：
- en: The [snippet](fts3.html#snippet) function cannot be used with the above query.
    Because the outer query does not include a "WHERE ... MATCH" clause, the snippet
    function may not be used with it. One solution is to duplicate the WHERE clause
    used by the sub-query in the outer query. The overhead associated with this is
    usually negligible.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数[片段](fts3.html#snippet)不能与上述查询一起使用。因为外部查询不包括“WHERE ... MATCH”子句，片段函数无法与之一起使用。一种解决方法是在外部查询中复制子查询中使用的WHERE子句。通常情况下，与此相关的开销是可以忽略不计的。
- en: The relevancy of a document may depend on something other than just the data
    available in the return value of matchinfo. For example each document in the database
    may be assigned a static weight based on factors unrelated to its content (origin,
    author, age, number of references etc.). These values can be stored by the application
    in a separate table that can be joined against the documents table in the sub-query
    so that the rank function may access them.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文档的相关性可能不仅仅取决于返回的matchinfo数据中可用的数据。例如，数据库中的每个文档可以根据与其内容无关的因素（来源、作者、年龄、引用数量等）被分配一个静态权重。这些值可以由应用程序存储在一个单独的表中，并在子查询中与文档表连接，以便rank函数可以访问它们。
- en: This version of the query is very similar to that used by the [sqlite.org documentation
    search](https://www.sqlite.org/search?q=fts3) application.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询版本与[sqlite.org文档搜索](https://www.sqlite.org/search?q=fts3)应用程序使用的查询非常相似。
- en: '[PRE70]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: All the example queries above return the ten most relevant query results. By
    modifying the values used with the OFFSET and LIMIT clauses, a query to return
    (say) the next ten most relevant results is easy to construct. This may be used
    to obtain the data required for a search applications second and subsequent pages
    of results.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 上面所有示例查询都返回十个最相关的查询结果。通过修改与OFFSET和LIMIT子句一起使用的值，可以轻松构建一个返回（例如）下一个十个最相关结果的查询。这可以用于获取搜索应用程序第二页及以后页面所需的数据。
- en: The next block contains an example rank function that uses matchinfo data implemented
    in C. Instead of a single weight, it allows a weight to be externally assigned
    to each column of each document. It may be registered with SQLite like any other
    user function using [sqlite3_create_function](c3ref/create_function.html).
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个区块包含一个使用在C语言中实现的matchinfo数据的示例排名函数。与单一权重不同的是，它允许为每个文档的每列外部分配一个权重。它可以像任何其他用户函数一样通过[sqlite3_create_function](c3ref/create_function.html)在SQLite中注册。
- en: '**Security Warning:** Because it is just an ordinary SQL function, rank() may
    be invoked as part of any SQL query in any context. This means that the first
    argument passed may not be a valid matchinfo blob. Implementors should take care
    to handle this case without causing buffer overruns or other potential security
    problems.'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全警告：** 由于它只是一个普通的SQL函数，rank()可以作为任何上下文中任何SQL查询的一部分调用。这意味着传递的第一个参数可能不是有效的matchinfo
    blob。实现者应当小心处理这种情况，以避免引发缓冲区溢出或其他潜在的安全问题。'
- en: '[PRE71]</integer></language-id>'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE71]</integer></language-id>'
