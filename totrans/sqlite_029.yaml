- en: 1\. Introduction to FTS3 and FTS4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://sqlite.com/fts3.html](https://sqlite.com/fts3.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FTS3 and FTS4 are SQLite virtual table modules that allows users to perform
    full-text searches on a set of documents. The most common (and effective) way
    to describe full-text searches is "what Google, Yahoo, and Bing do with documents
    placed on the World Wide Web". Users input a term, or series of terms, perhaps
    connected by a binary operator or grouped together into a phrase, and the full-text
    query system finds the set of documents that best matches those terms considering
    the operators and groupings the user has specified. This article describes the
    deployment and usage of FTS3 and FTS4.
  prefs: []
  type: TYPE_NORMAL
- en: FTS1 and FTS2 are obsolete full-text search modules for SQLite. There are known
    issues with these older modules and their use should be avoided. Portions of the
    original FTS3 code were contributed to the SQLite project by Scott Hess of [Google](http://www.google.com).
    It is now developed and maintained as part of SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: The FTS3 and FTS4 extension modules allows users to create special tables with
    a built-in full-text index (hereafter "FTS tables"). The full-text index allows
    the user to efficiently query the database for all rows that contain one or more
    words (hereafter "tokens"), even if the table contains many large documents.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if each of the 517430 documents in the "[Enron E-Mail Dataset](http://www.cs.cmu.edu/~enron/)"
    is inserted into both an FTS table and an ordinary SQLite table created using
    the following SQL script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Then either of the two queries below may be executed to find the number of documents
    in the database that contain the word "linux" (351). Using one desktop PC hardware
    configuration, the query on the FTS3 table returns in approximately 0.03 seconds,
    versus 22.5 for querying the ordinary table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the two queries above are not entirely equivalent. For example the
    LIKE query matches rows that contain terms such as "linuxophobe" or "EnterpriseLinux"
    (as it happens, the Enron E-Mail Dataset does not actually contain any such terms),
    whereas the MATCH query on the FTS3 table selects only those rows that contain
    "linux" as a discrete token. Both searches are case-insensitive. The FTS3 table
    consumes around 2006 MB on disk compared to just 1453 MB for the ordinary table.
    Using the same hardware configuration used to perform the SELECT queries above,
    the FTS3 table took just under 31 minutes to populate, versus 25 for the ordinary
    table.
  prefs: []
  type: TYPE_NORMAL
- en: 1.1\. Differences between FTS3 and FTS4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'FTS3 and FTS4 are nearly identical. They share most of their code in common,
    and their interfaces are the same. The differences are:'
  prefs: []
  type: TYPE_NORMAL
- en: FTS4 contains query performance optimizations that may significantly improve
    the performance of full-text queries that contain terms that are very common (present
    in a large percentage of table rows).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FTS4 supports some additional options that may used with the [matchinfo()](fts3.html#matchinfo)
    function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because it stores extra information on disk in two new [shadow tables](fts3.html#*shadowtab)
    in order to support the performance optimizations and extra matchinfo() options,
    FTS4 tables may consume more disk space than the equivalent table created using
    FTS3\. Usually the overhead is 1-2% or less, but may be as high as 10% if the
    documents stored in the FTS table are very small. The overhead may be reduced
    by specifying the directive ["matchinfo=fts3"](fts3.html#fts4matchinfo) as part
    of the FTS4 table declaration, but this comes at the expense of sacrificing some
    of the extra supported matchinfo() options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FTS4 provides hooks (the compress and uncompress [options](fts3.html#fts4_options))
    allowing data to be stored in a compressed form, reducing disk usage and IO.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FTS4 is an enhancement to FTS3. FTS3 has been available since SQLite [version
    3.5.0](releaselog/3_5_0.html) (2007-09-04) The enhancements for FTS4 were added
    with SQLite [version 3.7.4](releaselog/3_7_4.html) (2010-12-07).
  prefs: []
  type: TYPE_NORMAL
- en: Which module, FTS3 or FTS4, should you use in your application? FTS4 is sometimes
    significantly faster than FTS3, even orders of magnitude faster depending on the
    query, though in the common case the performance of the two modules is similar.
    FTS4 also offers the enhanced [matchinfo()](fts3.html#matchinfo) outputs which
    can be useful in ranking the results of a [MATCH](fts3.html#full_text_index_queries)
    operation. On the other hand, in the absence of a [matchinfo=fts3](fts3.html#fts4matchinfo)
    directive FTS4 requires a little more disk space than FTS3, though only a percent
    of two in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: For newer applications, FTS4 is recommended; though if compatibility with older
    versions of SQLite is important, then FTS3 will usually serve just as well.
  prefs: []
  type: TYPE_NORMAL
- en: 1.2\. Creating and Destroying FTS Tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like other virtual table types, new FTS tables are created using a [CREATE VIRTUAL
    TABLE](lang_createvtab.html) statement. The module name, which follows the USING
    keyword, is either "fts3" or "fts4". The virtual table module arguments may be
    left empty, in which case an FTS table with a single user-defined column named
    "content" is created. Alternatively, the module arguments may be passed a list
    of comma separated column names.
  prefs: []
  type: TYPE_NORMAL
- en: If column names are explicitly provided for the FTS table as part of the CREATE
    VIRTUAL TABLE statement, then a datatype name may be optionally specified for
    each column. This is pure syntactic sugar, the supplied typenames are not used
    by FTS or the SQLite core for any purpose. The same applies to any constraints
    specified along with an FTS column name - they are parsed but not used or recorded
    by the system in any way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As well as a list of columns, the module arguments passed to a CREATE VIRTUAL
    TABLE statement used to create an FTS table may be used to specify a [tokenizer](fts3.html#tokenizer).
    This is done by specifying a string of the form "tokenize=<tokenizer name> <tokenizer
    args>" in place of a column name, where <tokenizer name> is the name of the tokenizer
    to use and <tokenizer args> is an optional list of whitespace separated qualifiers
    to pass to the tokenizer implementation. A tokenizer specification may be placed
    anywhere in the column list, but at most one tokenizer declaration is allowed
    for each CREATE VIRTUAL TABLE statement. [See below](fts3.html#tokenizer) for
    a detailed description of using (and, if necessary, implementing) a tokenizer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'FTS tables may be dropped from the database using an ordinary [DROP TABLE](lang_droptable.html)
    statement. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 1.3\. Populating FTS Tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FTS tables are populated using [INSERT](lang_insert.html), [UPDATE](lang_update.html)
    and [DELETE](lang_delete.html) statements in the same way as ordinary SQLite tables
    are.
  prefs: []
  type: TYPE_NORMAL
- en: As well as the columns named by the user (or the "content" column if no module
    arguments were specified as part of the [CREATE VIRTUAL TABLE](lang_createvtab.html)
    statement), each FTS table has a "rowid" column. The rowid of an FTS table behaves
    in the same way as the rowid column of an ordinary SQLite table, except that the
    values stored in the rowid column of an FTS table remain unchanged if the database
    is rebuilt using the [VACUUM](lang_vacuum.html) command. For FTS tables, "docid"
    is allowed as an alias along with the usual "rowid", "oid" and "_oid_" identifiers.
    Attempting to insert or update a row with a docid value that already exists in
    the table is an error, just as it would be with an ordinary SQLite table.
  prefs: []
  type: TYPE_NORMAL
- en: There is one other subtle difference between "docid" and the normal SQLite aliases
    for the rowid column. Normally, if an INSERT or UPDATE statement assigns discrete
    values to two or more aliases of the rowid column, SQLite writes the rightmost
    of such values specified in the INSERT or UPDATE statement to the database. However,
    assigning a non-NULL value to both the "docid" and one or more of the SQLite rowid
    aliases when inserting or updating an FTS table is considered an error. See below
    for an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: To support full-text queries, FTS maintains an inverted index that maps from
    each unique term or word that appears in the dataset to the locations in which
    it appears within the table contents. For the curious, a complete description
    of the [data structure](fts3.html#data_structures) used to store this index within
    the database file appears below. A feature of this data structure is that at any
    time the database may contain not one index b-tree, but several different b-trees
    that are incrementally merged as rows are inserted, updated and deleted. This
    technique improves performance when writing to an FTS table, but causes some overhead
    for full-text queries that use the index. Evaluating the special ["optimize" command](fts3.html#*fts4optcmd),
    an SQL statement of the form "INSERT INTO <fts-table>(<fts-table>) VALUES('optimize')",
    causes FTS to merge all existing index b-trees into a single large b-tree containing
    the entire index. This can be an expensive operation, but may speed up future
    queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to optimize the full-text index for an FTS table named "docs":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The statement above may appear syntactically incorrect to some. Refer to the
    section describing the [simple fts queries](fts3.html#simple_fts_queries) for
    an explanation.
  prefs: []
  type: TYPE_NORMAL
- en: There is another, deprecated, method for invoking the optimize operation using
    a SELECT statement. New code should use statements similar to the INSERT above
    to optimize FTS structures.
  prefs: []
  type: TYPE_NORMAL
- en: 1.4\. Simple FTS Queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As for all other SQLite tables, virtual or otherwise, data is retrieved from
    FTS tables using a [SELECT](lang_select.html) statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'FTS tables can be queried efficiently using SELECT statements of two different
    forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Query by rowid**. If the WHERE clause of the SELECT statement contains a
    sub-clause of the form "rowid = ?", where ? is an SQL expression, FTS is able
    to retrieve the requested row directly using the equivalent of an SQLite [INTEGER
    PRIMARY KEY](lang_createtable.html#rowid) index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Full-text query**. If the WHERE clause of the SELECT statement contains a
    sub-clause of the form "<column> MATCH ?", FTS is able to use the built-in full-text
    index to restrict the search to those documents that match the full-text query
    string specified as the right-hand operand of the MATCH clause.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If neither of these two query strategies can be used, all queries on FTS tables
    are implemented using a linear scan of the entire table. If the table contains
    large amounts of data, this may be an impractical approach (the first example
    on this page shows that a linear scan of 1.5 GB of data takes around 30 seconds
    using a modern PC).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In all of the full-text queries above, the right-hand operand of the MATCH operator
    is a string consisting of a single term. In this case, the MATCH expression evaluates
    to true for all documents that contain one or more instances of the specified
    word ("sqlite", "search" or "database", depending on which example you look at).
    Specifying a single term as the right-hand operand of the MATCH operator results
    in the simplest and most common type of full-text query possible. However more
    complicated queries are possible, including phrase searches, term-prefix searches
    and searches for documents containing combinations of terms occurring within a
    defined proximity of each other. The various ways in which the full-text index
    may be queried are [described below](fts3.html#full_text_index_queries).
  prefs: []
  type: TYPE_NORMAL
- en: Normally, full-text queries are case-insensitive. However, this is dependent
    on the specific [tokenizer](fts3.html#tokenizer) used by the FTS table being queried.
    Refer to the section on [tokenizers](fts3.html#tokenizer) for details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The paragraph above notes that a MATCH operator with a simple term as the right-hand
    operand evaluates to true for all documents that contain the specified term. In
    this context, the "document" may refer to either the data stored in a single column
    of a row of an FTS table, or to the contents of all columns in a single row, depending
    on the identifier used as the left-hand operand to the MATCH operator. If the
    identifier specified as the left-hand operand of the MATCH operator is an FTS
    table column name, then the document that the search term must be contained in
    is the value stored in the specified column. However, if the identifier is the
    name of the FTS *table* itself, then the MATCH operator evaluates to true for
    each row of the FTS table for which any column contains the search term. The following
    example demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: At first glance, the final two full-text queries in the example above seem to
    be syntactically incorrect, as there is a table name ("mail") used as an SQL expression.
    The reason this is acceptable is that each FTS table actually has a [HIDDEN](c3ref/declare_vtab.html)
    column with the same name as the table itself (in this case, "mail"). The value
    stored in this column is not meaningful to the application, but can be used as
    the left-hand operand to a MATCH operator. This special column may also be passed
    as an argument to the [FTS auxiliary functions](fts3.html#snippet).
  prefs: []
  type: TYPE_NORMAL
- en: The following example illustrates the above. The expressions "docs", "docs.docs"
    and "main.docs.docs" all refer to column "docs". However, the expression "main.docs"
    does not refer to any column. It could be used to refer to a table, but a table
    name is not allowed in the context in which it is used below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 1.5\. Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From the users point of view, FTS tables are similar to ordinary SQLite tables
    in many ways. Data may be added to, modified within and removed from FTS tables
    using the INSERT, UPDATE and DELETE commands just as it may be with ordinary tables.
    Similarly, the SELECT command may be used to query data. The following list summarizes
    the differences between FTS and ordinary tables:'
  prefs: []
  type: TYPE_NORMAL
- en: As with all virtual table types, it is not possible to create indices or triggers
    attached to FTS tables. Nor is it possible to use the ALTER TABLE command to add
    extra columns to FTS tables (although it is possible to use ALTER TABLE to rename
    an FTS table).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Data-types specified as part of the "CREATE VIRTUAL TABLE" statement used to
    create an FTS table are ignored completely. Instead of the normal rules for applying
    type [affinity](datatype3.html#affinity) to inserted values, all values inserted
    into FTS table columns (except the special rowid column) are converted to type
    TEXT before being stored.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: FTS tables permit the special alias "docid" to be used to refer to the rowid
    column supported by all [virtual tables](vtab.html).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The [FTS MATCH](fts3.html#full_text_index_queries) operator is supported for
    queries based on the built-in full-text index.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The [FTS auxiliary functions](fts3.html#snippet), [snippet()](fts3.html#snippet),
    [offsets()](fts3.html#offsets), and [matchinfo()](fts3.html#matchinfo) are available
    to support full-text queries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every FTS table has a [hidden column](vtab.html#hiddencol) with the same name
    as the table itself. The value contained in each row for the hidden column is
    a blob that is only useful as the left operand of a [MATCH](fts3.html#full_text_index_queries)
    operator, or as the left-most argument to one of the [FTS auxiliary functions](fts3.html#snippet).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2\. Compiling and Enabling FTS3 and FTS4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although FTS3 and FTS4 are included with the SQLite core source code, they
    are not enabled by default. To build SQLite with FTS functionality enabled, define
    the preprocessor macro [SQLITE_ENABLE_FTS3](compile.html#enable_fts3) when compiling.
    New applications should also define the [SQLITE_ENABLE_FTS3_PARENTHESIS](compile.html#enable_fts3_parenthesis)
    macro to enable the [enhanced query syntax](fts3.html#_set_operations_using_the_enhanced_query_syntax)
    (see below). Usually, this is done by adding the following two switches to the
    compiler command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that enabling FTS3 also makes FTS4 available. There is not a separate SQLITE_ENABLE_FTS4
    compile-time option. A build of SQLite either supports both FTS3 and FTS4 or it
    supports neither.
  prefs: []
  type: TYPE_NORMAL
- en: 'If using the amalgamation autoconf based build system, setting the CPPFLAGS
    environment variable while running the ''configure'' script is an easy way to
    set these macros. For example, the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: where *<configure options>* are those options normally passed to the configure
    script, if any.
  prefs: []
  type: TYPE_NORMAL
- en: Because FTS3 and FTS4 are virtual tables, The [SQLITE_ENABLE_FTS3](compile.html#enable_fts3)
    compile-time option is incompatible with the [SQLITE_OMIT_VIRTUALTABLE](compile.html#omit_virtualtable)
    option.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a build of SQLite does not include the FTS modules, then any attempt to
    prepare an SQL statement to create an FTS3 or FTS4 table or to drop or access
    an existing FTS table in any way will fail. The error message returned will be
    similar to "no such module: ftsN" (where N is either 3 or 4).'
  prefs: []
  type: TYPE_NORMAL
- en: If the C version of the [ICU library](https://icu.unicode.org) is available,
    then FTS may also be compiled with the SQLITE_ENABLE_ICU pre-processor macro defined.
    Compiling with this macro enables an FTS [tokenizer](fts3.html#tokenizer) that
    uses the ICU library to split a document into terms (words) using the conventions
    for a specified language and locale.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 3\. Full-text Index Queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most useful thing about FTS tables is the queries that may be performed
    using the built-in full-text index. Full-text queries are performed by specifying
    a clause of the form "<column> MATCH <full-text query expression>" as part of
    the WHERE clause of a SELECT statement that reads data from an FTS table. [Simple
    FTS queries](fts3.html#simple_fts_queries) that return all documents that contain
    a given term are described above. In that discussion the right-hand operand of
    the MATCH operator was assumed to be a string consisting of a single term. This
    section describes the more complex query types supported by FTS tables, and how
    they may be utilized by specifying a more complex query expression as the right-hand
    operand of a MATCH operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'FTS tables support three basic query types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Token or token prefix queries**. An FTS table may be queried for all documents
    that contain a specified term (the [simple case](fts3.html#simple_fts_queries)
    described above), or for all documents that contain a term with a specified prefix.
    As we have seen, the query expression for a specific term is simply the term itself.
    The query expression used to search for a term prefix is the prefix itself with
    a ''*'' character appended to it. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Normally, a token or token prefix query is matched against the FTS table column
    specified as the left-hand side of the MATCH operator. Or, if the special column
    with the same name as the FTS table itself is specified, against all columns.
    This may be overridden by specifying a column-name followed by a ":" character
    before a basic term query. There may be space between the ":" and the term to
    query for, but not between the column-name and the ":" character. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If the FTS table is an FTS4 table (not FTS3), a token may also be prefixed
    with a "^" character. In this case, in order to match the token must appear as
    the very first token in any column of the matching row. Examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '**Phrase queries**. A phrase query is a query that retrieves all documents
    that contain a nominated set of terms or term prefixes in a specified order with
    no intervening tokens. Phrase queries are specified by enclosing a space separated
    sequence of terms or term prefixes in double quotes ("). For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '**NEAR queries**. A NEAR query is a query that returns documents that contain
    a two or more nominated terms or phrases within a specified proximity of each
    other (by default with 10 or less intervening terms). A NEAR query is specified
    by putting the keyword "NEAR" between two phrase, token or token prefix queries.
    To specify a proximity other than the default, an operator of the form "NEAR/*<N>*"
    may be used, where *<N>* is the maximum number of intervening terms allowed. For
    example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'More than one NEAR operator may appear in a single query. In this case each
    pair of terms or phrases separated by a NEAR operator must appear within the specified
    proximity of each other in the document. Using the same table and data as in the
    block of examples above:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Phrase and NEAR queries may not span multiple columns within a row.
  prefs: []
  type: TYPE_NORMAL
- en: 'The three basic query types described above may be used to query the full-text
    index for the set of documents that match the specified criteria. Using the FTS
    query expression language it is possible to perform various set operations on
    the results of basic queries. There are currently three supported operations:'
  prefs: []
  type: TYPE_NORMAL
- en: The AND operator determines the **intersection** of two sets of documents.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The OR operator calculates the **union** of two sets of documents.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The NOT operator (or, if using the standard syntax, a unary "-" operator) may
    be used to compute the **relative complement** of one set of documents with respect
    to another.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The FTS modules may be compiled to use one of two slightly different versions
    of the full-text query syntax, the "standard" query syntax and the "enhanced"
    query syntax. The basic term, term-prefix, phrase and NEAR queries described above
    are the same in both versions of the syntax. The way in which set operations are
    specified is slightly different. The following two sub-sections describe the part
    of the two query syntaxes that pertains to set operations. Refer to the description
    of how to [compile fts](fts3.html#compiling_and_enabling_fts3_and_fts4) for compilation
    notes.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1\. Set Operations Using The Enhanced Query Syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The enhanced query syntax supports the AND, OR and NOT binary set operators.
    Each of the two operands to an operator may be a basic FTS query, or the result
    of another AND, OR or NOT set operation. Operators must be entered using capital
    letters. Otherwise, they are interpreted as basic term queries instead of set
    operators.
  prefs: []
  type: TYPE_NORMAL
- en: The AND operator may be implicitly specified. If two basic queries appear with
    no operator separating them in an FTS query string, the results are the same as
    if the two basic queries were separated by an AND operator. For example, the query
    expression "implicit operator" is a more succinct version of "implicit AND operator".
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The examples above all use basic full-text term queries as both operands of
    the set operations demonstrated. Phrase and NEAR queries may also be used, as
    may the results of other set operations. When more than one set operation is present
    in an FTS query, the precedence of operators is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Enhanced Query Syntax Precedence |'
  prefs: []
  type: TYPE_TB
- en: '| NOT | Highest precedence (tightest grouping). |'
  prefs: []
  type: TYPE_TB
- en: '| AND |  |'
  prefs: []
  type: TYPE_TB
- en: '| OR | Lowest precedence (loosest grouping). |'
  prefs: []
  type: TYPE_TB
- en: 'When using the enhanced query syntax, parenthesis may be used to override the
    default precedence of the various operators. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 3.2\. Set Operations Using The Standard Query Syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'FTS query set operations using the standard query syntax are similar, but not
    identical, to set operations with the enhanced query syntax. There are four differences,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Only the implicit version of the AND operator is supported. Specifying the string
    "AND" as part of a standard query syntax query is interpreted as a term query
    for the set of documents containing the term "and".
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parenthesis are not supported.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The NOT operator is not supported. Instead of the NOT operator, the standard
    query syntax supports a unary "-" operator that may be applied to basic term and
    term-prefix queries (but not to phrase or NEAR queries). A term or term-prefix
    that has a unary "-" operator attached to it may not appear as an operand to an
    OR operator. An FTS query may not consist entirely of terms or term-prefix queries
    with unary "-" operators attached to them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The relative precedence of the set operations is different. In particular,
    using the standard query syntax the "OR" operator has a higher precedence than
    "AND". The precedence of operators when using the standard query syntax is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| Operator | Standard Query Syntax Precedence |'
  prefs: []
  type: TYPE_TB
- en: '| Unary "-" | Highest precedence (tightest grouping). |'
  prefs: []
  type: TYPE_TB
- en: '| OR |  |'
  prefs: []
  type: TYPE_TB
- en: '| AND | Lowest precedence (loosest grouping). |'
  prefs: []
  type: TYPE_TB
- en: 'The following example illustrates precedence of operators using the standard
    query syntax:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 4\. Auxiliary Functions - Snippet, Offsets and Matchinfo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The FTS3 and FTS4 modules provide three special SQL scalar functions that may
    be useful to the developers of full-text query systems: "snippet", "offsets" and
    "matchinfo". The purpose of the "snippet" and "offsets" functions is to allow
    the user to identify the location of queried terms in the returned documents.
    The "matchinfo" function provides the user with metrics that may be useful for
    filtering or sorting query results according to relevance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first argument to all three special SQL scalar functions must be the [FTS
    hidden column](fts3.html#hiddencol) of the FTS table that the function is applied
    to. The [FTS hidden column](fts3.html#hiddencol) is an automatically-generated
    column found on all FTS tables that has the same name as the FTS table itself.
    For example, given an FTS table named "mail":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The three auxiliary functions are only useful within a SELECT statement that
    uses the FTS table's full-text index. If used within a SELECT that uses the "query
    by rowid" or "linear scan" strategies, then the snippet and offsets both return
    an empty string, and the matchinfo function returns a blob value zero bytes in
    size.
  prefs: []
  type: TYPE_NORMAL
- en: All three auxiliary functions extract a set of "matchable phrases" from the
    FTS query expression to work with. The set of matchable phrases for a given query
    consists of all phrases (including unquoted tokens and token prefixes) in the
    expression except those that are prefixed with a unary "-" operator (standard
    syntax) or are part of a sub-expression that is used as the right-hand operand
    of a NOT operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the following provisos, each series of tokens in the FTS table that matches
    one of the matchable phrases in the query expression is known as a "phrase match":'
  prefs: []
  type: TYPE_NORMAL
- en: If a matchable phrase is part of a series of phrases connected by NEAR operators
    in the FTS query expression, then each phrase match must be sufficiently close
    to other phrase matches of the relevant types to satisfy the NEAR condition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the matchable phrase in the FTS query is restricted to matching data in a
    specified FTS table column, then only phrase matches that occur within that column
    are considered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 4.1\. The Offsets Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For a SELECT query that uses the full-text index, the offsets() function returns
    a text value containing a series of space-separated integers. For each term in
    each [phrase match](#matchable) of the current row, there are four integers in
    the returned list. Each set of four integers is interpreted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Integer | Interpretation |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | The column number that the term instance occurs in (0 for the leftmost
    column of the FTS table, 1 for the next leftmost, etc.). |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | The term number of the matching term within the full-text query expression.
    Terms within a query expression are numbered starting from 0 in the order that
    they occur. |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | The byte offset of the matching term within the column. |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | The size of the matching term in bytes. |'
  prefs: []
  type: TYPE_TB
- en: The following block contains examples that use the offsets function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 4.2\. The Snippet Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The snippet function is used to create formatted fragments of document text
    for display as part of a full-text query results report. The snippet function
    may be passed between one and six arguments, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Default Value | Description |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | N/A | The first argument to the snippet function must always be the [FTS
    hidden column](fts3.html#hiddencol) of the FTS table being queried and from which
    the snippet is to be taken. The [FTS hidden column](fts3.html#hiddencol) is an
    automatically generated column with the same name as the FTS table itself. |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | "<b>" | The "start match" text. |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | "</b>" | The "end match" text. |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | "<b>...</b>" | The "ellipses" text. |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | -1 | The FTS table column number to extract the returned fragments of
    text from. Columns are numbered from left to right starting with zero. A negative
    value indicates that the text may be extracted from any column. |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | -15 | The absolute value of this integer argument is used as the (approximate)
    number of tokens to include in the returned text value. The maximum allowable
    absolute value is 64\. The value of this argument is referred to as *N* in the
    discussion below. |'
  prefs: []
  type: TYPE_TB
- en: The snippet function first attempts to find a fragment of text consisting of
    *|N|* tokens within the current row that contains at least one phrase match for
    each matchable phrase matched somewhere in the current row, where *|N|* is the
    absolute value of the sixth argument passed to the snippet function. If the text
    stored in a single column contains less than *|N|* tokens, then the entire column
    value is considered. Text fragments may not span multiple columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'If such a text fragment can be found, it is returned with the following modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: If the text fragment does not begin at the start of a column value, the "ellipses"
    text is prepended to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the text fragment does not finish at the end of a column value, the "ellipses"
    text is appended to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each token in the text fragment that is part of a phrase match, the "start
    match" text is inserted into the fragment before the token, and the "end match"
    text is inserted immediately after it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If more than one such fragment can be found, then fragments that contain a larger
    number of "extra" phrase matches are favored. The start of the selected text fragment
    may be moved a few tokens forward or backward to attempt to concentrate the phrase
    matches toward the center of the fragment.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming *N* is a positive value, if no fragments can be found that contain
    a phrase match corresponding to each matchable phrase, the snippet function attempts
    to find two fragments of approximately *N*/2 tokens that between them contain
    at least one phrase match for each matchable phrase matched by the current row.
    If this fails, attempts are made to find three fragments of *N*/3 tokens each
    and finally four *N*/4 token fragments. If a set of four fragments cannot be found
    that encompasses the required phrase matches, the four fragments of *N*/4 tokens
    that provide the best coverage are selected.
  prefs: []
  type: TYPE_NORMAL
- en: If *N* is a negative value, and no single fragment can be found containing the
    required phrase matches, the snippet function searches for two fragments of *|N|*
    tokens each, then three, then four. In other words, if the specified value of
    *N* is negative, the sizes of the fragments is not decreased if more than one
    fragment is required to provide the desired phrase match coverage.
  prefs: []
  type: TYPE_NORMAL
- en: After the *M* fragments have been located, where *M* is between two and four
    as described in the paragraphs above, they are joined together in sorted order
    with the "ellipses" text separating them. The three modifications enumerated earlier
    are performed on the text before it is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 4.3\. The Matchinfo Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The matchinfo function returns a blob value. If it is used within a query that
    does not use the full-text index (a "query by rowid" or "linear scan"), then the
    blob is zero bytes in size. Otherwise, the blob consists of zero or more 32-bit
    unsigned integers in machine byte-order. The exact number of integers in the returned
    array depends on both the query and the value of the second argument (if any)
    passed to the matchinfo function.
  prefs: []
  type: TYPE_NORMAL
- en: The matchinfo function is called with either one or two arguments. As for all
    auxiliary functions, the first argument must be the special [FTS hidden column](fts3.html#hiddencol).
    The second argument, if it is specified, must be a text value comprised only of
    the characters 'p', 'c', 'n', 'a', 'l', 's', 'x', 'y' and 'b'. If no second argument
    is explicitly supplied, it defaults to "pcx". The second argument is referred
    to as the "format string" below.
  prefs: []
  type: TYPE_NORMAL
- en: Characters in the matchinfo format string are processed from left to right.
    Each character in the format string causes one or more 32-bit unsigned integer
    values to be added to the returned array. The "values" column in the following
    table contains the number of integer values appended to the output buffer for
    each supported format string character. In the formula given, *cols* is the number
    of columns in the FTS table, and *phrases* is the number of [matchable phrases](#matchable)
    in the query.
  prefs: []
  type: TYPE_NORMAL
- en: '| Character | Values | Description |'
  prefs: []
  type: TYPE_TB
- en: '| p | 1 | The number of matchable phrases in the query. |'
  prefs: []
  type: TYPE_TB
- en: '| c | 1 | The number of user defined columns in the FTS table (i.e. not including
    the docid or the [FTS hidden column](fts3.html#hiddencol)). |'
  prefs: []
  type: TYPE_TB
- en: '| x | 3 * *cols* * *phrases* | For each distinct combination of a phrase and
    table column, the following three values:'
  prefs: []
  type: TYPE_NORMAL
- en: In the current row, the number of times the phrase appears in the column.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The total number of times the phrase appears in the column in all rows in the
    FTS table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The total number of rows in the FTS table for which the column contains at least
    one instance of the phrase.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first set of three values corresponds to the left-most column of the table
    (column 0) and the left-most matchable phrase in the query (phrase 0). If the
    table has more than one column, the second set of three values in the output array
    correspond to phrase 0 and column 1\. Followed by phrase 0, column 2 and so on
    for all columns of the table. And so on for phrase 1, column 0, then phrase 1,
    column 1 etc. In other words, the data for occurrences of phrase *p* in column
    *c* may be found using the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| y | *cols* * *phrases* | For each distinct combination of a phrase and table
    column, the number of usable phrase matches that appear in the column. This is
    usually identical to the first value in each set of three returned by the [matchinfo
    ''x'' flag](fts3.html#matchinfo-x). However, the number of hits reported by the
    ''y'' flag is zero for any phrase that is part of a sub-expression that does not
    match the current row. This makes a difference for expressions that contain AND
    operators that are descendants of OR operators. For example, consider the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'and the document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The [matchinfo ''x'' flag](fts3.html#matchinfo-x) would report a single hit
    for the phrases "a" and "c". However, the ''y'' directive reports the number of
    hits for "c" as zero, as it is part of a sub-expression that does not match the
    document - (b AND c). For queries that do not contain AND operators descended
    from OR operators, the result values returned by ''y'' are always the same as
    those returned by ''x''.The first value in the array of integer values corresponds
    to the leftmost column of the table (column 0) and the first phrase in the query
    (phrase 0). The values corresponding to other column/phrase combinations may be
    located using the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: For queries that use OR expressions, or those that use LIMIT or return many
    rows, the 'y' matchinfo option may be faster than 'x'. |
  prefs: []
  type: TYPE_NORMAL
- en: '| b | *((cols+31)/32)* * *phrases* | The matchinfo ''b'' flag provides similar
    information to the [matchinfo ''y'' flag](fts3.html#matchinfo-y), but in a more
    compact form. Instead of the precise number of hits, ''b'' provides a single boolean
    flag for each phrase/column combination. If the phrase is present in the column
    at least once (i.e. if the corresponding integer output of ''y'' would be non-zero),
    the corresponding flag is set. Otherwise cleared.If the table has 32 or fewer
    columns, a single unsigned integer is output for each phrase in the query. The
    least significant bit of the integer is set if the phrase appears at least once
    in column 0\. The second least significant bit is set if the phrase appears once
    or more in column 1\. And so on.If the table has more than 32 columns, an extra
    integer is added to the output of each phrase for each extra 32 columns or part
    thereof. Integers corresponding to the same phrase are clumped together. For example,
    if a table with 45 columns is queried for two phrases, 4 integers are output.
    The first corresponds to phrase 0 and columns 0-31 of the table. The second integer
    contains data for phrase 0 and columns 32-44, and so on.For example, if nCol is
    the number of columns in the table, to determine if phrase p is present in column
    c:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| n | 1 | The number of rows in the FTS4 table. This value is only available
    when querying FTS4 tables, not FTS3. |'
  prefs: []
  type: TYPE_TB
- en: '| a | *cols* | For each column, the average number of tokens in the text values
    stored in the column (considering all rows in the FTS4 table). This value is only
    available when querying FTS4 tables, not FTS3. |'
  prefs: []
  type: TYPE_TB
- en: '| l | *cols* | For each column, the length of the value stored in the current
    row of the FTS4 table, in tokens. This value is only available when querying FTS4
    tables, not FTS3\. And only if the "matchinfo=fts3" directive was not specified
    as part of the "CREATE VIRTUAL TABLE" statement used to create the FTS4 table.
    |'
  prefs: []
  type: TYPE_TB
- en: '| s | *cols* | For each column, the length of the longest subsequence of phrase
    matches that the column value has in common with the query text. For example,
    if a table column contains the text ''a b c d e'' and the query is ''a c "d e"'',
    then the length of the longest common subsequence is 2 (phrase "c" followed by
    phrase "d e"). |'
  prefs: []
  type: TYPE_TB
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The matchinfo function is much faster than either the snippet or offsets functions.
    This is because the implementation of both snippet and offsets is required to
    retrieve the documents being analyzed from disk, whereas all data required by
    matchinfo is available as part of the same portions of the full-text index that
    are required to implement the full-text query itself. This means that of the following
    two queries, the first may be an order of magnitude faster than the second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The matchinfo function provides all the information required to calculate probabilistic
    "bag-of-words" relevancy scores such as [Okapi BM25/BM25F](http://en.wikipedia.org/wiki/Okapi_BM25)
    that may be used to order results in a full-text search application. Appendix
    A of this document, "[search application tips](fts3.html#appendix_a)", contains
    an example of using the matchinfo() function efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Fts4aux - Direct Access to the Full-Text Index
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As of [version 3.7.6](releaselog/3_7_6.html) (2011-04-12), SQLite includes a
    new virtual table module called "fts4aux", which can be used to inspect the full-text
    index of an existing FTS table directly. Despite its name, fts4aux works just
    as well with FTS3 tables as it does with FTS4 tables. Fts4aux tables are read-only.
    The only way to modify the contents of an fts4aux table is by modifying the contents
    of the associated FTS table. The fts4aux module is automatically included in all
    [builds that include FTS](fts3.html#compiling_and_enabling_fts3_and_fts4).
  prefs: []
  type: TYPE_NORMAL
- en: 'An fts4aux virtual table is constructed with one or two arguments. When used
    with a single argument, that argument is the unqualified name of the FTS table
    that it will be used to access. To access a table in a different database (for
    example, to create a TEMP fts4aux table that will access an FTS3 table in the
    MAIN database) use the two-argument form and give the name of the target database
    (ex: "main") in the first argument and the name of the FTS3/4 table as the second
    argument. (The two-argument form of fts4aux was added for SQLite [version 3.7.17](releaselog/3_7_17.html)
    (2013-05-20) and will throw an error in prior releases.) For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'For each term present in the FTS table, there are between 2 and N+1 rows in
    the fts4aux table, where N is the number of user-defined columns in the associated
    FTS table. An fts4aux table always has the same four columns, as follows, from
    left to right:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Column Name | Column Contents |'
  prefs: []
  type: TYPE_TB
- en: '| term | Contains the text of the term for this row. |'
  prefs: []
  type: TYPE_TB
- en: '| col | This column may contain either the text value ''*'' (i.e. a single
    character, U+002a) or an integer between 0 and N-1, where N is again the number
    of user-defined columns in the corresponding FTS table. |'
  prefs: []
  type: TYPE_TB
- en: '| documents | This column always contains an integer value greater than zero.'
  prefs: []
  type: TYPE_NORMAL
- en: If the "col" column contains the value '*', then this column contains the number
    of rows of the FTS table that contain at least one instance of the term (in any
    column). If col contains an integer value, then this column contains the number
    of rows of the FTS table that contain at least one instance of the term in the
    column identified by the col value. As usual, the columns of the FTS table are
    numbered from left to right, starting with zero. |
  prefs: []
  type: TYPE_NORMAL
- en: '| occurrences | This column also always contains an integer value greater than
    zero.'
  prefs: []
  type: TYPE_NORMAL
- en: If the "col" column contains the value '*', then this column contains the total
    number of instances of the term in all rows of the FTS table (in any column).
    Otherwise, if col contains an integer value, then this column contains the total
    number of instances of the term that appear in the FTS table column identified
    by the col value. |
  prefs: []
  type: TYPE_NORMAL
- en: '| languageid *(hidden)* | This column determines which [languageid](fts3.html#*fts4languageid)
    is used to extract vocabulary from the FTS3/4 table.'
  prefs: []
  type: TYPE_NORMAL
- en: The default value for languageid is 0\. If an alternative language is specified
    in WHERE clause constraints, then that alternative is used instead of 0\. There
    can only be a single languageid per query. In other words, the WHERE clause cannot
    contain a range constraint or IN operator on the languageid. |
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, using the tables created above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the example, the values in the "term" column are all lower case, even though
    they were inserted into table "ft" in mixed case. This is because an fts4aux table
    contains the terms as extracted from the document text by the [tokenizer](fts3.html#tokenizer).
    In this case, since table "ft" uses the [simple tokenizer](fts3.html#tokenizer),
    this means all terms have been folded to lower case. Also, there is (for example)
    no row with column "term" set to "apple" and column "col" set to 1\. Since there
    are no instances of the term "apple" in column 1, no row is present in the fts4aux
    table.
  prefs: []
  type: TYPE_NORMAL
- en: During a transaction, some of the data written to an FTS table may be cached
    in memory and written to the database only when the transaction is committed.
    However the implementation of the fts4aux module is only able to read data from
    the database. In practice this means that if an fts4aux table is queried from
    within a transaction in which the associated FTS table has been modified, the
    results of the query are likely to reflect only a (possibly empty) subset of the
    changes made.
  prefs: []
  type: TYPE_NORMAL
- en: 6\. FTS4 Options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the "CREATE VIRTUAL TABLE" statement specifies module FTS4 (not FTS3), then
    special directives - FTS4 options - similar to the "tokenize=*" option may also
    appear in place of column names. An FTS4 option consists of the option name, followed
    by an "=" character, followed by the option value. The option value may optionally
    be enclosed in single or double quotes, with embedded quote characters escaped
    in the same way as for SQL literals. There may not be whitespace on either side
    of the "=" character. For example, to create an FTS4 table with the value of option
    "matchinfo" set to "fts3":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'FTS4 currently supports the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Interpretation |'
  prefs: []
  type: TYPE_TB
- en: '| compress | The compress option is used to specify the compress function.
    It is an error to specify a compress function without also specifying an uncompress
    function. [See below](fts3.html#the_compress_and_uncompress_options) for details.
    |'
  prefs: []
  type: TYPE_TB
- en: '| content | The content allows the text being indexed to be stored in a separate
    table distinct from the FTS4 table, or even outside of SQLite. |'
  prefs: []
  type: TYPE_TB
- en: '| languageid | The languageid option causes the FTS4 table to have an additional
    hidden integer column that identifies the language of the text contained in each
    row. The use of the languageid option allows the same FTS4 table to hold text
    in multiple languages or scripts, each with different tokenizer rules, and to
    query each language independently of the others. |'
  prefs: []
  type: TYPE_TB
- en: '| matchinfo | When set to the value "fts3", the matchinfo option reduces the
    amount of information stored by FTS4 with the consequence that the "l" option
    of [matchinfo()](fts3.html#matchinfo) is no longer available. |'
  prefs: []
  type: TYPE_TB
- en: '| notindexed | This option is used to specify the name of a column for which
    data is not indexed. Values stored in columns that are not indexed are not matched
    by MATCH queries. Nor are they recognized by auxiliary functions. A single CREATE
    VIRTUAL TABLE statement may have any number of notindexed options. |'
  prefs: []
  type: TYPE_TB
- en: '| order | The "order" option may be set to either "DESC" or "ASC" (in upper
    or lower case). If it is set to "DESC", then FTS4 stores its data in such a way
    as to optimize returning results in descending order by docid. If it is set to
    "ASC" (the default), then the data structures are optimized for returning results
    in ascending order by docid. In other words, if many of the queries run against
    the FTS4 table use "ORDER BY docid DESC", then it may improve performance to add
    the "order=desc" option to the CREATE VIRTUAL TABLE statement. |'
  prefs: []
  type: TYPE_TB
- en: '| prefix | This option may be set to a comma-separated list of positive non-zero
    integers. For each integer N in the list, a separate index is created in the database
    file to optimize [prefix queries](fts3.html#termprefix) where the query term is
    N bytes in length, not including the ''*'' character, when encoded using UTF-8\.
    [See below](fts3.html#the_prefix_option) for details. |'
  prefs: []
  type: TYPE_TB
- en: '| uncompress | This option is used to specify the uncompress function. It is
    an error to specify an uncompress function without also specifying a compress
    function. [See below](fts3.html#the_compress_and_uncompress_options) for details.
    |'
  prefs: []
  type: TYPE_TB
- en: 'When using FTS4, specifying a column name that contains an "=" character and
    is not either a "tokenize=*" specification or a recognized FTS4 option is an error.
    With FTS3, the first token in the unrecognized directive is interpreted as a column
    name. Similarly, specifying multiple "tokenize=*" directives in a single table
    declaration is an error when using FTS4, whereas the second and subsequent "tokenize=*"
    directives are interpreted as column names by FTS3\. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 6.1\. The compress= and uncompress= options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The compress and uncompress options allow FTS4 content to be stored in the database
    in a compressed form. Both options should be set to the name of an SQL scalar
    function registered using [sqlite3_create_function()](c3ref/create_function.html)
    that accepts a single argument.
  prefs: []
  type: TYPE_NORMAL
- en: The compress function should return a compressed version of the value passed
    to it as an argument. Each time data is written to the FTS4 table, each column
    value is passed to the compress function and the result value stored in the database.
    The compress function may return any type of SQLite value (blob, text, real, integer
    or null).
  prefs: []
  type: TYPE_NORMAL
- en: The uncompress function should uncompress data previously compressed by the
    compress function. In other words, for all SQLite values X, it should be true
    that uncompress(compress(X)) equals X. When data that has been compressed by the
    compress function is read from the database by FTS4, it is passed to the uncompress
    function before it is used.
  prefs: []
  type: TYPE_NORMAL
- en: If the specified compress or uncompress functions do not exist, the table may
    still be created. An error is not returned until the FTS4 table is read (if the
    uncompress function does not exist) or written (if it is the compress function
    that does not exist).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: When implementing the compress and uncompress functions it is important to pay
    attention to data types. Specifically, when a user reads a value from a compressed
    FTS table, the value returned by FTS is exactly the same as the value returned
    by the uncompress function, including the data type. If that data type is not
    the same as the data type of the original value as passed to the compress function
    (for example if the uncompress function is returning BLOB when compress was originally
    passed TEXT), then the users query may not function as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2\. The content= option
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The content option allows FTS4 to forego storing the text being indexed. The
    content option can be used in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: The indexed documents are not stored within the SQLite database at all (a "contentless"
    FTS4 table), or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The indexed documents are stored in a database table created and managed by
    the user (an "external content" FTS4 table).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because the indexed documents themselves are usually much larger than the full-text
    index, the content option can be used to achieve significant space savings.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.1\. Contentless FTS4 Tables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to create an FTS4 table that does not store a copy of the indexed
    documents at all, the content option should be set to an empty string. For example,
    the following SQL creates such an FTS4 table with three columns - "a", "b", and
    "c":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Data can be inserted into such an FTS4 table using an INSERT statements. However,
    unlike ordinary FTS4 tables, the user must supply an explicit integer docid value.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: It is not possible to UPDATE or DELETE a row stored in a contentless FTS4 table.
    Attempting to do so is an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Contentless FTS4 tables also support SELECT statements. However, it is an error
    to attempt to retrieve the value of any table column other than the docid column.
    The auxiliary function matchinfo() may be used, but snippet() and offsets() may
    not. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Errors related to attempting to retrieve column values other than docid are
    runtime errors that occur within sqlite3_step(). In some cases, for example if
    the MATCH expression in a SELECT query matches zero rows, there may be no error
    at all even if a statement does refer to column values other than docid.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.2\. External Content FTS4 Tables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An "external content" FTS4 table is similar to a contentless table, except that
    if evaluation of a query requires the value of a column other than docid, FTS4
    attempts to retrieve that value from a table (or view, or virtual table) nominated
    by the user (hereafter referred to as the "content table"). The FTS4 module never
    writes to the content table, and writing to the content table does not affect
    the full-text index. It is the responsibility of the user to ensure that the content
    table and the full-text index are consistent.
  prefs: []
  type: TYPE_NORMAL
- en: 'An external content FTS4 table is created by setting the content option to
    the name of a table (or view, or virtual table) that may be queried by FTS4 to
    retrieve column values when required. If the nominated table does not exist, then
    an external content table behaves in the same way as a contentless table. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Assuming the nominated table does exist, then its columns must be the same as
    or a superset of those defined for the FTS table. The external table must also
    be in the same database file as the FTS table. In other words, The external table
    cannot be in a different database file connected using [ATTACH](lang_attach.html)
    nor may one of the FTS table and the external content be in the TEMP database
    when the other is in a persistent database file such as MAIN.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a users query on the FTS table requires a column value other than docid,
    FTS attempts to read the requested value from the corresponding column of the
    row in the content table with a rowid value equal to the current FTS docid. Only
    the subset of content-table columns duplicated in the FTS/34 table declaration
    can be queried for - to retrieve values from any other columns the content table
    must be queried directly. Or, if such a row cannot be found in the content table,
    a NULL value is used instead. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: When a row is deleted from an external content FTS4 table, FTS4 needs to retrieve
    the column values of the row being deleted from the content table. This is so
    that FTS4 can update the full-text index entries for each token that occurs within
    the deleted row to indicate that row has been deleted. If the content table row
    cannot be found, or if it contains values inconsistent with the contents of the
    FTS index, the results can be difficult to predict. The FTS index may be left
    containing entries corresponding to the deleted row, which can lead to seemingly
    nonsensical results being returned by subsequent SELECT queries. The same applies
    when a row is updated, as internally an UPDATE is the same as a DELETE followed
    by an INSERT.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that in order to keep an FTS in sync with an external content table,
    any UPDATE or DELETE operations must be applied first to the FTS table, and then
    to the external content table. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of writing separately to the full-text index and the content table,
    some users may wish to use database triggers to keep the full-text index up to
    date with respect to the set of documents stored in the content table. For example,
    using the tables from earlier examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The DELETE trigger must be fired before the actual delete takes place on the
    content table. This is so that FTS4 can still retrieve the original values in
    order to update the full-text index. And the INSERT trigger must be fired after
    the new row is inserted, so as to handle the case where the rowid is assigned
    automatically within the system. The UPDATE trigger must be split into two parts,
    one fired before and one after the update of the content table, for the same reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [FTS4 "rebuild" command](fts3.html#*fts4rebuidcmd) deletes the entire full-text
    index and rebuilds it based on the current set of documents in the content table.
    Assuming again that "t3" is the name of the external content FTS4 table, the rebuild
    command looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This command may also be used with ordinary FTS4 tables, for example if the
    implementation of the tokenizer changes. It is an error to attempt to rebuild
    the full-text index maintained by a contentless FTS4 table, since no content will
    be available to do the rebuilding.
  prefs: []
  type: TYPE_NORMAL
- en: 6.3\. The languageid= option
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the languageid option is present, it specifies the name of another [hidden
    column](vtab.html#hiddencol) that is added to the FTS4 table and which is used
    to specify the language stored in each row of the FTS4 table. The name of the
    languageid hidden column must be distinct from all other column names in the FTS4
    table. Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The default value of a languageid column is 0\. Any value inserted into a languageid
    column is converted to a 32-bit (not 64) signed integer.
  prefs: []
  type: TYPE_NORMAL
- en: By default, FTS queries (those that use the MATCH operator) consider only those
    rows with the languageid column set to 0\. To query for rows with other languageid
    values, a constraint of the form "
  prefs: []
  type: TYPE_NORMAL
- en: '<language-id>= <integer>" must be added to the queries WHERE clause. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: It is not possible for a single FTS query to return rows with different languageid
    values. The results of adding WHERE clauses that use other operators (e.g. lid!=5,
    or lid<=5) are undefined.
  prefs: []
  type: TYPE_NORMAL
- en: If the content option is used along with the languageid option, then the named
    languageid column must exist in the content= table (subject to the usual rules
    - if a query never needs to read the content table then this restriction does
    not apply).
  prefs: []
  type: TYPE_NORMAL
- en: When the languageid option is used, SQLite invokes the xLanguageid() on the
    sqlite3_tokenizer_module object immediately after the object is created in order
    to pass in the language id that the tokenizer should use. The xLanguageid() method
    will never be called more than once for any single tokenizer object. The fact
    that different languages might be tokenized differently is one reason why no single
    FTS query can return rows with different languageid values.
  prefs: []
  type: TYPE_NORMAL
- en: 6.4\. The matchinfo= option
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The matchinfo option may only be set to the value "fts3". Attempting to set
    matchinfo to anything other than "fts3" is an error. If this option is specified,
    then some of the extra information stored by FTS4 is omitted. This reduces the
    amount of disk space consumed by an FTS4 table until it is almost the same as
    the amount that would be used by the equivalent FTS3 table, but also means that
    the data accessed by passing the 'l' flag to the [matchinfo()](fts3.html#matchinfo)
    function is not available.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5\. The notindexed= option
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Normally, the FTS module maintains an inverted index of all terms in all columns
    of the table. This option is used to specify the name of a column for which entries
    should not be added to the index. Multiple "notindexed" options may be used to
    specify that multiple columns should be omitted from the index. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Values stored in unindexed columns are not eligible to match MATCH operators.
    They do not influence the results of the offsets() or matchinfo() auxiliary functions.
    Nor will the snippet() function ever return a snippet based on a value stored
    in an unindexed column.
  prefs: []
  type: TYPE_NORMAL
- en: 6.6\. The prefix= option
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The FTS4 prefix option causes FTS to index term prefixes of specified lengths
    in the same way that it always indexes complete terms. The prefix option must
    be set to a comma separated list of positive non-zero integers. For each value
    N in the list, prefixes of length N bytes (when encoded using UTF-8) are indexed.
    FTS4 uses term prefix indexes to speed up [prefix queries](fts3.html#termprefix).
    The cost, of course, is that indexing term prefixes as well as complete terms
    increases the database size and slows down write operations on the FTS4 table.
  prefs: []
  type: TYPE_NORMAL
- en: Prefix indexes may be used to optimize [prefix queries](fts3.html#termprefix)
    in two cases. If the query is for a prefix of N bytes, then a prefix index created
    with "prefix=N" provides the best optimization. Or, if no "prefix=N" index is
    available, a "prefix=N+1" index may be used instead. Using a "prefix=N+1" index
    is less efficient than a "prefix=N" index, but is better than no prefix index
    at all.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 7\. Special Commands For FTS3 and FTS4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Special INSERT operates can be used to issue commands to FTS3 and FTS4 tables.
    Every FTS3 and FTS4 has a hidden, read-only column which is the same name as the
    table itself. INSERTs into this hidden column are interpreted as commands to the
    FTS3/4 table. For a table with the name "xyz" the following commands are supported:'
  prefs: []
  type: TYPE_NORMAL
- en: INSERT INTO xyz(xyz) VALUES('optimize');
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: INSERT INTO xyz(xyz) VALUES('rebuild');
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: INSERT INTO xyz(xyz) VALUES('integrity-check');
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: INSERT INTO xyz(xyz) VALUES('merge=X,Y');
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: INSERT INTO xyz(xyz) VALUES('automerge=N');
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.1\. The "optimize" command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The "optimize" command causes FTS3/4 to merge together all of its inverted index
    b-trees into one large and complete b-tree. Doing an optimize will make subsequent
    queries run faster since there are fewer b-trees to search, and it may reduce
    disk usage by coalescing redundant entries. However, for a large FTS table, running
    optimize can be as expensive as running [VACUUM](lang_vacuum.html). The optimize
    command essentially has to read and write the entire FTS table, resulting in a
    large transaction.
  prefs: []
  type: TYPE_NORMAL
- en: In batch-mode operation, where an FTS table is initially built up using a large
    number of INSERT operations, then queried repeatedly without further changes,
    it is often a good idea to run "optimize" after the last INSERT and before the
    first query.
  prefs: []
  type: TYPE_NORMAL
- en: 7.2\. The "rebuild" command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The "rebuild" command causes SQLite to discard the entire FTS3/4 table and then
    rebuild it again from original text. The concept is similar to [REINDEX](lang_reindex.html),
    only that it applies to an FTS3/4 table instead of an ordinary index.
  prefs: []
  type: TYPE_NORMAL
- en: The "rebuild" command should be run whenever the implementation of a custom
    tokenizer changes, so that all content can be retokenized. The "rebuild" command
    is also useful when using the [FTS4 content option](fts3.html#*fts4content) after
    changes have been made to the original content table.
  prefs: []
  type: TYPE_NORMAL
- en: 7.3\. The "integrity-check" command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The "integrity-check" command causes SQLite to read and verify the accuracy
    of all inverted indices in an FTS3/4 table by comparing those inverted indices
    against the original content. The "integrity-check" command silently succeeds
    if the inverted indices are all ok, but will fail with an SQLITE_CORRUPT error
    if any problems are found.
  prefs: []
  type: TYPE_NORMAL
- en: 'The "integrity-check" command is similar in concept to [PRAGMA integrity_check](pragma.html#pragma_integrity_check).
    In a working system, the "integrity-command" should always be successful. Possible
    causes of integrity-check failures include:'
  prefs: []
  type: TYPE_NORMAL
- en: The application has made changes to the [FTS shadow tables](fts3.html#*shadowtab)
    directly, without using the FTS3/4 virtual table, causing the shadow tables to
    become out of sync with each other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the [FTS4 content option](fts3.html#*fts4content) and failing to manually
    keep the content in sync with the FTS4 inverted indices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bugs in the FTS3/4 virtual table. (The "integrity-check" command was original
    conceived as part of the test suite for FTS3/4.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Corruption to the underlying SQLite database file. (See documentation on [how
    to corrupt](howtocorrupt.html) and SQLite database for additional information.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.4\. The "merge=X,Y" command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The "merge=X,Y" command (where X and Y are integers) causes SQLite to do a limited
    amount of work toward merging the various inverted index b-trees of an FTS3/4
    table together into one large b-tree. The X value is the target number of "blocks"
    to be merged, and Y is the minimum number of b-tree segments on a level required
    before merging will be applied to that level. The value of Y should be between
    2 and 16 with a recommended value of 8\. The value of X can be any positive integer
    but values on the order of 100 to 300 are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: When an FTS table accumulates 16 b-tree segments at the same level, the next
    INSERT into that table will cause all 16 segments to be merged into a single b-tree
    segment at the next higher level. The effect of these level merges is that most
    INSERTs into an FTS table are very fast and take minimal memory, but an occasional
    INSERT is slow and generates a large transaction because of the need to do merging.
    This results in "spiky" performance of INSERTs.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid spiky INSERT performance, an application can run the "merge=X,Y" command
    periodically, possibly in an idle thread or idle process, to ensure that the FTS
    table never accumulates too many b-tree segments at the same level. INSERT performance
    spikes can generally be avoided, and performance of FTS3/4 can be maximized, by
    running "merge=X,Y" after every few thousand document inserts. Each "merge=X,Y"
    command will run in a separate transaction (unless they are grouped together using
    [BEGIN](lang_transaction.html)...[COMMIT](lang_transaction.html), of course).
    The transactions can be kept small by choosing a value for X in the range of 100
    to 300\. The idle thread that is running the merge commands can know when it is
    done by checking the difference in [sqlite3_total_changes()](c3ref/total_changes.html)
    before and after each "merge=X,Y" command and stopping the loop when the difference
    drops below two.
  prefs: []
  type: TYPE_NORMAL
- en: 7.5\. The "automerge=N" command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The "automerge=N" command (where N is an integer between 0 and 15, inclusive)
    is used to configure an FTS3/4 tables "automerge" parameter, which controls automatic
    incremental inverted index merging. The default automerge value for new tables
    is 0, meaning that automatic incremental merging is completely disabled. If the
    value of the automerge parameter is modified using the "automerge=N" command,
    the new parameter value is stored persistently in the database and is used by
    all subsequently established database connections.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the automerge parameter to a non-zero value enables automatic incremental
    merging. This causes SQLite to do a small amount of inverted index merging after
    every INSERT operation. The amount of merging performed is designed so that the
    FTS3/4 table never reaches a point where it has 16 segments at the same level
    and hence has to do a large merge in order to complete an insert. In other words,
    automatic incremental merging is designed to prevent spiky INSERT performance.
  prefs: []
  type: TYPE_NORMAL
- en: The downside of automatic incremental merging is that it makes every INSERT,
    UPDATE, and DELETE operation on an FTS3/4 table run a little slower, since extra
    time must be used to do the incremental merge. For maximum performance, it is
    recommended that applications disable automatic incremental merge and instead
    use the ["merge" command](fts3.html#*fts4mergecmd) in an idle process to keep
    the inverted indices well merged. But if the structure of an application does
    not easily allow for idle processes, the use of automatic incremental merge is
    a very reasonable fallback solution.
  prefs: []
  type: TYPE_NORMAL
- en: The actual value of the automerge parameter determines the number of index segments
    merged simultaneously by an automatic inverted index merge. If the value is set
    to N, the system waits until there are at least N segments on a single level before
    beginning to incrementally merge them. Setting a lower value of N causes segments
    to be merged more quickly, which may speed up full-text queries and, if the workload
    contains UPDATE or DELETE operations as well as INSERTs, reduce the space on disk
    consumed by the full-text index. However, it also increases the amount of data
    written to disk.
  prefs: []
  type: TYPE_NORMAL
- en: For general use in cases where the workload contains few UPDATE or DELETE operations,
    a good choice for automerge is 8\. If the workload contains many UPDATE or DELETE
    commands, or if query speed is a concern, it may be advantageous to reduce automerge
    to 2.
  prefs: []
  type: TYPE_NORMAL
- en: For reasons of backwards compatibility, the "automerge=1" command sets the automerge
    parameter to 8, not 1 (a value of 1 would make no sense anyway, as merging data
    from a single segment is a no-op).
  prefs: []
  type: TYPE_NORMAL
- en: 8\. Tokenizers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An FTS tokenizer is a set of rules for extracting terms from a document or basic
    FTS full-text query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unless a specific tokenizer is specified as part of the CREATE VIRTUAL TABLE
    statement used to create the FTS table, the default tokenizer, "simple", is used.
    The simple tokenizer extracts tokens from a document or basic FTS full-text query
    according to the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: A term is a contiguous sequence of eligible characters, where eligible characters
    are all alphanumeric characters and all characters with Unicode codepoint values
    greater than or equal to 128. All other characters are discarded when splitting
    a document into terms. Their only contribution is to separate adjacent terms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All uppercase characters within the ASCII range (Unicode codepoints less than
    128), are transformed to their lowercase equivalents as part of the tokenization
    process. Thus, full-text queries are case-insensitive when using the simple tokenizer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, when a document containing the text "Right now, they're very frustrated.",
    the terms extracted from the document and added to the full-text index are, in
    order, "right now they re very frustrated". Such a document would match a full-text
    query such as "MATCH 'Frustrated'", as the simple tokenizer transforms the term
    in the query to lowercase before searching the full-text index.
  prefs: []
  type: TYPE_NORMAL
- en: 'As well as the "simple" tokenizer, the FTS source code features a tokenizer
    that uses the [Porter Stemming algorithm](http://tartarus.org/~martin/PorterStemmer/).
    This tokenizer uses the same rules to separate the input document into terms including
    folding all terms into lower case, but also uses the Porter Stemming algorithm
    to reduce related English language words to a common root. For example, using
    the same input document as in the paragraph above, the porter tokenizer extracts
    the following tokens: "right now thei veri frustrat". Even though some of these
    terms are not even English words, in some cases using them to build the full-text
    index is more useful than the more intelligible output produced by the simple
    tokenizer. Using the porter tokenizer, the document not only matches full-text
    queries such as "MATCH ''Frustrated''", but also queries such as "MATCH ''Frustration''",
    as the term "Frustration" is reduced by the Porter stemmer algorithm to "frustrat"
    - just as "Frustrated" is. So, when using the porter tokenizer, FTS is able to
    find not just exact matches for queried terms, but matches against similar English
    language terms. For more information on the Porter Stemmer algorithm, please refer
    to the page linked above.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example illustrating the difference between the "simple" and "porter" tokenizers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'If this extension is compiled with the SQLITE_ENABLE_ICU pre-processor symbol
    defined, then there exists a built-in tokenizer named "icu" implemented using
    the ICU library. The first argument passed to the xCreate() method (see fts3_tokenizer.h)
    of this tokenizer may be an ICU locale identifier. For example "tr_TR" for Turkish
    as used in Turkey, or "en_AU" for English as used in Australia. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The ICU tokenizer implementation is very simple. It splits the input text according
    to the ICU rules for finding word boundaries and discards any tokens that consist
    entirely of white-space. This may be suitable for some applications in some locales,
    but not all. If more complex processing is required, for example to implement
    stemming or discard punctuation, this can be done by creating a tokenizer implementation
    that uses the ICU tokenizer as part of its implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The "unicode61" tokenizer is available beginning with SQLite [version 3.7.13](releaselog/3_7_13.html)
    (2012-06-11). Unicode61 works very much like "simple" except that it does simple
    unicode case folding according to rules in Unicode Version 6.1 and it recognizes
    unicode space and punctuation characters and uses those to separate tokens. The
    simple tokenizer only does case folding of ASCII characters and only recognizes
    ASCII space and punctuation characters as token separators.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, "unicode61" attempts to remove diacritics from Latin script characters.
    This behaviour can be overridden by adding the tokenizer argument "remove_diacritics=0".
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The remove_diacritics option may be set to "0", "1" or "2". The default value
    is "1". If it is set to "1" or "2", then diacritics are removed from Latin script
    characters as described above. However, if it is set to "1", then diacritics are
    not removed in the fairly uncommon case where a single unicode codepoint is used
    to represent a character with more that one diacritic. For example, diacritics
    are not removed from codepoint 0x1ED9 ("LATIN SMALL LETTER O WITH CIRCUMFLEX AND
    DOT BELOW"). This is technically a bug, but cannot be fixed without creating backwards
    compatibility problems. If this option is set to "2", then diacritics are correctly
    removed from all Latin characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to customize the set of codepoints that unicode61 treats
    as separator characters. The "separators=" option may be used to specify one or
    more extra characters that should be treated as separator characters, and the
    "tokenchars=" option may be used to specify one or more extra characters that
    should be treated as part of tokens instead of as separator characters. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If a character specified as part of the argument to "tokenchars=" is considered
    to be a token character by default, it is ignored. This is true even if it has
    been marked as a separator by an earlier "separators=" option. Similarly, if a
    character specified as part of a "separators=" option is treated as a separator
    character by default, it is ignored. If multiple "tokenchars=" or "separators="
    options are specified, all are processed. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The arguments passed to the "tokenchars=" or "separators=" options are case-sensitive.
    In the example above, specifying that "X" is a separator character does not affect
    the way "x" is handled.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1\. Custom (Application Defined) Tokenizers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to providing built-in "simple", "porter" and (possibly) "icu" and
    "unicode61" tokenizers, FTS provides an interface for applications to implement
    and register custom tokenizers written in C. The interface used to create a new
    tokenizer is defined and described in the fts3_tokenizer.h source file.
  prefs: []
  type: TYPE_NORMAL
- en: Registering a new FTS tokenizer is similar to registering a new virtual table
    module with SQLite. The user passes a pointer to a structure containing pointers
    to various callback functions that make up the implementation of the new tokenizer
    type. For tokenizers, the structure (defined in fts3_tokenizer.h) is called "sqlite3_tokenizer_module".
  prefs: []
  type: TYPE_NORMAL
- en: 'FTS does not expose a C-function that users call to register new tokenizer
    types with a database handle. Instead, the pointer must be encoded as an SQL blob
    value and passed to FTS through the SQL engine by evaluating a special scalar
    function, "fts3_tokenizer()". The fts3_tokenizer() function may be called with
    one or two arguments, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Where <tokenizer-name> is [parameter](lang_expr.html#varparam) to which a string
    is bound using [sqlite3_bind_text()](c3ref/bind_blob.html) where the string identifies
    the tokenizer and <sqlite3_tokenizer_module ptr> is a [parameter](lang_expr.html#varparam)
    to which a BLOB is bound using [sqlite3_bind_blob()](c3ref/bind_blob.html) where
    the value of the BLOB is a pointer to an sqlite3_tokenizer_module structure. If
    the second argument is present, it is registered as tokenizer <tokenizer-name>
    and a copy of it returned. If only one argument is passed, a pointer to the tokenizer
    implementation currently registered as <tokenizer-name> is returned, encoded as
    a blob. Or, if no such tokenizer exists, an SQL exception (error) is raised.
  prefs: []
  type: TYPE_NORMAL
- en: Prior to SQLite [version 3.11.0](releaselog/3_11_0.html) (2016-02-15), the arguments
    to fts3_tokenizer() could be literal strings or BLOBs. They did not have to be
    [bound parameters](lang_expr.html#varparam). But that could lead to security problems
    in the event of an SQL injection. Hence, the legacy behavior is now disabled by
    default. But the old legacy behavior can be enabled, for backwards compatibility
    in applications that really need it, by calling [sqlite3_db_config](c3ref/db_config.html)(db,[SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER](c3ref/c_dbconfig_defensive.html#sqlitedbconfigenablefts3tokenizer),1,0).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following block contains an example of calling the fts3_tokenizer() function
    from C code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 8.2\. Querying Tokenizers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The "fts3tokenize" virtual table can be used to directly access any tokenizer.
    The following SQL demonstrates how to create an instance of the fts3tokenize virtual
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The name of the desired tokenizer should be substituted in place of ''porter''
    in the example, of course. If the tokenizer requires one or more arguments, they
    should be separated by commas in the fts3tokenize declaration (even though they
    are separated by spaces in declarations of regular fts4 tables). The following
    creates fts4 and fts3tokenize tables that use the same tokenizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the virtual table is created, it can be queried as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The virtual table will return one row of output for each token in the input
    string. The "token" column is the text of the token. The "start" and "end" columns
    are the byte offset to the beginning and end of the token in the original input
    string. The "position" column is the sequence number of the token in the original
    input string. There is also an "input" column which is simply a copy of the input
    string that is specified in the WHERE clause. Note that a constraint of the form
    "input=?" must appear in the WHERE clause or else the virtual table will have
    no input to tokenize and will return no rows. The example above generates the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the tokens in the result set from the fts3tokenize virtual table
    have been transformed according to the rules of the tokenizer. Since this example
    used the "porter" tokenizer, the "This" token was converted into "thi". If the
    original text of the token is desired, it can be retrieved using the "start" and
    "end" columns with the [substr()](lang_corefunc.html#substr) function. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The fts3tokenize virtual table can be used on any tokenizer, regardless of whether
    or not there exists an FTS3 or FTS4 table that actually uses that tokenizer.
  prefs: []
  type: TYPE_NORMAL
- en: 9\. Data Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section describes at a high-level the way the FTS module stores its index
    and content in the database. It is **not necessary to read or understand the material
    in this section in order to use FTS** in an application. However, it may be useful
    to application developers attempting to analyze and understand FTS performance
    characteristics, or to developers contemplating enhancements to the existing FTS
    feature set.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1\. Shadow Tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For each FTS virtual table in a database, three to five real (non-virtual) tables
    are created to store the underlying data. These real tables are called "shadow
    tables". The real tables are named "%_content", "%_segdir", "%_segments", "%_stat",
    and "%_docsize", where "%" is replaced by the name of the FTS virtual table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The leftmost column of the "%_content" table is an INTEGER PRIMARY KEY field
    named "docid". Following this is one column for each column of the FTS virtual
    table as declared by the user, named by prepending the column name supplied by
    the user with "c*N*", where *N* is the index of the column within the table, numbered
    from left to right starting with 0\. Data types supplied as part of the virtual
    table declaration are not used as part of the %_content table declaration. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The %_content table contains the unadulterated data inserted by the user into
    the FTS virtual table by the user. If the user does not explicitly supply a "docid"
    value when inserting records, one is selected automatically by the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The %_stat and %_docsize tables are only created if the FTS table uses the
    FTS4 module, not FTS3\. Furthermore, the %_docsize table is omitted if the FTS4
    table is created with the ["matchinfo=fts3"](fts3.html#fts4matchinfo) directive
    specified as part of the CREATE VIRTUAL TABLE statement. If they are created,
    the schema of the two tables is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: For each row in the FTS table, the %_docsize table contains a corresponding
    row with the same "docid" value. The "size" field contains a blob consisting of
    *N* FTS varints, where *N* is the number of user-defined columns in the table.
    Each varint in the "size" blob is the number of tokens in the corresponding column
    of the associated row in the FTS table. The %_stat table always contains a single
    row with the "id" column set to 0\. The "value" column contains a blob consisting
    of *N+1* FTS varints, where *N* is again the number of user-defined columns in
    the FTS table. The first varint in the blob is set to the total number of rows
    in the FTS table. The second and subsequent varints contain the total number of
    tokens stored in the corresponding column for all rows of the FTS table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two remaining tables, %_segments and %_segdir, are used to store the full-text
    index. Conceptually, this index is a lookup table that maps each term (word) to
    the set of docid values corresponding to records in the %_content table that contain
    one or more occurrences of the term. To retrieve all documents that contain a
    specified term, the FTS module queries this index to determine the set of docid
    values for records that contain the term, then retrieves the required documents
    from the %_content table. Regardless of the schema of the FTS virtual table, the
    %_segments and %_segdir tables are always created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The schema depicted above is not designed to store the full-text index directly.
    Instead, it is used to store one or more b-tree structures. There is one b-tree
    for each row in the %_segdir table. The %_segdir table row contains the root node
    and various meta-data associated with the b-tree structure, and the %_segments
    table contains all other (non-root) b-tree nodes. Each b-tree is referred to as
    a "segment". Once it has been created, a segment b-tree is never updated (although
    it may be deleted altogether).
  prefs: []
  type: TYPE_NORMAL
- en: 'The keys used by each segment b-tree are terms (words). As well as the key,
    each segment b-tree entry has an associated "doclist" (document list). A doclist
    consists of zero or more entries, where each entry consists of:'
  prefs: []
  type: TYPE_NORMAL
- en: A docid (document id), and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of term offsets, one for each occurrence of the term within the document.
    A term offset indicates the number of tokens (words) that occur before the term
    in question, not the number of characters or bytes. For example, the term offset
    of the term "war" in the phrase "Ancestral voices prophesying war!" is 3.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entries within a doclist are sorted by docid. Positions within a doclist entry
    are stored in ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: The contents of the logical full-text index is found by merging the contents
    of all segment b-trees. If a term is present in more than one segment b-tree,
    then it maps to the union of each individual doclist. If, for a single term, the
    same docid occurs in more than one doclist, then only the doclist that is part
    of the most recently created segment b-tree is considered valid.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple b-tree structures are used instead of a single b-tree to reduce the
    cost of inserting records into FTS tables. When a new record is inserted into
    an FTS table that already contains a lot of data, it is likely that many of the
    terms in the new record are already present in a large number of existing records.
    If a single b-tree were used, then large doclist structures would have to be loaded
    from the database, amended to include the new docid and term-offset list, then
    written back to the database. Using multiple b-tree tables allows this to be avoided
    by creating a new b-tree which can be merged with the existing b-tree (or b-trees)
    later on. Merging of b-tree structures can be performed as a background task,
    or once a certain number of separate b-tree structures have been accumulated.
    Of course, this scheme makes queries more expensive (as the FTS code may have
    to look up individual terms in more than one b-tree and merge the results), but
    it has been found that in practice this overhead is often negligible.
  prefs: []
  type: TYPE_NORMAL
- en: 9.2\. Variable Length Integer (varint) Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Integer values stored as part of segment b-tree nodes are encoded using the
    FTS varint format. This encoding is similar, but **not identical**, to the [SQLite
    varint format](fileformat2.html#varint).
  prefs: []
  type: TYPE_NORMAL
- en: An encoded FTS varint consumes between one and ten bytes of space. The number
    of bytes required is determined by the sign and magnitude of the integer value
    encoded. More accurately, the number of bytes used to store the encoded integer
    depends on the position of the most significant set bit in the 64-bit twos-complement
    representation of the integer value. Negative values always have the most significant
    bit set (the sign bit), and so are always stored using the full ten bytes. Positive
    integer values may be stored using less space.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final byte of an encoded FTS varint has its most significant bit cleared.
    All preceding bytes have the most significant bit set. Data is stored in the remaining
    seven least significant bits of each byte. The first byte of the encoded representation
    contains the least significant seven bits of the encoded integer value. The second
    byte of the encoded representation, if it is present, contains the seven next
    least significant bits of the integer value, and so on. The following table contains
    examples of encoded integer values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Decimal | Hexadecimal | Encoded Representation |'
  prefs: []
  type: TYPE_TB
- en: '| 43 | 0x000000000000002B | 0x2B |'
  prefs: []
  type: TYPE_TB
- en: '| 200815 | 0x000000000003106F | 0xEF 0xA0 0x0C |'
  prefs: []
  type: TYPE_TB
- en: '| -1 | 0xFFFFFFFFFFFFFFFF | 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0x01
    |'
  prefs: []
  type: TYPE_TB
- en: 9.3\. Segment B-Tree Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Segment b-trees are prefix-compressed b+-trees. There is one segment b-tree
    for each row in the %_segdir table (see above). The root node of the segment b-tree
    is stored as a blob in the "root" field of the corresponding row of the %_segdir
    table. All other nodes (if any exist) are stored in the "blob" column of the %_segments
    table. Nodes within the %_segments table are identified by the integer value in
    the blockid field of the corresponding row. The following table describes the
    fields of the %_segdir table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Column | Interpretation |'
  prefs: []
  type: TYPE_TB
- en: '| level | Between them, the contents of the "level" and "idx" fields define
    the relative age of the segment b-tree. The smaller the value stored in the "level"
    field, the more recently the segment b-tree was created. If two segment b-trees
    are of the same "level", the segment with the larger value stored in the "idx"
    column is more recent. The PRIMARY KEY constraint on the %_segdir table prevents
    any two segments from having the same value for both the "level" and "idx" fields.
    |'
  prefs: []
  type: TYPE_TB
- en: '| idx | See above. |'
  prefs: []
  type: TYPE_TB
- en: '| start_block | The blockid that corresponds to the node with the smallest
    blockid that belongs to this segment b-tree. Or zero if the entire segment b-tree
    fits on the root node. If it exists, this node is always a leaf node. |'
  prefs: []
  type: TYPE_TB
- en: '| leaves_end_block | The blockid that corresponds to the leaf node with the
    largest blockid that belongs to this segment b-tree. Or zero if the entire segment
    b-tree fits on the root node. |'
  prefs: []
  type: TYPE_TB
- en: '| end_block | This field may contain either an integer or a text field consisting
    of two integers separated by a space character (unicode codepoint 0x20).The first,
    or only, integer is the blockid that corresponds to the interior node with the
    largest blockid that belongs to this segment b-tree. Or zero if the entire segment
    b-tree fits on the root node. If it exists, this node is always an interior node.The
    second integer, if it is present, is the aggregate size of all data stored on
    leaf pages in bytes. If the value is negative, then the segment is the output
    of an unfinished incremental-merge operation, and the absolute value is current
    size in bytes. |'
  prefs: []
  type: TYPE_TB
- en: '| root | Blob containing the root node of the segment b-tree. |'
  prefs: []
  type: TYPE_TB
- en: Apart from the root node, the nodes that make up a single segment b-tree are
    always stored using a contiguous sequence of blockids. Furthermore, the nodes
    that make up a single level of the b-tree are themselves stored as a contiguous
    block, in b-tree order. The contiguous sequence of blockids used to store the
    b-tree leaves are allocated starting with the blockid value stored in the "start_block"
    column of the corresponding %_segdir row, and finishing at the blockid value stored
    in the "leaves_end_block" field of the same row. It is therefore possible to iterate
    through all the leaves of a segment b-tree, in key order, by traversing the %_segments
    table in blockid order from "start_block" to "leaves_end_block".
  prefs: []
  type: TYPE_NORMAL
- en: 9.3.1\. Segment B-Tree Leaf Nodes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following diagram depicts the format of a segment b-tree leaf node.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3569763fbfe879eb171b338fc76bf4d6.png)'
  prefs: []
  type: TYPE_IMG
- en: Segment B-Tree Leaf Node Format
  prefs: []
  type: TYPE_NORMAL
- en: The first term stored on each node ("Term 1" in the figure above) is stored
    verbatim. Each subsequent term is prefix-compressed with respect to its predecessor.
    Terms are stored within a page in sorted (memcmp) order.
  prefs: []
  type: TYPE_NORMAL
- en: 9.3.2\. Segment B-Tree Interior Nodes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following diagram depicts the format of a segment b-tree interior (non-leaf)
    node.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b1ff44614c88bafdffa674afdb56fed0.png)'
  prefs: []
  type: TYPE_IMG
- en: Segment B-Tree Interior Node Format
  prefs: []
  type: TYPE_NORMAL
- en: 9.4\. Doclist Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A doclist consists of an array of 64-bit signed integers, serialized using
    the FTS varint format. Each doclist entry is made up of a series of two or more
    integers, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The docid value. The first entry in a doclist contains the literal docid value.
    The first field of each subsequent doclist entry contains the difference between
    the new docid and the previous one (always a positive number).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Zero or more term-offset lists. A term-offset list is present for each column
    of the FTS virtual table that contains the term. A term-offset list consists of
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Constant value 1\. This field is omitted for any term-offset list associated
    with column 0.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The column number (1 for the second leftmost column, etc.). This field is omitted
    for any term-offset list associated with column 0.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A list of term-offsets, sorted from smallest to largest. Instead of storing
    the term-offset value literally, each integer stored is the difference between
    the current term-offset and the previous one (or zero if the current term-offset
    is the first), plus 2.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Constant value 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../Images/8bb73ce4f82564c8acfe7a618932bae0.png)'
  prefs: []
  type: TYPE_IMG
- en: FTS3 Doclist Format
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8939947ade48c28fa4744a6e5363ee12.png)'
  prefs: []
  type: TYPE_IMG
- en: FTS Doclist Entry Format
  prefs: []
  type: TYPE_NORMAL
- en: For doclists for which the term appears in more than one column of the FTS virtual
    table, term-offset lists within the doclist are stored in column number order.
    This ensures that the term-offset list associated with column 0 (if any) is always
    first, allowing the first two fields of the term-offset list to be omitted in
    this case.
  prefs: []
  type: TYPE_NORMAL
- en: 10\. Limitations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 10.1\. UTF-16 byte-order-mark problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For UTF-16 databases, when using the "simple" tokenizer, it is possible to
    use malformed unicode strings to cause the [integrity-check special command](#integcheck)
    to falsely report corruption, or for [auxiliary functions](#snippet) to return
    incorrect results. More specifically, the bug can be triggered by any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A UTF-16 byte-order-mark (BOM) is embedded at the beginning of an SQL string
    literal value inserted into an FTS3 table. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Malformed UTF-8 that SQLite converts to a UTF-16 byte-order-mark is embedded
    at the beginning of an SQL string literal value inserted into an FTS3 table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A text value created by casting a blob that begins with the two bytes 0xFF
    and 0xFE, in either possible order, is inserted into an FTS3 table. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Everything works correctly if any of the following are true:'
  prefs: []
  type: TYPE_NORMAL
- en: The [database encoding](pragma.html#pragma_encoding) is UTF-8.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All text strings are insert using one of the [sqlite3_bind_text()](c3ref/bind_blob.html)
    family of functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Literal strings contain no byte-order-marks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A tokenizer is used that recognizes byte-order-marks as whitespace. (The default
    "simple" tokenizer for FTS3/4 does not think that BOMs are whitespace, but the
    unicode tokenizer does.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the above conditions must be false in order for problems to occur. And
    even if all of the conditiona above are false, most things will still operator
    correctly. Only the [integrity-check](#integcheck) command and the [auxiliary
    functions](#snippet) might given unexpected results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Appendix A: Search Application Tips'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: FTS is primarily designed to support Boolean full-text queries - queries to
    find the set of documents that match a specified criteria. However, many (most?)
    search applications require that results are somehow ranked in order of "relevance",
    where "relevance" is defined as the likelihood that the user who performed the
    search is interested in a specific element of the returned set of documents. When
    using a search engine to find documents on the world wide web, the user expects
    that the most useful, or "relevant", documents will be returned as the first page
    of results, and that each subsequent page contains progressively less relevant
    results. Exactly how a machine can determine document relevance based on a users
    query is a complicated problem and the subject of much ongoing research.
  prefs: []
  type: TYPE_NORMAL
- en: 'One very simple scheme might be to count the number of instances of the users
    search terms in each result document. Those documents that contain many instances
    of the terms are considered more relevant than those with a small number of instances
    of each term. In an FTS application, the number of term instances in each result
    could be determined by counting the number of integers in the return value of
    the [offsets](fts3.html#offsets) function. The following example shows a query
    that could be used to obtain the ten most relevant results for a query entered
    by the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The query above could be made to run faster by using the FTS [matchinfo](fts3.html#matchinfo)
    function to determine the number of query term instances that appear in each result.
    The matchinfo function is much more efficient than the offsets function. Furthermore,
    the matchinfo function provides extra information regarding the overall number
    of occurrences of each query term in the entire document set (not just the current
    row) and the number of documents in which each query term appears. This may be
    used (for example) to attach a higher weight to less common terms which may increase
    the overall computed relevancy of those results the user considers more interesting.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The SQL query in the example above uses less CPU than the first example in this
    section, but still has a non-obvious performance problem. SQLite satisfies this
    query by retrieving the value of the "title" column and matchinfo data from the
    FTS module for every row matched by the users query before it sorts and limits
    the results. Because of the way SQLite's virtual table interface works, retrieving
    the value of the "title" column requires loading the entire row from disk (including
    the "content" field, which may be quite large). This means that if the users query
    matches several thousand documents, many megabytes of "title" and "content" data
    may be loaded from disk into memory even though they will never be used for any
    purpose.
  prefs: []
  type: TYPE_NORMAL
- en: The SQL query in the following example block is one solution to this problem.
    In SQLite, when a [sub-query used in a join contains a LIMIT clause](optoverview.html#flattening),
    the results of the sub-query are calculated and stored in temporary table before
    the main query is executed. This means that SQLite will load only the docid and
    matchinfo data for each row matching the users query into memory, determine the
    docid values corresponding to the ten most relevant documents, then load only
    the title and content information for those 10 documents only. Because both the
    matchinfo and docid values are gleaned entirely from the full-text index, this
    results in dramatically less data being loaded from the database into memory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The next block of SQL enhances the query with solutions to two other problems
    that may arise in developing search applications using FTS:'
  prefs: []
  type: TYPE_NORMAL
- en: The [snippet](fts3.html#snippet) function cannot be used with the above query.
    Because the outer query does not include a "WHERE ... MATCH" clause, the snippet
    function may not be used with it. One solution is to duplicate the WHERE clause
    used by the sub-query in the outer query. The overhead associated with this is
    usually negligible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The relevancy of a document may depend on something other than just the data
    available in the return value of matchinfo. For example each document in the database
    may be assigned a static weight based on factors unrelated to its content (origin,
    author, age, number of references etc.). These values can be stored by the application
    in a separate table that can be joined against the documents table in the sub-query
    so that the rank function may access them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This version of the query is very similar to that used by the [sqlite.org documentation
    search](https://www.sqlite.org/search?q=fts3) application.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: All the example queries above return the ten most relevant query results. By
    modifying the values used with the OFFSET and LIMIT clauses, a query to return
    (say) the next ten most relevant results is easy to construct. This may be used
    to obtain the data required for a search applications second and subsequent pages
    of results.
  prefs: []
  type: TYPE_NORMAL
- en: The next block contains an example rank function that uses matchinfo data implemented
    in C. Instead of a single weight, it allows a weight to be externally assigned
    to each column of each document. It may be registered with SQLite like any other
    user function using [sqlite3_create_function](c3ref/create_function.html).
  prefs: []
  type: TYPE_NORMAL
- en: '**Security Warning:** Because it is just an ordinary SQL function, rank() may
    be invoked as part of any SQL query in any context. This means that the first
    argument passed may not be a valid matchinfo blob. Implementors should take care
    to handle this case without causing buffer overruns or other potential security
    problems.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]</integer></language-id>'
  prefs: []
  type: TYPE_NORMAL
