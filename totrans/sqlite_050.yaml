- en: 1\. How To Use Indexes On Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://sqlite.com/expridx.html](https://sqlite.com/expridx.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Normally, an SQL index references columns of a table. But an index can also
    be formed on expressions involving table columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, consider the following table that tracks dollar-amount changes
    on various "accounts":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Each entry in the account_change table records a deposit or a withdrawal into
    an account. Deposits have a positive "amt" and withdrawals have a negative "amt".
  prefs: []
  type: TYPE_NORMAL
- en: 'The acctchng_magnitude index is over the account number ("acct_no") and on
    the absolute value of the amount. This index allows one to do efficient queries
    over the magnitude of a change to the account. For example, to list all changes
    to account number $xyz that are more than $100.00, one can say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, to list all changes to one particular account ($xyz) in order of decreasing
    magnitude, one can write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Both of the above example queries would work fine without the acctchng_magnitude
    index. The acctchng_magnitude index merely helps the queries to run faster, especially
    on databases where there are many entries in the table for each account.
  prefs: []
  type: TYPE_NORMAL
- en: Use a [CREATE INDEX](lang_createindex.html) statement to create a new index
    on one or more expressions just like you would to create an index on columns.
    The only difference is that expressions are listed as the elements to be indexed
    rather than column names.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQLite query planner will consider using an index on an expression when
    the expression that is indexed appears in the WHERE clause or in the ORDER BY
    clause of a query, *exactly* as it is written in the CREATE INDEX statement. The
    query planner does not do algebra. In order to match WHERE clause constraints
    and ORDER BY terms to indexes, SQLite requires that the expressions be the same,
    except for minor syntactic differences such as white-space changes. So if you
    have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And then you run the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the index will not be used because the expression on the CREATE INDEX
    statement (x+y) is not the same as the expression as it appears in the query (y+x).
    The two expressions might be mathematically equivalent, but the SQLite query planner
    insists that they be the same, not merely equivalent. Consider rewriting the query
    thusly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This second query will likely use the index because now the expression in the
    WHERE clause (x+y) matches the expression in the index exactly.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Restrictions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are certain reasonable restrictions on expressions that appear in CREATE
    INDEX statements:'
  prefs: []
  type: TYPE_NORMAL
- en: Expressions in CREATE INDEX statements may only refer to columns of the table
    being indexed, not to columns in other tables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Expressions in CREATE INDEX statements may contain function calls, but only
    to functions whose output is always determined completely by its input parameters
    (a.k.a.: [deterministic functions](deterministic.html)). Obviously, functions
    like [random()](lang_corefunc.html#random) will not work well in an index. But
    also functions like [sqlite_version()](lang_corefunc.html#sqlite_version), though
    they are constant across any one database connection, are not constant across
    the life of the underlying database file, and hence may not be used in a CREATE
    INDEX statement.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that [application-defined SQL functions](appfunc.html) are by default considered
    non-deterministic and may not be used in a CREATE INDEX statement unless the [SQLITE_DETERMINISTIC](c3ref/c_deterministic.html#sqlitedeterministic)
    flag is used when the function is registered.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Expressions in CREATE INDEX statements may not use subqueries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expressions may only be used in CREATE INDEX statements, not within [UNIQUE](lang_createtable.html#uniqueconst)
    or [PRIMARY KEY](lang_createtable.html#primkeyconst) constraints within the [CREATE
    TABLE](lang_createtable.html) statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 3\. Compatibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to index expressions was added to SQLite with [version 3.9.0](releaselog/3_9_0.html)
    (2015-10-14). A database that uses an index on expressions will not be usable
    by earlier versions of SQLite.
  prefs: []
  type: TYPE_NORMAL
