- en: 1\. The RBU Extension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://sqlite.com/rbu.html](https://sqlite.com/rbu.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The RBU extension is an add-on for SQLite designed for use with large SQLite
    database files on low-power devices at the edge of a network. RBU may be used
    for two separate tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**RBU Update operations**. An [RBU Update](rbu.html#rbu_updates) is a bulk
    update of a database file that may include many insert, update and delete operations
    on one or more tables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RBU Vacuum operations**. An [RBU Vacuum](rbu.html#rbu_vacuum) optimizes and
    rebuilds an entire database file, with results similar to SQLite''s native VACUUM
    command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The acronym RBU stands for "Resumable Bulk Update".
  prefs: []
  type: TYPE_NORMAL
- en: 'Both of the RBU functions may be accomplished using SQLite''s built-in SQL
    commands - RBU update via a series of [INSERT](lang_insert.html), [DELETE](lang_delete.html)
    and [UPDATE](lang_update.html) commands within a single transaction, and RBU vacuum
    by a single [VACUUM](lang_vacuum.html) command. The RBU module provides the following
    advantages over these simpler approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '**RBU may be more efficient**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The most efficient way to apply changes to a B-Tree (the data structure that
    SQLite uses to store each table and index on disk) is to make the changes in key
    order. But if an SQL table has one or more indexes, the key order for each index
    may be different from the main table and the other auxiliary indexes. As a result,
    when executing a series of [INSERT](lang_insert.html), [UPDATE](lang_update.html)
    and [DELETE](lang_delete.html) statements it is not generally possible to order
    the operations so that all b-trees are updated in key order. The RBU update process
    works around this by applying all changes to the main table in one pass, then
    applying changes to each index in separate passes, ensuring each B-Tree is updated
    optimally. For a large database file (one that does not fit in the OS disk cache)
    this procedure can result in two orders of magnitude faster updates.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: An RBU Vacuum operation requires less temporary disk space and writes less data
    to disk than an SQLite VACUUM. An SQLite VACUUM requires roughly twice the size
    of the final database file in temporary disk space to run. The total amount of
    data written is around three times the size of the final database file. By contrast,
    an RBU Vacuum requires roughly the size of the final database file in temporary
    disk space and writes a total of twice that to disk.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On the other hand, an RBU Vacuum uses more CPU than a regular SQLite VACUUM
    - in one test as much as five times as much. For this reason, an RBU Vacuum is
    often significantly slower than an SQLite VACUUM under the same conditions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**RBU runs in the background**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An ongoing RBU operation (either an update or a vacuum) does not interfere with
    read access to the database file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**RBU runs incrementally**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RBU operations may be suspended and then later resumed, perhaps with intervening
    power outages and/or system resets. For an RBU update, the original database content
    remains visible to all database readers until the entire update has been applied
    - even if the update is suspended and then later resumed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The RBU extension is not enabled by default. To enable it, compile the [amalgamation](amalgamation.html)
    with the [SQLITE_ENABLE_RBU](compile.html#enable_rbu) compile-time option.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. RBU Updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 2.1\. RBU Update Limitations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following limitations apply to RBU updates:'
  prefs: []
  type: TYPE_NORMAL
- en: The changes must consist of [INSERT](lang_insert.html), [UPDATE](lang_update.html),
    and [DELETE](lang_delete.html) operations only. CREATE and DROP operations are
    not supported.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[INSERT](lang_insert.html) statements may not use default values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[UPDATE](lang_update.html) and [DELETE](lang_delete.html) statements must identify
    the target rows by rowid or by non-NULL PRIMARY KEY values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[UPDATE](lang_update.html) statements may not modify PRIMARY KEY or rowid values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RBU updates cannot be applied to any tables that contain a column named "rbu_control".
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The RBU update will not fire any triggers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The RBU update will not detect or prevent foreign key or CHECK constraint violations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All RBU updates use the "OR ROLLBACK" constraint handling mechanism.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The target database may not be in [WAL mode](wal.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ~~The target database may not contain [indexes on expressions](expridx.html).~~
    Indexes on expressions are supported beginning with SQLite 3.30.0 (2019-10-04).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No other writes may occur on the target database while the RBU update is being
    applied. A read-lock is held on the target database to prevent this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.2\. Preparing an RBU Update File
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All changes to be applied by RBU are stored in a separate SQLite database called
    the "RBU database". The database that is to be modified is called the "target
    database".
  prefs: []
  type: TYPE_NORMAL
- en: For each table in the target database that will be modified by the update, a
    corresponding table is created within the RBU database. The RBU database table
    schema is not the same as that of the target database, but is derived from it
    as [described below](rbu.html#database_tables).
  prefs: []
  type: TYPE_NORMAL
- en: The RBU database table contains a single row for each target database row inserted,
    updated or deleted by the update. Populating the RBU database tables is described
    in [the following section](rbu.html#database_contents).
  prefs: []
  type: TYPE_NORMAL
- en: 2.2.1\. The RBU Database Schema
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For each table in the target database, the RBU database should contain a table
    named "data<*integer*>_<*target-table-name*>" where <*target-table-name*> is the
    name of the table in the target database and <*integer*> is any sequence of zero
    or more numeric characters (0-9). Tables within the RBU database are processed
    in order by name (from smallest to largest according to the BINARY collation sequence),
    so the order in which target tables are updated is influenced by the selection
    of the <*integer*> portion of the data_% table name. While this can be useful
    when using RBU to update [certain types of virtual tables](rbu.html#fts4_tables),
    there is normally no reason to use anything other than an empty string in place
    of <*integer*>.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data_% table must have all the same columns as the target table, plus one
    additional column named "rbu_control". The data_% table should have no PRIMARY
    KEY or UNIQUE constraints, but each column should have the same type as the corresponding
    column in the target database. The rbu_control column should have no type at all.
    For example, if the target database contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the RBU database should contain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The order of the columns in the data_% table does not matter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the target database table is a virtual table or a table that has no PRIMARY
    KEY declaration, the data_% table must also contain a column named "rbu_rowid".
    The rbu_rowid column is mapped to the tables [ROWID](lang_createtable.html#rowid).
    For example, if the target database contains either of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'then the RBU database should contain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Virtual tables for which the "rowid" column does not function like a primary
    key value cannot be updated using RBU.
  prefs: []
  type: TYPE_NORMAL
- en: 'All non-hidden columns (i.e. all columns matched by "SELECT *") of the target
    table must be present in the input table. For virtual tables, hidden columns are
    optional - they are updated by RBU if present in the input table, or not otherwise.
    For example, to write to an fts4 table with a hidden languageid column such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Either of the following input table schemas may be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 2.2.2\. RBU Database Contents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For each row to INSERT into the target database as part of the RBU update, the
    corresponding data_% table should contain a single record with the "rbu_control"
    column set to contain integer value 0\. The other columns should be set to the
    values that make up the new record to insert.
  prefs: []
  type: TYPE_NORMAL
- en: The "rbu_control" column may also be set to integer value 2 for an INSERT. In
    this case, the new row silently replaces any existing row that has the same primary
    key values. This is equivalent to a DELETE followed by an INSERT with the same
    primary key values. It is not the same as an SQL REPLACE command, as in that case
    the new row may replace any conflicting rows (i.e. those that conflict due to
    UNIQUE constraints or indexes), not just those with conflicting primary keys.
  prefs: []
  type: TYPE_NORMAL
- en: If the target database table has an INTEGER PRIMARY KEY, it is not possible
    to insert a NULL value into the IPK column. Attempting to do so results in an
    SQLITE_MISMATCH error.
  prefs: []
  type: TYPE_NORMAL
- en: For each row to DELETE from the target database as part of the RBU update, the
    corresponding data_% table should contain a single record with the "rbu_control"
    column set to contain integer value 1\. The real primary key values of the row
    to delete should be stored in the corresponding columns of the data_% table. The
    values stored in the other columns are not used.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each row to UPDATE from the target database as part of the RBU update,
    the corresponding data_% table should contain a single record with the "rbu_control"
    column set to contain a value of type text. The real primary key values identifying
    the row to update should be stored in the corresponding columns of the data_%
    table row, as should the new values of all columns being update. The text value
    in the "rbu_control" column must contain the same number of characters as there
    are columns in the target database table, and must consist entirely of ''x'' and
    ''.'' characters (or in some special cases ''d'' - see below). For each column
    that is being updated, the corresponding character is set to ''x''. For those
    that remain as they are, the corresponding character of the rbu_control value
    should be set to ''.''. For example, given the tables above, the update statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'is represented by the data_t1 row created by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If RBU is used to update a large BLOB value within a target database, it may
    be more efficient to store a patch or delta that can be used to modify the existing
    BLOB instead of an entirely new value within the RBU database. RBU allows deltas
    to be specified in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: In the "fossil delta" format - the format used for blob deltas by the [Fossil
    source-code management system](http://fossil-scm.org), or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a custom format defined by the RBU application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fossil delta format may only be used to update BLOB values. Instead of storing
    the new BLOB within the data_% table, the fossil delta is stored instead. And
    instead of specifying an 'x' as part of the rbu_control string for the column
    to be updated, an 'f' character is stored. When processing an 'f' update, RBU
    loads the original BLOB data from disk, applies the fossil delta to it and stores
    the results back into the database file. The RBU databases generated by [sqldiff
    --rbu](rbu.html#sqldiff) make use of fossil deltas wherever doing so would save
    space in the RBU database.
  prefs: []
  type: TYPE_NORMAL
- en: To use a custom delta format, the RBU application must register a user-defined
    SQL function named "rbu_delta" before beginning to process the update. rbu_delta()
    will be invoked with two arguments - the original value stored in the target table
    column and the delta value provided as part of the RBU update. It should return
    the result of applying the delta to the original value. To use the custom delta
    function, the character of the rbu_control value corresponding to the target column
    to update must be set to 'd' instead of 'x'. Then, instead of updating the target
    table with the value stored in the corresponding data_% column, RBU invokes the
    user-defined SQL function "rbu_delta()" and the store in the target table column.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'causes RBU to update the target database table in a way similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If the target database table is a virtual table or a table with no PRIMARY
    KEY, the rbu_control value should not include a character corresponding to the
    rbu_rowid value. For example, this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'causes a result similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The data_% tables themselves should have no PRIMARY KEY declarations. However,
    RBU is more efficient if reading the rows in from each data_% table in "rowid"
    order is roughly the same as reading them sorted by the PRIMARY KEY of the corresponding
    target database table. In other words, rows should be sorted using the destination
    table PRIMARY KEY fields before they are inserted into the data_% tables.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2.3\. Using RBU with FTS3/4 Tables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Usually, an [FTS3 or FTS4](fts3.html) table is an example of a virtual table
    with a rowid that works like a PRIMARY KEY. So, for the following FTS4 tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The data_% tables may be created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: And populated as if the target table were an ordinary SQLite table with no explicit
    PRIMARY KEY columns.
  prefs: []
  type: TYPE_NORMAL
- en: '[Contentless FTS4 tables](fts3.html#_contentless_fts4_tables_) are handled
    similarly, except that any attempt to update or delete rows will cause an error
    when applying the update.'
  prefs: []
  type: TYPE_NORMAL
- en: '[External content FTS4 tables](fts3.html#_external_content_fts4_tables_) may
    also be updated using RBU. In this case the user is required to configure the
    RBU database so that the same set of UPDATE, DELETE and INSERT operations are
    applied to the FTS4 index as to the underlying content table. As for all updates
    of external content FTS4 tables, the user is also required to ensure that any
    UPDATE or DELETE operations are applied to the FTS4 index before they are applied
    to the underlying content table (refer to FTS4 documentation for a detailed explanation).
    In RBU, this is done by ensuring that the name of the data_% table used to write
    to the FTS4 table sorts before the name of the data_% table used to update the
    underlying content table using the [BINARY](datatype3.html#collation) collation
    sequence. In order to avoid duplicating data within the RBU database, an SQL view
    may be used in place of one of the data_% tables. For example, for the target
    database schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following RBU database schema may be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The data_ccc table may then be populated as normal with the updates intended
    for target database table ccc. The same updates will be read by RBU from the data0_ccc_fts
    view and applied to FTS table ccc_fts. Because "data0_ccc_fts" is smaller than
    "data_ccc", the FTS table will be updated first, as required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cases in which the underlying content table has an explicit INTEGER PRIMARY
    KEY column are slightly more difficult, as the text values stored in the rbu_control
    column are slightly different for the FTS index and its underlying content table.
    For the underlying content table, a character must be included in any rbu_control
    text values for the explicit IPK, but for the FTS table itself, which has an implicit
    rowid, it should not. This is inconvenient, but can be solved using a more complicated
    view, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The substr() function in the SQL view above returns the text of the rbu_control
    argument with the first character (the one corresponding to column "i", which
    is not required by the FTS table) removed.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2.4\. Automatically Generating RBU Updates with sqldiff
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As of SQLite [version 3.9.0](releaselog/3_9_0.html) (2015-10-14), the [sqldiff](sqldiff.html)
    utility is able to generate RBU databases representing the difference between
    two databases with identical schemas. For example, the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Outputs an SQL script to create an RBU database which, if used to update database
    t1.db, patches it so that its contents are identical to that of database t2.db.
  prefs: []
  type: TYPE_NORMAL
- en: By default, sqldiff attempts to process all non-virtual tables within the two
    databases provided to it. If any table appears in one database but not the other,
    or if any table has a slightly different schema in one database it is an error.
    The "--table" option may be useful if this causes a problem
  prefs: []
  type: TYPE_NORMAL
- en: 'Virtual tables are ignored by default by sqldiff. However, it is possible to
    explicitly create an RBU data_% table for a virtual table that features a rowid
    that functions like a primary key using a command such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, even though virtual tables are ignored by default, any [underlying
    database tables](fts3.html#*shadowtab) that they create in order to store data
    within the database are not, and [sqldiff](sqldiff.html) will include add these
    to any RBU database. For this reason, users attempting to use sqldiff to create
    RBU updates to apply to target databases with one or more virtual tables will
    likely have to run sqldiff using the --table option separately for each table
    to update in the target database.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3\. RBU Update C/C++ Programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The RBU extension interface allows an application to apply an RBU update stored
    in an RBU database to an existing target database. The procedure is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open an RBU handle using the sqlite3rbu_open(T,A,S) function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The T argument is the name of the target database file. The A argument is the
    name of the RBU database file. The S argument is the name of a "state database"
    used to store state information needed to resume the update after an interruption.
    The S argument can be NULL in which case the state information is stored in the
    RBU database in various tables whose names all begin with "rbu_".
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The sqlite3rbu_open(T,A,S) function returns a pointer to an "sqlite3rbu" object,
    which is then passed into the subsequent interfaces.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Register any required virtual table modules with the database handle returned
    by sqlite3rbu_db(X) (where argument X is the sqlite3rbu pointer returned from
    sqlite3rbu_open()). Also, if required, register the rbu_delta() SQL function using
    [sqlite3_create_function_v2()](c3ref/create_function.html).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke the sqlite3rbu_step(X) function one or more times on the sqlite3rbu object
    pointer X. Each call to sqlite3rbu_step() performs a single b-tree operation,
    so thousands of calls may be required to apply a complete update. The sqlite3rbu_step()
    interface will return SQLITE_DONE when the update has been completely applied.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call sqlite3rbu_close(X) to destroy the sqlite3rbu object pointer. If sqlite3rbu_step(X)
    has been called enough times to completely apply the update to the target database,
    then the RBU database is marked as fully applied. Otherwise, the state of the
    RBU update application is saved in the state database (or in the RBU database
    if the name of the state database file in sqlite3rbu_open() is NULL) for later
    resumption of the update.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If an update is only partially applied to the target database by the time sqlite3rbu_close()
    is called, state information is saved within the state database if it exists,
    or otherwise in the RBU database. This allows subsequent processes to automatically
    resume the RBU update from where it left off. If state information is stored in
    the RBU database, it can be removed by dropping all tables whose names begin with
    "rbu_".
  prefs: []
  type: TYPE_NORMAL
- en: For more details, refer to the comments in [header file sqlite3rbu.h](http://sqlite.org/src/doc/trunk/ext/rbu/sqlite3rbu.h).
  prefs: []
  type: TYPE_NORMAL
- en: 3\. RBU Vacuum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3.1\. RBU Vacuum Limitations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When compared with SQLite''s built-in VACUUM command, RBU Vacuum has the following
    limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: It may not be used on a database that contains [indexes on expressions](expridx.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The database being vacuumed may not be in [WAL mode](wal.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3.2\. RBU Vacuum C/C++ Programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section provides an overview of and example code demonstrating the integration
    of RBU Vacuum into an application program. For full details, refer to the comments
    in [header file sqlite3rbu.h](http://sqlite.org/src/doc/trunk/ext/rbu/sqlite3rbu.h).
  prefs: []
  type: TYPE_NORMAL
- en: 'RBU Vacuum applications all implement some variation of the following procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: An RBU handle is created by calling sqlite3rbu_vacuum(T, S).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Argument T is the name of the database file to vacuum. Argument S is the name
    of a database in which the RBU module will save its state if the vacuum operation
    is suspended.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If state database S does not exist when sqlite3rbu_vacuum() is invoked, it is
    automatically created and populated with the single table used to store the state
    of an RBU vacuum - "rbu_state". If an ongoing RBU vacuum is suspended, this table
    is populated with state data. The next time sqlite3rbu_vacuum() is called with
    the same S parameter, it detects this data and attempts to resume the suspended
    vacuum operation. When an RBU vacuum operation is completed or encounters an error,
    RBU automatically deletes the contents of the rbu_state table. In this case, the
    next call to sqlite3rbu_vacuum() starts an entirely new vacuum operation from
    scratch.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is a good idea to establish a convention for determining the RBU vacuum state
    database name based on the target database name. The example code below uses "<target>-vacuum",
    where <target> is the name of the database being vacuumed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Any custom collation sequences used by indexes within the database being vacuumed
    are registered with both of the database handles returned by the sqlite3rbu_db()
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Function sqlite3rbu_step() is called on the RBU handle until either the RBU
    vacuum is finished, an error occurs or the application wishes to suspend the RBU
    vacuum.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each call to sqlite3rbu_step() does a small amount of work towards completing
    the vacuum operation. Depending on the size of the database, a single vacuum may
    require thousands of calls to sqlite3rbu_step(). sqlite3rbu_step() returns SQLITE_DONE
    if the vacuum operation has finished, SQLITE_OK if the vacuum operation has not
    finished but no error has occurred, and an SQLite error code if an error is encountered.
    If an error does occur, all subsequent calls to sqlite3rbu_step() immediately
    return the same error code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, sqlite3rbu_close() is called to close the RBU handle. If the application
    stopped calling sqlite3rbu_step() before either the vacuum finished or an error
    occurred, the state of the vacuum is saved in the state database so that it may
    be resumed later on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Like sqlite3rbu_step(), if the vacuum operation has finished, sqlite3rbu_close()
    returns SQLITE_DONE. If the vacuum has not finished but no error has occurred,
    SQLITE_OK is returned. Or, if an error has occurred, an SQLite error code is returned.
    If an error occurred as part of a prior call to sqlite3rbu_step(), sqlite3rbu_close()
    returns the same error code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The following example code illustrates the techniques described above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
