- en: 1\. File overwrite by a rogue thread or process
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1\. 通过恶意线程或进程覆盖文件
- en: 原文：[https://sqlite.com/howtocorrupt.html](https://sqlite.com/howtocorrupt.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://sqlite.com/howtocorrupt.html](https://sqlite.com/howtocorrupt.html)
- en: Overview
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: An SQLite database is highly resistant to corruption. If an application crash,
    or an operating-system crash, or even a power failure occurs in the middle of
    a transaction, the partially written transaction should be automatically rolled
    back the next time the database file is accessed. The recovery process is fully
    automatic and does not require any action on the part of the user or the application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite数据库对损坏具有很高的抵抗力。如果应用程序崩溃，操作系统崩溃，甚至在事务进行中发生了断电，部分写入的事务应该在下次访问数据库文件时自动回滚。恢复过程完全自动化，不需要用户或应用程序采取任何操作。
- en: Though SQLite is resistant to database corruption, it is not immune. This document
    describes the various ways that an SQLite database might go corrupt.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SQLite对数据库损坏有所抵抗，但并非完全免疫。本文描述了SQLite数据库可能遭到损坏的各种方式。
- en: SQLite database files are ordinary disk files. That means that any process can
    open the file and overwrite it with garbage. There is nothing that the SQLite
    library can do to defend against this.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite数据库文件是普通的磁盘文件。这意味着任何进程都可以打开文件并用垃圾覆盖它。SQLite库无法防范此类行为。
- en: 1.1\. Continuing to use a file descriptor after it has been closed
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1\. 在关闭文件描述符后继续使用它
- en: We have seen multiple cases where a file descriptor was open on a file, then
    that file descriptor was closed and reopened on an SQLite database. Later, some
    other thread continued to write into the old file descriptor, not realizing that
    the original file had been closed already. But because the file descriptor had
    been reopened by SQLite, the information that was intended to go into the original
    file ended up overwriting parts of the SQLite database, leading to corruption
    of the database.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到多种情况，其中一个文件描述符在文件上打开，然后该文件描述符被关闭并重新打开在一个SQLite数据库上。后来，一些其他线程继续向旧的文件描述符写入，没有意识到原始文件已经关闭。但因为文件描述符已被SQLite重新打开，本来应该进入原始文件的信息最终覆盖了SQLite数据库的部分内容，导致数据库损坏。
- en: One example of this occurred circa 2013-08-30 on the canonical repository for
    the [Fossil DVCS](http://www.fossil-scm.org/). In that event, file descriptor
    2 (standard error) was being erroneously closed (by [stunnel](http://www.stunnel.org/),
    we suspect) prior to [sqlite3_open_v2()](c3ref/open.html) so that the file descriptor
    used for the repository database file was 2\. Later, an application bug caused
    an assert() statement to emit an error message by invoking write(2,...). But since
    file descriptor 2 was now connected to a database file, the error message overwrote
    part of the database. To guard against this kind of problem, SQLite [version 3.8.1](releaselog/3_8_1.html)
    (2013-10-17) and later refuse to use low-numbered file descriptors for database
    files. (See [SQLITE_MINIMUM_FILE_DESCRIPTOR](compile.html#minimum_file_descriptor)
    for additional information.)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况的一个例子发生在2013-08-30关于[Fossil DVCS的规范库](http://www.fossil-scm.org/)。在那次事件中，文件描述符2（标准错误）在[sqlite3_open_v2()](c3ref/open.html)之前被错误地关闭（我们怀疑是由[stunnel](http://www.stunnel.org/)执行），因此用于存储库数据库文件的文件描述符为2。后来，一个应用程序错误导致assert()语句通过调用write(2,...)发出错误消息。但由于文件描述符2现在连接到数据库文件，错误消息覆盖了数据库的一部分。为了防止这种问题，SQLite
    [版本3.8.1](releaselog/3_8_1.html)（2013-10-17）及更高版本拒绝使用低编号的文件描述符作为数据库文件。（有关更多信息，请参阅[SQLITE_MINIMUM_FILE_DESCRIPTOR](compile.html#minimum_file_descriptor)。）
- en: Another example of corruption caused by using a closed file descriptor was [reported
    by facebook engineers](https://code.facebook.com/posts/313033472212144/debugging-file-corruption-on-ios/)
    in a blog post on 2014-08-12.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用已关闭的文件描述符导致的腐败的另一个例子，[Facebook工程师报道](https://code.facebook.com/posts/313033472212144/debugging-file-corruption-on-ios/)于2014-08-12在一篇博客中。
- en: Another example of this error was reported against [Fossil](https://fossil-scm.org/)
    on 2019-07-11\. A file descriptor would be opened for debugging output, but then
    closed and reopened by SQLite. But the debugging logic continued to write into
    the original file descriptor. See the [forum discussion](https://fossil-scm.org/forum/forumpost/c51b9a1169)
    for the bug report and a link to the fix.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个这种错误的例子发生在2019-07-11针对[Fossil](https://fossil-scm.org/)。一个文件描述符用于调试输出，但随后被SQLite关闭并重新打开。但调试逻辑继续写入原始文件描述符。参见[论坛讨论](https://fossil-scm.org/forum/forumpost/c51b9a1169)以获取错误报告和修复链接。
- en: 1.2\. Backup or restore while a transaction is active
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2\. 在事务活动时备份或还原
- en: Systems that run automatic backups in the background might try to make a backup
    copy of an SQLite database file while it is in the middle of a transaction. The
    backup copy then might contain some old and some new content, and thus be corrupt.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在后台运行自动备份的系统可能会尝试在SQLite数据库文件处于事务中时创建备份副本。然后备份副本可能包含一些旧的和一些新的内容，从而变得损坏。
- en: The best approach to make reliable backup copies of an SQLite database is to
    make use of the [backup API](backup.html) that is part of the SQLite library.
    Failing that, it is safe to make a copy of an SQLite database file as long as
    there are no transactions in progress by any process. If the previous transaction
    failed, then it is important that any rollback journal (the `*-journal` file)
    or write-ahead log (the `*-wal` file) be copied together with the database file
    itself.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最可靠地备份 SQLite 数据库的方法是利用 SQLite 库的[备份 API](backup.html)。如果无法使用该 API，则可以安全地复制
    SQLite 数据库文件，只要没有任何进程正在进行事务。如果以前的事务失败，则重要的是任何回滚日志（`*-journal` 文件）或写前日志（`*-wal`
    文件）都要与数据库文件一起复制。
- en: 1.3\. Deleting a hot journal
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3\. 删除热日志
- en: SQLite normally stores all content in a single disk file. However, while performing
    a transaction, information necessary to recover the database following a crash
    or power failure is stored in auxiliary journal files. Such journal files are
    described as ["hot"](fileformat2.html#hotjrnl). The journal files have the same
    name as the original database file with the addition of `-journal` or `-wal` suffix.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 通常将所有内容存储在单个磁盘文件中。但是，在执行事务时，用于在崩溃或断电后恢复数据库的信息存储在辅助日志文件中。这些日志文件被描述为["热"](fileformat2.html#hotjrnl)。日志文件与原始数据库文件具有相同的名称，只是增加了
    `-journal` 或 `-wal` 后缀。
- en: SQLite must see the journal files in order to recover from a crash or power
    failure. If the [hot journal files](fileformat2.html#hotjrnl) are moved, deleted,
    or renamed after a crash or power failure, then automatic recovery will not work
    and the database may go corrupt.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 必须在崩溃或断电后看到日志文件才能恢复。如果[热日志文件](fileformat2.html#hotjrnl)在崩溃或断电后被移动、删除或重命名，则自动恢复将无法工作，数据库可能会损坏。
- en: Another manifestation of this problem is [database corruption caused by inconsistent
    use of 8+3 filenames](shortnames.html#db83corrupt).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题的表现形式是由于不一致使用 8+3 文件名造成的[数据库损坏](shortnames.html#db83corrupt)。
- en: 1.4\. Mispairing database files and hot journals
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4\. 错配数据库文件和热日志
- en: 'The previous example is a specific case of a more general problem: The state
    of an SQLite database is controlled by both the database file and the journal
    file. In a quiescent state, the journal file does not exist and only the database
    file matters. But if the journal file does exist, it must be kept together with
    the database to avoid corruption. The following actions are all likely to lead
    to corruption:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子是一个更普遍问题的特定案例：SQLite 数据库的状态由数据库文件和日志文件控制。在静止状态下，不存在日志文件，只有数据库文件重要。但如果存在日志文件，则必须与数据库文件一起保持以避免损坏。以下操作都可能导致损坏：
- en: Swapping journal files between two different databases.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交换两个不同数据库之间的日志文件。
- en: Overwritting a journal file with a different journal file.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用不同的日志文件覆盖日志文件。
- en: Moving a journal file from one database to another.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个数据库的日志文件移动到另一个数据库中。
- en: Copying a database file without also copying its journal.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制数据库文件时不复制其日志。
- en: Overwriting a database file with another without also deleting any hot journal
    associated with the original database.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不删除原始数据库相关的任何热日志的情况下，用另一个数据库文件覆盖数据库文件。
- en: 2\. File locking problems
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2\. 文件锁定问题
- en: SQLite uses file locks on the database file, and on the [write-ahead log](wal.html)
    or [WAL](wal.html) file, to coordinate access between concurrent processes. Without
    coordination, two threads or processes might try to make incompatible changes
    to a database file at the same time, resulting in database corruption.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 使用文件锁在数据库文件和[预写式日志（write-ahead log）](wal.html)或[WAL](wal.html)文件上，以协调并发进程之间的访问。没有协调，两个线程或进程可能同时尝试对数据库文件进行不兼容的更改，导致数据库损坏。
- en: 2.1\. Filesystems with broken or missing lock implementations
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1\. 具有损坏或缺失锁定实现的文件系统
- en: SQLite depends on the underlying filesystem to do locking as the documentation
    says it will. But some filesystems contain bugs in their locking logic such that
    the locks do not always behave as advertised. This is especially true of network
    filesystems and NFS in particular. If SQLite is used on a filesystem where the
    locking primitives contain bugs, and if two or more threads or processes try to
    access the same database at the same time, then database corruption might result.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 依赖底层文件系统来执行锁定，正如文档所述。但是一些文件系统中存在其锁定逻辑中的错误，使得锁定不总是按照广告中的方式行事。这对网络文件系统和特别是
    NFS 尤其真实。如果在存在锁定原语包含错误的文件系统上使用 SQLite，并且两个或更多线程或进程尝试同时访问同一数据库，则可能导致数据库损坏。
- en: 2.2\. Posix advisory locks canceled by a separate thread doing close()
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2\. 被关闭操作的独立线程取消的 POSIX 咨询锁定
- en: The default locking mechanism used by SQLite on unix platforms is POSIX advisory
    locking. Unfortunately, POSIX advisory locking has design quirks that make it
    prone to misuse and failure. In particular, any thread in the same process with
    a file descriptor that is holding a POSIX advisory lock can override that lock
    using a different file descriptor. One particularly pernicious problem is that
    the `close()` system call will cancel all POSIX advisory locks on the same file
    for all threads and all file descriptors in the process.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 在 Unix 平台上使用的默认锁定机制是 POSIX 咨询锁定。不幸的是，POSIX 咨询锁定存在设计怪异之处，容易被误用和失败。特别是，同一进程中具有持有
    POSIX 咨询锁定的文件描述符的任何线程可以使用另一个文件描述符覆盖该锁定。一个特别阴险的问题是，`close()` 系统调用会取消进程中所有线程和所有文件描述符对同一文件的所有
    POSIX 咨询锁定。
- en: So, for example, suppose a multi-thread process has two or more threads with
    separate SQLite database connections to the same database file. Then a third thread
    comes along and wants to read something out of that same database file on its
    own, without using the SQLite library. The third thread does an `open()`, a `read()`
    and then a `close()`. One would think this would be harmless. But the `close()`
    system call caused the locks held on the database by all the other threads to
    be dropped. Those other threads have no way of knowing that their locks have just
    been trashed (POSIX does not provide any mechanism to determine this) and so they
    keep on running under the assumption that their locks are still valid. This can
    lead to two or more threads or processes trying to write to the database at the
    same time, resulting in database corruption.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，举例来说，假设一个多线程进程有两个或更多个线程，每个线程都有独立的SQLite数据库连接指向同一个数据库文件。然后第三个线程出现，并且想要自己读取那个同一个数据库文件的内容，而不使用SQLite库。第三个线程执行了`open()`，`read()`和`close()`操作。人们可能会认为这是无害的。但是，`close()`系统调用导致了所有其他线程持有的数据库锁被释放。这些其他线程无法知道它们的锁刚刚被清除（POSIX没有提供任何机制来确定这一点），因此它们继续运行，假设它们的锁仍然有效。这可能导致两个或更多个线程或进程同时尝试写入数据库，导致数据库损坏。
- en: Note that it is perfectly safe for two or more threads to access the same SQLite
    database file using the SQLite library. The unix drivers for SQLite know about
    the POSIX advisory locking quirks and work around them. This problem only arises
    when a thread tries to bypass the SQLite library and read the database file directly.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用SQLite库时，两个或更多个线程同时访问同一个SQLite数据库文件是完全安全的。SQLite的Unix驱动程序了解POSIX建议锁定的怪癖并解决了这些问题。这个问题只在一个线程试图绕过SQLite库直接读取数据库文件时出现。
- en: 2.2.1\. Multiple copies of SQLite linked into the same application
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1\. 同一应用程序中链接的多个SQLite副本
- en: As pointed out in the previous paragraph, SQLite takes steps to work around
    the quirks of POSIX advisory locking. Part of that work-around involves keeping
    a global list (mutex protected) of open SQLite database files. But, if multiple
    copies of SQLite are linked into the same application, then there will be multiple
    instances of this global list. Database connections opened using one copy of the
    SQLite library will be unaware of database connections opened using the other
    copy, and will be unable to work around the POSIX advisory locking quirks. A `close()`
    operation on one connection might unknowingly clear the locks on a different database
    connection, leading to database corruption.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面段落所指出的，SQLite采取措施来解决POSIX建议锁定的问题。其中一个解决方法是维护一个全局列表（受互斥锁保护）来管理已打开的SQLite数据库文件。但是，如果将多个SQLite副本链接到同一个应用程序中，则会有多个此全局列表的实例。使用一个SQLite库打开的数据库连接将不知道使用另一个副本打开的数据库连接，并且将无法解决POSIX建议锁定的问题。在一个连接上执行`close()`操作可能会无意中清除另一个数据库连接上的锁定，导致数据库损坏。
- en: The scenario above sounds far-fetched. But the SQLite developers are aware of
    at least one commercial product that was released with exactly this bug. The vendor
    came to the SQLite developers seeking help in tracking down some infrequent database
    corruption issues they were seeing on Linux and Mac. The problem was eventually
    traced to the fact that the application was linking against two separate copies
    of SQLite. The solution was to change the application build procedures to link
    against just one copy of SQLite instead of two.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 上述场景听起来离谱。但 SQLite 的开发人员至少意识到有一个商业产品正是以这种 bug 发布的。供应商向 SQLite 的开发人员寻求帮助，以追踪一些在
    Linux 和 Mac 上偶发的数据库损坏问题。问题最终被追溯到应用程序链接了两个独立的 SQLite 副本。解决方案是修改应用程序的构建过程，改为只链接一个
    SQLite 副本，而不是两个。
- en: 2.3\. Two processes using different locking protocols
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3\. 两个进程使用不同的锁定协议
- en: The default locking mechanism used by SQLite on unix platforms is POSIX advisory
    locking, but there are other options. By selecting an alternative [sqlite3_vfs](c3ref/vfs.html)
    using the [sqlite3_open_v2()](c3ref/open.html) interface, an application can make
    use of other locking protocols that might be more appropriate to certain filesystems.
    For example, dot-file locking might be select for use in an application that has
    to run on an NFS filesystem that does not support POSIX advisory locking.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 在 Unix 平台上使用的默认锁定机制是 POSIX 咨询锁定，但也有其他选择。通过使用 [sqlite3_open_v2()](c3ref/open.html)
    接口选择替代的 [sqlite3_vfs](c3ref/vfs.html)，应用程序可以利用其他可能更适合某些文件系统的锁定协议。例如，在需要在不支持 POSIX
    咨询锁定的 NFS 文件系统上运行的应用程序中，可能会选择使用点文件锁定。
- en: It is important that all connections to the same database file use the same
    locking protocol. If one application is using POSIX advisory locks and another
    application is using dot-file locking, then the two applications will not see
    each other's locks and will not be able to coordinate database access, possibly
    leading to database corruption.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 所有连接到同一数据库文件的连接必须使用相同的锁定协议是很重要的。如果一个应用程序使用 POSIX 咨询锁定，而另一个应用程序使用点文件锁定，那么这两个应用程序将无法看到彼此的锁定，并且无法协调数据库访问，可能导致数据库损坏。
- en: 2.4\. Unlinking or renaming a database file while in use
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4\. 在使用中删除或重命名数据库文件
- en: If two processes have open connections to the same database file and one process
    closes its connection, unlinks the file, then creates a new database file in its
    place with the same name and reopens the new file, then the two processes will
    be talking to different database files with the same name. (Note that this is
    only possible on Posix and Posix-like systems that permit a file to be unlinked
    while it is still open for reading and writing. Windows does not allow this to
    occur.) Since rollback journals and WAL files are based on the name of the database
    file, the two different database files will share the same rollback journal or
    WAL file. A rollback or recovery for one of the databases might use content from
    the other database, resulting in corruption. A similar problem occurs if a database
    file is renamed while it is opened and a new file is created with the old name.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个进程同时打开同一个数据库文件，并且其中一个进程关闭了连接、取消了文件的链接，然后用同样的名称创建了一个新的数据库文件并重新打开它，那么这两个进程将会连接到同名但不同的数据库文件。（注意，这种情况只可能发生在允许在文件仍然打开的情况下取消链接的类Unix系统上，Windows不支持这种操作。）由于回滚日志和WAL文件是基于数据库文件名称命名的，这两个不同的数据库文件将共享同一个回滚日志或WAL文件。其中一个数据库的回滚或恢复可能会使用另一个数据库的内容，导致数据损坏。如果在打开的情况下重命名数据库文件并创建了一个旧名称的新文件，也会出现类似的问题。
- en: In other words, unlinking or renaming an open database file results in behavior
    that is undefined and probably undesirable.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，取消链接或重命名打开的数据库文件会导致未定义且可能不良的行为。
- en: Beginning with SQLite [version 3.7.17](releaselog/3_7_17.html) (2013-05-20),
    the unix OS interface will send SQLITE_WARNING messages to the [error log](errlog.html)
    if a database file is unlinked while it is still in use.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从SQLite [版本 3.7.17](releaselog/3_7_17.html)（2013-05-20）开始，Unix操作系统接口将会向[错误日志](errlog.html)发送SQLITE_WARNING消息，如果一个数据库文件在仍在使用时被取消链接。
- en: 2.5\. Multiple links to the same file
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5\. 同一个文件的多个链接
- en: If a single database file has multiple links (either hard or soft links) then
    that is just another way of saying that the file has multiple names. If two or
    more processes open the database using different names, then they will use different
    rollback journals and WAL files. That means that if one process crashes, the other
    process will be unable to recover the transaction in progress because it will
    be looking in the wrong place for the appropriate journal.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个单一的数据库文件有多个链接（硬链接或软链接），那就意味着这个文件有多个名称。如果两个或更多进程使用不同的名称打开数据库，它们将使用不同的回滚日志和WAL文件。这意味着如果一个进程崩溃，另一个进程将无法恢复正在进行的事务，因为它会在错误的位置查找适当的日志。
- en: In other words, opening and using a database file that has two or more names
    results in behavior that is undefined and probably undesirable.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，打开和使用具有两个或更多名称的数据库文件会导致未定义且可能不良的行为。
- en: Beginning with SQLite [version 3.7.17](releaselog/3_7_17.html) (2013-05-20),
    the unix OS interface will send SQLITE_WARNING messages to the [error log](errlog.html)
    if a database file has multiple hard links.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从 SQLite [version 3.7.17](releaselog/3_7_17.html)（2013-05-20）开始，unix 操作系统接口将会向
    [错误日志](errlog.html) 发送 SQLITE_WARNING 消息，如果数据库文件具有多个硬链接。
- en: Beginning with SQLite [version 3.10.0](releaselog/3_10_0.html) (2016-01-06),
    the unix OS interface will attempt to resolve symbolic links and open the database
    file by its canonical name. Prior to version 3.10.0, opening a database file through
    a symbolic link was similar to opening a database file that had multiple hard
    links and resulted in undefined behavior.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 从 SQLite [version 3.10.0](releaselog/3_10_0.html)（2016-01-06）开始，unix 操作系统接口将尝试通过其规范名称解析符号链接并打开数据库文件。在版本
    3.10.0 之前，通过符号链接打开数据库文件类似于打开具有多个硬链接的数据库文件，并导致未定义的行为。
- en: 2.6\. Carrying an open database connection across a fork()
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.6\. 在 fork() 过程中传递打开的数据库连接
- en: Do not open an SQLite database connection, then fork(), then try to use that
    database connection in the child process. All kinds of locking problems will result
    and you can easily end up with a corrupt database. SQLite is not designed to support
    that kind of behavior. Any database connection that is used in a child process
    must be opened in the child process, not inherited from the parent.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在打开 SQLite 数据库连接后进行 fork() 操作，然后尝试在子进程中使用该数据库连接。会导致各种锁定问题，并且很容易导致数据库损坏。SQLite
    不设计支持这种行为。任何在子进程中使用的数据库连接必须在子进程中打开，而不是从父进程继承的。
- en: Do not even call [sqlite3_close()](c3ref/close.html) on a database connection
    from a child process if the connection was opened in the parent. It is safe to
    close the underlying file descriptor, but the [sqlite3_close()](c3ref/close.html)
    interface might invoke cleanup activities that will delete content out from under
    the parent, leading to errors and perhaps even database corruption.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果连接是在父进程中打开的，请不要在子进程中甚至调用 [sqlite3_close()](c3ref/close.html) 关闭数据库连接。关闭底层文件描述符是安全的，但是
    [sqlite3_close()](c3ref/close.html) 接口可能会调用清理活动，从而删除父进程下的内容，导致错误甚至数据库损坏。
- en: 3\. Failure to sync
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3\. 同步失败
- en: In order to guarantee that database files are always consistent, SQLite will
    occasionally ask the operating system to flush all pending writes to persistent
    storage then wait for that flush to complete. This is accomplished using the `fsync()`
    system call under unix and `FlushFileBuffers()` under Windows. We call this flush
    of pending writes a "sync".
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保证数据库文件始终一致，SQLite 会偶尔请求操作系统将所有待定写入刷新到持久存储，然后等待刷新完成。在 unix 下，这是通过 `fsync()`
    系统调用实现的，在 Windows 下是通过 `FlushFileBuffers()`。我们称这种待定写入的刷新为“同步”。
- en: Actually, if one is only concerned with atomic and consistent writes and is
    willing to forego durable writes, the sync operation does not need to wait until
    the content is completely stored on persistent media. Instead, the sync operation
    can be thought of as an I/O barrier. As long as all writes that occur before the
    sync are completed before any write that happens after the sync, no database corruption
    will occur. If sync is operating as an I/O barrier and not as a true sync, then
    a power failure or system crash might cause one or more previously committed transactions
    to roll back (in violation of the "durable" property of "ACID") but the database
    will at least continue to be consistent, and that is what most people care about.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '实际上，如果一个人只关心原子性和一致性写入，并愿意放弃持久性写入，那么同步操作就不需要等到内容完全存储在持久介质上。相反，同步操作可以被视为I/O屏障。只要在同步之前发生的所有写入在同步之后发生的任何写入之前完成，就不会发生数据库损坏。如果同步操作作为I/O屏障而不是真正的同步运行，那么断电或系统崩溃可能导致一个或多个之前已提交的事务回滚（违反了"ACID"的"持久"属性），但数据库至少会继续保持一致性，这才是大多数人关心的。 '
- en: 3.1\. Disk drives that do not honor sync requests
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1\. 不支持同步请求的磁盘驱动器
- en: Unfortunately, most consumer-grade mass storage devices lie about syncing. Disk
    drives will report that content is safely on persistent media as soon as it reaches
    the track buffer and before actually being written to oxide. This makes the disk
    drives seem to operate faster (which is vitally important to the manufacturer
    so that they can show good benchmark numbers in trade magazines). And in fairness,
    the lie normally causes no harm, as long as there is no power loss or hard reset
    prior to the track buffer actually being written to oxide. But if a power loss
    or hard reset does occur, and if that results in content that was written after
    a sync reaching oxide while content written before the sync is still in a track
    buffer, then database corruption can occur.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，大多数消费级大容量存储设备关于同步是虚假的。磁盘驱动器会报告内容已安全存储在持久介质上，只要达到磁道缓冲区并在实际写入氧化物之前。这使得磁盘驱动器看起来运行更快（对制造商至关重要，以便他们可以在商业杂志中展示良好的基准数据）。公平地说，谎言通常不会造成伤害，只要在实际写入氧化物之前没有断电或硬重置。但是，如果发生断电或硬重置，并且导致在同步之后写入的内容到达氧化物时，之前在磁道缓冲区中写入的内容仍然存在，那么数据库损坏就会发生。
- en: USB flash memory sticks seem to be especially pernicious liars regarding sync
    requests. One can easily see this by committing a large transaction to an SQLite
    database on a USB memory stick. The COMMIT command will return relatively quickly,
    indicating that the memory stick has told the operating system and the operating
    system has told SQLite that all content is safely in persistent storage, and yet
    the LED on the end of the memory stick will continue flashing for several more
    seconds. Pulling out the memory stick while the LED is still flashing will frequently
    result in database corruption.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: USB闪存盘似乎在同步请求方面特别具有欺诈性。可以通过将大型事务提交到USB内存棒上的SQLite数据库来轻松看到这一点。COMMIT命令会相对较快地返回，表示内存棒已告诉操作系统，而操作系统已告诉SQLite所有内容都已安全存储在持久存储中，然而，内存棒尾部的LED灯会继续闪烁几秒钟。在LED仍在闪烁时拔出内存棒通常会导致数据库损坏。
- en: Note that SQLite must believe whatever the operating system and hardware tell
    it about the status of sync requests. There is no way for SQLite to detect that
    either is lying and that writes might be occurring out-of-order. However, SQLite
    in [WAL mode](wal.html) is far more forgiving of out-of-order writes than in the
    default rollback journal modes. In WAL mode, the only time that a failed sync
    operation can cause database corruption is during a [checkpoint](wal.html#ckpt)
    operation. A sync failure during a COMMIT might result in loss of durability but
    not in a corrupt database file. Hence, one line of defense against database corruption
    due to failed sync operations is to use SQLite in WAL mode and to checkpoint as
    infrequently as possible.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，SQLite必须相信操作系统和硬件关于同步请求状态的信息。SQLite没有办法检测操作系统或硬件是否在撒谎，并且写入可能以任意顺序发生。然而，与默认回滚日志模式相比，在WAL模式中，SQLite对乱序写入更具宽容性。在WAL模式中，仅在[checkpoint](wal.html#ckpt)操作期间发生同步失败时才会导致数据库损坏。在COMMIT期间发生同步失败可能会导致耐久性丧失，但不会导致损坏的数据库文件。因此，防止因同步操作失败而导致数据库损坏的一种防线是将SQLite设置为WAL模式，并尽可能少地进行检查点操作。
- en: 3.2\. Disabling sync using PRAGMAs
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2\. 使用PRAGMAs禁用同步
- en: The sync operations that SQLite performs to help ensure integrity can be disabled
    at run-time using the [synchronous pragma](pragma.html#pragma_synchronous). By
    setting PRAGMA synchronous=OFF, all sync operations are omitted. This makes SQLite
    seem to run faster, but it also allows the operating system to freely reorder
    writes, which could result in database corruption if a power failure or hard reset
    occurs prior to all content reaching persistent storage.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite执行的同步操作以帮助确保完整性可以在运行时使用[synchronous pragma](pragma.html#pragma_synchronous)进行禁用。通过设置PRAGMA
    synchronous=OFF，所有同步操作都将被省略。这使得SQLite似乎运行更快，但也允许操作系统自由重新排序写入，如果在所有内容到达持久存储之前发生断电或硬重置，这可能导致数据库损坏。
- en: For maximum reliability and for robustness against database corruption, SQLite
    should always be run with its default synchronous setting of FULL.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最大限度地提高可靠性并防止数据库损坏，SQLite应始终以其默认的同步设置FULL模式运行。
- en: 4\. Disk Drive and Flash Memory Failures
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4\. 磁盘驱动器和闪存存储器故障
- en: An SQLite database can become corrupt if the file content changes due to a disk
    drive or flash memory failure. It is very rare, but disks will occasionally flip
    a bit in the middle of a sector.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于磁盘驱动器或闪存存储器故障而导致文件内容发生变化，SQLite数据库可能会损坏。这种情况非常罕见，但是磁盘偶尔会在一个扇区的中间翻转一个位。
- en: 4.1\. Non-powersafe flash memory controllers
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1\. 非供电安全的闪存控制器
- en: We are told that in some flash memory controllers the wear-leveling logic can
    cause random filesystem damage if power is interrupted during a write. This can
    manifest, for example, as random changes in the middle of a file that was not
    even open at the time of the power loss. So, for example, a device would be writing
    content into an MP3 file in flash memory when a power loss occurs, and that could
    result in an SQLite database being corrupted even though the database was not
    even in use at the time of the power loss.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们被告知，在一些闪存控制器中，磨损平衡逻辑可能会在写入过程中断电时造成随机的文件系统损坏。例如，这可能表现为文件中间的随机更改，而当时甚至没有打开这个文件。举例来说，当设备正在将内容写入闪存中的MP3文件时断电，这可能导致一个SQLite数据库被损坏，尽管在断电时根本没有使用该数据库。
- en: 4.2\. Fake capacity USB sticks
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2\. 伪装容量的USB闪存
- en: 'There are many fraudulent USB sticks in circulation that report to have a high
    capacity (ex: 8GB) but are really only capable of storing a much smaller amount
    (ex: 1GB). Attempts to write on these devices will often result in unrelated files
    being overwritten. Any use of a fraudulent flash memory device can easily lead
    to database corruption, therefore. Internet searches such as "fake capacity usb"
    will turn up lots of disturbing information about this problem.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 目前市面上流通着许多虚假的USB闪存，声称具有很高的容量（例如：8GB），但实际上只能存储较小的容量（例如：1GB）。尝试在这些设备上写入数据通常会导致非相关文件被覆盖。因此，任何使用虚假闪存设备都很容易导致数据库损坏。例如，通过搜索“虚假容量USB”等关键词可以找到大量关于这个问题的令人不安的信息。
- en: 5\. Memory corruption
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5\. 内存损坏
- en: SQLite is a C-library that runs in the same address space as the application
    that it serves. That means that stray pointers, buffer overruns, heap corruption,
    or other malfunctions in the application can corrupt internal SQLite data structure
    and ultimately result in a corrupt database file. Normally these kinds of problems
    manifest themselves as segfaults prior to any database corruption occurring, but
    there have been instances where application code errors have caused SQLite to
    malfunction subtly so as to corrupt the database file rather than panicking.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite是一个运行在与其服务的应用程序相同地址空间的C库。这意味着应用程序中的偏移指针、缓冲区溢出、堆损坏或其他故障可能会损害SQLite的内部数据结构，并最终导致数据库文件损坏。通常这类问题会在数据库损坏之前就出现段错误，但确实有一些实例是因为应用程序代码错误导致SQLite表现出微妙的故障，最终导致数据库文件损坏而不是崩溃。
- en: The memory corruption problem becomes more acute when using [memory-mapped I/O](mmap.html).
    When all or part of the database file is mapped into the application's address
    space, then a stray pointer that overwrites any part of that mapped space will
    immediately corrupt the database file, without requiring the application to do
    a subsequent write() system call.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用[内存映射 I/O](mmap.html)时，内存损坏问题变得更加严重。当数据库文件的全部或部分映射到应用程序的地址空间时，任何覆盖该映射空间的偏移指针都会立即损坏数据库文件，而不需要应用程序执行后续的
    write() 系统调用。
- en: 6\. Other operating system problems
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6\. 其他操作系统问题
- en: Sometimes operating systems will exhibit non-standard behavior which can lead
    to problems. Sometimes this non-standard behavior is deliberate, and sometimes
    it is a mistake in the implementation. But in any event, if the operating performs
    differently from they way SQLite expects it to perform, the possibility of database
    corruption exists.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有时操作系统会表现出非标准的行为，这可能导致问题。这种非标准行为有时是故意的，有时是实现上的错误。但无论如何，如果操作系统的行为与 SQLite 预期的不同，就存在数据库损坏的可能性。
- en: 6.1\. Linux Threads
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1\. Linux 线程
- en: Some older versions of Linux used the LinuxThreads library for thread support.
    LinuxThreads is similar to Pthreads, but is subtly different with respect to handling
    of POSIX advisory locks. SQLite versions 2.2.3 through 3.6.23 recognized that
    LinuxThreads were being used at runtime and took appropriate action to work around
    the non-standard behavior of LinuxThreads. But most modern Linux implementations
    make use of the newer, and correct, NPTL implementation of Pthreads. Beginning
    with SQLite [version 3.7.0](releaselog/3_7_0.html) (2010-07-21), the use of NPTL
    is assumed. No checks are made. Hence, recent versions of SQLite will subtly malfunction
    and may corrupt database files if used in multi-threaded application that run
    on older linux systems that make use of LinuxThreads.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一些旧版本的 Linux 使用 LinuxThreads 库来支持线程。LinuxThreads 类似于 Pthreads，但在处理 POSIX 建议锁时略有不同。SQLite
    从版本 2.2.3 到 3.6.23 在运行时识别到使用了 LinuxThreads，并采取适当措施来解决 LinuxThreads 的非标准行为。但是，大多数现代
    Linux 实现都使用了更新且正确的 NPTL 实现的 Pthreads。从 SQLite [版本 3.7.0](releaselog/3_7_0.html)（2010-07-21）开始，假定使用
    NPTL。不再进行检查。因此，如果在旧版本的 Linux 系统上运行使用 LinuxThreads 的多线程应用程序，最近的 SQLite 版本可能会出现细微的故障，并可能损坏数据库文件。
- en: 6.2\. Failures of mmap() on QNX
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2\. QNX 上 mmap() 的失败
- en: There exists some subtle problem with mmap() on QNX such that making a second
    mmap() call against a single file descriptor can cause the memory obtained from
    the first mmap() call to be zeroed. SQLite on unix uses mmap() to create a shared
    memory region for transaction coordination in [WAL mode](wal.html), and it will
    call mmap() multiple times for large transactions. The QNX mmap() has been demonstrated
    to corrupt database file under that scenario. QNX engineers are aware of this
    problem and are working on a solution; the problem may have already been fixed
    by the time you read this.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: QNX 上存在一些关于 mmap() 的微妙问题，即对单个文件描述符进行第二次 mmap() 调用可能会导致从第一次 mmap() 调用获取的内存被清零。Unix
    上的 SQLite 在 [WAL 模式](wal.html) 下使用 mmap() 来创建用于事务协调的共享内存区域，并且对于大事务会多次调用 mmap()。已经证明
    QNX 的 mmap() 在这种情况下会损坏数据库文件。QNX 的工程师们已经意识到了这个问题，并正在努力解决；可能在您阅读此文时，问题已经得到了修复。
- en: When running on QNX, it is recommended that [memory-mapped I/O](mmap.html) never
    be used. Furthermore, to use [WAL mode](wal.html), it is recommended that applications
    employ the [exclusive locking mode](pragma.html#pragma_locking_mode) in order
    to use [WAL without shared memory](wal.html#noshm).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 QNX 上运行时，建议永远不要使用 [内存映射 I/O](mmap.html)。此外，要使用 [WAL 模式](wal.html)，建议应用程序使用
    [独占锁定模式](pragma.html#pragma_locking_mode) 以便在无共享内存的情况下使用 [WAL](wal.html#noshm)。
- en: 6.3\. Filesystem Corruption
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3\. 文件系统损坏
- en: Since SQLite databases are ordinary disk files, any malfunction in the filesystem
    can corrupt the database. Filesystems in modern operating systems are very reliable,
    but errors do still occur. For example, on 2013-10-01 the SQLite database that
    holds the [Wiki for Tcl/Tk](http://wiki.tcl-lang.org/) went corrupt a few days
    after the host computer was moved to a dodgy build of the (linux) kernel that
    had issues in the filesystem layer. In that event, the filesystem eventually became
    so badly corrupted that the machine was unusable, but the earliest symptom of
    trouble was the corrupted SQLite database.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 SQLite 数据库是普通的磁盘文件，因此文件系统中的任何故障都可能会导致数据库损坏。现代操作系统中的文件系统非常可靠，但仍然会出现错误。例如，在
    2013-10-01 日，保存 [Tcl/Tk 维基](http://wiki.tcl-lang.org/) 的 SQLite 数据库在主机计算机移动到一个有文件系统层问题的不稳定内核版本后几天就损坏了。在那次事件中，文件系统最终变得如此严重损坏，以至于该计算机无法使用，但问题的最早症状是损坏的
    SQLite 数据库。
- en: 7\. SQLite Configuration Errors
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7\. SQLite 配置错误
- en: SQLite has many built-in protections against database corruption. But many of
    these protections can be disabled by configuration options. If protections are
    disabled, database corruption may occur.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 内置了许多防止数据库损坏的保护措施。但是，许多这些保护措施可以通过配置选项禁用。如果禁用了这些保护措施，则可能会发生数据库损坏。
- en: 'The following are examples of disabling the built-in protection mechanisms
    of SQLite:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是禁用 SQLite 内置保护机制的示例：
- en: Setting [PRAGMA synchronous=OFF](pragma.html#pragma_synchronous) can cause the
    database to go corrupt if there is an operating-system crash or power failure,
    though this setting is safe from damage due to application crashes.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 [PRAGMA synchronous=OFF](pragma.html#pragma_synchronous) 可能会导致数据库在操作系统崩溃或停电时损坏，尽管该设置在应用程序崩溃时是安全的。
- en: Changing the [PRAGMA schema_version](pragma.html#pragma_schema_version) while
    other database connections are open.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其他数据库连接打开的情况下更改 [PRAGMA schema_version](pragma.html#pragma_schema_version)。
- en: Using [PRAGMA journal_mode=OFF](pragma.html#pragma_journal_mode) or [PRAGMA
    journal_mode=MEMORY](pragma.html#pragma_journal_mode) and taking an application
    crash in the middle of a write transaction.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 [PRAGMA journal_mode=OFF](pragma.html#pragma_journal_mode) 或者 [PRAGMA journal_mode=MEMORY](pragma.html#pragma_journal_mode)，在写事务进行中发生应用崩溃。
- en: Setting [PRAGMA writable_schema=ON](pragma.html#pragma_writable_schema) and
    then changing the database schema using DML statements can render the database
    completely unreadable, if not done carefully.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 [PRAGMA writable_schema=ON](pragma.html#pragma_writable_schema) 然后使用 DML
    语句更改数据库模式，如果操作不慎可能会导致数据库完全无法读取。
- en: 8\. Bugs in SQLite
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8\. SQLite 中的错误
- en: SQLite is [very carefully tested](testing.html) to help ensure that it is as
    bug-free as possible. Among the many tests that are carried out for every SQLite
    version are tests that simulate power failures, I/O errors, and out-of-memory
    (OOM) errors and verify that no database corruption occurs during any of these
    events. SQLite is also field-proven with approximately two billion active deployments
    with no serious problems.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 经过 [非常仔细的测试](testing.html)，以尽可能保证其没有错误。每个 SQLite 版本都进行了许多测试，包括模拟停电、I/O
    错误和内存耗尽（OOM）错误，并验证在这些事件期间不会发生数据库损坏。SQLite 在大约 20 亿个活跃部署中得到了验证，没有遇到严重问题。
- en: Nevertheless, no software is 100% perfect. There have been a few historical
    bugs in SQLite (now fixed) that could cause database corruption. And there may
    be yet a few more that remain undiscovered. Because of the extensive testing and
    widespread use of SQLite, bugs that result in database corruption tend to be very
    obscure. The likelihood of an application encountering an SQLite bug is small.
    To illustrate this, an account is given below of all database-corruption bugs
    found in SQLite during the four-year period from 2009-04-01 to 2013-04-15. This
    account should give the reader an intuitive sense of the kinds of bugs in SQLite
    that manage to slip through testing procedures and make it into a release.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，没有软件是100%完美的。 SQLite 曾经有过一些历史性的错误（现已修复），可能导致数据库损坏。而可能还存在一些尚未被发现的错误。由于 SQLite
    进行了广泛的测试和广泛的使用，导致数据库损坏的错误往往非常隐蔽。应用程序遇到 SQLite 错误的可能性很小。以下列出了 SQLite 在 2009-04-01
    至 2013-04-15 四年期间发现的所有数据库损坏错误。这些信息应该让读者直观地了解在测试程序中被忽略而进入发布版本的 SQLite 错误类型。
- en: 8.1\. False corruption reports due to database shrinkage
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1\. 数据库缩小导致的虚假损坏报告
- en: If a database is written by SQLite version 3.7.0 or later and then written again
    by SQLite version 3.6.23 or earlier in such a way as to make the size of the database
    file decrease, then the next time that SQLite version 3.7.0 access the database
    file, it might report that the database file is corrupt. The database file is
    not really corrupt, however. Version 3.7.0 was simply being overly zealous in
    its corruption detection.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个数据库先由SQLite版本3.7.0或更高版本编写，然后再由SQLite版本3.6.23或更早版本以使数据库文件大小减小的方式再次编写，则下一次SQLite版本3.7.0访问数据库文件时，可能会报告数据库文件损坏。然而，数据库文件实际上并没有损坏。版本3.7.0只是在其损坏检测中过于激进。
- en: The problem was fixed on 2011-02-20\. The fix first appears in SQLite [version
    3.7.6](releaselog/3_7_6.html) (2011-04-12).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在2011-02-20修复。修复首次出现在SQLite [版本3.7.6](releaselog/3_7_6.html) (2011-04-12)中。
- en: 8.2\. Corruption following switches between rollback and WAL modes
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2\. 在回滚和WAL模式之间切换后导致损坏。
- en: Repeatedly switching an SQLite database in and out of [WAL mode](wal.html) and
    running the [VACUUM](lang_vacuum.html) command in between switches, in one process
    or thread, can cause another process or thread that has the database file open
    to miss the fact that the database has changed. That second process or thread
    might then try to modify the database using a stale cache and cause database corruption.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 反复在一个进程或线程中切换SQLite数据库的[WAL模式](wal.html)，并在切换之间运行[VACUUM](lang_vacuum.html)命令，可能导致另一个打开数据库文件的进程或线程未能意识到数据库已经发生变化。然后，第二个进程或线程可能尝试使用过期的缓存来修改数据库，从而导致数据库损坏。
- en: This problem was discovered during internal testing and has never been observed
    in the wild. The problem was fixed on 2011-01-27 and in version 3.7.5.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题是在内部测试中发现的，从未在实际中观察到。该问题在2011-01-27修复，并在版本3.7.5中得到修复。
- en: 8.3\. I/O error while obtaining a lock leads to corruption
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3\. 在获取锁时发生的I/O错误导致损坏。
- en: If the operating system returns an I/O error while attempting to obtain a certain
    lock on shared memory in [WAL mode](wal.html) then SQLite might fail to reset
    its cache, which could lead to database corruption if subsequent writes are attempted.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作系统在尝试在[WAL模式](wal.html)的共享内存上获取某个锁时返回I/O错误，那么SQLite可能无法重置其缓存，如果尝试进行后续写操作，则可能导致数据库损坏。
- en: Note that this problem only occurs if the attempt to acquire the lock resulted
    in an I/O error. If the lock is simply not granted (because some other thread
    or process is already holding a conflicting lock) then no corruption will ever
    occur. We are not aware of any operating systems that will fail with an I/O error
    while attempting to get a file lock on shared memory. So this is a theoretical
    problem rather than a real problem. Needless to say, this problem has never been
    observed in the wild. The problem was discovered while doing stress testing of
    SQLite in a test harness that simulates I/O errors.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，只有在尝试获取锁时导致 I/O 错误时才会出现这个问题。如果锁只是因为其他线程或进程已经持有冲突锁而未被授予，则不会发生任何损坏。我们不知道任何操作系统在尝试在共享内存上获取文件锁时会失败
    I/O 错误。因此，这是一个理论上的问题而不是真实存在的问题。不用说，在野外从未观察到这个问题。这个问题是在模拟 SQLite 的压力测试中发现的，在这个测试中会模拟
    I/O 错误。
- en: This problem was fixed on 2010-09-20 for SQLite version 3.7.3.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题在 SQLite 版本 3.7.3 中的 2010-09-20 被修复。
- en: 8.4\. Database pages leak from the free page list
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4\. 数据库页面从空闲页面列表中泄漏
- en: When content is deleted from an SQLite database, pages that are no longer used
    are added to a free list and are reused to hold content added by subsequent inserts.
    A bug in SQLite that was present in version 3.6.16 through 3.7.2 might cause pages
    to go missing out of the free list when [incremental_vacuum](pragma.html#pragma_incremental_vacuum)
    was used. This would not cause data loss. But it would result in the database
    file being larger than necessary. And it would cause the [integrity_check pragma](pragma.html#pragma_integrity_check)
    to report pages missing from the free list.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当从 SQLite 数据库中删除内容时，不再使用的页面将被添加到空闲列表，并在后续插入时重用以容纳添加的内容。在 SQLite 中存在的一个 bug，在版本
    3.6.16 到 3.7.2 中可能会导致页面在使用 [incremental_vacuum](pragma.html#pragma_incremental_vacuum)
    时从空闲列表中丢失。这不会导致数据丢失。但它会导致数据库文件比必要时更大。并且会导致 [integrity_check pragma](pragma.html#pragma_integrity_check)
    报告从空闲列表中丢失的页面。
- en: This problem was fixed on 2010-08-23 for SQLite version 3.7.2.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题在 SQLite 版本 3.7.2 中的 2010-08-23 被修复。
- en: 8.5\. Corruption following alternating writes from 3.6 and 3.7
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.5\. 在从 3.6 和 3.7 交替写入后出现的损坏
- en: SQLite version 3.7.0 introduced a number of new enhancements to the SQLite database
    file format (such as but not limited to [WAL](wal.html)). The 3.7.0 release was
    a shake-out release for these new features. We expected to find problems and were
    not disappointed.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 版本 3.7.0 引入了一些新的增强功能到 SQLite 数据库文件格式（例如但不限于 [WAL](wal.html)）。3.7.0 版本是这些新功能的一个摇摆版本。我们预计会发现问题，而且并未失望。
- en: If a database were originally created using SQLite version 3.7.0, then written
    by SQLite version 3.6.23.1 such that the size of the database file increased,
    then written again by SQLite version 3.7.0, the database file could go corrupt.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个数据库最初是使用 SQLite 版本 3.7.0 创建的，然后使用 SQLite 版本 3.6.23.1 写入以增加数据库文件的大小，然后再次使用
    SQLite 版本 3.7.0 写入，则数据库文件可能会损坏。
- en: This problem was fixed on 2010-08-04 for SQLite version 3.7.1.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题在 SQLite 版本 3.7.1 中的 2010-08-04 被修复。
- en: 8.6\. Race condition in recovery on Windows systems
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.6\. Windows系统上恢复中的竞争条件
- en: SQLite version 3.7.16.2 fixes a subtle race condition in the locking logic on
    Windows systems. When a database file is in need of recovery because the previous
    process writing to it crashed in the middle of a transaction and two or more processes
    try to open the that database at the same time, then the race condition might
    cause one of those processes to get a false indication that the recovery has already
    completed, allowing that process to continue using the database file without running
    recovery first. If that process writes to the file, then the file might go corrupt.
    This race condition had apparently existed in all prior versions of SQLite for
    Windows going back to 2004\. But the race was very tight. Practically speaking,
    you need a fast multi-core machine in which you launch two processes to run recovery
    at the same moment on two separate cores. This defect was on Windows systems only
    and did not affect the posix OS interface.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 版本 3.7.16.2 修复了 Windows 系统上锁逻辑中的一个微妙的竞争条件。当一个数据库文件需要恢复，因为前一个写入它的进程在事务中间崩溃，并且两个或更多进程同时尝试打开该数据库时，竞争条件可能导致其中一个进程错误地得到一个指示已经完成恢复的信息，从而允许该进程在运行恢复之前继续使用数据库文件。如果该进程向文件写入，则文件可能会损坏。这个竞争条件显然存在于所有之前的
    SQLite 版本中，适用于从 2004 年起的所有 Windows 版本。但是这个竞争条件非常严格。实际上，你需要一台快速的多核机器，在其中启动两个进程同时在两个独立的核心上运行恢复操作。这个缺陷仅存在于
    Windows 系统中，不影响 posix 操作系统接口。
- en: 8.7\. Boundary value error in the secondary journals used by nested transactions
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.7\. 嵌套事务使用的次要日志的边界值错误
- en: When a nested transaction is started using [SAVEPOINT](lang_savepoint.html),
    SQLite uses a secondary rollback journal to track the changes for the nested transaction,
    in case the inner transaction needs to be rolled back. Secondary journals are
    not involved in protecting the database from corruption due to program crashes
    or power outages. The secondary journals only come into play when rolling back
    an inner transaction of a nested transaction.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用[保存点](lang_savepoint.html)启动嵌套事务时，SQLite会使用一个次要回滚日志来跟踪嵌套事务的更改，以防内部事务需要回滚。次要日志不参与保护数据库免受程序崩溃或断电造成的损坏。次要日志仅在回滚嵌套事务的内部事务时起作用。
- en: These secondary journals can be held either in memory or as temporary files
    on disk. The default behavior is to store them on disk. But that can be changed
    using the [-DSQLITE_TEMP_STORE](compile.html#temp_store) compile-time option,
    or at run-time using the [PRAGMA temp_store](pragma.html#pragma_temp_store) statement.
    The bug only arises when secondary journals are held in memory.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这些次要日志可以保存在内存中或作为临时文件存储在磁盘上。默认行为是将它们存储在磁盘上。但是可以通过[-DSQLITE_TEMP_STORE](compile.html#temp_store)编译时选项或使用[PRAGMA
    temp_store](pragma.html#pragma_temp_store)语句在运行时更改这一行为。只有当次要日志保存在内存中时才会出现此错误。
- en: In SQLite [version 3.35.0](releaselog/3_35_0.html) (2021-03-12), a new optimization
    was added so that when SQLite is holding secondary journals in memory, less memory
    will be used. Unfortunately, an boundary check in the new logic was coded incorrectly.
    What should have been a "<" operator was coded as "<=". This error might cause
    the secondary journal to enter an inconsistent state if it is ever rolled back.
    If additional changes are made and the outer transaction eventually commits, the
    database might be left in an inconsistent state.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLite [版本 3.35.0](releaselog/3_35_0.html) (2021-03-12) 中，添加了一个新的优化，以便当 SQLite
    在内存中保存辅助日志时，使用的内存更少。不幸的是，新逻辑中的边界检查编码错误。本应该是 "<" 操作符的地方被编写成了 "<="。这个错误可能会导致辅助日志在回滚时进入不一致状态。如果做了额外的更改并且最终提交了外部事务，可能会使数据库处于不一致状态。
- en: This problem was discovered by an [independent researcher](https://sqlite.org/forum/forumpost/b03d86f9516cb3a2)
    who was attempting to find bugs in SQLite using a fuzzer. The fuzzer found a failure
    in an [assert() statement](assert.html) that is used to help verify the internal
    state of the secondary journal. The bug was a sufficiently obscure corner-case
    that it might have gone unnoticed for many years, had it not been for the intensive
    use of assert() statements in SQLite, the persistence and tenacity of the security
    researchers, and their customized state-of-the-art fuzzer.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题是由一位[独立研究者](https://sqlite.org/forum/forumpost/b03d86f9516cb3a2)发现的，他试图使用模糊测试工具在SQLite中找到漏洞。模糊测试工具发现了一个在用于验证辅助日志内部状态的[assert()语句](assert.html)中的故障。这个
    bug 是一个足够隐秘的边缘案例，如果不是 SQLite 中对 assert() 语句的密集使用，安全研究人员的坚持和其定制的最先进的模糊测试工具，这个问题可能会在很多年内被忽略。
- en: This problem was [fixed](https://www.sqlite.org/src/info/73c2b50211d3ae26) in
    [version 3.37.2](releaselog/3_37_2.html) (2022-01-06).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题已经在 [版本 3.37.2](releaselog/3_37_2.html) (2022-01-06) 中 [修复](https://www.sqlite.org/src/info/73c2b50211d3ae26)。
