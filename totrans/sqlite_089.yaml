- en: 1\. Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://sqlite.com/vfs.html](https://sqlite.com/vfs.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This article describes the SQLite OS portability layer or "VFS" - the module
    at the bottom of the SQLite implementation stack that provides portability across
    operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. The VFS In Relation To The Rest Of SQLite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../Images/4c694eef2019b62b0ae37ce4a53f2e48.png)'
  prefs: []
  type: TYPE_IMG
- en: The internal organization of the SQLite library can be viewed as the stack of
    modules shown to the right. The Tokenizer, Parser, and Code Generator components
    are used to process SQL statements and convert them into executable programs in
    a virtual machine language or byte code. Roughly speaking, these top three layers
    implement [sqlite3_prepare_v2()](c3ref/prepare.html). The byte code generated
    by the top three layers is a [prepared statement](c3ref/stmt.html). The Virtual
    Machine module is responsible for running the SQL statement byte code. The B-Tree
    module organizes a database file into multiple key/value stores with ordered keys
    and logarithmic performance. The Pager module is responsible for loading pages
    of the database file into memory, for implementing and controlling transactions,
    and for creating and maintaining the journal files that prevent database corruption
    following a crash or power failure. The OS Interface is a thin abstraction that
    provides a common set of routines for adapting SQLite to run on different operating
    systems. Roughly speaking, the bottom four layers implement [sqlite3_step()](c3ref/step.html).
  prefs: []
  type: TYPE_NORMAL
- en: This article is about the bottom layer.
  prefs: []
  type: TYPE_NORMAL
- en: The OS Interface - also called the "VFS" - is what makes SQLite portable across
    operating systems. Whenever any of the other modules in SQLite needs to communicate
    with the operating system, they invoke methods in the VFS. The VFS then invokes
    the operating-specific code needed to satisfy the request. Hence, porting SQLite
    to a new operating system is simply a matter of writing a new OS interface layer
    or "VFS".
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Multiple VFSes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The standard SQLite source tree contains built-in VFSes for unix and windows.
    Alternative VFSes can be added at start-time or run-time using the [sqlite3_vfs_register()](c3ref/vfs_find.html)
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple VFSes can be registered at the same time. Each VFS has a unique names.
    Separate [database connections](c3ref/sqlite3.html) within the same process can
    be using different VFSes at the same time. For that matter, if a single database
    connection has multiple database files open using the [ATTACH](lang_attach.html)
    command, then each attached database might be using a different VFS.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1\. Standard Unix VFSes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unix builds come with multiple built-in VFSes. The default VFS for unix is
    called "unix" and is used in most applications. Other VFSes that might be found
    in unix (depending on compile-time options) include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**unix-dotfile** - uses dot-file locking rather than POSIX advisory locks.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**unix-excl** - obtains and holds an exclusive lock on database files, preventing
    other processes from accessing the database. Also keeps the [wal-index](walformat.html#shm)
    in heap rather than in shared memory.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**unix-none** - all file locking operations are no-ops.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**unix-namedsem** - uses named semaphores for file locking. VXWorks only.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The various unix VFSes differ only in the way they handle file locking - they
    share most of their implementation in common with one another and are all located
    in the same SQLite source file: [os_unix.c](https://www.sqlite.org/src/doc/trunk/src/os_unix.c).
    Note that except for "unix" and "unix-excl", the various unix VFSes all use incompatible
    locking implementations. If two processes are accessing the same SQLite database
    using different unix VFSes, they may not see each others locks and may end up
    interfering with one another, resulting in database corruption. The "unix-none"
    VFS in particular does no locking at all and will easily result in database corruption
    if used by two or more database connections at the same time. Programmers are
    encouraged to use only "unix" or "unix-excl" unless there is a compelling reason
    to do otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.2\. Standard Windows VFSes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Windows builds also come with multiple built-in VFSes. The default Windows
    VFS is called "win32" and is used in most applications. Other VFSes that might
    be found on windows builds include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**win32-longpath** - like "win32" except that pathnames can be up to 65534
    bytes in length, whereas pathnames max out at 1040 bytes in "win32".'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**win32-none** - all file locking operations are no-ops.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**win32-longpath-none** - combination of "win32-longpath" and "win32-none"
    - long pathnames are supported and all lock operations are no-ops.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As with unix, most of the code for the various Windows VFSes is shared.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3\. Specifying Which VFS To Use
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is always one VFS which is the default VFS. On unix systems, the "unix"
    VFS comes up as the default and on windows it is "win32". If no other actions
    are taken, new database connections will make use of the default VFS.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default VFS can be changed by registering or re-registering the VFS using
    the [sqlite3_vfs_register()](c3ref/vfs_find.html) interface with a second parameter
    of 1\. Hence, if a (unix) process wants to always use the "unix-nolock" VFS in
    place of "unix", the following code would work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'An alternate VFS can also be specified as the 4th parameter to the [sqlite3_open_v2()](c3ref/open.html)
    function. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'Finally, if [URI filenames](uri.html) have been enabled, then the alternative
    VFS can be specified using the "vfs=" parameter on the URI. This technique works
    with [sqlite3_open()](c3ref/open.html), [sqlite3_open16()](c3ref/open.html), [sqlite3_open_v2()](c3ref/open.html),
    and when a new database is [ATTACH](lang_attach.html)-ed to an existing database
    connection. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: The VFS specified by a URI has the highest priority. After that comes a VFS
    specified as the fourth argument to [sqlite3_open_v2()](c3ref/open.html). The
    default VFS is used if no VFS is specified otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4\. VFS Shims
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the point of view of the uppers layers of the SQLite stack, each open database
    file uses exactly one VFS. But in practice, a particular VFS might just be a thin
    wrapper around another VFS that does the real work. We call a wrapper VFS a "shim".
  prefs: []
  type: TYPE_NORMAL
- en: A simple example of a shim is the "vfstrace" VFS. This is a VFS (implemented
    in the [test_vfstrace.c](https://www.sqlite.org/src/doc/trunk/src/test_vfstrace.c)
    source file) that writes a message associated with each VFS method call into a
    log file, then passes control off to another VFS to do the actual work.
  prefs: []
  type: TYPE_NORMAL
- en: 3.5\. Other Example VFSes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are other VFS implementations available in the public SQLite
    source tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[appendvfs.c](https://www.sqlite.org/src/file/ext/misc/appendvfs.c) - This
    VFS allows an SQLite database to be appended to the end of some other file. This
    can be used, for example, to append an SQLite database onto the end of an executable
    such that, when run, it can easily locate the appended database. The [command-line
    shell](cli.html) will use this VFS if launched with the --append option, and its
    .archive command will use it given the --append flag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[test_demovfs.c](https://www.sqlite.org/src/doc/trunk/src/test_demovfs.c) -
    This file implements a very simple VFS named "demo" that uses POSIX functions
    such as open(), read(), write(), fsync(), close(), fsync(), sleep(), time(), and
    so forth. This VFS only works on unix systems. But it is not intended as a replacement
    for the standard "unix" VFS used by default on unix platforms. The "demo" VFS
    is deliberately kept very simple so that it can be used as a learning aid or as
    template for building other VFSes or for porting SQLite to new operating systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[test_quota.c](https://www.sqlite.org/src/doc/trunk/src/test_quota.c) - This
    file implements a shim called "quota" that enforces cumulative file size limits
    on a collection of database files. An auxiliary interface is used to define "quota
    groups". A quota group is a set of files (database files, journals, and temporary
    files) whose names all match a [GLOB](lang_expr.html#glob) pattern. The sum of
    the sizes of all files in each quota group is tracked, and if that sum exceeds
    a threshold defined for the quota group, a callback function is invoked. That
    callback can either increase the threshold or cause the operation that would have
    exceeded the quota to fail with an [SQLITE_FULL](rescode.html#full) error. One
    of the uses of this shim is used to enforce resource limits on application databases
    in Firefox.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[test_multiplex.c](https://www.sqlite.org/src/doc/trunk/src/test_multiplex.c)
    - This file implements a shim that allows database files to exceed the maximum
    file size of the underlying filesystem. This shim presents an interface to the
    upper six layers of SQLite that makes it look like very large files are being
    used, when in reality each such large file is split up into many smaller files
    on the underlying system. This shim has been used, for example, to allow databases
    to grow larger than 2 gibibytes on FAT16 filesystems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[test_onefile.c](https://www.sqlite.org/src/doc/trunk/src/test_onefile.c) -
    This file implements a demonstration VFS named "fs" that shows how SQLite can
    be used on an embedded device that lacks a filesystem. Content is written directly
    to the underlying media. A VFS derived from this demonstration code could be used
    by a gadget with a limited amount of flash memory to make SQLite behave as the
    filesystem for the flash memory on the device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[test_journal.c](https://www.sqlite.org/src/doc/trunk/src/test_journal.c) -
    This file implements a shim used during SQLite testing that verifies that the
    database and rollback journal are written in the correct order and are "synced"
    at appropriate times in order to guarantee that the database can recover from
    a power loss or hard reset at any time. The shim checks several invariants on
    the operation of databases and rollback journals and raises exceptions if any
    of those invariants are violated. These invariants, in turn, assure that the database
    is always recoverable. Running a large suite of test cases using this shim provides
    added assurance that SQLite databases will not be damaged by unexpected power
    failures or device resets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[test_vfs.c](https://www.sqlite.org/src/doc/trunk/src/test_vfs.c) - This file
    implements a shim that can be used to simulate filesystem faults. This shim is
    used during testing to verify that SQLite responses sanely to hardware malfunctions
    or to other error conditions such as running out of filesystem space that are
    difficult to test on a real system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are other VFS implementations both in the core SQLite source code library
    and in available extensions. The list above is not meant to be exhaustive but
    merely representative of the kinds of features that can be realized using the
    VFS interface.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. VFS Implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A new VFS is implemented by subclassing three objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[sqlite3_vfs](c3ref/vfs.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[sqlite3_io_methods](c3ref/io_methods.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[sqlite3_file](c3ref/file.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An [sqlite3_vfs](c3ref/vfs.html) object defines the name of the VFS and the
    core methods that implement the interface to the operating system, such as checking
    for existence of files, deleting files, creating files and opening and for reading
    and/or writing, converting filenames into their canonical form. The [sqlite3_vfs](c3ref/vfs.html)
    object also contains methods for obtaining randomness from the operating system,
    for suspending a process (sleeping) and for finding the current date and time.
  prefs: []
  type: TYPE_NORMAL
- en: The [sqlite3_file](c3ref/file.html) object represents an open file. The xOpen
    method of [sqlite3_vfs](c3ref/vfs.html) constructs an [sqlite3_file](c3ref/file.html)
    object when the file is opened. The [sqlite3_file](c3ref/file.html) keeps track
    of the state of the file while it is opened.
  prefs: []
  type: TYPE_NORMAL
- en: The [sqlite3_io_methods](c3ref/io_methods.html) object holds the methods used
    to interact with an open file. Each [sqlite3_file](c3ref/file.html) contains a
    pointer to an [sqlite3_io_methods](c3ref/io_methods.html) object that is appropriate
    for the file it represents. The [sqlite3_io_methods](c3ref/io_methods.html) object
    contains methods to do things such as read and write from the file, to truncate
    the file, to flush any changes to persistent storage, to find the size of the
    file, to lock and unlock the file, and to close file and destroy the [sqlite3_file](c3ref/file.html)
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the code for a new VFS involves constructing a subclass for the [sqlite3_vfs](c3ref/vfs.html)
    object and then registering that VFS object using a call to [sqlite3_vfs_register()](c3ref/vfs_find.html).
    The VFS implementation also provides subclasses for [sqlite3_file](c3ref/file.html)
    and [sqlite3_io_methods](c3ref/io_methods.html) but those objects are not registered
    directly with SQLite. Instead, the [sqlite3_file](c3ref/file.html) object is returned
    from the xOpen method of [sqlite3_vfs](c3ref/vfs.html) and the [sqlite3_file](c3ref/file.html)
    object points to an instance of the [sqlite3_io_methods](c3ref/io_methods.html)
    object.
  prefs: []
  type: TYPE_NORMAL
