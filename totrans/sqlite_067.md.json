["```sql\nCREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT, c UNIQUE);\n\n```", "```sql\nCREATE TABLE data_t1(a INTEGER, b TEXT, c, rbu_control);\n\n```", "```sql\nCREATE VIRTUAL TABLE x1 USING fts3(a, b);\nCREATE TABLE x1(a, b);\n\n```", "```sql\nCREATE TABLE data_x1(a, b, rbu_rowid, rbu_control);\n\n```", "```sql\nCREATE VIRTUAL TABLE ft1 USING fts4(a, b, languageid='langid');\n\n```", "```sql\nCREATE TABLE data_ft1(a, b, langid, rbu_rowid, rbu_control);\nCREATE TABLE data_ft1(a, b, rbu_rowid, rbu_control);\n\n```", "```sql\nUPDATE t1 SET c = 'usa' WHERE a = 4;\n\n```", "```sql\nINSERT INTO data_t1(a, b, c, rbu_control) VALUES(4, NULL, 'usa', '..x');\n\n```", "```sql\nINSERT INTO data_t1(a, b, c, rbu_control) VALUES(4, NULL, 'usa', '..d');\n\n```", "```sql\nUPDATE t1 SET c = rbu_delta(c, 'usa') WHERE a = 4;\n\n```", "```sql\nINSERT INTO data_ft1(a, b, rbu_rowid, rbu_control) \n  VALUES(NULL, 'usa', 12, '.x');\n\n```", "```sql\nUPDATE ft1 SET b = 'usa' WHERE rowid = 12;\n\n```", "```sql\nCREATE VIRTUAL TABLE ft1 USING fts4(addr, text);\nCREATE VIRTUAL TABLE ft2 USING fts4;             -- implicit \"content\" column\n\n```", "```sql\nCREATE TABLE data_ft1 USING fts4(addr, text, rbu_rowid, rbu_control);\nCREATE TABLE data_ft2 USING fts4(content, rbu_rowid, rbu_control);\n\n```", "```sql\nCREATE TABLE ccc(addr, text);\nCREATE VIRTUAL TABLE ccc_fts USING fts4(addr, text, content=ccc);\n\n```", "```sql\nCREATE TABLE data_ccc(addr, text, rbu_rowid, rbu_control);\nCREATE VIEW data0_ccc_fts AS SELECT * FROM data_ccc;\n\n```", "```sql\n-- Target database schema\nCREATE TABLE ddd(i INTEGER PRIMARY KEY, k TEXT);\nCREATE VIRTUAL TABLE ddd_fts USING fts4(k, content=ddd);\n\n-- RBU database schema\nCREATE TABLE data_ccc(i, k, rbu_control);\nCREATE VIEW data0_ccc_fts AS SELECT i AS rbu_rowid, k, CASE \n  WHEN rbu_control IN (0,1) THEN rbu_control ELSE substr(rbu_control, 2) END\nFROM data_ccc;\n\n```", "```sql\nsqldiff --rbu t1.db t2.db\n\n```", "```sql\nsqldiff --rbu --table <*virtual-table-name*> t1.db t2.db\n\n```", "```sql\n*/**\n*** Either start a new RBU vacuum or resume a suspended RBU vacuum on* \n*** database zTarget. Return when either an error occurs, the RBU* \n*** vacuum is finished or when the application signals an interrupt*\n*** (code not shown).*\n****\n*** If the RBU vacuum is completed successfully, return SQLITE_DONE.*\n*** If an error occurs, return SQLite error code. Or, if the application*\n*** signals an interrupt, suspend the RBU vacuum operation so that it*\n*** may be resumed by a subsequent call to this function and return*\n*** SQLITE_OK.*\n****\n*** This function uses the database named \"<zTarget>-vacuum\" for*\n*** the state database, where <zTarget> is the name of the database* \n*** being vacuumed.*\n**/*\nint do_rbu_vacuum(const char *zTarget){\n  int rc;\n  char *zState;                   */* Name of state database */*\n  sqlite3rbu *pRbu;               */* RBU vacuum handle */*\n\n  zState = sqlite3_mprintf(\"%s-vacuum\", zTarget);\n  if( zState==0 ) return SQLITE_NOMEM;\n  pRbu = sqlite3rbu_vacuum(zTarget, zState);\n  sqlite3_free(zState);\n\n  if( pRbu ){\n    sqlite3 *dbTarget = sqlite3rbu_db(pRbu, 0);\n    sqlite3 *dbState = sqlite3rbu_db(pRbu, 1);\n\n    */* Any custom collation sequences used by the target database must*\n    *** be registered with both database handles here.  */*\n\n    while( sqlite3rbu_step(pRbu)==SQLITE_OK ){\n      if( *<application has signaled interrupt>* ) break;\n    }\n  }\n  rc = sqlite3rbu_close(pRbu);\n  return rc;\n}\n\n```"]