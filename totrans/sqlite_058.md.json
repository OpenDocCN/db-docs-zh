["```sql\n/* This example uses the pthreads API */\n#include <pthread.h>\n\n/*\n** A pointer to an instance of this structure is passed as the user-context\n** pointer when registering for an unlock-notify callback.\n*/\ntypedef struct UnlockNotification UnlockNotification;\nstruct UnlockNotification {\n  int fired;                         /* True after unlock event has occurred */\n  pthread_cond_t cond;               /* Condition variable to wait on */\n  pthread_mutex_t mutex;             /* Mutex to protect structure */\n};\n\n/*\n** This function is an unlock-notify callback registered with SQLite.\n*/\nstatic void unlock_notify_cb(void **apArg, int nArg){\n  int i;\n  for(i=0; i<nArg; i++){\n    UnlockNotification *p = (UnlockNotification *)apArg[i];\n    pthread_mutex_lock(&p->mutex);\n    p->fired = 1;\n    pthread_cond_signal(&p->cond);\n    pthread_mutex_unlock(&p->mutex);\n  }\n}\n\n/*\n** This function assumes that an SQLite API call (either [sqlite3_prepare_v2](c3ref/prepare.html)() \n** or [sqlite3_step](c3ref/step.html)()) has just returned SQLITE_LOCKED. The argument is the\n** associated database connection.\n**\n** This function calls [sqlite3_unlock_notify](c3ref/unlock_notify.html)() to register for an \n** unlock-notify callback, then blocks until that callback is delivered \n** and returns SQLITE_OK. The caller should then retry the failed operation.\n**\n** Or, if [sqlite3_unlock_notify](c3ref/unlock_notify.html)() indicates that to block would deadlock \n** the system, then this function returns SQLITE_LOCKED immediately. In \n** this case the caller should not retry the operation and should roll \n** back the current transaction (if any).\n*/\nstatic int wait_for_unlock_notify(sqlite3 *db){\n  int rc;\n  UnlockNotification un;\n\n  /* Initialize the UnlockNotification structure. */\n  un.fired = 0;\n  pthread_mutex_init(&un.mutex, 0);\n  pthread_cond_init(&un.cond, 0);\n\n  /* Register for an unlock-notify callback. */\n  rc = sqlite3_unlock_notify(db, unlock_notify_cb, (void *)&un);\n  assert( rc==SQLITE_LOCKED || rc==SQLITE_OK );\n\n  /* The call to [sqlite3_unlock_notify](c3ref/unlock_notify.html)() always returns either SQLITE_LOCKED \n ** or SQLITE_OK. \n **\n ** If SQLITE_LOCKED was returned, then the system is deadlocked. In this\n ** case this function needs to return SQLITE_LOCKED to the caller so \n ** that the current transaction can be rolled back. Otherwise, block\n ** until the unlock-notify callback is invoked, then return SQLITE_OK.\n  */\n  if( rc==SQLITE_OK ){\n    pthread_mutex_lock(&un.mutex);\n    if( !un.fired ){\n      pthread_cond_wait(&un.cond, &un.mutex);\n    }\n    pthread_mutex_unlock(&un.mutex);\n  }\n\n  /* Destroy the mutex and condition variables. */\n  pthread_cond_destroy(&un.cond);\n  pthread_mutex_destroy(&un.mutex);\n\n  return rc;\n}\n\n/*\n** This function is a wrapper around the SQLite function [sqlite3_step](c3ref/step.html)().\n** It functions in the same way as step(), except that if a required\n** shared-cache lock cannot be obtained, this function may block waiting for\n** the lock to become available. In this scenario the normal API step()\n** function always returns SQLITE_LOCKED.\n**\n** If this function returns SQLITE_LOCKED, the caller should rollback\n** the current transaction (if any) and try again later. Otherwise, the\n** system may become deadlocked.\n*/\nint sqlite3_blocking_step(sqlite3_stmt *pStmt){\n  int rc;\n  while( SQLITE_LOCKED==(rc = sqlite3_step(pStmt)) ){\n    rc = wait_for_unlock_notify(sqlite3_db_handle(pStmt));\n    if( rc!=SQLITE_OK ) break;\n    sqlite3_reset(pStmt);\n  }\n  return rc;\n}\n\n/*\n** This function is a wrapper around the SQLite function [sqlite3_prepare_v2](c3ref/prepare.html)().\n** It functions in the same way as prepare_v2(), except that if a required\n** shared-cache lock cannot be obtained, this function may block waiting for\n** the lock to become available. In this scenario the normal API prepare_v2()\n** function always returns SQLITE_LOCKED.\n**\n** If this function returns SQLITE_LOCKED, the caller should rollback\n** the current transaction (if any) and try again later. Otherwise, the\n** system may become deadlocked.\n*/\nint sqlite3_blocking_prepare_v2(\n  sqlite3 *db,              /* Database handle. */\n  const char *zSql,         /* UTF-8 encoded SQL statement. */\n  int nSql,                 /* Length of zSql in bytes. */\n  sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */\n  const char **pz           /* OUT: End of parsed string */\n){\n  int rc;\n  while( SQLITE_LOCKED==(rc = sqlite3_prepare_v2(db, zSql, nSql, ppStmt, pz)) ){\n    rc = wait_for_unlock_notify(db);\n    if( rc!=SQLITE_OK ) break;\n  }\n  return rc;\n}\n\n```"]