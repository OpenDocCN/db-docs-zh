- en: Moving From SQLite 3.4.2 to 3.5.0
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从SQLite 3.4.2升级到3.5.0
- en: 原文：[https://sqlite.com/34to35.html](https://sqlite.com/34to35.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://sqlite.com/34to35.html](https://sqlite.com/34to35.html)
- en: SQLite version 3.5.0 (2007-09-04) introduces a new OS interface layer that is
    incompatible with all prior versions of SQLite. In addition, a few existing interfaces
    have been generalized to work across all database connections within a process
    rather than just all connections within a thread. The purpose of this article
    is to describe the changes to 3.5.0 in detail so that users of prior versions
    of SQLite can judge what, if any, effort will be required to upgrade to newer
    versions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 3.5.0版本（2007-09-04）引入了一个新的操作系统接口层，与所有先前版本的SQLite都不兼容。此外，一些现有接口已经泛化，可以在进程内所有数据库连接中使用，而不仅限于线程内的所有连接。本文的目的是详细描述3.5.0版本的变更，以便SQLite先前版本的用户可以评估升级到新版本所需的工作量，如果有的话。
- en: 1.0 Overview Of Changes
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.0 变更概述
- en: A quick enumeration of the changes in SQLite version 3.5.0 is provided here.
    Subsequent sections will describe these changes in more detail.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里提供了SQLite 3.5.0版本变更的快速概述。后续章节将更详细地描述这些变更。
- en: 'The OS interface layer has been completely reworked:'
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作系统接口层已完全重建：
- en: The undocumented **sqlite3_os_switch()** interface has been removed.
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 未记录的**sqlite3_os_switch()**接口已被移除。
- en: The **SQLITE_ENABLE_REDEF_IO** compile-time flag no longer functions. I/O procedures
    are now always redefinable.
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译时标志**SQLITE_ENABLE_REDEF_IO**不再起作用。现在，I/O过程总是可重定义的。
- en: 'Three new objects are defined for specifying I/O procedures: [sqlite3_vfs](c3ref/vfs.html),
    [sqlite3_file](c3ref/file.html), and [sqlite3_io_methods](c3ref/io_methods.html).'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义了三个新对象用于指定I/O过程：[sqlite3_vfs](https://sqlite.com/c3ref/vfs.html)，[sqlite3_file](https://sqlite.com/c3ref/file.html)，和[sqlite3_io_methods](https://sqlite.com/c3ref/io_methods.html)。
- en: 'Three new interfaces are used to create alternative OS interfaces: [sqlite3_vfs_register()](c3ref/vfs_find.html),
    [sqlite3_vfs_unregister()](c3ref/vfs_find.html), and [sqlite3_vfs_find()](c3ref/vfs_find.html).'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加了三个新接口用于创建替代操作系统接口：[sqlite3_vfs_register()](https://sqlite.com/c3ref/vfs_find.html)，[sqlite3_vfs_unregister()](https://sqlite.com/c3ref/vfs_find.html)和[sqlite3_vfs_find()](https://sqlite.com/c3ref/vfs_find.html)。
- en: 'A new interface has been added to provided additional control over the creation
    of new database connections: [sqlite3_open_v2()](c3ref/open.html). The legacy
    interfaces of [sqlite3_open()](c3ref/open.html) and [sqlite3_open16()](c3ref/open.html)
    continue to be fully supported.'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加了一个新接口，用于在创建新数据库连接时提供额外的控制：[sqlite3_open_v2()](https://sqlite.com/c3ref/open.html)。传统接口[sqlite3_open()](https://sqlite.com/c3ref/open.html)和[sqlite3_open16()](https://sqlite.com/c3ref/open.html)仍然得到完全支持。
- en: The optional shared cache and memory management features that were introduced
    in version 3.3.0 can now be used across multiple threads within the same process.
    Formerly, these extensions only applied to database connections operating within
    a single thread.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引入于版本3.3.0的可选共享缓存和内存管理功能现在可以在同一进程内的多个线程中使用。以前，这些扩展仅适用于单线程内操作的数据库连接。
- en: The [sqlite3_enable_shared_cache()](c3ref/enable_shared_cache.html) interface
    now applies to all threads within a process, not to just the one thread in which
    it was run.
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[sqlite3_enable_shared_cache()](c3ref/enable_shared_cache.html) 接口现在适用于进程中的所有线程，而不仅限于调用它的那个线程。'
- en: The [sqlite3_soft_heap_limit()](c3ref/soft_heap_limit.html) interface now applies
    to all threads within a process, not to just the one thread in which it was run.
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[sqlite3_soft_heap_limit()](c3ref/soft_heap_limit.html) 接口现在适用于进程中的所有线程，而不仅限于调用它的那个线程。'
- en: The [sqlite3_release_memory()](c3ref/release_memory.html) interface will now
    attempt to reduce the memory usages across all database connections in all threads,
    not just connections in the thread where the interface is called.
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[sqlite3_release_memory()](c3ref/release_memory.html) 接口现在尝试减少所有线程中所有数据库连接的内存使用，而不仅限于调用接口的线程中的连接。'
- en: The [sqlite3_thread_cleanup()](c3ref/aggregate_count.html) interface has become
    a no-op.
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[sqlite3_thread_cleanup()](c3ref/aggregate_count.html) 接口现在成为一个空操作。'
- en: Restrictions on the use of the same database connection by multiple threads
    have been dropped. It is now safe for multiple threads to use the same database
    connection at the same time.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不再限制同一数据库连接同时被多个线程使用。现在多个线程可以同时使用同一个数据库连接是安全的。
- en: There is now a compile-time option that allows an application to define alternative
    malloc()/free() implementations without having to modify any core SQLite code.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在有一个编译时选项，允许应用定义替代的malloc()/free()实现，而无需修改任何核心SQLite代码。
- en: There is now a compile-time option that allows an application to define alternative
    mutex implementations without having to modify any core SQLite code.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在有一个编译时选项，允许应用定义替代的互斥体实现，而无需修改任何核心SQLite代码。
- en: Of these changes, only 1a and 2a through 2c are incompatibilities in any formal
    sense. But users who have previously made custom modifications to the SQLite source
    (for example to add a custom OS layer for embedded hardware) might find that these
    changes have a larger impact. On the other hand, an important goal of these changes
    is to make it much easier to customize SQLite for use on different operating systems.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变更中，只有1a和2a到2c是在任何正式意义上的不兼容性。但之前对SQLite源代码进行过自定义修改（例如为嵌入式硬件添加自定义操作系统层）的用户可能会发现这些变更影响更大。另一方面，这些变更的一个重要目标是，使得在不同操作系统上定制SQLite变得更加容易。
- en: 2.0 The OS Interface Layer
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.0 操作系统接口层
- en: If your system defines a custom OS interface for SQLite or if you were using
    the undocumented **sqlite3_os_switch()** interface, then you will need to make
    modifications in order to upgrade to SQLite version 3.5.0\. This may seem painful
    at first glance. But as you look more closely, you will probably discover that
    your changes are made smaller and easier to understand and manage by the new SQLite
    interface. It is likely that your changes will now also work seamlessly with the
    SQLite amalgamation. You will no longer need to make any changes to the code SQLite
    source code. All of your changes can be effected by application code and you can
    link against a standard, unmodified version of the SQLite amalgamation. Furthermore,
    the OS interface layer, which was formerly undocumented, is now an officially
    support interface for SQLite. So you have some assurance that this will be a one-time
    change and that your new backend will continue to work in future versions of SQLite.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的系统定义了SQLite的自定义操作系统接口，或者如果您正在使用未记录的 **sqlite3_os_switch()** 接口，那么您需要进行修改以升级到SQLite版本3.5.0。乍一看这可能看起来很痛苦。但是仔细查看后，您可能会发现通过新的SQLite接口，您的更改变得更小、更容易理解和管理。您的更改现在可能也会与SQLite合并版无缝配合工作。您将不再需要对SQLite源代码进行任何更改。所有的更改都可以通过应用程序代码进行，并且您可以链接到标准、未修改的SQLite合并版。此外，以前未记录的操作系统接口层现在是SQLite的官方支持接口。因此，您可以确信这将是一次性的更改，并且您的新后端将在将来的SQLite版本中继续工作。
- en: 2.1 The Virtual File System Object
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1 虚拟文件系统对象
- en: The new OS interface for SQLite is built around an object named [sqlite3_vfs](c3ref/vfs.html).
    The "vfs" stands for "Virtual File System". The sqlite3_vfs object is basically
    a structure containing pointers to functions that implement the primitive disk
    I/O operations that SQLite needs to perform in order to read and write databases.
    In this article, we will often refer to an sqlite3_vfs objects as a "VFS".
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite的新操作系统接口围绕名为 [sqlite3_vfs](c3ref/vfs.html) 的对象构建。这里的"vfs"代表"虚拟文件系统"。sqlite3_vfs对象基本上是一个包含指向实现SQLite需要执行的原始磁盘I/O操作的函数指针的结构。在本文中，我们经常将sqlite3_vfs对象称为"VFS"。
- en: SQLite is able to use multiple VFSes at the same time. Each individual database
    connection is associated with just one VFS. But if you have multiple database
    connections, each connection can be associated with a different VFS.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite能够同时使用多个VFS。每个单独的数据库连接只与一个VFS相关联。但是，如果您有多个数据库连接，则每个连接可以与不同的VFS相关联。
- en: There is always a default VFS. The legacy interfaces [sqlite3_open()](c3ref/open.html)
    and [sqlite3_open16()](c3ref/open.html) always use the default VFS. The new interface
    for creating database connections, [sqlite3_open_v2()](c3ref/open.html), allows
    you to specify which VFS you want to use by name.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 总是有一个默认的VFS。传统接口 [sqlite3_open()](c3ref/open.html) 和 [sqlite3_open16()](c3ref/open.html)
    总是使用默认的VFS。新的创建数据库连接接口 [sqlite3_open_v2()](c3ref/open.html) 允许您通过名称指定要使用的VFS。
- en: 2.1.1 Registering New VFS Objects
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.1 注册新的VFS对象
- en: 'Standard builds of SQLite for Unix or Windows come with a single VFS named
    "unix" or "win32", as appropriate. This one VFS is also the default. So if you
    are using the legacy open functions, everything will continue to operate as it
    has before. The change is that an application now has the flexibility of adding
    new VFS modules to implement a customized OS layer. The [sqlite3_vfs_register()](c3ref/vfs_find.html)
    API can be used to tell SQLite about one or more application-defined VFS modules:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 Unix 或 Windows 上的 SQLite 构建都带有一个名为 "unix" 或 "win32" 的单一 VFS，适当时使用。这个 VFS
    也是默认的。因此，如果你在使用旧的打开函数，一切将继续像以前一样运行。改变的是，现在应用程序可以灵活地添加新的 VFS 模块来实现定制的操作系统层。可以使用
    [sqlite3_vfs_register()](c3ref/vfs_find.html) API 来告诉 SQLite 关于一个或多个应用程序定义的 VFS
    模块：
- en: '[PRE0]'
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Applications can call sqlite3_vfs_register() at any time, though of course a
    VFS needs to be registered before it can be used. The first argument is a pointer
    to a customized VFS object that the application has prepared. The second argument
    is true to make the new VFS the default VFS so that it will be used by the legacy
    [sqlite3_open()](c3ref/open.html) and [sqlite3_open16()](c3ref/open.html) APIs.
    If the new VFS is not the default, then you will probably have to use the new
    [sqlite3_open_v2()](c3ref/open.html) API to use it. Note, however, that if a new
    VFS is the only VFS known to SQLite (if SQLite was compiled without its usual
    default VFS or if the precompiled default VFS was removed using [sqlite3_vfs_unregister()](c3ref/vfs_find.html))
    then the new VFS automatically becomes the default VFS regardless of the makeDflt
    argument to [sqlite3_vfs_register()](c3ref/vfs_find.html).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以在任何时候调用 sqlite3_vfs_register()，尽管需要在使用之前注册 VFS。第一个参数是应用程序准备的自定义 VFS 对象的指针。第二个参数为
    true，以使新的 VFS 成为默认 VFS，这样它将被旧的 [sqlite3_open()](c3ref/open.html) 和 [sqlite3_open16()](c3ref/open.html)
    API 使用。如果新的 VFS 不是默认的，则可能需要使用新的 [sqlite3_open_v2()](c3ref/open.html) API 来使用它。但请注意，如果新的
    VFS 是 SQLite 知道的唯一 VFS（如果 SQLite 没有使用通常的默认 VFS 编译，或者使用 [sqlite3_vfs_unregister()](c3ref/vfs_find.html)
    移除了预编译的默认 VFS），则无论 [sqlite3_vfs_register()](c3ref/vfs_find.html) 的 makeDflt 参数如何，新的
    VFS 都会自动成为默认 VFS。
- en: Standard builds include the default "unix" or "win32" VFSes. But if you use
    the -DOS_OTHER=1 compile-time option, then SQLite is built without a default VFS.
    In that case, the application must register at least one VFS prior to calling
    [sqlite3_open()](c3ref/open.html). This is the approach that embedded applications
    should use. Rather than modifying the SQLite source to insert an alternative OS
    layer as was done in prior releases of SQLite, instead compile an unmodified SQLite
    source file (preferably the amalgamation) with the -DOS_OTHER=1 option, then invoke
    [sqlite3_vfs_register()](c3ref/vfs_find.html) to define the interface to the underlying
    filesystem prior to creating any database connections.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 标准构建包括默认的 "unix" 或 "win32" VFS。但如果使用了 -DOS_OTHER=1 编译时选项，则 SQLite 将没有默认的 VFS。在这种情况下，应用程序在调用
    [sqlite3_open()](c3ref/open.html) 之前必须至少注册一个 VFS。这是嵌入式应用程序应采用的方法。与修改 SQLite 源代码以插入替代
    OS 层相比（在以前版本的 SQLite 中执行的操作），更好的做法是使用 -DOS_OTHER=1 选项编译未修改的 SQLite 源文件（最好是汇总文件），然后在创建任何数据库连接之前调用
    [sqlite3_vfs_register()](c3ref/vfs_find.html) 定义底层文件系统的接口。
- en: 2.1.2 Additional Control Over VFS Objects
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.2 对 VFS 对象的额外控制
- en: The [sqlite3_vfs_unregister()](c3ref/vfs_find.html) API is used to remove an
    existing VFS from the system.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[sqlite3_vfs_unregister()](c3ref/vfs_find.html) API 用于从系统中移除现有的 VFS。'
- en: '[PRE1]'
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The [sqlite3_vfs_find()](c3ref/vfs_find.html) API is used to locate a particular
    VFS by name. Its prototype is as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[sqlite3_vfs_find()](c3ref/vfs_find.html) API 用于按名称查找特定的 VFS。其原型如下：'
- en: '[PRE2]'
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The argument is the symbolic name for the desired VFS. If the argument is a
    NULL pointer, then the default VFS is returned. The function returns a pointer
    to the [sqlite3_vfs](c3ref/vfs.html) object that implements the VFS. Or it returns
    a NULL pointer if no object could be found that matched the search criteria.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是所需 VFS 的符号名称。如果参数是 NULL 指针，则返回默认 VFS。该函数返回指向实现 VFS 的 [sqlite3_vfs](c3ref/vfs.html)
    对象的指针。如果找不到符合搜索条件的对象，则返回 NULL 指针。
- en: 2.1.3 Modifications Of Existing VFSes
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.3 修改现有 VFS
- en: Once a VFS has been registered, it should never be modified. If a change in
    behavior is required, a new VFS should be registered. The application could, perhaps,
    use [sqlite3_vfs_find()](c3ref/vfs_find.html) to locate the old VFS, make a copy
    of the old VFS into a new [sqlite3_vfs](c3ref/vfs.html) object, make the desired
    modifications to the new VFS, unregister the old VFS, then register the new VFS
    in its place. Existing database connections would continue to use the old VFS
    even after it is unregistered, but new database connections would use the new
    VFS.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦注册了 VFS，就不应再修改它。如果需要改变行为，则应注册一个新的 VFS。应用程序可以使用 [sqlite3_vfs_find()](c3ref/vfs_find.html)
    定位旧 VFS，将旧 VFS 复制到新的 [sqlite3_vfs](c3ref/vfs.html) 对象中，并对新的 VFS 进行所需的修改，然后注销旧
    VFS，并注册新的 VFS 替代其位置。即使在注销后，现有的数据库连接仍将继续使用旧的 VFS，但新的数据库连接将使用新的 VFS。
- en: 2.1.4 The VFS Object
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.4 VFS 对象
- en: 'A VFS object is an instance of the following structure:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: VFS 对象是以下结构的实例：
- en: '[PRE3]'
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To create a new VFS, an application fills in an instance of this structure with
    appropriate values and then calls [sqlite3_vfs_register()](c3ref/vfs_find.html).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新的VFS，应用程序需用适当的值填充此结构的实例，然后调用[sqlite3_vfs_register()](c3ref/vfs_find.html)。
- en: The iVersion field of [sqlite3_vfs](c3ref/vfs.html) should be 1 for SQLite version
    3.5.0. This number may increase in future versions of SQLite if we have to modify
    the VFS object in some way. We hope that this never happens, but the provision
    is made in case it does.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[sqlite3_vfs](c3ref/vfs.html)的`iVersion`字段应为1，适用于SQLite版本3.5.0。如果我们必须以某种方式修改VFS对象，SQLite未来的版本中这个数字可能会增加。我们希望这种情况永远不会发生，但做了相应的准备。'
- en: 'The szOsFile field is the size in bytes of the structure that defines an open
    file: the [sqlite3_file](c3ref/file.html) object. This object will be described
    more fully below. The point here is that each VFS implementation can define its
    own [sqlite3_file](c3ref/file.html) object containing whatever information the
    VFS implementation needs to store about an open file. SQLite needs to know how
    big this object is, however, in order to preallocate enough space to hold it.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`szOsFile`字段是定义打开文件的结构（[sqlite3_file](c3ref/file.html)对象）的字节大小。稍后会更详细地描述此对象。这里的重点是，每个VFS实现都可以定义自己的[sqlite3_file](c3ref/file.html)对象，包含VFS实现需要存储的任何信息。然而，SQLite需要知道这个对象的大小，以便预先分配足够的空间来容纳它。'
- en: The mxPathname field is the maximum length of a file pathname that this VFS
    can use. SQLite sometimes has to preallocate buffers of this size, so it should
    be as small as reasonably possible. Some filesystems permit huge pathnames, but
    in practice pathnames rarely extend beyond 100 bytes or so. You do not have to
    put the longest pathname that the underlying filesystem can handle here. You only
    have to put the longest pathname that you want SQLite to be able to handle. A
    few hundred is a good value in most cases.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`mxPathname`字段是此VFS可使用的文件路径名的最大长度。有时SQLite必须预分配这么大的缓冲区，因此应尽量保持较小。某些文件系统允许巨大的路径名，但实际上路径名很少超过大约100字节。您不必将底层文件系统能处理的最长路径名放在这里。您只需放入希望SQLite能够处理的最长路径名。在大多数情况下，几百字节是个不错的值。'
- en: The pNext field is used internally by SQLite. Specifically, SQLite uses this
    field to form a linked list of registered VFSes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`pNext`字段由SQLite内部使用。具体来说，SQLite使用此字段来形成注册VFS的链表。'
- en: The zName field is the symbolic name of the VFS. This is the name that the [sqlite3_vfs_find()](c3ref/vfs_find.html)
    compares against when it is looking for a VFS.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`zName`字段是VFS的符号名称。这是在寻找VFS时，[sqlite3_vfs_find()](c3ref/vfs_find.html)与之比较的名称。'
- en: The pAppData pointer is unused by the SQLite core. The pointer is available
    to store auxiliary information that a VFS information might want to carry around.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 指针`pAppData`在SQLite核心中未被使用。该指针可用于存储VFS信息可能需要携带的辅助信息。
- en: 'The remaining fields of the [sqlite3_vfs](c3ref/vfs.html) object all store
    pointers to functions that implement primitive operations. We call these "methods".
    The first method, xOpen, is used to open files on the underlying storage media.
    The result is an [sqlite3_file](c3ref/file.html) object. There are additional
    methods, defined by the [sqlite3_file](c3ref/file.html) object itself that are
    used to read and write and close the file. The additional methods are detailed
    below. The filename is in UTF-8. SQLite will guarantee that the zFilename string
    passed to xOpen() is a full pathname as generated by xFullPathname() and that
    the string will be valid and unchanged until xClose() is called. So the [sqlite3_file](c3ref/file.html)
    can store a pointer to the filename if it needs to remember the filename for some
    reason. The flags argument to xOpen() is a copy of the flags argument to sqlite3_open_v2().
    If sqlite3_open() or sqlite3_open16() is used, then flags is [SQLITE_OPEN_READWRITE](c3ref/c_open_autoproxy.html)
    | [SQLITE_OPEN_CREATE](c3ref/c_open_autoproxy.html). If xOpen() opens a file read-only
    then it sets *pOutFlags to include [SQLITE_OPEN_READONLY](c3ref/c_open_autoproxy.html).
    Other bits in *pOutFlags may be set. SQLite will also add one of the following
    flags to the xOpen() call, depending on the object being opened:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[sqlite3_vfs](c3ref/vfs.html) 对象的其余字段都存储指向实现基本操作的函数指针。我们称这些为“方法”。第一个方法，xOpen，用于打开底层存储介质上的文件。其结果是一个
    [sqlite3_file](c3ref/file.html) 对象。 [sqlite3_file](c3ref/file.html) 对象本身定义了其他用于读取、写入和关闭文件的方法。以下详细介绍了其他方法。文件名使用
    UTF-8 编码。SQLite 将保证传递给 xOpen() 的 zFilename 字符串是由 xFullPathname() 生成的完整路径名，并且该字符串在调用
    xClose() 之前是有效且不变的。因此，如果需要记住文件名， [sqlite3_file](c3ref/file.html) 可以存储指向文件名的指针。传递给
    xOpen() 的 flags 参数是 sqlite3_open_v2() 的 flags 参数的副本。如果使用 sqlite3_open() 或 sqlite3_open16()，则
    flags 是 [SQLITE_OPEN_READWRITE](c3ref/c_open_autoproxy.html) | [SQLITE_OPEN_CREATE](c3ref/c_open_autoproxy.html)。如果
    xOpen() 以只读方式打开文件，则设置 *pOutFlags 来包含 [SQLITE_OPEN_READONLY](c3ref/c_open_autoproxy.html)。*pOutFlags
    中可能设置其他位。SQLite 还将根据正在打开的对象之一向 xOpen() 调用添加以下标志之一：'
- en: '[SQLITE_OPEN_MAIN_DB](c3ref/c_open_autoproxy.html)'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQLITE_OPEN_MAIN_DB](c3ref/c_open_autoproxy.html)'
- en: '[SQLITE_OPEN_MAIN_JOURNAL](c3ref/c_open_autoproxy.html)'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQLITE_OPEN_MAIN_JOURNAL](c3ref/c_open_autoproxy.html)'
- en: '[SQLITE_OPEN_TEMP_DB](c3ref/c_open_autoproxy.html)'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQLITE_OPEN_TEMP_DB](c3ref/c_open_autoproxy.html)'
- en: '[SQLITE_OPEN_TEMP_JOURNAL](c3ref/c_open_autoproxy.html)'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQLITE_OPEN_TEMP_JOURNAL](c3ref/c_open_autoproxy.html)'
- en: '[SQLITE_OPEN_TRANSIENT_DB](c3ref/c_open_autoproxy.html)'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQLITE_OPEN_TRANSIENT_DB](c3ref/c_open_autoproxy.html)'
- en: '[SQLITE_OPEN_SUBJOURNAL](c3ref/c_open_autoproxy.html)'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQLITE_OPEN_SUBJOURNAL](c3ref/c_open_autoproxy.html)'
- en: '[SQLITE_OPEN_SUPER_JOURNAL](c3ref/c_open_autoproxy.html)'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQLITE_OPEN_SUPER_JOURNAL](c3ref/c_open_autoproxy.html)'
- en: 'The file I/O implementation can use the object type flags to changes the way
    it deals with files. For example, an application that does not care about crash
    recovery or rollback, might make the open of a journal file a no-op. Writes to
    this journal are also a no-op. Any attempt to read the journal returns [SQLITE_IOERR](rescode.html#ioerr).
    Or the implementation might recognize the a database file will be doing page-aligned
    sector reads and writes in a random order and set up its I/O subsystem accordingly.
    SQLite might also add one of the following flags to the xOpen method:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 I/O 实现可以使用对象类型标志来改变它处理文件的方式。例如，一个不关心崩溃恢复或回滚的应用程序可能会将日志文件的打开操作设为无操作。对此日志文件的写操作也将是无操作。任何尝试读取日志文件的操作都会返回
    [SQLITE_IOERR](rescode.html#ioerr)。或者实现可以识别数据库文件将以随机顺序进行页对齐扇区读写，并相应地设置其 I/O 子系统。SQLite
    也可能在 xOpen 方法中添加以下标志之一：
- en: '[SQLITE_OPEN_DELETEONCLOSE](c3ref/c_open_autoproxy.html)'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQLITE_OPEN_DELETEONCLOSE](c3ref/c_open_autoproxy.html)'
- en: '[SQLITE_OPEN_EXCLUSIVE](c3ref/c_open_autoproxy.html)'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQLITE_OPEN_EXCLUSIVE](c3ref/c_open_autoproxy.html)'
- en: The [SQLITE_OPEN_DELETEONCLOSE](c3ref/c_open_autoproxy.html) flag means the
    file should be deleted when it is closed. This will always be set for TEMP databases
    and journals and for subjournals. The [SQLITE_OPEN_EXCLUSIVE](c3ref/c_open_autoproxy.html)
    flag means the file should be opened for exclusive access. This flag is set for
    all files except for the main database file. The [sqlite3_file](c3ref/file.html)
    structure passed as the third argument to xOpen is allocated by the caller. xOpen
    just fills it in. The caller allocates a minimum of szOsFile bytes for the [sqlite3_file](c3ref/file.html)
    structure.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQLITE_OPEN_DELETEONCLOSE](c3ref/c_open_autoproxy.html) 标志表示文件在关闭时应删除。这个标志总是为临时数据库、日志文件以及子日志设置。[SQLITE_OPEN_EXCLUSIVE](c3ref/c_open_autoproxy.html)
    标志表示文件应该以独占方式打开。除了主数据库文件外，所有文件都设置了这个标志。作为第三个参数传递给 xOpen 的 [sqlite3_file](c3ref/file.html)
    结构由调用者分配。xOpen 只是填充它。调用者为 [sqlite3_file](c3ref/file.html) 结构分配至少 szOsFile 字节。'
- en: 'The differences between an [SQLITE_OPEN_TEMP_DB](c3ref/c_open_autoproxy.html)
    database and an [SQLITE_OPEN_TRANSIENT_DB](c3ref/c_open_autoproxy.html) database
    is this: The [SQLITE_OPEN_TEMP_DB](c3ref/c_open_autoproxy.html) is used for explicitly
    declared and named TEMP tables (using the CREATE TEMP TABLE syntax) or for named
    tables in a temporary database that is created by opening a database with a filename
    that is an empty string. An [SQLITE_OPEN_TRANSIENT_DB](c3ref/c_open_autoproxy.html)
    holds a database table that SQLite creates automatically in order to evaluate
    a subquery or ORDER BY or GROUP BY clause. Both TEMP_DB and TRANSIENT_DB databases
    are private and are deleted automatically. TEMP_DB databases last for the duration
    of the database connection. TRANSIENT_DB databases last only for the duration
    of a single SQL statement.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQLITE_OPEN_TEMP_DB](c3ref/c_open_autoproxy.html) 数据库与 [SQLITE_OPEN_TRANSIENT_DB](c3ref/c_open_autoproxy.html)
    数据库的区别在于：[SQLITE_OPEN_TEMP_DB](c3ref/c_open_autoproxy.html) 用于显式声明和命名的 TEMP 表（使用
    CREATE TEMP TABLE 语法）或用于通过以空字符串作为文件名打开数据库而创建的临时数据库中的命名表。[SQLITE_OPEN_TRANSIENT_DB](c3ref/c_open_autoproxy.html)
    包含 SQLite 自动创建的用于评估子查询、ORDER BY 或 GROUP BY 子句的数据库表。TEMP_DB 和 TRANSIENT_DB 数据库都是私有的并且会自动删除。TEMP_DB
    数据库持续整个数据库连接的时间。TRANSIENT_DB 数据库只持续单个 SQL 语句的时间。'
- en: The xDelete method is used to delete a file. The name of the file is given in
    the second parameter. The filename will be in UTF-8. The VFS must convert the
    filename into whatever character representation the underlying operating system
    expects. If the syncDir parameter is true, then the xDelete method should not
    return until the change to the directory contents for the directory containing
    the deleted file have been synced to disk in order to ensure that the file does
    not "reappear" if a power failure occurs soon after.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`xDelete` 方法用于删除文件。文件名在第二个参数中给出，文件名将采用 UTF-8 编码。虚拟文件系统（VFS）必须将文件名转换为底层操作系统期望的字符表示。如果
    `syncDir` 参数为真，则 `xDelete` 方法在目录内容发生变化后应该一直等待，直到这些变化同步到磁盘，以确保如果在断电后不会再次“出现”该文件。'
- en: The xAccess method is used to check for access permissions on a file. The filename
    will be UTF-8 encoded. The flags argument will be [SQLITE_ACCESS_EXISTS](c3ref/c_access_exists.html)
    to check for the existence of the file, [SQLITE_ACCESS_READWRITE](c3ref/c_access_exists.html)
    to check to see if the file is both readable and writable, or [SQLITE_ACCESS_READ](c3ref/c_access_exists.html)
    to check to see if the file is at least readable. The "file" named by the second
    parameter might be a directory or folder name.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`xAccess` 方法用于检查文件的访问权限。文件名将采用 UTF-8 编码。`flags` 参数可以是 [SQLITE_ACCESS_EXISTS](c3ref/c_access_exists.html)
    用于检查文件是否存在，[SQLITE_ACCESS_READWRITE](c3ref/c_access_exists.html) 用于检查文件是否可读写，或者
    [SQLITE_ACCESS_READ](c3ref/c_access_exists.html) 用于检查文件是否至少可读。第二个参数指定的“文件”可能是一个目录名。'
- en: The xGetTempName method computes the name of a temporary file that SQLite can
    use. The name should be written into the buffer given by the second parameter.
    SQLite will size that buffer to hold at least mxPathname bytes. The generated
    filename should be in UTF-8. To avoid security problems, the generated temporary
    filename should contain enough randomness to prevent an attacker from guessing
    the temporary filename in advance.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `xGetTempName` 用于计算 SQLite 可以使用的临时文件的名称。名称应写入由第二个参数给出的缓冲区。SQLite 将调整该缓冲区的大小以容纳至少
    `mxPathname` 字节。生成的文件名应为 UTF-8 编码。为了避免安全问题，生成的临时文件名应包含足够的随机性，以防止攻击者提前猜测临时文件名。
- en: The xFullPathname method is used to convert a relative pathname into a full
    pathname. The resulting full pathname is written into the buffer provided by the
    third parameter. SQLite will size the output buffer to at least mxPathname bytes.
    Both the input and output names should be in UTF-8.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `xFullPathname` 用于将相对路径名转换为完整路径名。结果的完整路径名写入由第三个参数提供的缓冲区。SQLite 将调整输出缓冲区的大小至少为
    `mxPathname` 字节。输入和输出名称都应为 UTF-8 编码。
- en: The xDlOpen, xDlError, xDlSym, and xDlClose methods are all used for accessing
    shared libraries at run-time. These methods may be omitted (and their pointers
    set to zero) if the library is compiled with [SQLITE_OMIT_LOAD_EXTENSION](compile.html#omit_load_extension)
    or if the [sqlite3_enable_load_extension()](c3ref/enable_load_extension.html)
    interface is never used to enable dynamic extension loading. The xDlOpen method
    opens a shared library or DLL and returns a pointer to a handle. NULL is returned
    if the open fails. If the open fails, the xDlError method can be used to obtain
    a text error message. The message is written into the zErrMsg buffer of the third
    parameter which is at least nByte bytes in length. The xDlSym returns a pointer
    to a symbol in the shared library. The name of the symbol is given by the second
    parameter. UTF-8 encoding is assumed. If the symbol is not found a NULL pointer
    is returned. The xDlClose routine closes the shared library.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `xDlOpen`、`xDlError`、`xDlSym` 和 `xDlClose` 用于在运行时访问共享库。如果库使用 [SQLITE_OMIT_LOAD_EXTENSION](compile.html#omit_load_extension)
    编译，或者从未使用 [sqlite3_enable_load_extension()](c3ref/enable_load_extension.html)
    接口启用动态扩展加载，则可以省略这些方法（将它们的指针设为零）。方法 `xDlOpen` 打开共享库或 DLL 并返回一个句柄指针。如果打开失败，返回 NULL。打开失败时，可以使用方法
    `xDlError` 获取文本错误消息。消息写入第三个参数的 `zErrMsg` 缓冲区，该缓冲区长度至少为 `nByte` 字节。方法 `xDlSym`
    返回共享库中符号的指针。符号的名称由第二个参数给出。假定为 UTF-8 编码。如果未找到符号，则返回 NULL 指针。方法 `xDlClose` 关闭共享库。
- en: 'The xRandomness method is used exactly once to initialize the pseudo-random
    number generator (PRNG) inside of SQLite. Only the xRandomness method on the default
    VFS is used. The xRandomness methods on other VFSes are never accessed by SQLite.
    The xRandomness routine requests that nByte bytes of randomness be written into
    zOut. The routine returns the actual number of bytes of randomness obtained. The
    quality of the randomness so obtained will determine the quality of the randomness
    generated by built-in SQLite functions such as random() and randomblob(). SQLite
    also uses its PRNG to generate temporary file names. On some platforms (ex: Windows)
    SQLite assumes that temporary file names are unique without actually testing for
    collisions, so it is important to have good-quality randomness even if the random()
    and randomblob() functions are never used.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: xRandomness 方法仅被用于初始化 SQLite 内的伪随机数生成器（PRNG），且仅在默认的 VFS 上使用。其他 VFS 上的 xRandomness
    方法从未被 SQLite 访问过。xRandomness 程序请求将 nByte 字节的随机性写入 zOut。该程序返回实际获取的随机性字节数。所获取的随机性质量将决定内置
    SQLite 函数（如 random() 和 randomblob()）生成的随机性质量。SQLite 还使用其 PRNG 来生成临时文件名。在某些平台上（例如：Windows），SQLite
    假设临时文件名是唯一的，即使未实际测试碰撞，因此即使不使用 random() 和 randomblob() 函数，拥有高质量的随机性也很重要。
- en: The xSleep method is used to suspend the calling thread for at least the number
    of microseconds given. This method is used to implement the [sqlite3_sleep()](c3ref/sleep.html)
    and [sqlite3_busy_timeout()](c3ref/busy_timeout.html) APIs. In the case of [sqlite3_sleep()](c3ref/sleep.html)
    the xSleep method of the default VFS is always used. If the underlying system
    does not have a microsecond resolution sleep capability, then the sleep time should
    be rounded up. xSleep returns this rounded-up value.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: xSleep 方法用于至少挂起给定微秒数的调用线程。该方法用于实现 [sqlite3_sleep()](c3ref/sleep.html) 和 [sqlite3_busy_timeout()](c3ref/busy_timeout.html)
    API。在 [sqlite3_sleep()](c3ref/sleep.html) 的情况下，总是使用默认 VFS 的 xSleep 方法。如果底层系统没有微秒级分辨率的休眠功能，则休眠时间应向上舍入。xSleep
    返回这个向上舍入的值。
- en: The xCurrentTime method finds the current time and date and writes the result
    as a double-precision floating point value into pointer provided by the second
    parameter. The time and date is in coordinated universal time (UTC) and is a fractional
    Julian day number.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: xCurrentTime 方法查找当前时间和日期，并将结果写入由第二个参数提供的双精度浮点指针中。时间和日期以协调世界时（UTC）表示，并且是一个分数化的儒略日数。
- en: 2.1.5 The Open File Object
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.5 打开文件对象
- en: 'The result of opening a file is an instance of an [sqlite3_file](c3ref/file.html)
    object. The [sqlite3_file](c3ref/file.html) object is an abstract base class defined
    as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件的结果是一个 [sqlite3_file](c3ref/file.html) 对象的实例。[sqlite3_file](c3ref/file.html)
    对象是一个抽象基类，定义如下：
- en: '[PRE4]'
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Each VFS implementation will subclass the [sqlite3_file](c3ref/file.html) by
    adding additional fields at the end to hold whatever information the VFS needs
    to know about an open file. It does not matter what information is stored as long
    as the total size of the structure does not exceed the szOsFile value recorded
    in the [sqlite3_vfs](c3ref/vfs.html) object.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 VFS 实现都会通过在结尾添加额外的字段来继承 [sqlite3_file](c3ref/file.html)，以保存 VFS 需要了解的关于打开文件的任何信息。存储的信息并不重要，只要结构的总大小不超过
    [sqlite3_vfs](c3ref/vfs.html) 对象中记录的 szOsFile 值即可。
- en: 'The [sqlite3_io_methods](c3ref/io_methods.html) object is a structure that
    contains pointers to methods for reading, writing, and otherwise dealing with
    files. This object is defined as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[sqlite3_io_methods](c3ref/io_methods.html) 对象是一个包含指向处理文件读取、写入及其他操作方法的指针的结构。该对象定义如下：'
- en: '[PRE5]'
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The iVersion field of [sqlite3_io_methods](c3ref/io_methods.html) is provided
    as insurance against future enhancements. The iVersion value should always be
    1 for SQLite version 3.5.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[sqlite3_io_methods](c3ref/io_methods.html) 的 iVersion 字段是为了应对未来的增强而提供的保险措施。对于
    SQLite 版本 3.5，iVersion 值应始终为 1。'
- en: The xClose method closes the file. The space for the [sqlite3_file](c3ref/file.html)
    structure is deallocated by the caller. But if the [sqlite3_file](c3ref/file.html)
    contains pointers to other allocated memory or resources, those allocations should
    be released by the xClose method.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: xClose 方法关闭文件。调用者释放 [sqlite3_file](c3ref/file.html) 结构的空间。但是，如果 [sqlite3_file](c3ref/file.html)
    包含指向其他分配的内存或资源的指针，则这些分配应该由 xClose 方法释放。
- en: The xRead method reads iAmt bytes from the file beginning at a byte offset to
    iOfst. The data read is stored in the pointer of the second parameter. xRead returns
    the [SQLITE_OK](rescode.html#ok) on success, [SQLITE_IOERR_SHORT_READ](rescode.html#ioerr_short_read)
    if it was not able to read the full number of bytes because it reached end-of-file,
    or [SQLITE_IOERR_READ](rescode.html#ioerr_read) for any other error.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: xRead 方法从文件的字节偏移 iOfst 处开始读取 iAmt 字节。读取的数据存储在第二个参数的指针中。如果成功，xRead 返回 [SQLITE_OK](rescode.html#ok)，如果因为达到文件末尾而未能读取完整的字节数，则返回
    [SQLITE_IOERR_SHORT_READ](rescode.html#ioerr_short_read)，其他任何错误都返回 [SQLITE_IOERR_READ](rescode.html#ioerr_read)。
- en: The xWrite method writes iAmt bytes of data from the second parameter into the
    file beginning at an offset of iOfst bytes. If the size of the file is less than
    iOfst bytes prior to the write, then xWrite should ensure that the file is extended
    with zeros up to iOfst bytes prior to beginning its write. xWrite continues to
    extends the file as necessary so that the size of the file is at least iAmt+iOfst
    bytes at the conclusion of the xWrite call. The xWrite method returns [SQLITE_OK](rescode.html#ok)
    on success. If the write cannot complete because the underlying storage medium
    is full, then [SQLITE_FULL](rescode.html#full) is returned. [SQLITE_IOERR_WRITE](rescode.html#ioerr_write)
    should be returned for any other error.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: xWrite 方法从第二个参数开始的偏移量 iOfst 字节处向文件写入 iAmt 字节数据。如果写入前文件的大小小于 iOfst 字节，则 xWrite
    应确保在开始写入之前将文件扩展到 iOfst 字节并填充零。xWrite 持续扩展文件以确保在 xWrite 调用结束时文件的大小至少为 iAmt+iOfst
    字节。xWrite 方法在成功时返回 [SQLITE_OK](rescode.html#ok)。如果由于底层存储介质已满而导致写入无法完成，则返回 [SQLITE_FULL](rescode.html#full)。对于其他任何错误则返回
    [SQLITE_IOERR_WRITE](rescode.html#ioerr_write)。
- en: The xTruncate method truncates a file to be nByte bytes in length. If the file
    is already nByte bytes or less in length then this method is a no-op. The xTruncate
    method returns [SQLITE_OK](rescode.html#ok) on success and [SQLITE_IOERR_TRUNCATE](rescode.html#ioerr_truncate)
    if anything goes wrong.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: xTruncate 方法将文件截断为 nByte 字节长度。如果文件已经少于或等于 nByte 字节长度，则此方法不做任何操作。xTruncate 方法在成功时返回
    [SQLITE_OK](rescode.html#ok)，如果出现任何问题则返回 [SQLITE_IOERR_TRUNCATE](rescode.html#ioerr_truncate)。
- en: The xSync method is used to force previously written data out of operating system
    cache and into non-volatile memory. The second parameter is usually [SQLITE_SYNC_NORMAL](c3ref/c_sync_dataonly.html).
    If the second parameter is [SQLITE_SYNC_FULL](c3ref/c_sync_dataonly.html) then
    the xSync method should make sure that data has also been flushed through the
    disk controllers cache. The [SQLITE_SYNC_FULL](c3ref/c_sync_dataonly.html) parameter
    is the equivalent of the F_FULLSYNC ioctl() on Mac OS X. The xSync method returns
    [SQLITE_OK](rescode.html#ok) on success and [SQLITE_IOERR_FSYNC](rescode.html#ioerr_fsync)
    if anything goes wrong.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: xSync 方法用于强制将先前写入的数据从操作系统缓存刷入非易失性存储器。第二个参数通常是 [SQLITE_SYNC_NORMAL](c3ref/c_sync_dataonly.html)。如果第二个参数是
    [SQLITE_SYNC_FULL](c3ref/c_sync_dataonly.html)，则 xSync 方法应确保数据也已通过磁盘控制器的缓存刷入。[SQLITE_SYNC_FULL](c3ref/c_sync_dataonly.html)
    参数相当于在 Mac OS X 上的 F_FULLSYNC ioctl()。xSync 方法在成功时返回 [SQLITE_OK](rescode.html#ok)，如果出现任何问题则返回
    [SQLITE_IOERR_FSYNC](rescode.html#ioerr_fsync)。
- en: The xFileSize() method determines the current size of the file in bytes and
    writes that value into *pSize. It returns [SQLITE_OK](rescode.html#ok) on success
    and [SQLITE_IOERR_FSTAT](rescode.html#ioerr_fstat) if something goes wrong.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: xFileSize() 方法确定文件当前的字节大小，并将该值写入 *pSize。成功时返回 [SQLITE_OK](rescode.html#ok)，如果出现问题则返回
    [SQLITE_IOERR_FSTAT](rescode.html#ioerr_fstat)。
- en: 'The xLock and xUnlock methods are used to set and clear file locks. SQLite
    supports five levels of file locks, in order:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`xLock` 和 `xUnlock` 方法用于设置和清除文件锁。SQLite 支持五种文件锁级别，依次为：'
- en: '[SQLITE_LOCK_NONE](c3ref/c_lock_exclusive.html)'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQLITE_LOCK_NONE](c3ref/c_lock_exclusive.html)'
- en: '[SQLITE_LOCK_SHARED](c3ref/c_lock_exclusive.html)'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQLITE_LOCK_SHARED](c3ref/c_lock_exclusive.html)'
- en: '[SQLITE_LOCK_RESERVED](c3ref/c_lock_exclusive.html)'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQLITE_LOCK_RESERVED](c3ref/c_lock_exclusive.html)'
- en: '[SQLITE_LOCK_PENDING](c3ref/c_lock_exclusive.html)'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQLITE_LOCK_PENDING](c3ref/c_lock_exclusive.html)'
- en: '[SQLITE_LOCK_EXCLUSIVE](c3ref/c_lock_exclusive.html)'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQLITE_LOCK_EXCLUSIVE](c3ref/c_lock_exclusive.html)'
- en: The underlying implementation can support some subset of these locking levels
    as long as it meets the other requirements of this paragraph. The locking level
    is specified as the second argument to both xLock and xUnlock. The xLock method
    increases the locking level to the specified locking level or higher. The xUnlock
    method decreases the locking level to no lower than the level specified. [SQLITE_LOCK_NONE](c3ref/c_lock_exclusive.html)
    means that the file is unlocked. [SQLITE_LOCK_SHARED](c3ref/c_lock_exclusive.html)
    gives permission to read the file. Multiple database connections can hold [SQLITE_LOCK_SHARED](c3ref/c_lock_exclusive.html)
    at the same time. [SQLITE_LOCK_RESERVED](c3ref/c_lock_exclusive.html) is like
    [SQLITE_LOCK_SHARED](c3ref/c_lock_exclusive.html) in that it is permission to
    read the file. But only a single connection can hold a reserved lock at any point
    in time. The [SQLITE_LOCK_PENDING](c3ref/c_lock_exclusive.html) is also permission
    to read the file. Other connections can continue to read the file as well, but
    no other connection is allowed to escalate a lock from none to shared. [SQLITE_LOCK_EXCLUSIVE](c3ref/c_lock_exclusive.html)
    is permission to write on the file. Only a single connection can hold an exclusive
    lock and no other connection can hold any lock (other than "none") while one connection
    holds an exclusive lock. The xLock returns [SQLITE_OK](rescode.html#ok) on success,
    [SQLITE_BUSY](rescode.html#busy) if it is unable to obtain the lock, or [SQLITE_IOERR_RDLOCK](rescode.html#ioerr_rdlock)
    if something else goes wrong. The xUnlock method returns [SQLITE_OK](rescode.html#ok)
    on success and [SQLITE_IOERR_UNLOCK](rescode.html#ioerr_unlock) for problems.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 实现的底层可以支持这些锁定级别的某个子集，只要满足本段的其他要求。锁定级别被指定为`xLock`和`xUnlock`的第二个参数。`xLock`方法将锁定级别增加到指定的级别或更高。`xUnlock`方法将锁定级别降低到不低于指定的级别。[SQLITE_LOCK_NONE](c3ref/c_lock_exclusive.html)表示文件未锁定。[SQLITE_LOCK_SHARED](c3ref/c_lock_exclusive.html)允许读取文件。多个数据库连接可以同时持有[SQLITE_LOCK_SHARED](c3ref/c_lock_exclusive.html)。[SQLITE_LOCK_RESERVED](c3ref/c_lock_exclusive.html)与[SQLITE_LOCK_SHARED](c3ref/c_lock_exclusive.html)类似，允许读取文件，但是任何时候只能有一个连接持有保留锁。[SQLITE_LOCK_PENDING](c3ref/c_lock_exclusive.html)也允许读取文件。其他连接也可以继续读取文件，但是不允许其他连接将锁从无锁升级为共享锁。[SQLITE_LOCK_EXCLUSIVE](c3ref/c_lock_exclusive.html)允许写文件。只能有一个连接持有排他锁，并且在一个连接持有排他锁时，其他连接不能持有任何锁（除了“无锁”）。`xLock`在成功时返回[SQLITE_OK](rescode.html#ok)，如果无法获得锁则返回[SQLITE_BUSY](rescode.html#busy)，如果发生其他问题则返回[SQLITE_IOERR_RDLOCK](rescode.html#ioerr_rdlock)。`xUnlock`方法在成功时返回[SQLITE_OK](rescode.html#ok)，在出现问题时返回[SQLITE_IOERR_UNLOCK](rescode.html#ioerr_unlock)。
- en: The xCheckReservedLock() method checks to see if another connection or another
    process is currently holding a reserved, pending, or exclusive lock on the file.
    It returns true or false.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`xCheckReservedLock()`方法用于检查另一个连接或进程是否当前持有文件的保留、挂起或排他锁。它返回true或false。'
- en: The xFileControl() method is a generic interface that allows custom VFS implementations
    to directly control an open file using the (new and experimental) [sqlite3_file_control()](c3ref/file_control.html)
    interface. The second "op" argument is an integer opcode. The third argument is
    a generic pointer which is intended to be a pointer to a structure that may contain
    arguments or space in which to write return values. Potential uses for xFileControl()
    might be functions to enable blocking locks with timeouts, to change the locking
    strategy (for example to use dot-file locks), to inquire about the status of a
    lock, or to break stale locks. The SQLite core reserves opcodes less than 100
    for its own use. A [list of opcodes](c3ref/c_fcntl_begin_atomic_write.html#sqlitefcntllockstate)
    less than 100 is available. Applications that define a custom xFileControl method
    should use opcodes greater than 100 to avoid conflicts.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: xFileControl() 方法是一个通用接口，允许自定义 VFS 实现直接控制打开的文件，使用（新的实验性）[sqlite3_file_control()](c3ref/file_control.html)
    接口。第二个 "op" 参数是一个整数操作码。第三个参数是一个通用指针，预期指向一个可能包含参数或用于写入返回值的结构体指针。xFileControl()
    的潜在用途可能包括启用带有超时的阻塞锁功能，更改锁定策略（例如使用点文件锁），查询锁的状态，或者解除过期锁定。SQLite 核心保留了小于 100 的操作码供自身使用。可以查看小于
    100 的 [操作码列表](c3ref/c_fcntl_begin_atomic_write.html#sqlitefcntllockstate)。定义自定义
    xFileControl 方法的应用程序应使用大于 100 的操作码以避免冲突。
- en: The xSectorSize returns the "sector size" of the underlying non-volatile media.
    A "sector" is defined as the smallest unit of storage that can be written without
    disturbing adjacent storage. On a disk drive the "sector size" has until recently
    been 512 bytes, though there is a push to increase this value to 4KiB. SQLite
    needs to know the sector size so that it can write a full sector at a time, and
    thus avoid corrupting adjacent storage space if a power loss occurs in the middle
    of a write.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: xSectorSize 方法返回底层非易失性介质的 "扇区大小"。一个 "扇区" 被定义为可以在不干扰相邻存储的情况下写入的最小存储单元。在磁盘驱动器上，"扇区大小"
    直到最近一直为 512 字节，尽管目前有推动将该值增加到 4KiB。SQLite 需要知道扇区大小，以便可以一次写入一个完整的扇区，从而在写入过程中发生断电时避免损坏相邻存储空间。
- en: 'The xDeviceCharacteristics method returns an integer bit vector that defines
    any special properties that the underlying storage medium might have that SQLite
    can use to increase performance. The allowed return is the bit-wise OR of the
    following values:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: xDeviceCharacteristics 方法返回一个整数位向量，定义了底层存储介质可能具有的特殊属性，SQLite 可以利用这些属性来提高性能。允许的返回值是以下值的按位
    OR 结果：
- en: '[SQLITE_IOCAP_ATOMIC](c3ref/c_iocap_atomic.html)'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQLITE_IOCAP_ATOMIC](c3ref/c_iocap_atomic.html)'
- en: '[SQLITE_IOCAP_ATOMIC512](c3ref/c_iocap_atomic.html)'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQLITE_IOCAP_ATOMIC512](c3ref/c_iocap_atomic.html)'
- en: '[SQLITE_IOCAP_ATOMIC1K](c3ref/c_iocap_atomic.html)'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQLITE_IOCAP_ATOMIC1K](c3ref/c_iocap_atomic.html)'
- en: '[SQLITE_IOCAP_ATOMIC2K](c3ref/c_iocap_atomic.html)'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQLITE_IOCAP_ATOMIC2K](c3ref/c_iocap_atomic.html)'
- en: '[SQLITE_IOCAP_ATOMIC4K](c3ref/c_iocap_atomic.html)'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQLITE_IOCAP_ATOMIC4K](c3ref/c_iocap_atomic.html)'
- en: '[SQLITE_IOCAP_ATOMIC8K](c3ref/c_iocap_atomic.html)'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQLITE_IOCAP_ATOMIC8K](c3ref/c_iocap_atomic.html)'
- en: '[SQLITE_IOCAP_ATOMIC16K](c3ref/c_iocap_atomic.html)'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQLITE_IOCAP_ATOMIC16K](c3ref/c_iocap_atomic.html)'
- en: '[SQLITE_IOCAP_ATOMIC32K](c3ref/c_iocap_atomic.html)'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQLITE_IOCAP_ATOMIC32K](c3ref/c_iocap_atomic.html)'
- en: '[SQLITE_IOCAP_ATOMIC64K](c3ref/c_iocap_atomic.html)'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQLITE_IOCAP_ATOMIC64K](c3ref/c_iocap_atomic.html)'
- en: '[SQLITE_IOCAP_SAFE_APPEND](c3ref/c_iocap_atomic.html)'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQLITE_IOCAP_SAFE_APPEND](c3ref/c_iocap_atomic.html)'
- en: '[SQLITE_IOCAP_SEQUENTIAL](c3ref/c_iocap_atomic.html)'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQLITE_IOCAP_SEQUENTIAL](c3ref/c_iocap_atomic.html)'
- en: The [SQLITE_IOCAP_ATOMIC](c3ref/c_iocap_atomic.html) bit means that all writes
    to this device are atomic in the sense that either the entire write occurs or
    none of it occurs. The other [SQLITE_IOCAP_ATOMIC*nnn*](c3ref/c_iocap_atomic.html)
    values indicate that writes of aligned blocks of the indicated size are atomic.
    [SQLITE_IOCAP_SAFE_APPEND](c3ref/c_iocap_atomic.html) means that when extending
    a file with new data, the new data is written first and then the file size is
    updated. So if a power failure occurs, there is no chance that the file might
    have been extended with randomness. The [SQLITE_IOCAP_SEQUENTIAL](c3ref/c_iocap_atomic.html)
    bit means that all writes occur in the order that they are issued and are not
    reordered by the underlying file system.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQLITE_IOCAP_ATOMIC](c3ref/c_iocap_atomic.html)位表示对此设备的所有写入是原子的，即要么整个写入发生，要么根本不发生。其他[SQLITE_IOCAP_ATOMIC*nnn*](c3ref/c_iocap_atomic.html)值指示对齐块的写入是原子的，大小由指定的值决定。[SQLITE_IOCAP_SAFE_APPEND](c3ref/c_iocap_atomic.html)意味着在用新数据扩展文件时，会先写入新数据，然后更新文件大小。因此，如果发生电源故障，则不会出现文件可能被随机扩展的情况。[SQLITE_IOCAP_SEQUENTIAL](c3ref/c_iocap_atomic.html)位表示所有写入按照发出的顺序进行，不会被底层文件系统重新排序。'
- en: 2.1.6 Checklist For Constructing A New VFS
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.6 构建新VFS的检查表
- en: 'The preceding paragraphs contain a lot of information. To ease the task of
    constructing a new VFS for SQLite we offer the following implementation checklist:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的段落包含大量信息。为了简化为SQLite构建新VFS的任务，我们提供以下实现检查表：
- en: Define an appropriate subclass of the [sqlite3_file](c3ref/file.html) object.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个适当的[sqlite3_file](c3ref/file.html)对象的子类。
- en: Implement the methods required by the [sqlite3_io_methods](c3ref/io_methods.html)
    object.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现[sqlite3_io_methods](c3ref/io_methods.html)对象所需的方法。
- en: Create a static and constant [sqlite3_io_methods](c3ref/io_methods.html) object
    containing pointers to the methods from the previous step.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个静态和常量的[sqlite3_io_methods](c3ref/io_methods.html)对象，包含指向前一步方法的指针。
- en: Implement the xOpen method that opens a file and populates an [sqlite3_file](c3ref/file.html)
    object, including setting pMethods to point to the [sqlite3_io_methods](c3ref/io_methods.html)
    object from the previous step.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现xOpen方法，打开文件并填充一个[sqlite3_file](c3ref/file.html)对象，包括将pMethods设置为指向上一步中的[sqlite3_io_methods](c3ref/io_methods.html)对象。
- en: Implement the other methods required by [sqlite3_vfs](c3ref/vfs.html).
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现[sqlite3_vfs](c3ref/vfs.html)需要的其他方法。
- en: Define a static (but not constant) [sqlite3_vfs](c3ref/vfs.html) structure that
    contains pointers to the xOpen method and the other methods and which contains
    the appropriate values for iVersion, szOsFile, mxPathname, zName, and pAppData.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个静态（但不是常量的）[sqlite3_vfs](c3ref/vfs.html) 结构体，其中包含指向 xOpen 方法和其他方法的指针，并包含
    iVersion、szOsFile、mxPathname、zName 和 pAppData 的适当值。
- en: Implement a procedure that calls [sqlite3_vfs_register()](c3ref/vfs_find.html)
    and passes it a pointer to the [sqlite3_vfs](c3ref/vfs.html) structure from the
    previous step. This procedure is probably the only exported symbol in the source
    file that implements your VFS.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个过程，调用 [sqlite3_vfs_register()](c3ref/vfs_find.html)，并传递上一步中的 [sqlite3_vfs](c3ref/vfs.html)
    结构体的指针。这个过程可能是实现你的VFS的源文件中唯一导出的符号。
- en: Within your application, call the procedure implemented in the last step above
    as part of your initialization process before any database connections are opened.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序中，在打开任何数据库连接之前，在初始化过程中调用上述最后一步实现的过程。
- en: 3.0 The Memory Allocation Subsystem
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.0 内存分配子系统
- en: Beginning with version 3.5, SQLite obtains all of the heap memory it needs using
    the routines [sqlite3_malloc()](c3ref/free.html), [sqlite3_free()](c3ref/free.html),
    and [sqlite3_realloc()](c3ref/free.html). These routines have existed in prior
    versions of SQLite, but SQLite has previously bypassed these routines and used
    its own memory allocator. This all changes in version 3.5.0.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 3.5 开始，SQLite 使用 [sqlite3_malloc()](c3ref/free.html)、[sqlite3_free()](c3ref/free.html)
    和 [sqlite3_realloc()](c3ref/free.html) 这些例程来获取所有需要的堆内存。这些例程在 SQLite 的先前版本中已存在，但
    SQLite 以前绕过了这些例程，使用自己的内存分配器。在 3.5.0 版本中，这一切都发生了变化。
- en: The SQLite source tree actually contains multiple versions of the memory allocator.
    The default high-speed version found in the "mem1.c" source file is used for most
    builds. But if the SQLITE_MEMDEBUG flag is enabled, a separate memory allocator
    the "mem2.c" source file is used instead. The mem2.c allocator implements lots
    of hooks to do error checking and to simulate memory allocation failures for testing
    purposes. Both of these allocators use the malloc()/free() implementation in the
    standard C library.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 源码树实际上包含多个版本的内存分配器。在大多数构建中，默认的高速版本位于 "mem1.c" 源文件中。但如果启用了 SQLITE_MEMDEBUG
    标志，则会使用另一个内存分配器，即 "mem2.c" 源文件。mem2.c 分配器实现了大量钩子来进行错误检查，并模拟用于测试目的的内存分配失败。这两个分配器都使用标准
    C 库中的 malloc()/free() 实现。
- en: Applications are not required to use either of these standard memory allocators.
    If SQLite is compiled with [SQLITE_OMIT_MEMORY_ALLOCATION](compile.html#omitfeatures)
    then no implementation for the [sqlite3_malloc()](c3ref/free.html), [sqlite3_realloc()](c3ref/free.html),
    and [sqlite3_free()](c3ref/free.html) functions is provided. Instead, the application
    that links against SQLite must provide its own implementation of these functions.
    The application provided memory allocator is not required to use the malloc()/free()
    implementation in the standard C library. An embedded application might provide
    an alternative memory allocator that uses memory for a fixed memory pool set aside
    for the exclusive use of SQLite, for example.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序不需要使用这两种标准内存分配器中的任何一种。如果SQLite是用[SQLITE_OMIT_MEMORY_ALLOCATION](compile.html#omitfeatures)编译的，则不提供[sqlite3_malloc()](c3ref/free.html)，[sqlite3_realloc()](c3ref/free.html)和[sqlite3_free()](c3ref/free.html)函数的实现。而是链接到SQLite的应用程序必须提供这些函数的自己的实现。应用程序提供的内存分配器不需要使用标准C库中的malloc()/free()实现。例如，嵌入式应用程序可以提供一个替代内存分配器，该分配器使用专门为SQLite的固定内存池设置的内存。
- en: 'Applications that implement their own memory allocator must provide implementation
    for the usual three allocation functions [sqlite3_malloc()](c3ref/free.html),
    [sqlite3_realloc()](c3ref/free.html), and [sqlite3_free()](c3ref/free.html). And
    they must also implement a fourth function:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 实现自己内存分配器的应用程序必须提供通常的三个分配函数[sqlite3_malloc()](c3ref/free.html)，[sqlite3_realloc()](c3ref/free.html)和[sqlite3_free()](c3ref/free.html)的实现。它们还必须实现第四个函数：
- en: '[PRE6]'
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The [sqlite3_memory_alarm](c3ref/aggregate_count.html) routine is used to register
    a callback on memory allocation events. This routine registers or clears a callback
    that fires when the amount of memory allocated exceeds iThreshold. Only a single
    callback can be registered at a time. Each call to [sqlite3_memory_alarm()](c3ref/aggregate_count.html)
    overwrites the previous callback. The callback is disabled by setting xCallback
    to a NULL pointer.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[sqlite3_memory_alarm](c3ref/aggregate_count.html)例程用于在内存分配事件上注册回调。此例程注册或清除一个回调，当分配的内存量超过iThreshold时触发。每次只能注册一个回调。每次调用[sqlite3_memory_alarm()](c3ref/aggregate_count.html)都会覆盖先前的回调。通过将xCallback设置为NULL指针来禁用回调。'
- en: The parameters to the callback are the pArg value, the amount of memory currently
    in use, and the size of the allocation that provoked the callback. The callback
    will presumably invoke [sqlite3_free()](c3ref/free.html) to free up memory space.
    The callback may invoke [sqlite3_malloc()](c3ref/free.html) or [sqlite3_realloc()](c3ref/free.html)
    but if it does, no additional callbacks will be invoked by the recursive calls.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数的参数是pArg值，当前正在使用的内存量以及引发回调的分配大小。回调函数可能会调用[sqlite3_free()](c3ref/free.html)来释放内存空间。回调函数可能会调用[sqlite3_malloc()](c3ref/free.html)或[sqlite3_realloc()](c3ref/free.html)，但如果调用，递归调用将不会再调用任何其他回调函数。
- en: The [sqlite3_soft_heap_limit()](c3ref/soft_heap_limit.html) interface works
    by registering a memory alarm at the soft heap limit and invoking [sqlite3_release_memory()](c3ref/release_memory.html)
    in the alarm callback. Application programs should not attempt to use the [sqlite3_memory_alarm()](c3ref/aggregate_count.html)
    interface because doing so will interfere with the [sqlite3_soft_heap_limit()](c3ref/soft_heap_limit.html)
    module. This interface is exposed only so that applications can provide their
    own alternative implementation when the SQLite core is compiled with [SQLITE_OMIT_MEMORY_ALLOCATION](compile.html#omitfeatures).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[sqlite3_soft_heap_limit()](c3ref/soft_heap_limit.html) 接口通过在软堆限制处注册内存警报，并在警报回调中调用
    [sqlite3_release_memory()](c3ref/release_memory.html) 来工作。应用程序不应尝试使用 [sqlite3_memory_alarm()](c3ref/aggregate_count.html)
    接口，因为这样做会干扰 [sqlite3_soft_heap_limit()](c3ref/soft_heap_limit.html) 模块。此接口仅暴露给应用程序，以便在编译
    SQLite 核心时使用 [SQLITE_OMIT_MEMORY_ALLOCATION](compile.html#omitfeatures) 时提供其自己的替代实现。'
- en: 'The built-in memory allocators in SQLite also provide the following additional
    interfaces:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 内置的内存分配器还提供以下额外的接口：
- en: '[PRE7]'
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These interfaces can be used by an application to monitor how much memory SQLite
    is using. The [sqlite3_memory_used()](c3ref/memory_highwater.html) routine returns
    the number of bytes of memory currently in use and the [sqlite3_memory_highwater()](c3ref/memory_highwater.html)
    returns the maximum instantaneous memory usage. Neither routine includes the overhead
    associated with the memory allocator. These routines are provided for use by the
    application. SQLite never invokes them itself. So if the application is providing
    its own memory allocation subsystem, it can omit these interfaces if desired.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以使用这些接口来监视 SQLite 正在使用的内存量。[sqlite3_memory_used()](c3ref/memory_highwater.html)
    例程返回当前正在使用的内存字节数，而 [sqlite3_memory_highwater()](c3ref/memory_highwater.html) 则返回最大瞬时内存使用量。这些例程都不包括与内存分配器相关的开销。这些例程是为应用程序提供的。SQLite
    本身从不调用它们。因此，如果应用程序提供自己的内存分配子系统，则可以根据需要省略这些接口。
- en: 4.0 The Mutex Subsystem
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.0 互斥子系统
- en: SQLite has always been threadsafe in the sense that it is safe to use different
    SQLite database connections in different threads at the same time. The constraint
    was that the same database connection could not be used in two separate threads
    at once. SQLite version 3.5.0 relaxes this constraint.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 在“同一时间可以在不同线程中使用不同的 SQLite 数据库连接”这个意义上始终是线程安全的。约束条件是不能在两个独立的线程中同时使用同一个数据库连接。SQLite
    版本 3.5.0 放宽了这个约束条件。
- en: 'In order to allow multiple threads to use the same database connection at the
    same time, SQLite must make extensive use of mutexes. And for this reason a new
    mutex subsystem as been added. The mutex subsystem as the following interface:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许多个线程同时使用同一个数据库连接，SQLite 必须大量使用互斥锁。因此，新增了一个新的互斥子系统。互斥子系统具有以下接口：
- en: '[PRE8]'
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Though these routines exist for the use of the SQLite core, application code
    is free to use these routines as well, if desired. A mutex is an [sqlite3_mutex](c3ref/mutex.html)
    object. The [sqlite3_mutex_alloc()](c3ref/mutex_alloc.html) routine allocates
    a new mutex object and returns a pointer to it. The argument to [sqlite3_mutex_alloc()](c3ref/mutex_alloc.html)
    should be [SQLITE_MUTEX_FAST](c3ref/c_mutex_fast.html) or [SQLITE_MUTEX_RECURSIVE](c3ref/c_mutex_fast.html)
    for non-recursive and recursive mutexes, respectively. If the underlying system
    does not provide non-recursive mutexes, then a recursive mutex can be substituted
    in that case. The argument to [sqlite3_mutex_alloc()](c3ref/mutex_alloc.html)
    can also be a constant designating one of several static mutexes:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些例程是为了SQLite核心的使用而存在的，但如果需要的话，应用程序代码也可以自由使用这些例程。互斥体是一个[sqlite3_mutex](c3ref/mutex.html)对象。[sqlite3_mutex_alloc()](c3ref/mutex_alloc.html)例程分配一个新的互斥体对象，并返回一个指向它的指针。对于非递归和递归互斥体，[sqlite3_mutex_alloc()](c3ref/mutex_alloc.html)的参数应该是[SQLITE_MUTEX_FAST](c3ref/c_mutex_fast.html)或[SQLITE_MUTEX_RECURSIVE](c3ref/c_mutex_fast.html)。如果底层系统不提供非递归互斥体，则可以在这种情况下替代为递归互斥体。[sqlite3_mutex_alloc()](c3ref/mutex_alloc.html)的参数还可以是一个常数，指定几个静态互斥体之一：
- en: '[SQLITE_MUTEX_STATIC_MAIN](c3ref/c_mutex_fast.html)'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQLITE_MUTEX_STATIC_MAIN](c3ref/c_mutex_fast.html)'
- en: '[SQLITE_MUTEX_STATIC_MEM](c3ref/c_mutex_fast.html)'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQLITE_MUTEX_STATIC_MEM](c3ref/c_mutex_fast.html)'
- en: '[SQLITE_MUTEX_STATIC_MEM2](c3ref/c_mutex_fast.html)'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQLITE_MUTEX_STATIC_MEM2](c3ref/c_mutex_fast.html)'
- en: '[SQLITE_MUTEX_STATIC_PRNG](c3ref/c_mutex_fast.html)'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQLITE_MUTEX_STATIC_PRNG](c3ref/c_mutex_fast.html)'
- en: '[SQLITE_MUTEX_STATIC_LRU](c3ref/c_mutex_fast.html)'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQLITE_MUTEX_STATIC_LRU](c3ref/c_mutex_fast.html)'
- en: These static mutexes are reserved for use internally by SQLite and should not
    be used by the application. The static mutexes are all non-recursive.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这些静态互斥体被SQLite内部保留，不应由应用程序使用。所有静态互斥体均为非递归。
- en: The [sqlite3_mutex_free()](c3ref/mutex_alloc.html) routine should be used to
    deallocate a non-static mutex. If a static mutex is passed to this routine then
    the behavior is undefined.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[sqlite3_mutex_free()](c3ref/mutex_alloc.html)例程应用于释放非静态互斥体。如果将静态互斥体传递给此例程，则行为是未定义的。'
- en: The [sqlite3_mutex_enter()](c3ref/mutex_alloc.html) attempts to enter the mutex
    and blocks if another threads is already there. [sqlite3_mutex_try()](c3ref/mutex_alloc.html)
    attempts to enter and returns [SQLITE_OK](rescode.html#ok) on success or [SQLITE_BUSY](rescode.html#busy)
    if another thread is already there. [sqlite3_mutex_leave()](c3ref/mutex_alloc.html)
    exits a mutex. The mutex is held until the number of exits matches the number
    of entrances. If [sqlite3_mutex_leave()](c3ref/mutex_alloc.html) is called on
    a mutex that the thread is not currently holding, then the behavior is undefined.
    If any routine is called for a deallocated mutex, then the behavior is undefined.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[sqlite3_mutex_enter()](c3ref/mutex_alloc.html)尝试进入互斥体，如果其他线程已经在使用，则会阻塞。[sqlite3_mutex_try()](c3ref/mutex_alloc.html)尝试进入互斥体，成功时返回[SQLITE_OK](rescode.html#ok)，如果另一个线程已经在使用则返回[SQLITE_BUSY](rescode.html#busy)。[sqlite3_mutex_leave()](c3ref/mutex_alloc.html)退出互斥体。互斥体会一直保持到退出的次数与进入的次数相匹配。如果在一个线程没有持有的互斥体上调用[sqlite3_mutex_leave()](c3ref/mutex_alloc.html)，则其行为是未定义的。如果对已释放的互斥体调用任何例程，则其行为是未定义的。'
- en: The SQLite source code provides multiple implementations of these APIs, suitable
    for varying environments. If SQLite is compiled with the SQLITE_THREADSAFE=0 flag
    then a no-op mutex implementation that is fast but does no real mutual exclusion
    is provided. That implementation is suitable for use in single-threaded applications
    or applications that only use SQLite in a single thread. Other real mutex implementations
    are provided based on the underlying operating system.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite源代码提供了多种这些API的实现，适用于不同的环境。如果SQLite编译时使用了SQLITE_THREADSAFE=0标志，则提供了一个仅执行空操作的互斥体实现，速度快但不提供真正的互斥。该实现适用于单线程应用程序或者只在单线程中使用SQLite的应用程序。其他真实的互斥体实现是基于底层操作系统提供的。
- en: Embedded applications may wish to provide their own mutex implementation. If
    SQLite is compiled with the -DSQLITE_MUTEX_APPDEF=1 compile-time flag then the
    SQLite core provides no mutex subsystem and a mutex subsystem that matches the
    interface described above must be provided by the application that links against
    SQLite.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式应用程序可能希望提供自己的互斥体实现。如果SQLite编译时使用了-DSQLITE_MUTEX_APPDEF=1编译时标志，则SQLite核心不提供互斥体子系统，而必须由链接到SQLite的应用程序提供一个与上述接口相匹配的互斥体子系统。
- en: 5.0 Other Interface Changes
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.0 其他接口变更
- en: Version 3.5.0 of SQLite changes the behavior of a few APIs in ways that are
    technically incompatible. However, these APIs are seldom used and even when they
    are used it is difficult to imagine a scenario where the change might break something.
    The changes actually makes these interface much more useful and powerful.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite版本3.5.0改变了一些API的行为，从技术上讲是不兼容的。然而，这些API很少被使用，即使被使用，很难想象出会破坏任何东西的情况。这些变更实际上使这些接口更加有用和强大。
- en: Prior to version 3.5.0, the [sqlite3_enable_shared_cache()](c3ref/enable_shared_cache.html)
    API would enable and disable the shared cache feature for all connections within
    a single thread - the same thread from which the sqlite3_enable_shared_cache()
    routine was called. Database connections that used the shared cache were restricted
    to running in the same thread in which they were opened. Beginning with version
    3.5.0, the sqlite3_enable_shared_cache() applies to all database connections in
    all threads within the process. Now database connections running in separate threads
    can share a cache. And database connections that use shared cache can migrate
    from one thread to another.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本 3.5.0 之前，[sqlite3_enable_shared_cache()](c3ref/enable_shared_cache.html)
    API 用于在单个线程中启用或禁用共享缓存功能 - 即调用 sqlite3_enable_shared_cache() 的同一线程。使用共享缓存的数据库连接限制在它们打开的同一线程中运行。从版本
    3.5.0 开始，sqlite3_enable_shared_cache() 应用于进程中所有线程的所有数据库连接。现在，在不同线程中运行的数据库连接可以共享缓存。并且使用共享缓存的数据库连接可以从一个线程迁移到另一个线程。
- en: Prior to version 3.5.0 the [sqlite3_soft_heap_limit()](c3ref/soft_heap_limit.html)
    set an upper bound on heap memory usage for all database connections within a
    single thread. Each thread could have its own heap limit. Beginning in version
    3.5.0, there is a single heap limit for the entire process. This seems more restrictive
    (one limit as opposed to many) but in practice it is what most users want.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本 3.5.0 之前，[sqlite3_soft_heap_limit()](c3ref/soft_heap_limit.html) 设置了单个线程中所有数据库连接的堆内存使用上限。每个线程可以有自己的堆限制。从版本
    3.5.0 开始，整个进程只有一个堆限制。这似乎更为严格（只有一个限制而不是多个），但实际上这是大多数用户想要的。
- en: Prior to version 3.5.0 the [sqlite3_release_memory()](c3ref/release_memory.html)
    function would try to reclaim memory from all database connections in the same
    thread as the sqlite3_release_memory() call. Beginning with version 3.5.0, the
    sqlite3_release_memory() function will attempt to reclaim memory from all database
    connections in all threads.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本 3.5.0 之前，[sqlite3_release_memory()](c3ref/release_memory.html) 函数尝试从调用 sqlite3_release_memory()
    的同一线程中的所有数据库连接中回收内存。从版本 3.5.0 开始，sqlite3_release_memory() 函数将尝试从所有线程中的所有数据库连接中回收内存。
- en: 6.0 Summary
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.0 总结
- en: The transition from SQLite version 3.4.2 to 3.5.0 is a major change. Every source
    code file in the SQLite core had to be modified, some extensively. And the change
    introduced some minor incompatibilities in the C interface. But we feel that the
    benefits of the transition from 3.4.2 to 3.5.0 far outweigh the pain of porting.
    The new VFS layer is now well-defined and stable and should simplify future customizations.
    The VFS layer, and the separable memory allocator and mutex subsystems allow a
    standard SQLite source code amalgamation to be used in an embedded project without
    change, greatly simplifying configuration management. And the resulting system
    is much more tolerant of highly threaded designs.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 从SQLite 3.4.2版本到3.5.0版本的转换是一个重大变化。SQLite核心中的每个源代码文件都必须进行修改，有些修改非常广泛。这种变化在C接口中引入了一些轻微的不兼容性。但我们认为，从3.4.2到3.5.0的过渡带来的好处远远超过了移植的痛苦。新的VFS层现在已经定义明确且稳定，应该简化未来的定制工作。VFS层、可分离的内存分配器和互斥子系统使得标准的SQLite源代码聚合可以在嵌入式项目中无需修改即可使用，大大简化配置管理。由此产生的系统对高度多线程设计更加宽容。
