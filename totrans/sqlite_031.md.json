["```sql\n-DSQLITE_ENABLE_SESSION -DSQLITE_ENABLE_PREUPDATE_HOOK\n\n```", "```sql\n*/*\n** Argument zSql points to a buffer containing an SQL script to execute\n** against the database handle passed as the first argument. As well as\n** executing the SQL script, this function collects a changeset recording\n** all changes made to the \"main\" database file. Assuming no error occurs,\n** output variables (*ppChangeset) and (*pnChangeset) are set to point\n** to a buffer containing the changeset and the size of the changeset in\n** bytes before returning SQLITE_OK. In this case it is the responsibility\n** of the caller to eventually free the changeset blob by passing it to\n** the sqlite3_free function.\n**\n** Or, if an error does occur, return an SQLite error code. The final\n** value of (*pChangeset) and (*pnChangeset) are undefined in this case.\n*/*\nint sql_exec_changeset(\n  sqlite3 *db,                  */* Database handle */*\n  const char *zSql,             */* SQL script to execute */*\n  int *pnChangeset,             */* OUT: Size of changeset blob in bytes */*\n  void **ppChangeset            */* OUT: Pointer to changeset blob */*\n){\n  sqlite3_session *pSession = 0;\n  int rc;\n\n  */* Create a new session object */*\n  rc = sqlite3session_create(db, \"main\", &pSession);\n\n  */* Configure the session object to record changes to all tables */*\n  if( rc==SQLITE_OK ) rc = sqlite3session_attach(pSession, NULL);\n\n  */* Execute the SQL script */*\n  if( rc==SQLITE_OK ) rc = sqlite3_exec(db, zSql, 0, 0, 0);\n\n  */* Collect the changeset */*\n  if( rc==SQLITE_OK ){\n    rc = sqlite3session_changeset(pSession, pnChangeset, ppChangeset);\n  }\n\n  */* Delete the session object */*\n  sqlite3session_delete(pSession);\n\n  return rc;\n}\n\n```", "```sql\n*/*\n** Conflict handler callback used by apply_changeset(). See below.\n*/*\nstatic int xConflict(void *pCtx, int eConflict, sqlite3_changeset_iter *pIter){\n  int ret = (int)pCtx;\n  return ret;\n}\n\n*/*\n** Apply the changeset contained in blob pChangeset, size nChangeset bytes,\n** to the main database of the database handle passed as the first argument.\n** Return SQLITE_OK if successful, or an SQLite error code if an error\n** occurs.\n**\n** If parameter bIgnoreConflicts is true, then any conflicting changes\n** within the changeset are simply ignored. Or, if bIgnoreConflicts is\n** false, then this call fails with an SQLITE_ABORT error if a changeset\n** conflict is encountered.\n*/*\nint apply_changeset(\n  sqlite3 *db,                  */* Database handle */*\n  int bIgnoreConflicts,         */* True to ignore conflicting changes */*\n  int nChangeset,               */* Size of changeset in bytes */*\n  void *pChangeset              */* Pointer to changeset blob */*\n){\n  return sqlite3changeset_apply(\n      db,\n      nChangeset, pChangeset,\n      0, xConflict,\n      (void*)bIgnoreConflicts\n  );\n}\n\n```", "```sql\n*/*\n** Print the contents of the changeset to stdout.\n*/*\nstatic int print_changeset(void *pChangeset, int nChangeset){\n  int rc;\n  sqlite3_changeset_iter *pIter = 0;\n\n  */* Create an iterator to iterate through the changeset */*\n  rc = sqlite3changeset_start(&pIter, nChangeset, pChangeset);\n  if( rc!=SQLITE_OK ) return rc;\n\n  */* This loop runs once for each change in the changeset */*\n  while( SQLITE_ROW==sqlite3changeset_next(pIter) ){\n    const char *zTab;           */* Table change applies to */*\n    int nCol;                   */* Number of columns in table zTab */*\n    int op;                     */* SQLITE_INSERT, UPDATE or DELETE */*\n    sqlite3_value *pVal;\n\n    */* Print the type of operation and the table it is on */*\n    rc = sqlite3changeset_op(pIter, &zTab, &nCol, &op, 0);\n    if( rc!=SQLITE_OK ) goto exit_print_changeset;\n    printf(\"%s on table %s\\n\",\n      op==SQLITE_INSERT?\"INSERT\" : op==SQLITE_UPDATE?\"UPDATE\" : \"DELETE\",\n      zTab\n    );\n\n    */* If this is an UPDATE or DELETE, print the old.* values */*\n    if( op==SQLITE_UPDATE || op==SQLITE_DELETE ){\n      printf(\"Old values:\");\n      for(i=0; i<nCol; i++){\n        rc = sqlite3changeset_old(pIter, i, &pVal);\n        if( rc!=SQLITE_OK ) goto exit_print_changeset;\n        printf(\" %s\", pVal ? sqlite3_value_text(pVal) : \"-\");\n      }\n      printf(\"\\n\");\n    }\n\n    */* If this is an UPDATE or INSERT, print the new.* values */*\n    if( op==SQLITE_UPDATE || op==SQLITE_INSERT ){\n      printf(\"New values:\");\n      for(i=0; i<nCol; i++){\n        rc = sqlite3changeset_new(pIter, i, &pVal);\n        if( rc!=SQLITE_OK ) goto exit_print_changeset;\n        printf(\" %s\", pVal ? sqlite3_value_text(pVal) : \"-\");\n      }\n      printf(\"\\n\");\n    }\n  }\n\n  */* Clean up the changeset and return an error code (or SQLITE_OK) */*\n exit_print_changeset:\n  rc2 = sqlite3changeset_finalize(pIter);\n  if( rc==SQLITE_OK ) rc = rc2;\n  return rc;\n}\n\n```"]