- en: 1\. Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://sqlite.com/csv.html](https://sqlite.com/csv.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The CSV virtual table reads [RFC 4180](https://www.ietf.org/rfc/rfc4180.txt)
    formatted comma-separated values, and returns that content as if it were rows
    and columns of an SQL table.
  prefs: []
  type: TYPE_NORMAL
- en: The CSV virtual table is useful to applications that need to bulk-load large
    amounts of comma-separated value content. The CSV virtual table is also useful
    as a template source file for implementing other virtual tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CSV virtual table is not built into the SQLite amalgamation. It is available
    as a [separate source file](https://www.sqlite.org/src/artifact?ci=trunk&filename=ext/misc/csv.c)
    that can be compiled into a [loadable extension](loadext.html). Typical usage
    of the CSV virtual table from the [command-line shell](cli.html) would be something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line of the script above causes the [command-line shell](cli.html)
    to read and activate the run-time loadable extension for CSV. For an application,
    the equivalent C-language API is [sqlite3_load_extension()](c3ref/load_extension.html).
    Observe that the filename extension (ex: ".dll" or ".so" or ".dylib") is omitted
    from the extension filename. Omitting the filename extension is not required,
    but it helps in making the script cross-platform. SQLite will automatically append
    the appropriate extension.'
  prefs: []
  type: TYPE_NORMAL
- en: The second line above creates a virtual table named "t1" that reads the content
    of the file named in the argument. The number and names of the columns is determined
    automatically by reading the first line of content. Other options to the CSV virtual
    table provide the ability to take the CSV content from a string rather than a
    separate file, and give the programmer more control over the number and names
    of the columns. The options are detailed below. The CSV virtual table is usually
    created as a TEMP table so that it exists only for the current database connection
    and does not become a permanent part of the database schema. Note that there is
    no "CREATE TEMP VIRTUAL TABLE" command in SQLite. Instead, prepend the "temp."
    schema prefix to the name of the virtual table.
  prefs: []
  type: TYPE_NORMAL
- en: The third line of the example shows the virtual table being used, to read all
    content of the CSV file. This is perhaps the simplest possible use of the virtual
    table. The CSV virtual table can be used anywhere an ordinary virtual table can
    be used. One can use the CSV virtual table inside subqueries, or [common table
    expressions](lang_with.html) or add WHERE, GROUP BY, HAVING, ORDER BY, and LIMIT
    clauses as required.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example above showed a single **filename='thefile.csv'** argument for the
    CSV virtual table. But other arguments are also possible.
  prefs: []
  type: TYPE_NORMAL
- en: '**filename=***FILENAME*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **filename=** argument specifies an external file from which CSV content
    is read. Every CSV virtual table must have either a **filename=** argument or
    a **data=** argument and not both.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**data=***TEXT*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **data=** argument specifies that *TEXT* is the literal content of the CSV
    file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**schema=***SCHEMA*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **schema=** argument specifies a [CREATE TABLE](lang_createtable.html) statement
    that the CSV virtual table passes to the [sqlite3_declare_vtab()](c3ref/declare_vtab.html)
    interface in order to define the names of the columns in the virtual table.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**columns=***N*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **columns=***N* argument specifies the number of columns in the CSV file.
    If the input data contains more columns than this, then the excess columns are
    ignored. If the input data contains fewer columns, then extra columns are filled
    with NULL. If the **columns=***N* argument is omitted, the first line of the CSV
    file is read to determine the number of columns.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**header=***BOOLEAN*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: or just
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**header**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the **header** argument is true then the first row of the CSV file to be
    treated as a header rather than as data. The second line of the CSV file becomes
    the first row of content. If the **schema=** options is omitted, then the first
    line of the CSV file determines the names of the columns.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 3\. Column Names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The column names of the virtual table are determined primarily by the **schema=**
    argument. If the **schema=** argument is omitted, but **header** is true, then
    the values found in the first line of the CSV file become the column names. If
    the **schema=** argument is omitted and **header** is false, then the columns
    are named "c0", "c1", "c2", and so forth.
  prefs: []
  type: TYPE_NORMAL
