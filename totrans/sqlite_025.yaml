- en: 1\. Datatypes In SQLite
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1\. SQLite中的数据类型
- en: 原文：[https://sqlite.com/datatype3.html](https://sqlite.com/datatype3.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://sqlite.com/datatype3.html](https://sqlite.com/datatype3.html)
- en: Most SQL database engines (every SQL database engine other than SQLite, as far
    as we know) uses static, rigid typing. With static typing, the datatype of a value
    is determined by its container - the particular column in which the value is stored.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数SQL数据库引擎（我们所知道的除SQLite外的每个SQL数据库引擎）使用静态、严格的类型。在静态类型中，值的数据类型由其容器确定 - 值存储在的特定列。
- en: SQLite uses a more general dynamic type system. In SQLite, the datatype of a
    value is associated with the value itself, not with its container. The dynamic
    type system of SQLite is backwards compatible with the more common static type
    systems of other database engines in the sense that SQL statements that work on
    statically typed databases work the same way in SQLite. However, the dynamic typing
    in SQLite allows it to do things which are not possible in traditional rigidly
    typed databases. [Flexible typing is a feature](flextypegood.html) of SQLite,
    not a bug.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite使用更通用的动态类型系统。在SQLite中，值的数据类型与值本身关联，而不是与其容器关联。SQLite的动态类型系统与其他数据库引擎中更常见的静态类型系统向后兼容，这意味着在SQLite中可以像在静态类型数据库中一样使用SQL语句。然而，SQLite中的动态类型使其能够执行传统上无法在严格类型数据库中实现的功能。[灵活的类型](flextypegood.html)是SQLite的特点，而非bug。
- en: 'Update: As of version 3.37.0 (2021-11-27), SQLite provides [STRICT tables](stricttables.html)
    that do rigid type enforcement, for developers who prefer that kind of thing.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 更新：从版本3.37.0开始（2021-11-27），SQLite提供了[STRICT表](stricttables.html)，用于那些喜欢这种类型强制的开发者。
- en: 2\. Storage Classes and Datatypes
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2\. 存储类和数据类型
- en: 'Each value stored in an SQLite database (or manipulated by the database engine)
    has one of the following storage classes:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite数据库中存储（或由数据库引擎操作）的每个值都有以下存储类之一：
- en: '**NULL**. The value is a NULL value.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NULL**. 这个值是NULL值。'
- en: '**INTEGER**. The value is a signed integer, stored in 0, 1, 2, 3, 4, 6, or
    8 bytes depending on the magnitude of the value.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**INTEGER**. 这个值是有符号整数，存储在0、1、2、3、4、6或8个字节中，具体取决于值的大小。'
- en: '**REAL**. The value is a floating point value, stored as an 8-byte IEEE floating
    point number.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**REAL**. 这个值是一个浮点数值，以8字节IEEE浮点数格式存储。'
- en: '**TEXT**. The value is a text string, stored using the database encoding (UTF-8,
    UTF-16BE or UTF-16LE).'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TEXT**. 这个值是文本字符串，使用数据库编码（UTF-8、UTF-16BE或UTF-16LE）存储。'
- en: '**BLOB**. The value is a blob of data, stored exactly as it was input.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BLOB**. 这个值是一个数据块，按照输入时的精确格式存储。'
- en: A storage class is more general than a datatype. The INTEGER storage class,
    for example, includes 7 different integer datatypes of different lengths. [This
    makes a difference on disk.](fileformat2.html#record_format) But as soon as INTEGER
    values are read off of disk and into memory for processing, they are converted
    to the most general datatype (8-byte signed integer). And so for the most part,
    "storage class" is indistinguishable from "datatype" and the two terms can be
    used interchangeably.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 存储类比数据类型更一般化。例如，INTEGER存储类包括7种不同长度的整数数据类型。[这在磁盘上有所不同。](fileformat2.html#record_format)但是一旦INTEGER值从磁盘读入内存进行处理，它们将转换为最通用的数据类型（8字节有符号整数）。因此，在大多数情况下，“存储类”与“数据类型”几乎没有区别，两个术语可以互换使用。
- en: Any column in an SQLite version 3 database, except an [INTEGER PRIMARY KEY](lang_createtable.html#rowid)
    column, may be used to store a value of any storage class.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQLite版本3数据库中，除了[INTEGER PRIMARY KEY](lang_createtable.html#rowid)列之外，任何列都可以用来存储任何存储类的值。
- en: All values in SQL statements, whether they are literals embedded in SQL statement
    text or [parameters](lang_expr.html#varparam) bound to [precompiled SQL statements](c3ref/stmt.html)
    have an implicit storage class. Under circumstances described below, the database
    engine may convert values between numeric storage classes (INTEGER and REAL) and
    TEXT during query execution.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: SQL语句中的所有值，无论是嵌入SQL语句文本中的字面量还是绑定到[预编译SQL语句](c3ref/stmt.html)的[参数](lang_expr.html#varparam)，都有一个隐式的存储类。在下文描述的情况下，数据库引擎可能在查询执行期间在数值存储类（INTEGER和REAL）和TEXT之间转换值。
- en: 2.1\. Boolean Datatype
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1\. 布尔数据类型
- en: SQLite does not have a separate Boolean storage class. Instead, Boolean values
    are stored as integers 0 (false) and 1 (true).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite没有单独的布尔存储类。相反，布尔值以整数0（false）和1（true）存储。
- en: SQLite recognizes the keywords "TRUE" and "FALSE", as of version 3.23.0 (2018-04-02)
    but those keywords are really just alternative spellings for the integer literals
    1 and 0 respectively.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 自版本 3.23.0（2018-04-02）起，识别关键字 "TRUE" 和 "FALSE"，但这些关键字实际上只是整数字面值 1 和 0
    的替代拼写。
- en: 2.2\. Date and Time Datatype
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2\. 日期和时间数据类型
- en: 'SQLite does not have a storage class set aside for storing dates and/or times.
    Instead, the built-in [Date And Time Functions](lang_datefunc.html) of SQLite
    are capable of storing dates and times as TEXT, REAL, or INTEGER values:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 没有专门用于存储日期和/或时间的存储类。相反，SQLite 的内置 [日期和时间函数](lang_datefunc.html) 能够将日期和时间存储为
    TEXT、REAL 或 INTEGER 值：
- en: '**TEXT** as ISO8601 strings ("YYYY-MM-DD HH:MM:SS.SSS").'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TEXT** 作为 ISO8601 字符串（"YYYY-MM-DD HH:MM:SS.SSS"）。'
- en: '**REAL** as Julian day numbers, the number of days since noon in Greenwich
    on November 24, 4714 B.C. according to the proleptic Gregorian calendar.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**REAL** 作为儒略日数，即格林尼治时间 4714 年 11 月 24 日中午以来的天数，根据推测的格里高利历。'
- en: '**INTEGER** as Unix Time, the number of seconds since 1970-01-01 00:00:00 UTC.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**INTEGER** 作为 Unix 时间，即从 1970-01-01 00:00:00 UTC 起的秒数。'
- en: Applications can choose to store dates and times in any of these formats and
    freely convert between formats using the built-in [date and time functions](lang_datefunc.html).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以选择使用这些格式存储日期和时间，并使用内置的 [日期和时间函数](lang_datefunc.html) 在这些格式之间自由转换。
- en: 3\. Type Affinity
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3\. 类型亲和力
- en: 'SQL database engines that use rigid typing will usually try to automatically
    convert values to the appropriate datatype. Consider this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用严格类型的 SQL 数据库引擎通常会尝试自动将值转换为适当的数据类型。考虑以下示例：
- en: '[PRE0]'
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Rigidly-typed database will convert the string '123' into an integer 123 and
    the integer 456 into a string '456' prior to doing the insert.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 严格类型化的数据库将在执行插入之前，将字符串 '123' 转换为整数 123，将整数 456 转换为字符串 '456'。
- en: In order to maximize compatibility between SQLite and other database engines,
    and so that the example above will work on SQLite as it does on other SQL database
    engines, SQLite supports the concept of "type affinity" on columns. The type affinity
    of a column is the recommended type for data stored in that column. The important
    idea here is that the type is recommended, not required. Any column can still
    store any type of data. It is just that some columns, given the choice, will prefer
    to use one storage class over another. The preferred storage class for a column
    is called its "affinity".
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最大化 SQLite 与其他数据库引擎之间的兼容性，并使上述示例在 SQLite 上与其他 SQL 数据库引擎一样有效，SQLite 支持列的 "类型亲和力"
    概念。列的类型亲和力是存储在该列中的数据的推荐类型。这里的重要思想是类型是推荐的，而不是必须的。任何列仍然可以存储任何类型的数据。只是，某些列在选择时更倾向于使用一个存储类而不是另一个。列的首选存储类称为其
    "亲和力"。
- en: 'Each column in an SQLite 3 database is assigned one of the following type affinities:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 3 数据库中的每列被分配以下类型亲和力之一：
- en: TEXT
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TEXT**'
- en: NUMERIC
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NUMERIC**'
- en: INTEGER
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**INTEGER**'
- en: REAL
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**REAL**'
- en: BLOB
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BLOB**'
- en: '(Historical note: The "BLOB" type affinity used to be called "NONE". But that
    term was easy to confuse with "no affinity" and so it was renamed.)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: （历史注："BLOB" 类型亲和力曾被称为 "NONE"。但该术语易于与 "无亲和力" 混淆，因此改名。）
- en: A column with TEXT affinity stores all data using storage classes NULL, TEXT
    or BLOB. If numerical data is inserted into a column with TEXT affinity it is
    converted into text form before being stored.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 具有 TEXT 亲和力的列使用 NULL、TEXT 或 BLOB 存储所有数据。如果将数值数据插入具有 TEXT 亲和力的列中，则在存储之前将其转换为文本形式。
- en: A column with NUMERIC affinity may contain values using all five storage classes.
    When text data is inserted into a NUMERIC column, the storage class of the text
    is converted to INTEGER or REAL (in order of preference) if the text is a well-formed
    integer or real literal, respectively. If the TEXT value is a well-formed integer
    literal that is too large to fit in a 64-bit signed integer, it is converted to
    REAL. For conversions between TEXT and REAL storage classes, only the first 15
    significant decimal digits of the number are preserved. If the TEXT value is not
    a well-formed integer or real literal, then the value is stored as TEXT. For the
    purposes of this paragraph, hexadecimal integer literals are not considered well-formed
    and are stored as TEXT. (This is done for historical compatibility with versions
    of SQLite prior to [version 3.8.6](releaselog/3_8_6.html) 2014-08-15 where hexadecimal
    integer literals were first introduced into SQLite.) If a floating point value
    that can be represented exactly as an integer is inserted into a column with NUMERIC
    affinity, the value is converted into an integer. No attempt is made to convert
    NULL or BLOB values.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有NUMERIC亲和性的列可以包含使用所有五种存储类别的值。当将文本数据插入NUMERIC列时，如果文本是一个格式良好的整数或实数文字字面值，则文本的存储类别将分别转换为INTEGER或REAL（优先顺序）。如果TEXT值是一个格式良好的整数文字字面值，但太大而无法适应64位有符号整数，则将其转换为REAL。在TEXT和REAL存储类别之间进行转换时，只保留数字的前15个有效十进制数字。如果TEXT值不是格式良好的整数或实数文字字面值，则该值将作为TEXT存储。在本段的目的下，十六进制整数文字字面值不被视为格式良好，并且将作为TEXT存储（这是为了与SQLite
    [3.8.6版本](releaselog/3_8_6.html) 2014-08-15之前的版本的历史兼容性而执行的）。如果可以准确表示为整数的浮点值插入具有NUMERIC亲和性的列中，则该值将转换为整数。不会尝试转换NULL或BLOB值。
- en: A string might look like a floating-point literal with a decimal point and/or
    exponent notation but as long as the value can be expressed as an integer, the
    NUMERIC affinity will convert it into an integer. Hence, the string '3.0e+5' is
    stored in a column with NUMERIC affinity as the integer 300000, not as the floating
    point value 300000.0.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串可能看起来像带有小数点和/或指数符号的浮点文字字面值，但只要该值可以表示为整数，NUMERIC亲和性将其转换为整数。因此，字符串'3.0e+5'在具有NUMERIC亲和性的列中存储为整数300000，而不是浮点值300000.0。
- en: 'A column that uses INTEGER affinity behaves the same as a column with NUMERIC
    affinity. The difference between INTEGER and NUMERIC affinity is only evident
    in a [CAST expression](lang_expr.html#castexpr): The expression "CAST(4.0 AS INT)"
    returns an integer 4, whereas "CAST(4.0 AS NUMERIC)" leaves the value as a floating-point
    4.0.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用INTEGER亲和性的列与使用NUMERIC亲和性的列的行为相同。INTEGER和NUMERIC亲和性之间的区别仅在于[CAST表达式](lang_expr.html#castexpr)中明显：表达式"CAST(4.0
    AS INT)"返回整数4，而"CAST(4.0 AS NUMERIC)"将值保留为浮点数4.0。
- en: A column with REAL affinity behaves like a column with NUMERIC affinity except
    that it forces integer values into floating point representation. (As an internal
    optimization, small floating point values with no fractional component and stored
    in columns with REAL affinity are written to disk as integers in order to take
    up less space and are automatically converted back into floating point as the
    value is read out. This optimization is completely invisible at the SQL level
    and can only be detected by examining the raw bits of the database file.)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 具有REAL亲和性的列的行为类似于具有NUMERIC亲和性的列，但是它会强制整数值转换为浮点表示。（作为内部优化，没有分数部分的小浮点值并且存储在具有REAL亲和性的列中的整数被写入磁盘以占用更少空间，并且在值读取时会自动转换回浮点值。这种优化在SQL级别完全不可见，只能通过检查数据库文件的原始位来检测到。）
- en: A column with affinity BLOB does not prefer one storage class over another and
    no attempt is made to coerce data from one storage class into another.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 具有BLOB亲和性的列不偏好一种存储类别，也不会尝试将数据从一种存储类别强制转换为另一种存储类别。
- en: 3.1\. Determination Of Column Affinity
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1\. 确定列亲和性
- en: 'For tables not declared as [STRICT](stricttables.html), the affinity of a column
    is determined by the declared type of the column, according to the following rules
    in the order shown:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于未声明为[STRICT](stricttables.html)的表，列的亲和性由列的声明类型决定，根据以下规则按照显示的顺序：
- en: If the declared type contains the string "INT" then it is assigned INTEGER affinity.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果声明类型包含字符串"INT"，则分配INTEGER亲和性。
- en: If the declared type of the column contains any of the strings "CHAR", "CLOB",
    or "TEXT" then that column has TEXT affinity. Notice that the type VARCHAR contains
    the string "CHAR" and is thus assigned TEXT affinity.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: If the declared type of the column contains any of the strings "CHAR", "CLOB",
    or "TEXT" then that column has TEXT affinity. Notice that the type VARCHAR contains
    the string "CHAR" and is thus assigned TEXT affinity.
- en: If the declared type for a column contains the string "BLOB" or if no type is
    specified then the column has affinity BLOB.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: If the declared type for a column contains the string "BLOB" or if no type is
    specified then the column has affinity BLOB.
- en: If the declared type for a column contains any of the strings "REAL", "FLOA",
    or "DOUB" then the column has REAL affinity.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: If the declared type for a column contains any of the strings "REAL", "FLOA",
    or "DOUB" then the column has REAL affinity.
- en: Otherwise, the affinity is NUMERIC.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Otherwise, the affinity is NUMERIC.
- en: Note that the order of the rules for determining column affinity is important.
    A column whose declared type is "CHARINT" will match both rules 1 and 2 but the
    first rule takes precedence and so the column affinity will be INTEGER.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Note that the order of the rules for determining column affinity is important.
    A column whose declared type is "CHARINT" will match both rules 1 and 2 but the
    first rule takes precedence and so the column affinity will be INTEGER.
- en: 3.1.1\. Affinity Name Examples
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.1\. Affinity Name Examples
- en: 'The following table shows how many common datatype names from more traditional
    SQL implementations are converted into affinities by the five rules of the previous
    section. This table shows only a small subset of the datatype names that SQLite
    will accept. Note that numeric arguments in parentheses that following the type
    name (ex: "VARCHAR(255)") are ignored by SQLite - SQLite does not impose any length
    restrictions (other than the large global [SQLITE_MAX_LENGTH](limits.html#max_length)
    limit) on the length of strings, BLOBs or numeric values.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 'The following table shows how many common datatype names from more traditional
    SQL implementations are converted into affinities by the five rules of the previous
    section. This table shows only a small subset of the datatype names that SQLite
    will accept. Note that numeric arguments in parentheses that following the type
    name (ex: "VARCHAR(255)") are ignored by SQLite - SQLite does not impose any length
    restrictions (other than the large global [SQLITE_MAX_LENGTH](limits.html#max_length)
    limit) on the length of strings, BLOBs or numeric values.'
- en: '| Example Typenames From The CREATE TABLE Statement'
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '| Example Typenames From The CREATE TABLE Statement'
- en: or CAST Expression | Resulting Affinity | Rule Used To Determine Affinity |
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: or CAST Expression | Resulting Affinity | Rule Used To Determine Affinity |
- en: '| INT INTEGER'
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '| INT INTEGER'
- en: TINYINT
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: TINYINT
- en: SMALLINT
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SMALLINT
- en: MEDIUMINT
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: MEDIUMINT
- en: BIGINT
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: BIGINT
- en: UNSIGNED BIG INT
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: UNSIGNED BIG INT
- en: INT2
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: INT2
- en: INT8 | INTEGER | 1 |
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: INT8 | INTEGER | 1 |
- en: '| CHARACTER(20) VARCHAR(255)'
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '| CHARACTER(20) VARCHAR(255)'
- en: VARYING CHARACTER(255)
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: VARYING CHARACTER(255)
- en: NCHAR(55)
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: NCHAR(55)
- en: NATIVE CHARACTER(70)
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: NATIVE CHARACTER(70)
- en: NVARCHAR(100)
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: NVARCHAR(100)
- en: TEXT
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: TEXT
- en: CLOB | TEXT | 2 |
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: CLOB | TEXT | 2 |
- en: '| BLOB *no datatype specified* | BLOB | 3 |'
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| BLOB *no datatype specified* | BLOB | 3 |'
- en: '| REAL DOUBLE'
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '| REAL DOUBLE'
- en: DOUBLE PRECISION
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: DOUBLE PRECISION
- en: FLOAT | REAL | 4 |
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: FLOAT | REAL | 4 |
- en: '| NUMERIC DECIMAL(10,5)'
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '| NUMERIC DECIMAL(10,5)'
- en: BOOLEAN
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: BOOLEAN
- en: DATE
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: DATE
- en: DATETIME | NUMERIC | 5 |
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: DATETIME | NUMERIC | 5 |
- en: Note that a declared type of "FLOATING POINT" would give INTEGER affinity, not
    REAL affinity, due to the "INT" at the end of "POINT". And the declared type of
    "STRING" has an affinity of NUMERIC, not TEXT.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Note that a declared type of "FLOATING POINT" would give INTEGER affinity, not
    REAL affinity, due to the "INT" at the end of "POINT". And the declared type of
    "STRING" has an affinity of NUMERIC, not TEXT.
- en: 3.2\. Affinity Of Expressions
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2\. Affinity Of Expressions
- en: Every table column has a type affinity (one of BLOB, TEXT, INTEGER, REAL, or
    NUMERIC) but expressions do not necessarily have an affinity.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Every table column has a type affinity (one of BLOB, TEXT, INTEGER, REAL, or
    NUMERIC) but expressions do not necessarily have an affinity.
- en: 'Expression affinity is determined by the following rules:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 'Expression affinity is determined by the following rules:'
- en: The right-hand operand of an IN or NOT IN operator has no affinity if the operand
    is a list, or has the same affinity as the affinity of the result set expression
    if the operand is a SELECT.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: The right-hand operand of an IN or NOT IN operator has no affinity if the operand
    is a list, or has the same affinity as the affinity of the result set expression
    if the operand is a SELECT.
- en: When an expression is a simple reference to a column of a real table (not a
    [VIEW](lang_createview.html) or subquery) then the expression has the same affinity
    as the table column.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: When an expression is a simple reference to a column of a real table (not a
    [VIEW](lang_createview.html) or subquery) then the expression has the same affinity
    as the table column.
- en: Parentheses around the column name are ignored. Hence if X and Y.Z are column
    names, then (X) and (Y.Z) are also considered column names and have the affinity
    of the corresponding columns.
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Parentheses around the column name are ignored. Hence if X and Y.Z are column
    names, then (X) and (Y.Z) are also considered column names and have the affinity
    of the corresponding columns.
- en: Any operators applied to column names, including the no-op unary "+" operator,
    convert the column name into an expression which always has no affinity. Hence
    even if X and Y.Z are column names, the expressions +X and +Y.Z are not column
    names and have no affinity.
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用于列名的任何运算符（包括无操作符的一元"+"运算符）将列名转换为总是没有亲和力的表达式。因此，即使X和Y.Z是列名，表达式+X和+Y.Z也不是列名，也没有亲和力。
- en: An expression of the form "CAST(*expr* AS *type*)" has an affinity that is the
    same as a column with a declared type of "*type*".
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形式为"CAST(*expr* AS *type*)"的表达式具有与声明类型为"*type*"的列相同的亲和力。
- en: A COLLATE operator has the same affinity as its left-hand side operand.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: COLLATE运算符具有与其左侧操作数相同的亲和力。
- en: Otherwise, an expression has no affinity.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，表达式没有亲和力。
- en: 3.3\. Column Affinity For Views And Subqueries
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3\. 视图和子查询的列亲和力
- en: 'The "columns" of a [VIEW](lang_createview.html) or FROM-clause subquery are
    really the expressions in the result set of the [SELECT](lang_select.html) statement
    that implements the VIEW or subquery. Thus, the affinity for columns of a VIEW
    or subquery are determined by the expression affinity rules above. Consider an
    example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[视图](lang_createview.html)或FROM子查询的“列”实际上是实现视图或子查询的[SELECT](lang_select.html)语句结果集中的表达式。因此，视图或子查询的列的亲和力由上述表达式亲和力规则确定。考虑一个例子：'
- en: '[PRE1]'
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The affinity of the v1.x column will be the same as the affinity of t1.b (TEXT),
    since v1.x maps directly into t1.b. But columns v1.y and v1.z both have no affinity,
    since those columns map into expression a+c and 42, and expressions always have
    no affinity.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: v1.x列的亲和力将与t1.b(TEXT)的亲和力相同，因为v1.x直接映射到t1.b。但v1.y和v1.z列都没有亲和力，因为这些列映射到表达式a+c和42，而表达式总是没有亲和力的。
- en: 3.3.1\. Column Affinity For Compound Views
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1\. 复合视图的列亲和力
- en: When the [SELECT](lang_select.html) statement that implements a [VIEW](lang_createview.html)
    or FROM-clause subquery is a [compound SELECT](lang_select.html#compound) then
    the affinity of each column of the VIEW or subquery will be the affinity of the
    corresponding result column for one of the individual SELECT statements that make
    up the compound. However, it is indeterminate which of the SELECT statements will
    be used to determine affinity. Different constituent SELECT statements might be
    used to determine affinity at different times during query evaluation. The choice
    might vary across different versions of SQLite. The choice might change between
    one query and the next in the same version of SQLite. The choice might be different
    at different times within the same query. Hence, you can never be sure what affinity
    will be used for columns of a compound SELECT that have different affinities in
    the constituent subqueries.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当实现一个[视图](lang_createview.html)或FROM子查询的[SELECT](lang_select.html)语句是一个[复合SELECT](lang_select.html#compound)时，视图或子查询的每一列的亲和力将是组成复合SELECT的各个单独SELECT语句的相应结果列的亲和力。然而，确定使用哪个SELECT语句来确定亲和力是不确定的。在查询评估过程中，不同的组成SELECT语句可能在不同的时间确定亲和力。这个选择可能会在不同版本的SQLite中有所不同。这个选择可能会在同一版本的SQLite中的不同查询之间改变。在同一查询的不同时间，这个选择可能会有所不同。因此，你永远无法确定复合SELECT的列的亲和力将使用哪个版本中具有不同亲和力的子查询。
- en: Best practice is to avoid mixing affinities in a compound SELECT if you care
    about the datatype of the result. Mixing affinities in a compound SELECT can lead
    to surprising and unintuitive results. See, for example, [forum post 02d7be94d7](https://sqlite.org/forum/forumpost/02d7be94d7).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是避免在复合SELECT中混合使用亲和力，如果您关心结果的数据类型。在复合SELECT中混合使用亲和力可能会导致令人惊讶和不直观的结果。例如，参见[论坛帖子02d7be94d7](https://sqlite.org/forum/forumpost/02d7be94d7)。
- en: 3.4\. Column Affinity Behavior Example
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4\. 列亲和力行为示例
- en: The following SQL demonstrates how SQLite uses column affinity to do type conversions
    when values are inserted into a table.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下SQL演示了SQLite在将值插入表时如何使用列亲和力进行类型转换。
- en: '[PRE2]'
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 4\. Comparison Expressions
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4\. 比较表达式
- en: SQLite version 3 has the usual set of SQL comparison operators including "=",
    "==", "<", "<=", ">", ">=", "!=", "", "IN", "NOT IN", "BETWEEN", "IS", and "IS
    NOT", .
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite版本3具有通常的SQL比较运算符集，包括"="、"=="、"<"、"<="、">"、">="、"!="、""、"IN"、"NOT IN"、"BETWEEN"、"IS"和"IS
    NOT"。
- en: 4.1\. Sort Order
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1\. 排序顺序
- en: 'The results of a comparison depend on the storage classes of the operands,
    according to the following rules:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 比较的结果取决于操作数的存储类，根据以下规则：
- en: A value with storage class NULL is considered less than any other value (including
    another value with storage class NULL).
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有存储类 NULL 的值被视为小于任何其他值（包括具有存储类 NULL 的另一个值）。
- en: An INTEGER or REAL value is less than any TEXT or BLOB value. When an INTEGER
    or REAL is compared to another INTEGER or REAL, a numerical comparison is performed.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: INTEGER 或 REAL 值小于任何 TEXT 或 BLOB 值。当 INTEGER 或 REAL 与另一个 INTEGER 或 REAL 进行比较时，执行数值比较。
- en: A TEXT value is less than a BLOB value. When two TEXT values are compared an
    appropriate collating sequence is used to determine the result.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TEXT 值小于 BLOB 值。当比较两个 TEXT 值时，使用适当的排序序列确定结果。
- en: When two BLOB values are compared, the result is determined using memcmp().
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当比较两个 BLOB 值时，结果使用 memcmp() 决定。
- en: 4.2\. Type Conversions Prior To Comparison
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2\. 类型转换优先于比较
- en: SQLite may attempt to convert values between the storage classes INTEGER, REAL,
    and/or TEXT before performing a comparison. Whether or not any conversions are
    attempted before the comparison takes place depends on the type affinity of the
    operands.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行比较之前，SQLite 可能会尝试在存储类 INTEGER、REAL 和/或 TEXT 之间转换值。在进行比较之前是否尝试进行任何转换取决于操作数的类型亲和性。
- en: To "apply affinity" means to convert an operand to a particular storage class
    if and only if the conversion does not lose essential information. Numeric values
    can always be converted into TEXT. TEXT values can be converted into numeric values
    if the text content is a well-formed integer or real literal, but not a hexadecimal
    integer literal. BLOB values are converted into TEXT values by simply interpreting
    the binary BLOB content as a text string in the current database encoding.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '"应用亲和性" 意味着仅当转换不会丢失重要信息时，将操作数转换为特定的存储类。数值始终可以转换为 TEXT。如果文本内容是格式良好的整数或实数文字，TEXT
    值可以转换为数值，但不能是十六进制整数文字。通过简单地解释二进制 BLOB 内容作为当前数据库编码中的文本字符串，将 BLOB 值转换为 TEXT 值。'
- en: 'Affinity is applied to operands of a comparison operator prior to the comparison
    according to the following rules in the order shown:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在比较操作数之前，根据以下规则按照所示顺序应用亲和性：
- en: If one operand has INTEGER, REAL or NUMERIC affinity and the other operand has
    TEXT or BLOB or no affinity then NUMERIC affinity is applied to other operand.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个操作数具有 INTEGER、REAL 或 NUMERIC 亲和性，另一个操作数具有 TEXT 或 BLOB 或没有亲和性，则将 NUMERIC
    亲和性应用于另一个操作数。
- en: If one operand has TEXT affinity and the other has no affinity, then TEXT affinity
    is applied to the other operand.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个操作数具有 TEXT 亲和性，另一个操作数没有亲和性，则将 TEXT 亲和性应用于另一个操作数。
- en: Otherwise, no affinity is applied and both operands are compared as is.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，不应用任何亲和性，并且两个操作数按原样进行比较。
- en: The expression "a BETWEEN b AND c" is treated as two separate binary comparisons
    "a >= b AND a <= c", even if that means different affinities are applied to 'a'
    in each of the comparisons. Datatype conversions in comparisons of the form "x
    IN (SELECT y ...)" are handled as if the comparison were really "x=y". The expression
    "a IN (x, y, z, ...)" is equivalent to "a = +x OR a = +y OR a = +z OR ...". In
    other words, the values to the right of the IN operator (the "x", "y", and "z"
    values in this example) are considered to have no affinity, even if they happen
    to be column values or CAST expressions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 "a BETWEEN b AND c" 被视为两个独立的二进制比较 "a >= b AND a <= c"，即使这意味着在每个比较中 'a' 应用不同的亲和性。在类似
    "x IN (SELECT y ...)" 的比较中，数据类型转换被处理为实际上是 "x=y" 的比较。表达式 "a IN (x, y, z, ...)"
    等效于 "a = +x OR a = +y OR a = +z OR ..."。换句话说，IN 操作符右侧的值（此示例中的 "x"、"y" 和 "z" 值）被认为没有亲和性，即使它们恰好是列值或
    CAST 表达式。
- en: 4.3\. Comparison Example
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3\. 比较示例
- en: '[PRE3]'
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE3]'
- en: All of the results in the example are the same if the comparisons are commuted
    - if expressions of the form "a<40" are rewritten as "40>a".
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对形式为 "a<40" 的表达式重写为 "40>a"，则示例中的所有结果都相同。
- en: 5\. Operators
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5\. 操作符
- en: Mathematical operators (+, -, *, /, %, <<, >>, &, and |) interpret both operands
    as if they were numbers. STRING or BLOB operands automatically convert into REAL
    or INTEGER values. If the STRING or BLOB looks like a real number (if it has a
    decimal point or an exponent) or if the value is outside the range that can be
    represented as a 64-bit signed integer, then it converts to REAL. Otherwise the
    operand converts to INTEGER. The implied type conversion of mathematical operands
    is slightly different from [CAST to NUMERIC](lang_expr.html#castexpr) in that
    string and BLOB values that look like real numbers but have no fractional part
    are kept as REAL instead of being converted into INTEGER as they would be for
    [CAST to NUMERIC](lang_expr.html#castexpr). The conversion from STRING or BLOB
    into REAL or INTEGER is performed even if it is lossy and irreversible. Some mathematical
    operators (%, <<, >>, &, and |) expect INTEGER operands. For those operators,
    REAL operands are converted into INTEGER in the same way as a [CAST to INTEGER](lang_expr.html#castexpr).
    The <<, >>, &, and | operators always return an INTEGER (or NULL) result, but
    the % operator returns either INTEGER or REAL (or NULL) depending on the type
    of its operands. A NULL operand on a mathematical operator yields a NULL result.
    An operand on a mathematical operator that does not look in any way numeric and
    is not NULL is converted to 0 or 0.0. Division by zero gives a result of NULL.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 数学运算符（+、-、*、/、%、<<、>>、& 和 |）会将两个操作数解释为数值。字符串或 BLOB 操作数会自动转换为 REAL 或 INTEGER
    值。如果字符串或 BLOB 看起来像是一个实数（如果有小数点或指数）或者其值超出了可以表示为 64 位有符号整数的范围，那么它会被转换为 REAL。否则，操作数会转换为
    INTEGER。数学操作数的隐含类型转换与[转换为 NUMERIC](lang_expr.html#castexpr)略有不同，即看起来像实数但没有小数部分的字符串和
    BLOB 值会保持为 REAL，而不会像[转换为 NUMERIC](lang_expr.html#castexpr)那样转换为 INTEGER。即使这种从
    STRING 或 BLOB 到 REAL 或 INTEGER 的转换是有损且不可逆的，也会执行。某些数学运算符（%，<<、>>、& 和 |）需要 INTEGER
    操作数。对于这些运算符，REAL 操作数会像[转换为 INTEGER](lang_expr.html#castexpr)一样转换为 INTEGER。<<、>>、&
    和 | 运算符始终返回 INTEGER（或 NULL）结果，但 % 运算符根据其操作数的类型返回 INTEGER 或 REAL（或 NULL）结果。在数学运算符上的
    NULL 操作数会产生 NULL 结果。在数学运算符上的操作数如果看起来根本不是数值且不为 NULL，则会被转换为 0 或 0.0。除以零会得到 NULL
    结果。
- en: 6\. Sorting, Grouping and Compound SELECTs
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6\. 排序、分组和复合 SELECT
- en: When query results are sorted by an ORDER BY clause, values with storage class
    NULL come first, followed by INTEGER and REAL values interspersed in numeric order,
    followed by TEXT values in collating sequence order, and finally BLOB values in
    memcmp() order. No storage class conversions occur before the sort.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过 ORDER BY 子句对查询结果进行排序时，存储类别为 NULL 的值首先出现，然后是以数值顺序交错出现的 INTEGER 和 REAL 值，然后是按排序序列顺序出现的
    TEXT 值，最后是按 memcmp() 顺序出现的 BLOB 值。在排序之前不会发生存储类别转换。
- en: When grouping values with the GROUP BY clause values with different storage
    classes are considered distinct, except for INTEGER and REAL values which are
    considered equal if they are numerically equal. No affinities are applied to any
    values as the result of a GROUP by clause.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GROUP BY 子句中对值进行分组时，具有不同存储类别的值被视为不同，除非它们在数值上相等，INTEGER 和 REAL 值在数值上相等时会被视为相等。在
    GROUP BY 子句的结果上不会应用任何亲和力。
- en: The compound SELECT operators UNION, INTERSECT and EXCEPT perform implicit comparisons
    between values. No affinity is applied to comparison operands for the implicit
    comparisons associated with UNION, INTERSECT, or EXCEPT - the values are compared
    as is.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 复合 SELECT 操作符 UNION、INTERSECT 和 EXCEPT 在值之间执行隐式比较。对于与 UNION、INTERSECT 或 EXCEPT
    关联的隐式比较，不会应用任何亲和力到比较操作数上 - 值会按原样进行比较。
- en: 7\. Collating Sequences
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7\. 排序序列
- en: 'When SQLite compares two strings, it uses a collating sequence or collating
    function (two terms for the same thing) to determine which string is greater or
    if the two strings are equal. SQLite has three built-in collating functions: BINARY,
    NOCASE, and RTRIM.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当 SQLite 比较两个字符串时，它使用一个排序序列或排序函数（这两个术语是相同的）来确定哪个字符串更大或两个字符串是否相等。SQLite 内置了三个排序函数：BINARY、NOCASE
    和 RTRIM。
- en: '**BINARY** - Compares string data using memcmp(), regardless of text encoding.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BINARY** - 使用 memcmp() 比较字符串数据，无论文本编码如何。'
- en: '**NOCASE** - Similar to binary, except that it uses [sqlite3_strnicmp()](c3ref/stricmp.html)
    for the comparison. Hence the 26 upper case characters of ASCII are folded to
    their lower case equivalents before the comparison is performed. Note that only
    ASCII characters are case folded. SQLite does not attempt to do full UTF case
    folding due to the size of the tables required. Also note that any U+0000 characters
    in the string are considered string terminators for comparison purposes.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NOCASE** - 与binary相似，但使用[sqlite3_strnicmp()](c3ref/stricmp.html)进行比较。因此，在执行比较之前，ASCII的26个大写字符被折叠成它们的小写等价字符。请注意，只有ASCII字符会被折叠大小写。由于表的尺寸，SQLite不尝试进行完整的UTF大小写折叠。还请注意，字符串中的任何U+0000字符都被视为比较目的的字符串终止符。'
- en: '**RTRIM** - The same as binary, except that trailing space characters are ignored.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RTRIM** - 与binary相同，但忽略尾随空格字符。'
- en: An application can register additional collating functions using the [sqlite3_create_collation()](c3ref/create_collation.html)
    interface.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以使用[sqlite3_create_collation()](c3ref/create_collation.html)接口注册额外的排序函数。
- en: Collating functions only matter when comparing string values. Numeric values
    are always compared numerically, and BLOBs are always compared byte-by-byte using
    memcmp().
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 排序函数仅在比较字符串值时才重要。数字值始终以数值方式比较，而BLOB始终使用memcmp()逐字节比较。
- en: 7.1\. Assigning Collating Sequences from SQL
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1. 从SQL分配排序序列
- en: Every column of every table has an associated collating function. If no collating
    function is explicitly defined, then the collating function defaults to BINARY.
    The COLLATE clause of the [column definition](lang_createtable.html#tablecoldef)
    is used to define alternative collating functions for a column.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 每个表的每个列都有一个关联的排序函数。如果未明确定义排序函数，则默认为BINARY。[列定义](lang_createtable.html#tablecoldef)的COLLATE子句用于为列定义替代排序函数。
- en: 'The rules for determining which collating function to use for a binary comparison
    operator (=, <, >, <=, >=, !=, IS, and IS NOT) are as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 用于二进制比较运算符（=，<，>，<=，>=，!=，IS和IS NOT）确定使用哪个排序函数的规则如下：
- en: If either operand has an explicit collating function assignment using the postfix
    [COLLATE operator](lang_expr.html#collateop), then the explicit collating function
    is used for comparison, with precedence to the collating function of the left
    operand.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果任一操作数使用后缀[COLLATE operator](lang_expr.html#collateop)具有显式的排序函数分配，则将使用显式的排序函数进行比较，优先于左操作数的排序函数。
- en: If either operand is a column, then the collating function of that column is
    used with precedence to the left operand. For the purposes of the previous sentence,
    a column name preceded by one or more unary "+" operators and/or CAST operators
    is still considered a column name.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果任一操作数是列，则使用该列的排序函数，左操作数优先。对于前述句子，以一个或多个一元“+”运算符和/或CAST运算符前缀的列名仍然被视为列名。
- en: Otherwise, the BINARY collating function is used for comparison.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，将使用BINARY排序函数进行比较。
- en: An operand of a comparison is considered to have an explicit collating function
    assignment (rule 1 above) if any subexpression of the operand uses the postfix
    [COLLATE operator](lang_expr.html#collateop). Thus, if a [COLLATE operator](lang_expr.html#collateop)
    is used anywhere in a comparison expression, the collating function defined by
    that operator is used for string comparison regardless of what table columns might
    be a part of that expression. If two or more [COLLATE operator](lang_expr.html#collateop)
    subexpressions appear anywhere in a comparison, the left most explicit collating
    function is used regardless of how deeply the COLLATE operators are nested in
    the expression and regardless of how the expression is parenthesized.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果比较的操作数的任何子表达式使用后缀[COLLATE operator](lang_expr.html#collateop)，则该操作数被认为有显式的排序函数分配（规则1）。因此，如果在比较表达式的任何地方使用[COLLATE
    operator](lang_expr.html#collateop)，则该操作数的排序函数定义将用于字符串比较，而不管该表的列可能是该表达式的一部分。如果在比较中的任何地方出现两个或更多的[COLLATE
    operator](lang_expr.html#collateop)子表达式，则无论COLLATE运算符在表达式中嵌套多深，以及表达式如何括号化，最左边的显式排序函数都将被使用。
- en: 'The expression "x BETWEEN y and z" is logically equivalent to two comparisons
    "x >= y AND x <= z" and works with respect to collating functions as if it were
    two separate comparisons. The expression "x IN (SELECT y ...)" is handled in the
    same way as the expression "x = y" for the purposes of determining the collating
    sequence. The collating sequence used for expressions of the form "x IN (y, z,
    ...)" is the collating sequence of x. If an explicit collating sequence is required
    on an IN operator it should be applied to the left operand, like this: "x COLLATE
    nocase IN (y,z, ...)".'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式"x BETWEEN y and z"在逻辑上等同于两个比较"x >= y AND x <= z"，并且在处理排序函数时，它会被视为两个独立的比较。表达式"x
    IN (SELECT y ...)"在确定排序顺序时与表达式"x = y"处理方式相同。对于形式为"x IN (y, z, ...)"的表达式，使用的排序顺序是x的排序顺序。如果在IN运算符上需要明确的排序顺序，则应将其应用于左操作数，如下所示："x
    COLLATE nocase IN (y,z, ...)"。
- en: Terms of the ORDER BY clause that is part of a [SELECT](lang_select.html) statement
    may be assigned a collating sequence using the [COLLATE operator](lang_expr.html#collateop),
    in which case the specified collating function is used for sorting. Otherwise,
    if the expression sorted by an ORDER BY clause is a column, then the collating
    sequence of the column is used to determine sort order. If the expression is not
    a column and has no COLLATE clause, then the BINARY collating sequence is used.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[SELECT](lang_select.html)语句的ORDER BY子句的项可以使用[COLLATE运算符](lang_expr.html#collateop)分配排序顺序，这样指定的排序函数将用于排序。否则，如果由ORDER
    BY子句排序的表达式是列，则使用该列的排序顺序确定排序顺序。如果表达式不是列并且没有COLLATE子句，则使用BINARY排序顺序。'
- en: 7.2\. Collation Sequence Examples
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2\. 排序顺序示例
- en: The examples below identify the collating sequences that would be used to determine
    the results of text comparisons that may be performed by various SQL statements.
    Note that a text comparison may not be required, and no collating sequence used,
    in the case of numeric, blob or NULL values.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例确定了可能由各种SQL语句执行的文本比较的排序顺序。请注意，在数字、blob或NULL值的情况下可能不需要文本比较，并且不使用排序顺序。
- en: '[PRE4]'
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE4]'
