["```sql\nCREATE VIRTUAL TABLE email USING fts5(sender, title, body);\n\n```", "```sql\n*-- Query for all rows that contain at least once instance of the term*\n*-- \"fts5\" (in any column). The following three queries are equivalent.*\nSELECT * FROM email WHERE email MATCH 'fts5';\nSELECT * FROM email WHERE email = 'fts5';\nSELECT * FROM email('fts5');\n\n```", "```sql\n*-- Query for all rows that contain at least once instance of the term*\n*-- \"fts5\" (in any column). Return results in order from best to worst*\n*-- match.* \nSELECT * FROM email WHERE email MATCH 'fts5' ORDER BY rank;\n\n```", "```sql\n*-- Query for rows that match \"fts5\". Return a copy of the \"body\" column*\n*-- of each row with the matches surrounded by <b></b> tags.*\nSELECT highlight(email, 2, '<b>', '</b>') FROM email('fts5');\n\n```", "```sql\n$ wget -c https://www.sqlite.org/src/tarball/SQLite-trunk.tgz?uuid=trunk -O SQLite-trunk.tgz\n.... output ...\n$ tar -xzf SQLite-trunk.tgz\n$ cd SQLite-trunk\n$ ./configure && make fts5.c\n... lots of output ...\n$ ls fts5.[ch]\nfts5.c        fts5.h\n\n```", "```sql\n<phrase>    := string [*]\n<phrase>    := <phrase> + <phrase>\n<neargroup> := NEAR ( <phrase> <phrase> ... [, N] )\n<query>     := [ [-] <colspec> :] [^] <phrase>\n<query>     := [ [-] <colspec> :] <neargroup>\n<query>     := [ [-] <colspec> :] ( <query> )\n<query>     := <query> AND <query>\n<query>     := <query> OR <query>\n<query>     := <query> NOT <query>\n<colspec>   := colname\n<colspec>   := { colname1 colname2 ... }\n\n```", "```sql\n... MATCH '\"one two three\"'\n... MATCH 'one + two + three'\n... MATCH '\"one two\" + three'\n... MATCH 'one.two.three'\n\n```", "```sql\n... MATCH '\"one two thr\" * '\n... MATCH 'one + two + thr*'\n... MATCH '\"one two thr*\"'      -- May not work as expected!\n\n```", "```sql\n... MATCH '^one'              *-- first token in any column must be \"one\"*\n... MATCH '^ one + two'       *-- phrase \"one two\" must appear at start of a column*\n... MATCH '^ \"one two\"'       *-- same as previous* \n... MATCH 'a : ^two'          *-- first token of column \"a\" must be \"two\"*\n... MATCH 'NEAR(^one, two)'   -- syntax error! \n... MATCH 'one + ^two'        -- syntax error! \n... MATCH '\"^one two\"'        -- May not work as expected!\n\n```", "```sql\n... MATCH 'NEAR(\"one two\" \"three four\", 10)'\n... MATCH 'NEAR(\"one two\" thr* + four)'\n\n```", "```sql\nCREATE VIRTUAL TABLE f USING fts5(x);\nINSERT INTO f(rowid, x) VALUES(1, 'A B C D x x x E F x');\n\n... MATCH 'NEAR(e d, 4)';                      *-- Matches!*\n... MATCH 'NEAR(e d, 3)';                      *-- Matches!*\n... MATCH 'NEAR(e d, 2)';                      *-- Does not match!*\n\n... MATCH 'NEAR(\"c d\" \"e f\", 3)';              *-- Matches!*\n... MATCH 'NEAR(\"c\"   \"e f\", 3)';              *-- Does not match!*\n\n... MATCH 'NEAR(a d e, 6)';                    *-- Matches!*\n... MATCH 'NEAR(a d e, 5)';                    *-- Does not match!*\n\n... MATCH 'NEAR(\"a b c d\" \"b c\" \"e f\", 4)';    *-- Matches!*\n... MATCH 'NEAR(\"a b c d\" \"b c\" \"e f\", 3)';    *-- Does not match!*\n\n```", "```sql\n... MATCH 'colname : NEAR(\"one two\" \"three four\", 10)'\n... MATCH '\"colname\" : one + two + three'\n\n... MATCH '{col1 col2} : NEAR(\"one two\" \"three four\", 10)'\n... MATCH '{col2 col1 col3} : one + two + three'\n\n```", "```sql\n*-- Search for matches in all columns except \"colname\"*\n... MATCH '- colname : NEAR(\"one two\" \"three four\", 10)'\n\n*-- Search for matches in all columns except \"col1\", \"col2\" and \"col3\"*\n... MATCH '- {col2 col1 col3} : one + two + three'\n\n```", "```sql\n*-- The following are equivalent:*\n... MATCH '{a b} : ( {b c} : \"hello\" AND \"world\" )'\n... MATCH '(b : \"hello\") AND ({a b} : \"world\")'\n\n```", "```sql\n*-- Given the following table*\nCREATE VIRTUAL TABLE ft USING fts5(a, b, c);\n\n*-- The following are equivalent*\nSELECT * FROM ft WHERE b MATCH 'uvw AND xyz';\nSELECT * FROM ft WHERE ft MATCH 'b : (uvw AND xyz)';\n\n*-- This query cannot match any rows (since all columns are filtered out):* \nSELECT * FROM ft WHERE b MATCH 'a : xyz';\n\n```", "```sql\n*-- Because NOT groups more tightly than OR, either of the following may*\n*-- be used to match all documents that contain the token \"two\" but not*\n*-- \"three\", or contain the token \"one\".* \n... MATCH 'one OR two NOT three'\n... MATCH 'one OR (two NOT three)'\n\n*-- Matches documents that contain at least one instance of either \"one\"*\n*-- or \"two\", but do not contain any instances of token \"three\".*\n... MATCH '(one OR two) NOT three'\n\n```", "```sql\n... MATCH 'one two three'         *-- 'one AND two AND three'*\n... MATCH 'three \"one two\"'       *-- 'three AND \"one two\"'*\n... MATCH 'NEAR(one two) three'   *-- 'NEAR(one two) AND three'*\n... MATCH 'one OR two three'      *-- 'one OR two AND three'*\n... MATCH 'one NOT two three'     *-- 'one NOT (two AND three)'*\n\n... MATCH '(one OR two) three'    *-- Syntax error!*\n... MATCH 'func(one two)'         *-- Syntax error!*\n\n```", "```sql\nCREATE VIRTUAL TABLE mail USING fts5(sender, title, body, tokenize = 'porter ascii');\n\n```", "```sql\nCREATE VIRTUAL TABLE customers USING fts5(name, addr, uuid UNINDEXED);\n\n```", "```sql\n*-- Two ways to create an FTS5 table that maintains prefix indexes for\n-- two and three character prefix tokens.*\nCREATE VIRTUAL TABLE ft USING fts5(a, b, prefix='2 3');\nCREATE VIRTUAL TABLE ft USING fts5(a, b, prefix=2, prefix=3);\n\n```", "```sql\n*-- The following are all equivalent*\nCREATE VIRTUAL TABLE t1 USING fts5(x, tokenize = 'porter ascii');\nCREATE VIRTUAL TABLE t1 USING fts5(x, tokenize = \"porter ascii\");\nCREATE VIRTUAL TABLE t1 USING fts5(x, tokenize = \"'porter' 'ascii'\");\nCREATE VIRTUAL TABLE t1 USING fts5(x, tokenize = '''porter'' ''ascii''');\n\n*-- But this will fail:*\nCREATE VIRTUAL TABLE t1 USING fts5(x, tokenize = '\"porter\" \"ascii\"');\n\n*-- This will fail too:*\nCREATE VIRTUAL TABLE t1 USING fts5(x, tokenize = 'porter' 'ascii');\n\n```", "```sql\n*-- Create an FTS5 table that does not remove diacritics from Latin\n-- script characters, and that considers hyphens and underscore characters\n-- to be part of tokens.* \nCREATE VIRTUAL TABLE ft USING fts5(a, b,\n    tokenize = \"unicode61 remove_diacritics 0 tokenchars '-_'\"\n);\n\n```", "```sql\n*-- Create an FTS5 table that, as well as the default token character classes,*\n*-- considers characters in class \"Mn\" to be token characters.*\nCREATE VIRTUAL TABLE ft USING fts5(a, b,\n    tokenize = \"unicode61 categories 'L* N* Co Mn'\"\n);\n\n```", "```sql\n*-- Create an FTS5 table that uses the ascii tokenizer, but does not\n-- consider numeric characters to be part of tokens.*\nCREATE VIRTUAL TABLE ft USING fts5(a, b,\n    tokenize = \"ascii separators '0123456789'\"\n);\n\n```", "```sql\n*-- Two ways to create an FTS5 table that uses the porter tokenizer to\n-- stem the output of the default tokenizer (unicode61).* \nCREATE VIRTUAL TABLE t1 USING fts5(x, tokenize = porter);\nCREATE VIRTUAL TABLE t1 USING fts5(x, tokenize = 'porter unicode61');\n\n*-- A porter tokenizer used to stem the output of the unicode61 tokenizer,\n-- with diacritics removed before stemming.*\nCREATE VIRTUAL TABLE t1 USING fts5(x, tokenize = 'porter unicode61 remove_diacritics 1');\n\n```", "```sql\nCREATE VIRTUAL TABLE tri USING fts5(a, tokenize=\"trigram\");\nINSERT INTO tri VALUES('abcdefghij KLMNOPQRST uvwxyz');\n\n*-- The following queries all match the single row in the table*\nSELECT * FROM tri('cdefg');\nSELECT * FROM tri('cdefg AND pqr');\nSELECT * FROM tri('\"hij klm\" NOT stuv');\n\n```", "```sql\n*-- A case-sensitive trigram index*\nCREATE VIRTUAL TABLE tri USING fts5(a, tokenize=\"trigram case_sensitive 1\");\n\n```", "```sql\nSELECT * FROM tri WHERE a LIKE '%cdefg%';\nSELECT * FROM tri WHERE a GLOB '*ij klm*xyz';\n\n```", "```sql\nCREATE VIRTUAL TABLE f1 USING fts5(a, b, c, content='');\n\n```", "```sql\nCREATE VIRTUAL TABLE f1 USING fts5(a, b, c, content='', contentless_delete=1);\n\n```", "```sql\n*-- Supported UPDATE statement:*\nUPDATE f1 SET a=?, b=?, c=? WHERE rowid=?;\n\n*-- This UPDATE is not supported, as it does not supply a new value*\n*-- for column \"c\".*\nUPDATE f1 SET a=?, b=? WHERE rowid=?;\n\n```", "```sql\nSELECT <content_rowid>, <cols> FROM <content> WHERE <content_rowid> = ?;\n\n```", "```sql\n*-- If the database schema is:* \nCREATE TABLE tbl (a, b, c, d INTEGER PRIMARY KEY);\nCREATE VIRTUAL TABLE fts USING fts5(a, c, content=tbl, content_rowid=d);\n\n*-- Fts5 may issue queries such as:*\nSELECT d, a, c FROM tbl WHERE d = ?;\n\n```", "```sql\nSELECT <content_rowid>, <cols> FROM <content> ORDER BY <content_rowid> ASC;\nSELECT <content_rowid>, <cols> FROM <content> ORDER BY <content_rowid> DESC;\n\n```", "```sql\n*-- Create a table. And an external content fts5 table to index it.*\nCREATE TABLE tbl(a INTEGER PRIMARY KEY, b, c);\nCREATE VIRTUAL TABLE fts_idx USING fts5(b, c, content='tbl', content_rowid='a');\n\n*-- Triggers to keep the FTS index up to date.*\nCREATE TRIGGER tbl_ai AFTER INSERT ON tbl BEGIN\n  INSERT INTO fts_idx(rowid, b, c) VALUES (new.a, new.b, new.c);\nEND;\nCREATE TRIGGER tbl_ad AFTER DELETE ON tbl BEGIN\n  INSERT INTO fts_idx(fts_idx, rowid, b, c) VALUES('delete', old.a, old.b, old.c);\nEND;\nCREATE TRIGGER tbl_au AFTER UPDATE ON tbl BEGIN\n  INSERT INTO fts_idx(fts_idx, rowid, b, c) VALUES('delete', old.a, old.b, old.c);\n  INSERT INTO fts_idx(rowid, b, c) VALUES (new.a, new.b, new.c);\nEND;\n\n```", "```sql\nSELECT <content_rowid>, <cols> FROM <content> WHERE <content_rowid> = ?;\n\n```", "```sql\n*-- Create and populate a table.* \nCREATE TABLE tbl(a INTEGER PRIMARY KEY, t TEXT);\nINSERT INTO tbl VALUES(1, 'all that glitters');\nINSERT INTO tbl VALUES(2, 'is not gold');\n\n*-- Create an external content FTS5 table* \nCREATE VIRTUAL TABLE ft USING fts5(t, content='tbl', content_rowid='a');\n\n```", "```sql\n*-- Returns 2 rows.  Because the query does not use the FTS index, it is*\n*-- effectively executed against table 'tbl' directly, and so returns*\n*-- both rows.*\nSELECT * FROM t1;\n\n*-- Returns 0 rows.  This query does use the FTS index, which currently*\n*-- contains no entries. So it returns 0 rows.*\nSELECT rowid, t FROM t1('gold')\n\n```", "```sql\n*-- Create and populate a table.* \nCREATE TABLE tbl(a INTEGER PRIMARY KEY, t TEXT);\n\n*-- Create an external content FTS5 table* \nCREATE VIRTUAL TABLE ft USING fts5(t, content='tbl', content_rowid='a');\nINSERT INTO ft(rowid, t) VALUES(1, 'all that glitters');\nINSERT INTO ft(rowid, t) VALUES(2, 'is not gold');\n\n```", "```sql\n*-- Returns 0 rows.  Since it does not use the FTS index, the query is*\n*-- passed directly through to table 'tbl', which contains no data.*\nSELECT * FROM t1;\n\n*-- Returns 1 row. The \"rowid\" field of the returned row is 2, and*\n*-- the \"t\" field set to NULL. \"t\" is set to NULL because when the external*\n*-- content table \"tbl\" was queried for the data associated with the row*\n*-- with a=2 (\"a\" is the content_rowid column), none could be found.*\nSELECT rowid, t FROM t1('gold')\n\n```", "```sql\n*-- Create and populate a table.* \nCREATE TABLE tbl(a INTEGER PRIMARY KEY, t TEXT);\nINSERT INTO tbl VALUES(1, 'all that glitters');\nINSERT INTO tbl VALUES(2, 'is not gold');\n\n*-- Create an external content FTS5 table* \nCREATE VIRTUAL TABLE ft USING fts5(t, content='tbl', content_rowid='a');\n\n*-- Create triggers to keep the FTS5 table up to date*\nCREATE TRIGGER tbl_ai AFTER INSERT ON tbl BEGIN\n  INSERT INTO ft(rowid, t) VALUES (new.a, new.t);\nEND;\n<similar triggers for update + delete>\n\n```", "```sql\n*-- A table without the xColumnSize() values stored on disk:*\nCREATE VIRTUAL TABLE ft USING fts5(a, b, c, columnsize=0);\n\n*-- Three equivalent ways of creating a table that does store the*\n*-- xColumnSize() values on disk:*\nCREATE VIRTUAL TABLE ft USING fts5(a, b, c);\nCREATE VIRTUAL TABLE ft USING fts5(a, b, c, columnsize=1);\nCREATE VIRTUAL TABLE ft USING fts5(a, b, columnsize='1', c);\n\n```", "```sql\n*-- The following two lines are equivalent (because the default value*\n*-- of \"detail\" is \"full\".* \nCREATE VIRTUAL TABLE ft1 USING fts5(a, b, c);\nCREATE VIRTUAL TABLE ft1 USING fts5(a, b, c, detail=full);\n\nCREATE VIRTUAL TABLE ft2 USING fts5(a, b, c, detail=column);\nCREATE VIRTUAL TABLE ft3 USING fts5(a, b, c, detail=none);\n\n```", "```sql\nSELECT highlight(email, 2, '<b>', '</b>') FROM email WHERE email MATCH 'fts5'\n\n```", "```sql\nSELECT * FROM fts WHERE fts MATCH ? ORDER BY bm25(fts)\n\n```", "```sql\n*-- Assuming the following schema:*\nCREATE VIRTUAL TABLE email USING fts5(sender, title, body);\n\n*-- Return results in bm25 order, with each phrase hit in the \"sender\"*\n*-- column considered the equal of 10 hits in the \"body\" column, and*\n*-- each hit in the \"title\" column considered as valuable as 5 hits in*\n*-- the \"body\" column.*\nSELECT * FROM email WHERE email MATCH ? ORDER BY bm25(email, 10.0, 5.0);\n\n```", "```sql\n*-- Return a copy of the text from the leftmost column of the current*\n*-- row, with phrase matches marked using html \"b\" tags.*\nSELECT highlight(fts, 0, '<b>', '</b>') FROM fts WHERE fts MATCH ?\n\n```", "```sql\n*-- Assuming this:*\nCREATE VIRTUAL TABLE ft USING fts5(a);\nINSERT INTO ft VALUES('a b c x c d e');\nINSERT INTO ft VALUES('a b c c d e');\nINSERT INTO ft VALUES('a b c d e');\n\n*-- The following SELECT statement returns these three rows:*\n*--   '[a b c] x [c d e]'*\n*--   '[a b c] [c d e]'*\n*--   '[a b c d e]'*\nSELECT highlight(ft, 0, '[', ']') FROM ft WHERE ft MATCH 'a+b+c AND c+d+e';\n\n```", "```sql\n*-- The following queries are logically equivalent. But the second may*\n*-- be faster, particularly if the caller abandons the query before*\n*-- all rows have been returned (or if the queries were modified to* \n*-- include LIMIT clauses).*\nSELECT * FROM fts WHERE fts MATCH ? ORDER BY bm25(fts);\nSELECT * FROM fts WHERE fts MATCH ? ORDER BY rank;\n\n```", "```sql\nrank MATCH 'auxiliary-function-name(arg1, arg2, ...)'\nrank = 'auxiliary-function-name(arg1, arg2, ...)'\n\n```", "```sql\n*-- The following queries are logically equivalent. But the second may*\n*-- be faster. See above.* \nSELECT * FROM fts WHERE fts MATCH ? ORDER BY bm25(fts, 10.0, 5.0);\nSELECT * FROM fts WHERE fts MATCH ? AND rank MATCH 'bm25(10.0, 5.0)' ORDER BY rank;\n\n```", "```sql\nSELECT * FROM fts WHERE fts MATCH ? AND rank MATCH 'bm25(10.0, 5.0)' ORDER BY rank;\nSELECT * FROM fts WHERE fts = ? AND rank = 'bm25(10.0, 5.0)' ORDER BY rank;\nSELECT * FROM fts WHERE fts(?, 'bm25(10.0, 5.0)') ORDER BY rank;\n\n```", "```sql\nINSERT INTO ft(ft, rank) VALUES('automerge', 8);\n\n```", "```sql\nINSERT INTO ft(ft, rank) VALUES('crisismerge', 16);\n\n```", "```sql\n*-- Insert a row with rowid=14 into the fts5 table.*\nINSERT INTO ft(rowid, a, b, c) VALUES(14, $a, $b, $c);\n\n*-- Remove the same row from the fts5 table.*\nINSERT INTO ft(ft, rowid, a, b, c) VALUES('delete', 14, $a, $b, $c);\n\n```", "```sql\nINSERT INTO ft(ft) VALUES('delete-all');\n\n```", "```sql\nINSERT INTO ft(ft, rank) VALUES('deletemerge', 15);\n\n```", "```sql\nINSERT INTO ft(ft) VALUES('integrity-check');\nINSERT INTO ft(ft, rank) VALUES('integrity-check', 0);\nINSERT INTO ft(ft, rank) VALUES('integrity-check', 1);\n\n```", "```sql\nINSERT INTO ft(ft, rank) VALUES('merge', 500);\n\n```", "```sql\nINSERT INTO ft(ft) VALUES('optimize');\n\n```", "```sql\nINSERT INTO ft(ft, rank) VALUES('pgsz', 4072);\n\n```", "```sql\nINSERT INTO ft(ft, rank) VALUES('rank', 'bm25(10.0, 5.0)');\n\n```", "```sql\nINSERT INTO ft(ft) VALUES('rebuild');\n\n```", "```sql\nINSERT INTO ft(ft, rank) VALUES('secure-delete', 1);\n\n```", "```sql\nINSERT INTO ft(ft, rank) VALUES('usermerge', 4);\n\n```", "```sql\n*/*\n** Return a pointer to the fts5_api pointer for database connection db.\n** If an error occurs, return NULL and leave an error in the database\n** handle (accessible using sqlite3_errcode()/errmsg()).\n*/*\nfts5_api *fts5_api_from_db(sqlite3 *db){\n  fts5_api *pRet = 0;\n  sqlite3_stmt *pStmt = 0;\n\n  if( SQLITE_OK==sqlite3_prepare(db, \"SELECT fts5(?1)\", -1, &pStmt, 0) ){\n    sqlite3_bind_pointer(pStmt, 1, (void*)&pRet, \"fts5_api_ptr\", NULL);\n    sqlite3_step(pStmt);\n  }\n  sqlite3_finalize(pStmt);\n  return pRet;\n}\n\n```", "```sql\ntypedef struct fts5_api fts5_api;\nstruct fts5_api {\n  int iVersion;                   */* Currently always set to 2 */*\n\n  */* Create a new tokenizer */*\n  int (*xCreateTokenizer)(\n    fts5_api *pApi,\n    const char *zName,\n    void *pUserData,\n    fts5_tokenizer *pTokenizer,\n    void (*xDestroy)(void*)\n  );\n\n  */* Find an existing tokenizer */*\n  int (*xFindTokenizer)(\n    fts5_api *pApi,\n    const char *zName,\n    void **ppUserData,\n    fts5_tokenizer *pTokenizer\n  );\n\n  */* Create a new auxiliary function */*\n  int (*xCreateFunction)(\n    fts5_api *pApi,\n    const char *zName,\n    void *pUserData,\n    fts5_extension_function xFunction,\n    void (*xDestroy)(void*)\n  );\n};\n\n```", "```sql\nrc = pFts5Api->xCreateTokenizer(pFts5Api, ... other args ...);\n\n```", "```sql\ntypedef struct Fts5Tokenizer Fts5Tokenizer;\ntypedef struct fts5_tokenizer fts5_tokenizer;\nstruct fts5_tokenizer {\n  int (*xCreate)(void*, const char **azArg, int nArg, Fts5Tokenizer **ppOut);\n  void (*xDelete)(Fts5Tokenizer*);\n  int (*xTokenize)(Fts5Tokenizer*, \n      void *pCtx,\n      int flags,            */* Mask of FTS5_TOKENIZE_* flags */*\n      const char *pText, int nText, \n      int (*xToken)(\n        void *pCtx,         */* Copy of 2nd argument to xTokenize() */*\n        int tflags,         */* Mask of FTS5_TOKEN_* flags */*\n        const char *pToken, */* Pointer to buffer containing token */*\n        int nToken,         */* Size of token in bytes */*\n        int iStart,         */* Byte offset of token within input text */*\n        int iEnd            */* Byte offset of end of token within input text */*\n      )\n  );\n};\n\n*/* Flags that may be passed as the third argument to xTokenize() */*\n#define FTS5_TOKENIZE_QUERY     0x0001\n#define FTS5_TOKENIZE_PREFIX    0x0002\n#define FTS5_TOKENIZE_DOCUMENT  0x0004\n#define FTS5_TOKENIZE_AUX       0x0008\n\n*/* Flags that may be passed by the tokenizer implementation back to FTS5\n** as the third argument to the supplied xToken callback. */*\n#define FTS5_TOKEN_COLOCATED    0x0001      */* Same position as prev. token */*\n\n```", "```sql\n    ... MATCH 'first place'\n\n    ```", "```sql\n    ... MATCH '(first OR 1st) place'\n\n    ```", "```sql\nxToken(pCtx, 0, \"i\",                      1,  0,  1);\nxToken(pCtx, 0, \"won\",                    3,  2,  5);\nxToken(pCtx, 0, \"first\",                  5,  6, 11);\nxToken(pCtx, FTS5_TOKEN_COLOCATED, \"1st\", 3,  6, 11);\nxToken(pCtx, 0, \"place\",                  5, 12, 17);\n\n```", "```sql\n... MATCH '1s*'\n\n```", "```sql\ntypedef struct Fts5ExtensionApi Fts5ExtensionApi;\ntypedef struct Fts5Context Fts5Context;\ntypedef struct Fts5PhraseIter Fts5PhraseIter;\n\ntypedef void (*fts5_extension_function)(\n  const Fts5ExtensionApi *pApi,   */* API offered by current FTS version */*\n  Fts5Context *pFts,              */* First arg to pass to pApi functions */*\n  sqlite3_context *pCtx,          */* Context for returning result/error */*\n  int nVal,                       */* Number of values in apVal[] array */*\n  sqlite3_value **apVal           */* Array of trailing arguments */*\n);\n\n```", "```sql\n*/*\n** Implementation of an auxiliary function that returns the number\n** of tokens in the current row (including all columns).\n*/*\nstatic void column_size_imp(\n  const Fts5ExtensionApi *pApi,\n  Fts5Context *pFts,\n  sqlite3_context *pCtx,\n  int nVal,\n  sqlite3_value **apVal\n){\n  int rc;\n  int nToken;\n  rc = pApi->xColumnSize(pFts, -1, &nToken);\n  if( rc==SQLITE_OK ){\n    sqlite3_result_int(pCtx, nToken);\n  }else{\n    sqlite3_result_error_code(pCtx, rc);\n  }\n}\n\n```", "```sql\nCREATE VIRTUAL TABLE ft USING fts5(a, b);\nINSERT INTO ft(rowid, a, b) VALUES\n        (1, 'ab cd', 'cd de one'),\n        (2, 'de fg', 'fg gh'),\n        (3, 'gh ij', 'ij ab three four');\n\n```", "```sql\nSELECT my_aux_function(ft) FROM ft('ab')\n\n```", "```sql\nSELECT my_aux_function(ft) FROM ft('ab AND \"cd ef gh\" OR ij + kl')\n\n```", "```sql\nCREATE VIRTUAL TABLE ft2 USING fts5(x, y);\nINSERT INTO ft2(rowid, x, y) VALUES\n        (1, 'xxx one two xxx five xxx six', 'seven four'),\n        (2, 'five four four xxx six', 'three four five six four five six');\n\n```", "```sql\nSELECT my_aux_function(ft2) FROM ft2(\n    '(\"one two\" OR \"three\") AND y:four NEAR(five six, 2)'\n);\n\n```", "```sql\nstruct Fts5ExtensionApi {\n  int iVersion;                   */* Currently always set to 3 */*\n\n  void *(*xUserData)(Fts5Context*);\n\n  int (*xColumnCount)(Fts5Context*);\n  int (*xRowCount)(Fts5Context*, sqlite3_int64 *pnRow);\n  int (*xColumnTotalSize)(Fts5Context*, int iCol, sqlite3_int64 *pnToken);\n\n  int (*xTokenize)(Fts5Context*, \n    const char *pText, int nText, */* Text to tokenize */*\n    void *pCtx,                   */* Context passed to xToken() */*\n    int (*xToken)(void*, int, const char*, int, int, int)       */* Callback */*\n  );\n\n  int (*xPhraseCount)(Fts5Context*);\n  int (*xPhraseSize)(Fts5Context*, int iPhrase);\n\n  int (*xInstCount)(Fts5Context*, int *pnInst);\n  int (*xInst)(Fts5Context*, int iIdx, int *piPhrase, int *piCol, int *piOff);\n\n  sqlite3_int64 (*xRowid)(Fts5Context*);\n  int (*xColumnText)(Fts5Context*, int iCol, const char **pz, int *pn);\n  int (*xColumnSize)(Fts5Context*, int iCol, int *pnToken);\n\n  int (*xQueryPhrase)(Fts5Context*, int iPhrase, void *pUserData,\n    int(*)(const Fts5ExtensionApi*,Fts5Context*,void*)\n  );\n  int (*xSetAuxdata)(Fts5Context*, void *pAux, void(*xDelete)(void*));\n  void *(*xGetAuxdata)(Fts5Context*, int bClear);\n\n  int (*xPhraseFirst)(Fts5Context*, int iPhrase, Fts5PhraseIter*, int*, int*);\n  void (*xPhraseNext)(Fts5Context*, Fts5PhraseIter*, int *piCol, int *piOff);\n\n  int (*xPhraseFirstColumn)(Fts5Context*, int iPhrase, Fts5PhraseIter*, int*);\n  void (*xPhraseNextColumn)(Fts5Context*, Fts5PhraseIter*, int *piCol);\n\n  */* Below this point are iVersion>=3 only */*\n  int (*xQueryToken)(Fts5Context*, \n      int iPhrase, int iToken, \n      const char **ppToken, int *pnToken\n  );\n  int (*xInstToken)(Fts5Context*, int iIdx, int iToken, const char**, int*);\n};\n\n```", "```sql\n... FROM ftstable WHERE ftstable MATCH $p ORDER BY rowid\n\n```", "```sql\nSELECT count(*) FROM ftstable;\n\n```", "```sql\nFts5PhraseIter iter;\nint iCol, iOff;\nfor(pApi->xPhraseFirst(pFts, iPhrase, &iter, &iCol, &iOff);\n    iCol>=0;\n    pApi->xPhraseNext(pFts, &iter, &iCol, &iOff)\n){\n  // An instance of phrase iPhrase at offset iOff of column iCol\n}\n\n```", "```sql\nFts5PhraseIter iter;\nint iCol;\nfor(pApi->xPhraseFirstColumn(pFts, iPhrase, &iter, &iCol);\n    iCol>=0;\n    pApi->xPhraseNextColumn(pFts, &iter, &iCol)\n){\n  // Column iCol contains at least one instance of phrase iPhrase\n}\n\n```", "```sql\n*-- Create an fts5vocab \"row\" table to query the full-text index belonging\n-- to FTS5 table \"ft1\".*\nCREATE VIRTUAL TABLE ft1_v USING fts5vocab('ft1', 'row');\n\n*-- Create an fts5vocab \"col\" table to query the full-text index belonging\n-- to FTS5 table \"ft2\".*\nCREATE VIRTUAL TABLE ft2_v USING fts5vocab(ft2, col);\n\n*-- Create an fts5vocab \"instance\" table to query the full-text index\n-- belonging to FTS5 table \"ft3\".*\nCREATE VIRTUAL TABLE ft3_v USING fts5vocab(ft3, instance);\n\n```", "```sql\n*-- Create an fts5vocab \"row\" table to query the full-text index belonging\n-- to FTS5 table \"ft1\" in database \"main\".*\nCREATE VIRTUAL TABLE temp.ft1_v USING fts5vocab(main, 'ft1', 'row');\n\n*-- Create an fts5vocab \"col\" table to query the full-text index belonging\n-- to FTS5 table \"ft2\" in attached database \"aux\".*\nCREATE VIRTUAL TABLE temp.ft2_v USING fts5vocab('aux', ft2, col);\n\n*-- Create an fts5vocab \"instance\" table to query the full-text index\n-- belonging to FTS5 table \"ft3\" in attached database \"other\".*\nCREATE VIRTUAL TABLE temp.ft2_v USING fts5vocab('aux', ft3, 'instance');\n\n```", "```sql\n*-- Assuming a database created using:*\nCREATE VIRTUAL TABLE ft1 USING fts5(c1, c2);\nINSERT INTO ft1 VALUES('apple banana cherry', 'banana banana cherry');\nINSERT INTO ft1 VALUES('cherry cherry cherry', 'date date date');\n\n*-- Then querying the following fts5vocab table (type \"col\") returns:\n--\n--    apple  | c1 | 1 | 1\n--    banana | c1 | 1 | 1\n--    banana | c2 | 1 | 2\n--    cherry | c1 | 2 | 4\n--    cherry | c2 | 1 | 1\n--    date   | c3 | 1 | 3\n--*\nCREATE VIRTUAL TABLE ft1_v_col USING fts5vocab(ft1, col);\n\n*-- Querying an fts5vocab table of type \"row\" returns:\n--\n--    apple  | 1 | 1\n--    banana | 1 | 3\n--    cherry | 2 | 5\n--    date   | 1 | 3\n--*\nCREATE VIRTUAL TABLE ft1_v_row USING fts5vocab(ft1, row);\n\n*-- And, for type \"instance\"\nINSERT INTO ft1 VALUES('apple banana cherry', 'banana banana cherry');\nINSERT INTO ft1 VALUES('cherry cherry cherry', 'date date date');\n--\n--    apple  | 1 | c1 | 0\n--    banana | 1 | c1 | 1\n--    banana | 1 | c2 | 0\n--    banana | 1 | c2 | 1\n--    cherry | 1 | c1 | 2\n--    cherry | 1 | c2 | 2\n--    cherry | 2 | c1 | 0\n--    cherry | 2 | c1 | 1\n--    cherry | 2 | c1 | 2\n--    date   | 2 | c2 | 0\n--    date   | 2 | c2 | 1\n--    date   | 2 | c2 | 2\n--*\nCREATE VIRTUAL TABLE ft1_v_instance USING fts5vocab(ft1, instance);\n\n```", "```sql\n*-- This table contains most of the full-text index data.* \nCREATE TABLE %_data(id INTEGER PRIMARY KEY, block BLOB);\n\n*-- This table contains the remainder of the full-text index data.* \n*-- It is almost always much smaller than the %_data table.* \nCREATE TABLE %_idx(segid, term, pgno, PRIMARY KEY(segid, term)) WITHOUT ROWID;\n\n*-- Contains the values of persistent configuration parameters.*\nCREATE TABLE %_config(k PRIMARY KEY, v) WITHOUT ROWID;\n\n*-- Contains the size of each column of each row in the virtual table*\n*-- in tokens. This shadow table is not present if the \"columnsize\"*\n*-- option is set to 0.*\nCREATE TABLE %_docsize(id INTEGER PRIMARY KEY, sz BLOB);\n\n*-- Contains the actual data inserted into the FTS5 table. There*\n*-- is one \"cN\" column for each indexed column in the FTS5 table.*\n*-- This shadow table is not present for contentless or external* \n*-- content FTS5 tables.* \nCREATE TABLE %_content(id INTEGER PRIMARY KEY, c0, c1...);\n\n```", "```sql\nSELECT ... FROM fts_table('term') WHERE rowid BETWEEN ? AND ?\n\n```", "```sql\nCREATE TABLE %_data(\n  id INTEGER PRIMARY KEY,\n  block BLOB\n);\n\n```", "```sql\n               2, 12, 7, 3\n\n    ```", "```sql\nCREATE TABLE %_idx(\n  segid INTEGER,              *-- segment id*\n  term TEXT,                  *-- prefix of first key on page*\n  pgno INTEGER,               *-- (2*pgno + bDoclistIndex)*\n  PRIMARY KEY(segid, term)\n);\n\n```", "```sql\n       (pgno*2 + bDoclistIndexFlag)\n\n```", "```sql\nSELECT pgno FROM %_idx WHERE segid=$i AND term>=$t ORDER BY term LIMIT 1\n\n```", "```sql\nCREATE TABLE %_docsize(\n    id INTEGER PRIMARY KEY,   -- id of FTS5 row this record pertains to\n    sz BLOB                   -- blob containing nCol packed varints\n);\n\n```", "```sql\nCREATE TABLE %_content(id INTEGER PRIMARY KEY, c0, c1...);\n\n```", "```sql\nCREATE TABLE %_config(k PRIMARY KEY, v) WITHOUT ROWID;\n\n```", "```sql\nsqlite> SELECT * FROM fts_tbl_config;\n┌─────────────┬──────┐\n│      k      │  v   │\n├─────────────┼──────┤\n│ crisismerge │ 8    │\n│ pgsz        │ 8000 │\n│ usermerge   │ 4    │\n│ version     │ 4    │\n└─────────────┴──────┘\n\n```", "```sql\n *-- FTS3/4 statement* \nCREATE VIRTUAL TABLE t1 USING fts4(\n  linkid INTEGER,\n  header CHAR(20),\n  text VARCHAR,\n  notindexed=linkid,\n  matchinfo=fts3,\n  tokenizer=unicode61\n);\n\n *-- FTS5 equivalent (note - the \"tokenizer=unicode61\" option is not*\n *-- required as this is the default for FTS5 anyway)*\nCREATE VIRTUAL TABLE t1 USING fts5(\n  linkid UNINDEXED,\n  header,\n  text,\n  columnsize=0\n);\n\n```", "```sql\n    ... a MATCH 'b: string'\n\n    ```", "```sql\n*-- Given the following SQL:*\nCREATE VIRTUAL TABLE ft USING fts5(a, b);\nINSERT INTO ft(rowid, a, b) VALUES(1, 'X Y', 'Y Z');\nINSERT INTO ft(rowid, a, b) VALUES(2, 'A Z', 'Y Y');\n\n*-- The FTS5 module creates the following mapping on disk:*\nA --> (2, 0, 0)\nX --> (1, 0, 0)\nY --> (1, 0, 1) (1, 1, 0) (2, 1, 0) (2, 1, 1)\nZ --> (1, 1, 1) (2, 0, 1)\n\n```"]