- en: PRAGMA Statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://sqlite.com/pragma.html](https://sqlite.com/pragma.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The PRAGMA statement is an SQL extension specific to SQLite and used to modify
    the operation of the SQLite library or to query the SQLite library for internal
    (non-table) data. The PRAGMA statement is issued using the same interface as other
    SQLite commands (e.g. [SELECT](lang_select.html), [INSERT](lang_insert.html))
    but is different in the following important respects:'
  prefs: []
  type: TYPE_NORMAL
- en: The pragma command is specific to SQLite and is not compatible with any other
    SQL database engine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specific pragma statements may be removed and others added in future releases
    of SQLite. There is no guarantee of backwards compatibility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No error messages are generated if an unknown pragma is issued. Unknown pragmas
    are simply ignored. This means if there is a typo in a pragma statement the library
    does not inform the user of the fact.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some pragmas take effect during the SQL compilation stage, not the execution
    stage. This means if using the C-language [sqlite3_prepare()](c3ref/prepare.html),
    [sqlite3_step()](c3ref/step.html), [sqlite3_finalize()](c3ref/finalize.html) API
    (or similar in a wrapper interface), the pragma may run during the [sqlite3_prepare()](c3ref/prepare.html)
    call, not during the [sqlite3_step()](c3ref/step.html) call as normal SQL statements
    do. Or the pragma might run during sqlite3_step() just like normal SQL statements.
    Whether or not the pragma runs during sqlite3_prepare() or sqlite3_step() depends
    on the pragma and on the specific release of SQLite.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [EXPLAIN](lang_explain.html) and [EXPLAIN QUERY PLAN](eqp.html) prefixes
    to SQL statements only affect the behavior of the statement during [sqlite3_step()](c3ref/step.html).
    That means that PRAGMA statements that take effect during [sqlite3_prepare()](c3ref/prepare.html)
    will behave the same way regardless of whether or not they are prefaced by "EXPLAIN".
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The C-language API for SQLite provides the [SQLITE_FCNTL_PRAGMA](c3ref/c_fcntl_begin_atomic_write.html#sqlitefcntlpragma)
    [file control](c3ref/file_control.html) which gives [VFS](vfs.html) implementations
    the opportunity to add new PRAGMA statements or to override the meaning of built-in
    PRAGMA statements.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA command syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**[pragma-stmt:](syntax/pragma-stmt.html)**'
  prefs: []
  type: TYPE_NORMAL
- en: <svg class="pikchr" viewBox="0 0 824.352 99.576"><text x="75" y="17" text-anchor="middle"
    fill="rgb(0,0,0)" dominant-baseline="central">PRAGMA</text> <text x="218" y="17"
    text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">schema-name</text>
    <text x="320" y="17" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)"
    dominant-baseline="central">.</text> <text x="435" y="17" text-anchor="middle"
    fill="rgb(0,0,0)" dominant-baseline="central">pragma-name</text> <text x="555"
    y="82" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)" dominant-baseline="central">(</text>
    <text x="656" y="82" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">pragma-value</text>
    <text x="758" y="82" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)"
    dominant-baseline="central">)</text> <text x="555" y="44" text-anchor="middle"
    font-weight="bold" fill="rgb(0,0,0)" dominant-baseline="central">=</text> <text
    x="656" y="44" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">pragma-value</text></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '**[pragma-value:](syntax/pragma-value.html)**'
  prefs: []
  type: TYPE_NORMAL
- en: <svg class="pikchr" viewBox="0 0 264.499 110.16"><text x="132" y="17" text-anchor="middle"
    fill="rgb(0,0,0)" dominant-baseline="central">signed-number</text> <text x="92"
    y="55" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">name</text>
    <text x="125" y="92" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">signed-literal</text></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '**[signed-number:](syntax/signed-number.html)**'
  prefs: []
  type: TYPE_NORMAL
- en: <svg class="pikchr" viewBox="0 0 292.013 99.576"><text x="66" y="44" text-anchor="middle"
    font-weight="bold" fill="rgb(0,0,0)" dominant-baseline="central">+</text> <text
    x="191" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">numeric-literal</text>
    <text x="66" y="82" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)"
    dominant-baseline="central">-</text></svg>
  prefs: []
  type: TYPE_NORMAL
- en: 'A pragma can take either zero or one argument. The argument is may be either
    in parentheses or it may be separated from the pragma name by an equal sign. The
    two syntaxes yield identical results. In many pragmas, the argument is a boolean.
    The boolean can be one of:'
  prefs: []
  type: TYPE_NORMAL
- en: '**1 yes true on'
  prefs: []
  type: TYPE_NORMAL
- en: 0 no false off**
  prefs: []
  type: TYPE_NORMAL
- en: 'Keyword arguments can optionally appear in quotes. (Example: `''yes'' [FALSE]`.)
    Some pragmas takes a string literal as their argument. When pragma takes a keyword
    argument, it will usually also take a numeric equivalent as well. For example,
    "0" and "no" mean the same thing, as does "1" and "yes". When querying the value
    of a setting, many pragmas return the number rather than the keyword.'
  prefs: []
  type: TYPE_NORMAL
- en: A pragma may have an optional schema-name before the pragma name. The schema-name
    is the name of an [ATTACH](lang_attach.html)-ed database or "main" or "temp" for
    the main and the TEMP databases. If the optional schema name is omitted, "main"
    is assumed. In some pragmas, the schema name is meaningless and is simply ignored.
    In the documentation below, pragmas for which the schema name is meaningful are
    shown with a "*schema.*" prefix.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PRAGMAs that return results and that have no side-effects can be accessed from
    ordinary [SELECT](lang_select.html) statements as [table-valued functions](vtab.html#tabfunc2).
    For each participating PRAGMA, the corresponding table-valued function has the
    same name as the PRAGMA with a 7-character "pragma_" prefix. The PRAGMA argument
    and schema, if any, are passed as arguments to the table-valued function, with
    the schema as an optional, last argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, information about the columns in an index can be read using the
    [index_info pragma](pragma.html#pragma_index_info) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'Or, the same content can be read using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'The advantage of the table-valued function format is that the query can return
    just a subset of the PRAGMA columns, can include a WHERE clause, can use aggregate
    functions, and the table-valued function can be just one of several data sources
    in a join. For example, to get a list of all indexed columns in a schema, one
    could query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'Additional notes:'
  prefs: []
  type: TYPE_NORMAL
- en: Table-valued functions exist only for built-in PRAGMAs, not for PRAGMAs defined
    using the [SQLITE_FCNTL_PRAGMA](c3ref/c_fcntl_begin_atomic_write.html#sqlitefcntlpragma)
    file control.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Table-valued functions exist only for PRAGMAs that return results and that have
    no side-effects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This feature could be used to implement [information schema](https://en.wikipedia.org/wiki/Information_schema)
    by first creating a separate schema using
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_PRE
- en: Then creating [VIEWs](lang_createview.html) in that schema that implement the
    official information schema tables using table-valued PRAGMA functions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The table-valued functions for PRAGMA feature was added in SQLite version 3.16.0
    (2017-01-02). Prior versions of SQLite cannot use this feature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: List Of PRAGMAs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[analysis_limit](pragma.html#pragma_analysis_limit)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[application_id](pragma.html#pragma_application_id)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[auto_vacuum](pragma.html#pragma_auto_vacuum)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[automatic_index](pragma.html#pragma_automatic_index)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[busy_timeout](pragma.html#pragma_busy_timeout)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[cache_size](pragma.html#pragma_cache_size)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[cache_spill](pragma.html#pragma_cache_spill)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[~~case_sensitive_like¹~~](pragma.html#pragma_case_sensitive_like)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[cell_size_check](pragma.html#pragma_cell_size_check)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[checkpoint_fullfsync](pragma.html#pragma_checkpoint_fullfsync)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[collation_list](pragma.html#pragma_collation_list)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[compile_options](pragma.html#pragma_compile_options)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[~~count_changes¹~~](pragma.html#pragma_count_changes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[~~data_store_directory¹~~](pragma.html#pragma_data_store_directory)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[data_version](pragma.html#pragma_data_version)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[database_list](pragma.html#pragma_database_list)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[~~default_cache_size¹~~](pragma.html#pragma_default_cache_size)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[defer_foreign_keys](pragma.html#pragma_defer_foreign_keys)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[~~empty_result_callbacks¹~~](pragma.html#pragma_empty_result_callbacks)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[encoding](pragma.html#pragma_encoding)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[foreign_key_check](pragma.html#pragma_foreign_key_check)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[foreign_key_list](pragma.html#pragma_foreign_key_list)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[foreign_keys](pragma.html#pragma_foreign_keys)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[freelist_count](pragma.html#pragma_freelist_count)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[~~full_column_names¹~~](pragma.html#pragma_full_column_names)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[fullfsync](pragma.html#pragma_fullfsync)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[function_list](pragma.html#pragma_function_list)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[hard_heap_limit](pragma.html#pragma_hard_heap_limit)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ignore_check_constraints](pragma.html#pragma_ignore_check_constraints)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[incremental_vacuum](pragma.html#pragma_incremental_vacuum)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[index_info](pragma.html#pragma_index_info)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[index_list](pragma.html#pragma_index_list)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[index_xinfo](pragma.html#pragma_index_xinfo)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[integrity_check](pragma.html#pragma_integrity_check)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[journal_mode](pragma.html#pragma_journal_mode)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[journal_size_limit](pragma.html#pragma_journal_size_limit)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[legacy_alter_table](pragma.html#pragma_legacy_alter_table)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[legacy_file_format](pragma.html#pragma_legacy_file_format)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[locking_mode](pragma.html#pragma_locking_mode)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[max_page_count](pragma.html#pragma_max_page_count)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[mmap_size](pragma.html#pragma_mmap_size)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[module_list](pragma.html#pragma_module_list)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[optimize](pragma.html#pragma_optimize)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[page_count](pragma.html#pragma_page_count)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[page_size](pragma.html#pragma_page_size)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[parser_trace²](pragma.html#pragma_parser_trace)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[pragma_list](pragma.html#pragma_pragma_list)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[query_only](pragma.html#pragma_query_only)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[quick_check](pragma.html#pragma_quick_check)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[read_uncommitted](pragma.html#pragma_read_uncommitted)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[recursive_triggers](pragma.html#pragma_recursive_triggers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[reverse_unordered_selects](pragma.html#pragma_reverse_unordered_selects)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[schema_version³](pragma.html#pragma_schema_version)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[secure_delete](pragma.html#pragma_secure_delete)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[~~short_column_names¹~~](pragma.html#pragma_short_column_names)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[shrink_memory](pragma.html#pragma_shrink_memory)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[soft_heap_limit](pragma.html#pragma_soft_heap_limit)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[stats³](pragma.html#pragma_stats)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[synchronous](pragma.html#pragma_synchronous)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[table_info](pragma.html#pragma_table_info)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[table_list](pragma.html#pragma_table_list)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[table_xinfo](pragma.html#pragma_table_xinfo)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[temp_store](pragma.html#pragma_temp_store)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[~~temp_store_directory¹~~](pragma.html#pragma_temp_store_directory)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[threads](pragma.html#pragma_threads)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[trusted_schema](pragma.html#pragma_trusted_schema)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[user_version](pragma.html#pragma_user_version)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[vdbe_addoptrace²](pragma.html#pragma_vdbe_addoptrace)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[vdbe_debug²](pragma.html#pragma_vdbe_debug)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[vdbe_listing²](pragma.html#pragma_vdbe_listing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[vdbe_trace²](pragma.html#pragma_vdbe_trace)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[wal_autocheckpoint](pragma.html#pragma_wal_autocheckpoint)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[wal_checkpoint](pragma.html#pragma_wal_checkpoint)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[writable_schema³](pragma.html#pragma_writable_schema)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Notes:'
  prefs: []
  type: TYPE_NORMAL
- en: Pragmas whose names are ~~struck through~~ are deprecated. Do not use them.
    They exist for historical compatibility.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These pragmas are only available in builds using non-standard compile-time options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These pragmas are used for testing SQLite and are not recommended for use in
    application programs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <h _id="pragma_analysis_limit" style="display:none">PRAGMA analysis_limit</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA analysis_limit;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA analysis_limit =** *N***;**
  prefs: []
  type: TYPE_NORMAL
- en: Query or change a limit on the [approximate ANALYZE](lang_analyze.html#approx)
    setting. This is the approximate number of rows examined in each index by the
    [ANALYZE](lang_analyze.html) command. If the argument *N* is omitted, then the
    analysis limit is unchanged. If the limit is zero, then the analysis limit is
    disabled and the ANALYZE command will examine all rows of each index. If N is
    greater than zero, then the analysis limit is set to N and subsequent ANALYZE
    commands will stop analyzing each index after it has examined approximately N
    rows. If N is a negative number or something other than an integer value, then
    the pragma behaves as if the N argument was omitted. In all cases, the value returned
    is the new analysis limit used for subsequent ANALYZE commands.
  prefs: []
  type: TYPE_NORMAL
- en: This pragma can be used to help the ANALYZE command run faster on large databases.
    The results of analysis are not as good when only part of each index is examined,
    but the results are usually good enough. Setting N to 100 or 1000 allows the ANALYZE
    command to run quickly, even on enormous database files.
  prefs: []
  type: TYPE_NORMAL
- en: This pragma was added in SQLite version 3.32.0 (2020-05-22). The current implementation
    only uses the lower 31 bits of the N value - higher order bits are silently ignored.
    Future versions of SQLite might begin using higher order bits.
  prefs: []
  type: TYPE_NORMAL
- en: Beginning with SQLite version 3.46.0 (2024-05-23), the recommended way of running
    [ANALYZE](lang_analyze.html) is with the [PRAGMA optimize](pragma.html#pragma_optimize)
    command. The [PRAGMA optimize](pragma.html#pragma_optimize) will automatically
    set a reasonable, temporary analysis limit that ensures that the [PRAGMA optimize](pragma.html#pragma_optimize)
    command will finish quickly even on enormous databases. Applications that use
    the [PRAGMA optimize](pragma.html#pragma_optimize) instead of running [ANALYZE](lang_analyze.html)
    directly do not need to set an analysis limit. <h _id="pragma_application_id"
    style="display:none">PRAGMA application_id</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA** *schema.***application_id;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA** *schema.***application_id =** *integer* **;**
  prefs: []
  type: TYPE_NORMAL
- en: The application_id PRAGMA is used to query or set the 32-bit signed big-endian
    "Application ID" integer located at offset 68 into the [database header](fileformat2.html#database_header).
    Applications that use SQLite as their [application file-format](appfileformat.html)
    should set the Application ID integer to a unique integer so that utilities such
    as [file(1)](http://www.darwinsys.com/file/) can determine the specific file type
    rather than just reporting "SQLite3 Database". A list of assigned application
    IDs can be seen by consulting the [magic.txt](https://www.sqlite.org/src/artifact?ci=trunk&filename=magic.txt)
    file in the SQLite source repository.
  prefs: []
  type: TYPE_NORMAL
- en: See also the [user_version pragma](pragma.html#pragma_user_version). <h _id="pragma_auto_vacuum"
    style="display:none">PRAGMA auto_vacuum</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA** *schema.***auto_vacuum;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA** *schema.***auto_vacuum =** *0 | NONE | 1 | FULL | 2 | INCREMENTAL***;**
  prefs: []
  type: TYPE_NORMAL
- en: Query or set the auto-vacuum status in the database.
  prefs: []
  type: TYPE_NORMAL
- en: The default setting for auto-vacuum is 0 or "none", unless the [SQLITE_DEFAULT_AUTOVACUUM](compile.html#default_autovacuum)
    compile-time option is used. The "none" setting means that auto-vacuum is disabled.
    When auto-vacuum is disabled and data is deleted data from a database, the database
    file remains the same size. Unused database file pages are added to a "[freelist](fileformat2.html#freelist)"
    and reused for subsequent inserts. So no database file space is lost. However,
    the database file does not shrink. In this mode the [VACUUM](lang_vacuum.html)
    command can be used to rebuild the entire database file and thus reclaim unused
    disk space.
  prefs: []
  type: TYPE_NORMAL
- en: When the auto-vacuum mode is 1 or "full", the freelist pages are moved to the
    end of the database file and the database file is truncated to remove the freelist
    pages at every transaction commit. Note, however, that auto-vacuum only truncates
    the freelist pages from the file. Auto-vacuum does not defragment the database
    nor repack individual database pages the way that the [VACUUM](lang_vacuum.html)
    command does. In fact, because it moves pages around within the file, auto-vacuum
    can actually make fragmentation worse.
  prefs: []
  type: TYPE_NORMAL
- en: Auto-vacuuming is only possible if the database stores some additional information
    that allows each database page to be traced backwards to its referrer. Therefore,
    auto-vacuuming must be turned on before any tables are created. It is not possible
    to enable or disable auto-vacuum after a table has been created.
  prefs: []
  type: TYPE_NORMAL
- en: When the value of auto-vacuum is 2 or "incremental" then the additional information
    needed to do auto-vacuuming is stored in the database file but auto-vacuuming
    does not occur automatically at each commit as it does with auto_vacuum=full.
    In incremental mode, the separate [incremental_vacuum](pragma.html#pragma_incremental_vacuum)
    pragma must be invoked to cause the auto-vacuum to occur.
  prefs: []
  type: TYPE_NORMAL
- en: The database connection can be changed between full and incremental autovacuum
    mode at any time. However, changing from "none" to "full" or "incremental" can
    only occur when the database is new (no tables have yet been created) or by running
    the [VACUUM](lang_vacuum.html) command. To change auto-vacuum modes, first use
    the auto_vacuum pragma to set the new desired mode, then invoke the [VACUUM](lang_vacuum.html)
    command to reorganize the entire database file. To change from "full" or "incremental"
    back to "none" always requires running [VACUUM](lang_vacuum.html) even on an empty
    database.
  prefs: []
  type: TYPE_NORMAL
- en: When the auto_vacuum pragma is invoked with no arguments, it returns the current
    auto_vacuum mode.
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_automatic_index" style="display:none">PRAGMA automatic_index</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA automatic_index;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA automatic_index =** *boolean***;**
  prefs: []
  type: TYPE_NORMAL
- en: Query, set, or clear the [automatic indexing](optoverview.html#autoindex) capability.
  prefs: []
  type: TYPE_NORMAL
- en: '[Automatic indexing](optoverview.html#autoindex) is enabled by default as of
    [version 3.7.17](releaselog/3_7_17.html) (2013-05-20), but this might change in
    future releases of SQLite. <h _id="pragma_busy_timeout" style="display:none">PRAGMA
    busy_timeout</h>'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA busy_timeout;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA busy_timeout =** *milliseconds***;**
  prefs: []
  type: TYPE_NORMAL
- en: Query or change the setting of the [busy timeout](c3ref/busy_timeout.html).
    This pragma is an alternative to the [sqlite3_busy_timeout()](c3ref/busy_timeout.html)
    C-language interface which is made available as a pragma for use with language
    bindings that do not provide direct access to [sqlite3_busy_timeout()](c3ref/busy_timeout.html).
  prefs: []
  type: TYPE_NORMAL
- en: Each database connection can only have a single [busy handler](c3ref/busy_handler.html).
    This PRAGMA sets the busy handler for the process, possibly overwriting any previously
    set busy handler. <h _id="pragma_cache_size" style="display:none">PRAGMA cache_size</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA** *schema.***cache_size;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA** *schema.***cache_size =** *pages***;
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA** *schema.***cache_size = -***kibibytes***;**
  prefs: []
  type: TYPE_NORMAL
- en: Query or change the suggested maximum number of database disk pages that SQLite
    will hold in memory at once per open database file. Whether or not this suggestion
    is honored is at the discretion of the [Application Defined Page Cache](c3ref/pcache_methods2.html).
    The default page cache that is built into SQLite honors the request, however alternative
    application-defined page cache implementations may choose to interpret the suggested
    cache size in different ways or to ignore it all together. The default suggested
    cache size is -2000, which means the cache size is limited to 2048000 bytes of
    memory. The default suggested cache size can be altered using the [SQLITE_DEFAULT_CACHE_SIZE](compile.html#default_cache_size)
    compile-time options. The TEMP database has a default suggested cache size of
    0 pages.
  prefs: []
  type: TYPE_NORMAL
- en: If the argument N is positive then the suggested cache size is set to N. If
    the argument N is negative, then the number of cache pages is adjusted to be a
    number of pages that would use approximately abs(N*1024) bytes of memory based
    on the current page size. SQLite remembers the number of pages in the page cache,
    not the amount of memory used. So if you set the cache size using a negative number
    and subsequently change the page size (using the [PRAGMA page_size](pragma.html#pragma_page_size)
    command) then the maximum amount of cache memory will go up or down in proportion
    to the change in page size.
  prefs: []
  type: TYPE_NORMAL
- en: '*Backwards compatibility note:* The behavior of cache_size with a negative
    N was different prior to [version 3.7.10](releaselog/3_7_10.html) (2012-01-16).
    In earlier versions, the number of pages in the cache was set to the absolute
    value of N.'
  prefs: []
  type: TYPE_NORMAL
- en: When you change the cache size using the cache_size pragma, the change only
    endures for the current session. The cache size reverts to the default value when
    the database is closed and reopened.
  prefs: []
  type: TYPE_NORMAL
- en: The default page cache implemention does not allocate the full amount of cache
    memory all at once. Cache memory is allocated in smaller chunks on an as-needed
    basis. The page_cache setting is a (suggested) upper bound on the amount of memory
    that the cache can use, not the amount of memory it will use all of the time.
    This is the behavior of the default page cache implementation, but an [application
    defined page cache](c3ref/pcache_methods2.html) is free to behave differently
    if it wants. <h _id="pragma_cache_spill" style="display:none">PRAGMA cache_spill</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA cache_spill;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA cache_spill=***boolean***;
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA** *schema.***cache_spill=*N*;**
  prefs: []
  type: TYPE_NORMAL
- en: The cache_spill pragma enables or disables the ability of the pager to spill
    dirty cache pages to the database file in the middle of a transaction. Cache_spill
    is enabled by default and most applications should leave it that way as cache
    spilling is usually advantageous. However, a cache spill has the side-effect of
    acquiring an [EXCLUSIVE lock](lockingv3.html#excl_lock) on the database file.
    Hence, some applications that have large long-running transactions may want to
    disable cache spilling in order to prevent the application from acquiring an exclusive
    lock on the database until the moment that the transaction [COMMIT](lang_transaction.html)s.
  prefs: []
  type: TYPE_NORMAL
- en: The "PRAGMA cache_spill=*N*" form of this pragma sets a minimum cache size threshold
    required for spilling to occur. The number of pages in cache must exceed both
    the cache_spill threshold and the maximum cache size set by the [PRAGMA cache_size](pragma.html#pragma_cache_size)
    statement in order for spilling to occur.
  prefs: []
  type: TYPE_NORMAL
- en: The "PRAGMA cache_spill=*boolean*" form of this pragma applies across all databases
    attached to the database connection. But the "PRAGMA cache_spill=*N*" form of
    this statement only applies to the "main" schema or whatever other schema is specified
    as part of the statement. <h _id="pragma_case_sensitive_like" style="display:none">PRAGMA
    case_sensitive_like</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA case_sensitive_like =** *boolean***;**'
  prefs: []
  type: TYPE_NORMAL
- en: The default behavior of the [LIKE](lang_expr.html#like) operator is to ignore
    case for ASCII characters. Hence, by default **'a' LIKE 'A'** is true. The case_sensitive_like
    pragma installs a new application-defined LIKE function that is either case sensitive
    or insensitive depending on the value of the case_sensitive_like pragma. When
    case_sensitive_like is disabled, the default LIKE behavior is expressed. When
    case_sensitive_like is enabled, case becomes significant. So, for example, **'a'
    LIKE 'A'** is false but **'a' LIKE 'a'** is still true.
  prefs: []
  type: TYPE_NORMAL
- en: This pragma uses [sqlite3_create_function()](c3ref/create_function.html) to
    overload the LIKE and GLOB functions, which may override previous implementations
    of LIKE and GLOB registered by the application. This pragma only changes the behavior
    of the SQL [LIKE](lang_expr.html#like) operator. It does not change the behavior
    of the [sqlite3_strlike()](c3ref/strlike.html) C-language interface, which is
    always case insensitive.
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING:** If a database uses the LIKE operator anywhere in the schema, such
    as in a [CHECK constraint](lang_createtable.html#ckconst) or in an [expression
    index](expridx.html) or in the WHERE clause of a [partial index](partialindex.html),
    then changing the definition of the LIKE operator using this PRAGMA can cause
    the database to appear to be corrupt. [PRAGMA integrity_check](pragma.html#pragma_integrity_check)
    will report errors. The database is not really corrupt in that changing the behavior
    of LIKE back to the way it was when the schema was defined and the database was
    populated will clear the problem. If the use of LIKE occurs only in indexes, then
    the problem can be cleared by running [REINDEX](lang_reindex.html). Nevertheless,
    the use of the case_sensitive_like pragma is discouraged.'
  prefs: []
  type: TYPE_NORMAL
- en: '**This pragma is deprecated** and exists for backwards compatibility only.
    New applications should avoid using this pragma. Older applications should discontinue
    use of this pragma at the earliest opportunity. This pragma may be omitted from
    the build when SQLite is compiled using [SQLITE_OMIT_DEPRECATED](compile.html#omit_deprecated).'
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_cell_size_check" style="display:none">PRAGMA cell_size_check</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA cell_size_check'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA cell_size_check =** *boolean***;**
  prefs: []
  type: TYPE_NORMAL
- en: The cell_size_check pragma enables or disables additional sanity checking on
    database b-tree pages as they are initially read from disk. With cell size checking
    enabled, database corruption is detected earlier and is less likely to "spread".
    However, there is a small performance hit for doing the extra checks and so cell
    size checking is turned off by default. <h _id="pragma_checkpoint_fullfsync" style="display:none">PRAGMA
    checkpoint_fullfsync</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA checkpoint_fullfsync'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA checkpoint_fullfsync =** *boolean***;**
  prefs: []
  type: TYPE_NORMAL
- en: Query or change the fullfsync flag for [checkpoint](wal.html#ckpt) operations.
    If this flag is set, then the F_FULLFSYNC syncing method is used during checkpoint
    operations on systems that support F_FULLFSYNC. The default value of the checkpoint_fullfsync
    flag is off. Only Mac OS-X supports F_FULLFSYNC.
  prefs: []
  type: TYPE_NORMAL
- en: If the [fullfsync](pragma.html#pragma_fullfsync) flag is set, then the F_FULLFSYNC
    syncing method is used for all sync operations and the checkpoint_fullfsync setting
    is irrelevant.
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_collation_list" style="display:none">PRAGMA collation_list</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA collation_list;**'
  prefs: []
  type: TYPE_NORMAL
- en: Return a list of the collating sequences defined for the current database connection.
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_compile_options" style="display:none">PRAGMA compile_options</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA compile_options;**'
  prefs: []
  type: TYPE_NORMAL
- en: This pragma returns the names of [compile-time options](compile.html) used when
    building SQLite, one option per row. The "SQLITE_" prefix is omitted from the
    returned option names. See also the [sqlite3_compileoption_get()](c3ref/compileoption_get.html)
    C/C++ interface and the [sqlite_compileoption_get()](lang_corefunc.html#sqlite_compileoption_get)
    SQL functions.
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_count_changes" style="display:none">PRAGMA count_changes</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA count_changes;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA count_changes =** boolean**;**
  prefs: []
  type: TYPE_NORMAL
- en: Query or change the count-changes flag. Normally, when the count-changes flag
    is not set, [INSERT](lang_insert.html), [UPDATE](lang_update.html) and [DELETE](lang_delete.html)
    statements return no data. When count-changes is set, each of these commands returns
    a single row of data consisting of one integer value - the number of rows inserted,
    modified or deleted by the command. The returned change count does not include
    any insertions, modifications or deletions performed by triggers, any changes
    made automatically by [foreign key actions](foreignkeys.html#fk_actions), or updates
    caused by an [upsert](lang_upsert.html).
  prefs: []
  type: TYPE_NORMAL
- en: Another way to get the row change counts is to use the [sqlite3_changes()](c3ref/changes.html)
    or [sqlite3_total_changes()](c3ref/total_changes.html) interfaces. There is a
    subtle different, though. When an INSERT, UPDATE, or DELETE is run against a view
    using an [INSTEAD OF trigger](lang_createtrigger.html#instead_of_trigger), the
    count_changes pragma reports the number of rows in the view that fired the trigger,
    whereas [sqlite3_changes()](c3ref/changes.html) and [sqlite3_total_changes()](c3ref/total_changes.html)
    do not.
  prefs: []
  type: TYPE_NORMAL
- en: '**This pragma is deprecated** and exists for backwards compatibility only.
    New applications should avoid using this pragma. Older applications should discontinue
    use of this pragma at the earliest opportunity. This pragma may be omitted from
    the build when SQLite is compiled using [SQLITE_OMIT_DEPRECATED](compile.html#omit_deprecated).'
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_data_store_directory" style="display:none">PRAGMA data_store_directory</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA data_store_directory;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA data_store_directory = '***directory-name***';**
  prefs: []
  type: TYPE_NORMAL
- en: Query or change the value of the [sqlite3_data_directory](c3ref/data_directory.html)
    global variable, which windows operating-system interface backends use to determine
    where to store database files specified using a relative pathname.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the data_store_directory setting is not threadsafe. Never change the
    data_store_directory setting if another thread within the application is running
    any SQLite interface at the same time. Doing so results in undefined behavior.
    Changing the data_store_directory setting writes to the [sqlite3_data_directory](c3ref/data_directory.html)
    global variable and that global variable is not protected by a mutex.
  prefs: []
  type: TYPE_NORMAL
- en: This facility is provided for WinRT which does not have an OS mechanism for
    reading or changing the current working directory. The use of this pragma in any
    other context is discouraged and may be disallowed in future releases.
  prefs: []
  type: TYPE_NORMAL
- en: '**This pragma is deprecated** and exists for backwards compatibility only.
    New applications should avoid using this pragma. Older applications should discontinue
    use of this pragma at the earliest opportunity. This pragma may be omitted from
    the build when SQLite is compiled using [SQLITE_OMIT_DEPRECATED](compile.html#omit_deprecated).'
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_data_version" style="display:none">PRAGMA data_version</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA** *schema.***data_version;**'
  prefs: []
  type: TYPE_NORMAL
- en: The "PRAGMA data_version" command provides an indication that the database file
    has been modified. Interactive programs that hold database content in memory or
    that display database content on-screen can use the PRAGMA data_version command
    to determine if they need to flush and reload their memory or update the screen
    display.
  prefs: []
  type: TYPE_NORMAL
- en: The integer values returned by two invocations of "PRAGMA data_version" from
    the same connection will be different if changes were committed to the database
    by any other connection in the interim. The "PRAGMA data_version" value is unchanged
    for commits made on the same database connection. The behavior of "PRAGMA data_version"
    is the same for all database connections, including database connections in separate
    processes and [shared cache](sharedcache.html) database connections.
  prefs: []
  type: TYPE_NORMAL
- en: The "PRAGMA data_version" value is a local property of each database connection
    and so values returned by two concurrent invocations of "PRAGMA data_version"
    on separate database connections are often different even though the underlying
    database is identical. It is only meaningful to compare the "PRAGMA data_version"
    values returned by the same database connection at two different points in time.
    <h _id="pragma_database_list" style="display:none">PRAGMA database_list</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA database_list;**'
  prefs: []
  type: TYPE_NORMAL
- en: This pragma works like a query to return one row for each database attached
    to the current database connection. The second column is "main" for the main database
    file, "temp" for the database file used to store TEMP objects, or the name of
    the ATTACHed database for other database files. The third column is the name of
    the database file itself, or an empty string if the database is not associated
    with a file.
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_default_cache_size" style="display:none">PRAGMA default_cache_size</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA** *schema.***default_cache_size;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA** *schema.***default_cache_size =** *Number-of-pages***;**
  prefs: []
  type: TYPE_NORMAL
- en: This pragma queries or sets the suggested maximum number of pages of disk cache
    that will be allocated per open database file. The difference between this pragma
    and [cache_size](pragma.html#pragma_cache_size) is that the value set here persists
    across database connections. The value of the default cache size is stored in
    the 4-byte big-endian integer located at offset 48 in the header of the database
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '**This pragma is deprecated** and exists for backwards compatibility only.
    New applications should avoid using this pragma. Older applications should discontinue
    use of this pragma at the earliest opportunity. This pragma may be omitted from
    the build when SQLite is compiled using [SQLITE_OMIT_DEPRECATED](compile.html#omit_deprecated).'
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_defer_foreign_keys" style="display:none">PRAGMA defer_foreign_keys</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA defer_foreign_keys'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA defer_foreign_keys =** *boolean***;**
  prefs: []
  type: TYPE_NORMAL
- en: When the defer_foreign_keys [PRAGMA](pragma.html#syntax) is on, enforcement
    of all [foreign key constraints](foreignkeys.html) is delayed until the outermost
    transaction is committed. The defer_foreign_keys pragma defaults to OFF so that
    foreign key constraints are only deferred if they are created as "DEFERRABLE INITIALLY
    DEFERRED". The defer_foreign_keys pragma is automatically switched off at each
    COMMIT or ROLLBACK. Hence, the defer_foreign_keys pragma must be separately enabled
    for each transaction. This pragma is only meaningful if foreign key constraints
    are enabled, of course.
  prefs: []
  type: TYPE_NORMAL
- en: The [sqlite3_db_status](c3ref/db_status.html)(db,[SQLITE_DBSTATUS_DEFERRED_FKS](c3ref/c_dbstatus_options.html#sqlitedbstatusdeferredfks),...)
    C-language interface can be used during a transaction to determine if there are
    deferred and unresolved foreign key constraints.
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_empty_result_callbacks" style="display:none">PRAGMA empty_result_callbacks</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA empty_result_callbacks;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA empty_result_callbacks =** *boolean***;**
  prefs: []
  type: TYPE_NORMAL
- en: Query or change the empty-result-callbacks flag.
  prefs: []
  type: TYPE_NORMAL
- en: The empty-result-callbacks flag affects the [sqlite3_exec()](c3ref/exec.html)
    API only. Normally, when the empty-result-callbacks flag is cleared, the callback
    function supplied to the [sqlite3_exec()](c3ref/exec.html) is not invoked for
    commands that return zero rows of data. When empty-result-callbacks is set in
    this situation, the callback function is invoked exactly once, with the third
    parameter set to 0 (NULL). This is to enable programs that use the [sqlite3_exec()](c3ref/exec.html)
    API to retrieve column-names even when a query returns no data.
  prefs: []
  type: TYPE_NORMAL
- en: '**This pragma is deprecated** and exists for backwards compatibility only.
    New applications should avoid using this pragma. Older applications should discontinue
    use of this pragma at the earliest opportunity. This pragma may be omitted from
    the build when SQLite is compiled using [SQLITE_OMIT_DEPRECATED](compile.html#omit_deprecated).'
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_encoding" style="display:none">PRAGMA encoding</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA encoding;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA encoding = 'UTF-8';
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA encoding = 'UTF-16';
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA encoding = 'UTF-16le';
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA encoding = 'UTF-16be';**
  prefs: []
  type: TYPE_NORMAL
- en: In first form, if the main database has already been created, then this pragma
    returns the text encoding used by the main database, one of 'UTF-8', 'UTF-16le'
    (little-endian UTF-16 encoding) or 'UTF-16be' (big-endian UTF-16 encoding). If
    the main database has not already been created, then the value returned is the
    text encoding that will be used to create the main database, if it is created
    by this session.
  prefs: []
  type: TYPE_NORMAL
- en: The second through fifth forms of this pragma set the encoding that the main
    database will be created with if it is created by this session. The string 'UTF-16'
    is interpreted as "UTF-16 encoding using native machine byte-ordering". It is
    not possible to change the text encoding of a database after it has been created
    and any attempt to do so will be silently ignored.
  prefs: []
  type: TYPE_NORMAL
- en: If no encoding is first set with this pragma, then the encoding with which the
    main database will be created defaults to one determined by the [API used to open
    the connection](c3ref/open.html).
  prefs: []
  type: TYPE_NORMAL
- en: Once an encoding has been set for a database, it cannot be changed.
  prefs: []
  type: TYPE_NORMAL
- en: Databases created by the [ATTACH](lang_attach.html) command always use the same
    encoding as the main database. An attempt to [ATTACH](lang_attach.html) a database
    with a different text encoding from the "main" database will fail.
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_foreign_key_check" style="display:none">PRAGMA foreign_key_check</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA** *schema.***foreign_key_check;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA** *schema.***foreign_key_check(***table-name***);**
  prefs: []
  type: TYPE_NORMAL
- en: The foreign_key_check pragma checks the database, or the table called "*table-name*",
    for [foreign key constraints](foreignkeys.html) that are violated. The foreign_key_check
    pragma returns one row output for each foreign key violation. There are four columns
    in each result row. The first column is the name of the table that contains the
    REFERENCES clause. The second column is the [rowid](lang_createtable.html#rowid)
    of the row that contains the invalid REFERENCES clause, or NULL if the child table
    is a [WITHOUT ROWID](withoutrowid.html) table. The third column is the name of
    the table that is referred to. The fourth column is the index of the specific
    foreign key constraint that failed. The fourth column in the output of the foreign_key_check
    pragma is the same integer as the first column in the output of the [foreign_key_list
    pragma](pragma.html#pragma_foreign_key_list). When a "*table-name*" is specified,
    the only foreign key constraints checked are those created by REFERENCES clauses
    in the CREATE TABLE statement for *table-name*.
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_foreign_key_list" style="display:none">PRAGMA foreign_key_list</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA foreign_key_list(***table-name***);**'
  prefs: []
  type: TYPE_NORMAL
- en: This pragma returns one row for each [foreign key constraint](foreignkeys.html)
    created by a REFERENCES clause in the CREATE TABLE statement of table "*table-name*".
    <h _id="pragma_foreign_keys" style="display:none">PRAGMA foreign_keys</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA foreign_keys;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA foreign_keys =** *boolean***;**
  prefs: []
  type: TYPE_NORMAL
- en: Query, set, or clear the enforcement of [foreign key constraints](foreignkeys.html).
  prefs: []
  type: TYPE_NORMAL
- en: This pragma is a no-op within a transaction; foreign key constraint enforcement
    may only be enabled or disabled when there is no pending [BEGIN](lang_transaction.html)
    or [SAVEPOINT](lang_savepoint.html).
  prefs: []
  type: TYPE_NORMAL
- en: Changing the foreign_keys setting affects the execution of all statements prepared
    using the database connection, including those prepared before the setting was
    changed. Any existing statements prepared using the legacy [sqlite3_prepare()](c3ref/prepare.html)
    interface may fail with an [SQLITE_SCHEMA](rescode.html#schema) error after the
    foreign_keys setting is changed.
  prefs: []
  type: TYPE_NORMAL
- en: As of SQLite [version 3.6.19](releaselog/3_6_19.html), the default setting for
    foreign key enforcement is OFF. However, that might change in a future release
    of SQLite. The default setting for foreign key enforcement can be specified at
    compile-time using the [SQLITE_DEFAULT_FOREIGN_KEYS](compile.html#default_foreign_keys)
    preprocessor macro. To minimize future problems, applications should set the foreign
    key enforcement flag as required by the application and not depend on the default
    setting. <h _id="pragma_freelist_count" style="display:none">PRAGMA freelist_count</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA** *schema.***freelist_count;**'
  prefs: []
  type: TYPE_NORMAL
- en: Return the number of unused pages in the database file.
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_full_column_names" style="display:none">PRAGMA full_column_names</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA full_column_names;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA full_column_names =** *boolean***;**
  prefs: []
  type: TYPE_NORMAL
- en: 'Query or change the full_column_names flag. This flag together with the [short_column_names](pragma.html#pragma_short_column_names)
    flag determine the way SQLite assigns names to result columns of [SELECT](lang_select.html)
    statements. Result columns are named by applying the following rules in order:'
  prefs: []
  type: TYPE_NORMAL
- en: If there is an AS clause on the result, then the name of the column is the right-hand
    side of the AS clause.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the result is a general expression, not a just the name of a source table
    column, then the name of the result is a copy of the expression text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the [short_column_names](pragma.html#pragma_short_column_names) pragma is
    ON, then the name of the result is the name of the source table column without
    the source table name prefix: COLUMN.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If both pragmas [short_column_names](pragma.html#pragma_short_column_names)
    and [full_column_names](pragma.html#pragma_full_column_names) are OFF then case
    (2) applies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The name of the result column is a combination of the source table and source
    column name: TABLE.COLUMN'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**This pragma is deprecated** and exists for backwards compatibility only.
    New applications should avoid using this pragma. Older applications should discontinue
    use of this pragma at the earliest opportunity. This pragma may be omitted from
    the build when SQLite is compiled using [SQLITE_OMIT_DEPRECATED](compile.html#omit_deprecated).'
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_fullfsync" style="display:none">PRAGMA fullfsync</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA fullfsync'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA fullfsync =** *boolean***;**
  prefs: []
  type: TYPE_NORMAL
- en: Query or change the fullfsync flag. This flag determines whether or not the
    F_FULLFSYNC syncing method is used on systems that support it. The default value
    of the fullfsync flag is off. Only Mac OS X supports F_FULLFSYNC.
  prefs: []
  type: TYPE_NORMAL
- en: See also [checkpoint_fullfsync](pragma.html#pragma_checkpoint_fullfsync).
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_function_list" style="display:none">PRAGMA function_list</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA function_list;**'
  prefs: []
  type: TYPE_NORMAL
- en: This pragma returns a list of SQL functions known to the database connection.
    Each row of the result describes a single calling signature for a single SQL function.
    Some SQL functions will have multiple rows in the result set if they can (for
    example) be invoked with a varying number of arguments or can accept text in various
    encodings. <h _id="pragma_hard_heap_limit" style="display:none">PRAGMA hard_heap_limit</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA hard_heap_limit'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA hard_heap_limit=***N*
  prefs: []
  type: TYPE_NORMAL
- en: This pragma invokes the [sqlite3_hard_heap_limit64()](c3ref/hard_heap_limit64.html)
    interface with the argument N, if N is specified and N is a positive integer that
    is less than the current hard heap limit. The hard_heap_limit pragma always returns
    the same integer that would be returned by the [sqlite3_hard_heap_limit64](c3ref/hard_heap_limit64.html)(-1)
    C-language function. That is to say, it always returns the value of the hard heap
    limit that is set after any changes imposed by this PRAGMA.
  prefs: []
  type: TYPE_NORMAL
- en: This pragma can only lower the heap limit, never raise it. The C-language interface
    [sqlite3_hard_heap_limit64()](c3ref/hard_heap_limit64.html) must be used to raise
    the heap limit.
  prefs: []
  type: TYPE_NORMAL
- en: See also the [soft_heap_limit pragma](pragma.html#pragma_soft_heap_limit). <h
    _id="pragma_ignore_check_constraints" style="display:none">PRAGMA ignore_check_constraints</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA ignore_check_constraints =** *boolean***;**'
  prefs: []
  type: TYPE_NORMAL
- en: This pragma enables or disables the enforcement of CHECK constraints. The default
    setting is off, meaning that CHECK constraints are enforced by default.
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_incremental_vacuum" style="display:none">PRAGMA incremental_vacuum</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA** *schema.***incremental_vacuum***(N)***;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA** *schema.***incremental_vacuum;**
  prefs: []
  type: TYPE_NORMAL
- en: The incremental_vacuum pragma causes up to *N* pages to be removed from the
    [freelist](fileformat2.html#freelist). The database file is truncated by the same
    amount. The incremental_vacuum pragma has no effect if the database is not in
    [auto_vacuum=incremental](#pragma_auto_vacuum) mode or if there are no pages on
    the freelist. If there are fewer than *N* pages on the freelist, or if *N* is
    less than 1, or if the "(*N*)" argument is omitted, then the entire freelist is
    cleared.
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_index_info" style="display:none">PRAGMA index_info</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA** *schema.***index_info(***index-name***);**'
  prefs: []
  type: TYPE_NORMAL
- en: This pragma returns one row for each key column in the named index. A key column
    is a column that is actually named in the [CREATE INDEX](lang_createindex.html)
    index statement or [UNIQUE constraint](lang_createtable.html#uniqueconst) or [PRIMARY
    KEY constraint](lang_createtable.html#primkeyconst) that created the index. Index
    entries also usually contain auxiliary columns that point back to the table row
    being indexed. The auxiliary index-columns are not shown by the index_info pragma,
    but they are listed by the [index_xinfo pragma](pragma.html#pragma_index_xinfo).
  prefs: []
  type: TYPE_NORMAL
- en: 'Output columns from the index_info pragma are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The rank of the column within the index. (0 means left-most.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The rank of the column within the table being indexed. A value of -1 means [rowid](lang_createtable.html#rowid)
    and a value of -2 means that an [expression](expridx.html) is being used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The name of the column being indexed. This columns is NULL if the column is
    the [rowid](lang_createtable.html#rowid) or an [expression](expridx.html).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there is no index named *index-name* but there is a [WITHOUT ROWID](withoutrowid.html)
    table with that name, then (as of SQLite [version 3.30.0](releaselog/3_30_0.html)
    on 2019-10-04) this pragma returns the PRIMARY KEY columns of the WITHOUT ROWID
    table as they are used in the records of the underlying b-tree, which is to say
    with duplicate columns removed. <h _id="pragma_index_list" style="display:none">PRAGMA
    index_list</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA** *schema.***index_list(***table-name***);**'
  prefs: []
  type: TYPE_NORMAL
- en: This pragma returns one row for each index associated with the given table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Output columns from the index_list pragma are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A sequence number assigned to each index for internal tracking purposes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The name of the index.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '"1" if the index is UNIQUE and "0" if not.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '"c" if the index was created by a [CREATE INDEX](lang_createindex.html) statement,
    "u" if the index was created by a [UNIQUE constraint](lang_createtable.html#uniqueconst),
    or "pk" if the index was created by a [PRIMARY KEY constraint](lang_createtable.html#primkeyconst).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '"1" if the index is a [partial index](partialindex.html) and "0" if not.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <h _id="pragma_index_xinfo" style="display:none">PRAGMA index_xinfo</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA** *schema.***index_xinfo(***index-name***);**'
  prefs: []
  type: TYPE_NORMAL
- en: This pragma returns information about every column in an index. Unlike this
    [index_info pragma](pragma.html#pragma_index_info), this pragma returns information
    about every column in the index, not just the key columns. (A key column is a
    column that is actually named in the [CREATE INDEX](lang_createindex.html) index
    statement or [UNIQUE constraint](lang_createtable.html#uniqueconst) or [PRIMARY
    KEY constraint](lang_createtable.html#primkeyconst) that created the index. Auxiliary
    columns are additional columns needed to locate the table entry that corresponds
    to each index entry.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Output columns from the index_xinfo pragma are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The rank of the column within the index. (0 means left-most. Key columns come
    before auxiliary columns.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The rank of the column within the table being indexed, or -1 if the index-column
    is the [rowid](lang_createtable.html#rowid) of the table being indexed and -2
    if the [index is on an expression](expridx.html).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The name of the column being indexed, or NULL if the index-column is the [rowid](lang_createtable.html#rowid)
    of the table being indexed or an [expression](expridx.html).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 1 if the index-column is sorted in reverse (DESC) order by the index and 0 otherwise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The name for the [collating sequence](datatype3.html#collation) used to compare
    values in the index-column.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 1 if the index-column is a key column and 0 if the index-column is an auxiliary
    column.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there is no index named *index-name* but there is a [WITHOUT ROWID](withoutrowid.html)
    table with that name, then (as of SQLite [version 3.30.0](releaselog/3_30_0.html)
    on 2019-10-04) this pragma returns the columns of the WITHOUT ROWID table as they
    are used in the records of the underlying b-tree, which is to say with de-duplicated
    PRIMARY KEY columns first followed by data columns. <h _id="pragma_integrity_check"
    style="display:none">PRAGMA integrity_check</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA** *schema.***integrity_check;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA** *schema.***integrity_check(***N***)
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA** *schema.***integrity_check(***TABLENAME***)**
  prefs: []
  type: TYPE_NORMAL
- en: 'This pragma does a low-level formatting and consistency check of the database.
    The integrity_check pragma look for:'
  prefs: []
  type: TYPE_NORMAL
- en: Table or index entries that are out of sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Misformatted records
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Missing pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Missing or surplus index entries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UNIQUE, CHECK, and NOT NULL constraint errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrity of the freelist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sections of the database that are used more than once, or not at all
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the integrity_check pragma finds problems, strings are returned (as multiple
    rows with a single column per row) which describe the problems. Pragma integrity_check
    will return at most *N* errors before the analysis quits, with N defaulting to
    100\. If pragma integrity_check finds no errors, a single row with the value 'ok'
    is returned.
  prefs: []
  type: TYPE_NORMAL
- en: The usual case is that the entire database file is checked. However, if the
    argument is *TABLENAME*, then checking is only performed for the the table named
    and its associated indexes. This is called a "partial integrity check". Because
    only a subset of the database is checked, errors such as unused sections of the
    file or duplication use of the same section of the file by two or more tables
    cannot be detected. The freelist is only verified on a partial integrity check
    if *TABLENAME* is [sqlite_schema](schematab.html) or one of its aliases. Support
    for partial integrity checks was added with version 3.33.0 (2020-08-14).
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA integrity_check does not find [FOREIGN KEY](foreignkeys.html) errors.
    Use the [PRAGMA foreign_key_check](pragma.html#pragma_foreign_key_check) command
    to find errors in FOREIGN KEY constraints.
  prefs: []
  type: TYPE_NORMAL
- en: See also the [PRAGMA quick_check](pragma.html#pragma_quick_check) command which
    does most of the checking of PRAGMA integrity_check but runs much faster.
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_journal_mode" style="display:none">PRAGMA journal_mode</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA** *schema.***journal_mode;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA** *schema.***journal_mode = *DELETE | TRUNCATE | PERSIST | MEMORY | WAL
    | OFF***
  prefs: []
  type: TYPE_NORMAL
- en: This pragma queries or sets the journal mode for databases associated with the
    current [database connection](c3ref/sqlite3.html).
  prefs: []
  type: TYPE_NORMAL
- en: The first form of this pragma queries the current journaling mode for *database*.
    When *database* is omitted, the "main" database is queried.
  prefs: []
  type: TYPE_NORMAL
- en: The second form changes the journaling mode for "*database*" or for all attached
    databases if "*database*" is omitted. The new journal mode is returned. If the
    journal mode could not be changed, the original journal mode is returned.
  prefs: []
  type: TYPE_NORMAL
- en: The DELETE journaling mode is the normal behavior. In the DELETE mode, the rollback
    journal is deleted at the conclusion of each transaction. Indeed, the delete operation
    is the action that causes the transaction to commit. (See the document titled
    [Atomic Commit In SQLite](atomiccommit.html) for additional detail.)
  prefs: []
  type: TYPE_NORMAL
- en: The TRUNCATE journaling mode commits transactions by truncating the rollback
    journal to zero-length instead of deleting it. On many systems, truncating a file
    is much faster than deleting the file since the containing directory does not
    need to be changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The PERSIST journaling mode prevents the rollback journal from being deleted
    at the end of each transaction. Instead, the header of the journal is overwritten
    with zeros. This will prevent other database connections from rolling the journal
    back. The PERSIST journaling mode is useful as an optimization on platforms where
    deleting or truncating a file is much more expensive than overwriting the first
    block of a file with zeros. See also: [PRAGMA journal_size_limit](pragma.html#pragma_journal_size_limit)
    and [SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT](compile.html#default_journal_size_limit).'
  prefs: []
  type: TYPE_NORMAL
- en: The MEMORY journaling mode stores the rollback journal in volatile RAM. This
    saves disk I/O but at the expense of database safety and integrity. If the application
    using SQLite crashes in the middle of a transaction when the MEMORY journaling
    mode is set, then the database file will very likely [go corrupt](howtocorrupt.html#cfgerr).
  prefs: []
  type: TYPE_NORMAL
- en: The WAL journaling mode uses a [write-ahead log](wal.html) instead of a rollback
    journal to implement transactions. The WAL journaling mode is persistent; after
    being set it stays in effect across multiple database connections and after closing
    and reopening the database. A database in WAL journaling mode can only be accessed
    by SQLite [version 3.7.0](releaselog/3_7_0.html) (2010-07-21) or later.
  prefs: []
  type: TYPE_NORMAL
- en: The OFF journaling mode disables the rollback journal completely. No rollback
    journal is ever created and hence there is never a rollback journal to delete.
    The OFF journaling mode disables the atomic commit and rollback capabilities of
    SQLite. The [ROLLBACK](lang_transaction.html) command no longer works; it behaves
    in an undefined way. Applications must avoid using the [ROLLBACK](lang_transaction.html)
    command when the journal mode is OFF. If the application crashes in the middle
    of a transaction when the OFF journaling mode is set, then the database file will
    very likely [go corrupt](howtocorrupt.html#cfgerr). Without a journal, there is
    no way for a statement to unwind partially completed operations following a constraint
    error. This might also leave the database in a corrupted state. For example, if
    a duplicate entry causes a [CREATE UNIQUE INDEX](lang_createindex.html) statement
    to fail half-way through, it will leave behind a partially created, and hence
    corrupt, index. Because OFF journaling mode allows the database file to be corrupted
    using ordinary SQL, it is disabled when [SQLITE_DBCONFIG_DEFENSIVE](c3ref/c_dbconfig_defensive.html#sqlitedbconfigdefensive)
    is enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the journal_mode for an [in-memory database](inmemorydb.html) is either
    MEMORY or OFF and can not be changed to a different value. An attempt to change
    the journal_mode of an [in-memory database](inmemorydb.html) to any setting other
    than MEMORY or OFF is ignored. Note also that the journal_mode cannot be changed
    while a transaction is active.
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_journal_size_limit" style="display:none">PRAGMA journal_size_limit</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA** *schema.***journal_size_limit'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA** *schema.***journal_size_limit =** *N* **;**
  prefs: []
  type: TYPE_NORMAL
- en: If a database connection is operating in [exclusive locking mode](pragma.html#pragma_locking_mode)
    or in [persistent journal mode](pragma.html#pragma_journal_mode) (PRAGMA journal_mode=persist)
    then after committing a transaction the [rollback journal](lockingv3.html#rollback)
    file may remain in the file-system. This increases performance for subsequent
    transactions since overwriting an existing file is faster than append to a file,
    but it also consumes file-system space. After a large transaction (e.g. a [VACUUM](lang_vacuum.html)),
    the rollback journal file may consume a very large amount of space.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, in [WAL mode](wal.html), the write-ahead log file is not truncated
    following a [checkpoint](wal.html#ckpt). Instead, SQLite reuses the existing file
    for subsequent WAL entries since overwriting is faster than appending.
  prefs: []
  type: TYPE_NORMAL
- en: The journal_size_limit pragma may be used to limit the size of rollback-journal
    and WAL files left in the file-system after transactions or checkpoints. Each
    time a transaction is committed or a WAL file resets, SQLite compares the size
    of the rollback journal file or WAL file left in the file-system to the size limit
    set by this pragma and if the journal or WAL file is larger it is truncated to
    the limit.
  prefs: []
  type: TYPE_NORMAL
- en: The second form of the pragma listed above is used to set a new limit in bytes
    for the specified database. A negative number implies no limit. To always truncate
    rollback journals and WAL files to their minimum size, set the journal_size_limit
    to zero. Both the first and second forms of the pragma listed above return a single
    result row containing a single integer column - the value of the journal size
    limit in bytes. The default journal size limit is -1 (no limit). The [SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT](compile.html#default_journal_size_limit)
    preprocessor macro can be used to change the default journal size limit at compile-time.
  prefs: []
  type: TYPE_NORMAL
- en: This pragma only operates on the single database specified prior to the pragma
    name (or on the "main" database if no database is specified.) There is no way
    to change the journal size limit on all attached databases using a single PRAGMA
    statement. The size limit must be set separately for each attached database. <h
    _id="pragma_legacy_alter_table" style="display:none">PRAGMA legacy_alter_table</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA legacy_alter_table;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA legacy_alter_table = *boolean***
  prefs: []
  type: TYPE_NORMAL
- en: 'This pragma sets or queries the value of the legacy_alter_table flag. When
    this flag is on, the [ALTER TABLE RENAME](lang_altertable.html#altertabrename)
    command (for changing the name of a table) works as it did in SQLite 3.24.0 (2018-06-04)
    and earlier. More specifically, when this flag is on the [ALTER TABLE RENAME](lang_altertable.html#altertabrename)
    command only rewrites the initial occurrence of the table name in its [CREATE
    TABLE](lang_createtable.html) statement and in any associated [CREATE INDEX](lang_createindex.html)
    and [CREATE TRIGGER](lang_createtrigger.html) statements. Other references to
    the table are unmodified, including:'
  prefs: []
  type: TYPE_NORMAL
- en: References to the table within the bodies of triggers and views.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: References to the table within CHECK constraints in the original CREATE TABLE
    statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: References to the table within the WHERE clauses of [partial indexes](partialindex.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default setting for this pragma is OFF, which means that all references
    to the table anywhere in the schema are converted to the new name.
  prefs: []
  type: TYPE_NORMAL
- en: This pragma is provided as a work-around for older programs that contain code
    that expect the incomplete behavior of [ALTER TABLE RENAME](lang_altertable.html#altertabrename)
    found in older versions of SQLite. New applications should leave this flag turned
    off.
  prefs: []
  type: TYPE_NORMAL
- en: For compatibility with older [virtual table](vtab.html) implementations, this
    flag is turned on temporarily while the [sqlite3_module.xRename](vtab.html#xrename)
    method is being run. The value of this flag is restored after the [sqlite3_module.xRename](vtab.html#xrename)
    method finishes.
  prefs: []
  type: TYPE_NORMAL
- en: The legacy alter table behavior can also be toggled on and off using the [SQLITE_DBCONFIG_LEGACY_ALTER_TABLE](c3ref/c_dbconfig_defensive.html#sqlitedbconfiglegacyaltertable)
    option to the [sqlite3_db_config()](c3ref/db_config.html) interface.
  prefs: []
  type: TYPE_NORMAL
- en: The legacy alter table behavior is a per-connection setting. Turning this features
    on or off affects all attached database files within the [database connection](c3ref/sqlite3.html).
    The setting does not persist. Changing this setting in one connection does not
    affect any other connections. <h _id="pragma_legacy_file_format" style="display:none">PRAGMA
    legacy_file_format</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA legacy_file_format;**'
  prefs: []
  type: TYPE_NORMAL
- en: This pragma no longer functions. It has become a no-op. The capabilities formerly
    provided by PRAGMA legacy_file_format are now available using the [SQLITE_DBCONFIG_LEGACY_FILE_FORMAT](c3ref/c_dbconfig_defensive.html#sqlitedbconfiglegacyfileformat)
    option to the [sqlite3_db_config()](c3ref/db_config.html) C-language interface.
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_locking_mode" style="display:none">PRAGMA locking_mode</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA** *schema.***locking_mode;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA** *schema.***locking_mode = *NORMAL | EXCLUSIVE***
  prefs: []
  type: TYPE_NORMAL
- en: This pragma sets or queries the database connection locking-mode. The locking-mode
    is either NORMAL or EXCLUSIVE.
  prefs: []
  type: TYPE_NORMAL
- en: In NORMAL locking-mode (the default unless overridden at compile-time using
    [SQLITE_DEFAULT_LOCKING_MODE](compile.html#default_locking_mode)), a database
    connection unlocks the database file at the conclusion of each read or write transaction.
    When the locking-mode is set to EXCLUSIVE, the database connection never releases
    file-locks. The first time the database is read in EXCLUSIVE mode, a shared lock
    is obtained and held. The first time the database is written, an exclusive lock
    is obtained and held.
  prefs: []
  type: TYPE_NORMAL
- en: Database locks obtained by a connection in EXCLUSIVE mode may be released either
    by closing the database connection, or by setting the locking-mode back to NORMAL
    using this pragma and then accessing the database file (for read or write). Simply
    setting the locking-mode to NORMAL is not enough - locks are not released until
    the next time the database file is accessed.
  prefs: []
  type: TYPE_NORMAL
- en: There are three reasons to set the locking-mode to EXCLUSIVE.
  prefs: []
  type: TYPE_NORMAL
- en: The application wants to prevent other processes from accessing the database
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The number of system calls for filesystem operations is reduced, possibly resulting
    in a small performance increase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[WAL](wal.html) databases can be accessed in EXCLUSIVE mode without the use
    of shared memory. ([Additional information](wal.html#noshm))'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When the locking_mode pragma specifies a particular database, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA **main.**locking_mode=EXCLUSIVE;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: then the locking mode applies only to the named database. If no database name
    qualifier precedes the "locking_mode" keyword then the locking mode is applied
    to all databases, including any new databases added by subsequent [ATTACH](lang_attach.html)
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: The "temp" database (in which TEMP tables and indices are stored) and [in-memory
    databases](inmemorydb.html) always uses exclusive locking mode. The locking mode
    of temp and [in-memory databases](inmemorydb.html) cannot be changed. All other
    databases use the normal locking mode by default and are affected by this pragma.
  prefs: []
  type: TYPE_NORMAL
- en: If the locking mode is EXCLUSIVE when first entering [WAL journal mode](wal.html),
    then the locking mode cannot be changed to NORMAL until after exiting WAL journal
    mode. If the locking mode is NORMAL when first entering WAL journal mode, then
    the locking mode can be changed between NORMAL and EXCLUSIVE and back again at
    any time and without needing to exit WAL journal mode.
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_max_page_count" style="display:none">PRAGMA max_page_count</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA** *schema.***max_page_count;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA** *schema.***max_page_count =** *N***;**
  prefs: []
  type: TYPE_NORMAL
- en: Query or set the maximum number of pages in the database file. Both forms of
    the pragma return the maximum page count. The second form attempts to modify the
    maximum page count. The maximum page count cannot be reduced below the current
    database size.
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_mmap_size" style="display:none">PRAGMA mmap_size</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA** *schema.***mmap_size;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA** *schema.***mmap_size=***N*
  prefs: []
  type: TYPE_NORMAL
- en: Query or change the maximum number of bytes that are set aside for memory-mapped
    I/O on a single database. The first form (without an argument) queries the current
    limit. The second form (with a numeric argument) sets the limit for the specified
    database, or for all databases if the optional database name is omitted. In the
    second form, if the database name is omitted, the limit that is set becomes the
    default limit for all databases that are added to the [database connection](c3ref/sqlite3.html)
    by subsequent [ATTACH](lang_attach.html) statements.
  prefs: []
  type: TYPE_NORMAL
- en: The argument N is the maximum number of bytes of the database file that will
    be accessed using memory-mapped I/O. If N is zero then memory mapped I/O is disabled.
    If N is negative, then the limit reverts to the default value determined by the
    most recent [sqlite3_config](c3ref/config.html)([SQLITE_CONFIG_MMAP_SIZE](c3ref/c_config_covering_index_scan.html#sqliteconfigmmapsize)),
    or to the compile time default determined by [SQLITE_DEFAULT_MMAP_SIZE](compile.html#default_mmap_size)
    if not start-time limit has been set.
  prefs: []
  type: TYPE_NORMAL
- en: The [PRAGMA mmap_size](pragma.html#pragma_mmap_size) statement will never increase
    the amount of address space used for memory-mapped I/O above the hard limit set
    by the [SQLITE_MAX_MMAP_SIZE](compile.html#max_mmap_size) compile-time option,
    nor the hard limit set at startup-time by the second argument to sqlite3_config([SQLITE_CONFIG_MMAP_SIZE](c3ref/c_config_covering_index_scan.html#sqliteconfigmmapsize))
  prefs: []
  type: TYPE_NORMAL
- en: The size of the memory-mapped I/O region cannot be changed while the memory-mapped
    I/O region is in active use, to avoid unmapping memory out from under running
    SQL statements. For this reason, the mmap_size pragma may be a no-op if the prior
    mmap_size is non-zero and there are other SQL statements running concurrently
    on the same [database connection](c3ref/sqlite3.html).
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_module_list" style="display:none">PRAGMA module_list</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA module_list;**'
  prefs: []
  type: TYPE_NORMAL
- en: This pragma returns a list of [virtual table](vtab.html) modules registered
    with the database connection. <h _id="pragma_optimize" style="display:none">PRAGMA
    optimize</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA optimize;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA optimize(***MASK***);
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA** *schema***.optimize;
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA** *schema***.optimize(***MASK***);**
  prefs: []
  type: TYPE_NORMAL
- en: Attempt to optimize the database. All schemas are optimized in the first two
    forms, and only the specified schema is optimized in the latter two.
  prefs: []
  type: TYPE_NORMAL
- en: 'In most applications, using PRAGMA optimize as follows will help SQLite to
    achieve the best possible query performance:'
  prefs: []
  type: TYPE_NORMAL
- en: Applications with short-lived database connections should run "PRAGMA optimize;"
    once, just prior to closing each database connection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Applications that use long-lived database connections should run "PRAGMA optimize=0x10002;"
    when the connection is first opened, and then also run "PRAGMA optimize;" periodically,
    perhaps once per day or once per hour.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All applications should run "PRAGMA optimize;" after a schema change, especially
    after one or more [CREATE INDEX](lang_createindex.html) statements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This pragma is usually a no-op or nearly so and is very fast. On the occasions
    where it does need to run ANALYZE on one or more tables, it sets a temporary [analysis
    limit](pragma.html#pragma_analysis_limit), valid for the duration of this pragma
    only, that prevents the ANALYZE invocations from running for to long.
  prefs: []
  type: TYPE_NORMAL
- en: Recommended practice is that applications with short-lived database connections
    should run "PRAGMA optimize" once when the database connection closes. Applications
    with long-lived database connections should run "PRAGMA optimize=0x10002" when
    the database connection first opens, then run "PRAGMA optimize" again at periodic
    intervals - perhaps once per day. All applications should run "PRAGMA optimize"
    after schema changes, especially [CREATE INDEX](lang_createindex.html).
  prefs: []
  type: TYPE_NORMAL
- en: The details of optimizations performed by this pragma are expected to change
    and improve over time. Applications should anticipate that this pragma will perform
    new optimizations in future releases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The optional MASK argument is a bitmask of optimizations to perform:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 0x00001 | Debugging mode. Do not actually perform any optimizations but instead
    return one line of text for each optimization that would have been done. Off by
    default. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x00002 | Run [ANALYZE](lang_analyze.html) on tables that might benefit.
    On by default. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x00010 | When running [ANALYZE](lang_analyze.html), set a temporary [PRAGMA
    analysis_limit](pragma.html#pragma_analysis_limit) to prevent excess run-time.
    On by default. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x10000 | Check the size of all tables, not just tables that have not been
    recently used, to see if any have grown and shrunk significantly and hence might
    benefit from being re-analyzed. Off by default. |'
  prefs: []
  type: TYPE_TB
- en: The default MASK is 0xfffe.
  prefs: []
  type: TYPE_NORMAL
- en: To see all optimizations that would have been done without actually doing them,
    run "PRAGMA optimize(-1)".
  prefs: []
  type: TYPE_NORMAL
- en: '**Determination Of When To Run Analyze**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the current implementation, a table is analyzed if and only if all of the
    following are true:'
  prefs: []
  type: TYPE_NORMAL
- en: MASK bit 0x02 is set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The table is an ordinary table, not a view or virtual table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The table name does not begin with "sqlite_".
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'One or more of the following are true:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The 0x10000 bit of MASK is set
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: One or more indexes on the table lack entries in the sqlite_stat1 table.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The query planner used sqlite_stat1 statistics for one or more indexes of this
    table at some point during the lifetime of the current database connection.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'One or more of the following are true:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One or more indexes on the table lack entries in the sqlite_stat1 table.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The number of rows in the table has increased or decreased by 10-fold since
    the last time ANALYZE was run on the table.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The rules for when tables are analyzed are likely to change in future releases.
    New MASK values may be added in the future. Future versions of this pragma might
    accept a string literal argument instead of a bit mask, though the bit mask argument
    will continue to be supported for backwards compatibility. <h _id="pragma_page_count"
    style="display:none">PRAGMA page_count</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA** *schema.***page_count;**'
  prefs: []
  type: TYPE_NORMAL
- en: Return the total number of pages in the database file.
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_page_size" style="display:none">PRAGMA page_size</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA** *schema.***page_size;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA** *schema.***page_size =** *bytes***;**
  prefs: []
  type: TYPE_NORMAL
- en: Query or set the page size of the database. The page size must be a power of
    two between 512 and 65536 inclusive.
  prefs: []
  type: TYPE_NORMAL
- en: When a new database is created, SQLite assigns a page size to the database based
    on platform and filesystem. For many years, the default page size was almost always
    1024 bytes, but beginning with SQLite [version 3.12.0](releaselog/3_12_0.html)
    (2016-03-29), the default page size increased to 4096. The default page size is
    recommended for most applications.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying a new page size does not change the page size immediately. Instead,
    the new page size is remembered and is used to set the page size when the database
    is first created, if it does not already exist when the page_size pragma is issued,
    or at the next [VACUUM](lang_vacuum.html) command that is run on the same database
    connection while not in [WAL mode](wal.html).
  prefs: []
  type: TYPE_NORMAL
- en: The [SQLITE_DEFAULT_PAGE_SIZE](compile.html#default_page_size) compile-time
    option can be used to change the default page size assigned to new databases.
    <h _id="pragma_parser_trace" style="display:none">PRAGMA parser_trace</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA parser_trace =** *boolean***;**'
  prefs: []
  type: TYPE_NORMAL
- en: If SQLite has been compiled with the [SQLITE_DEBUG](compile.html#debug) compile-time
    option, then the parser_trace pragma can be used to turn on tracing for the SQL
    parser used internally by SQLite. This feature is used for debugging SQLite itself.
  prefs: []
  type: TYPE_NORMAL
- en: This pragma is intended for use when debugging SQLite itself. It is only available
    when the [SQLITE_DEBUG](compile.html#debug) compile-time option is used.
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_pragma_list" style="display:none">PRAGMA pragma_list</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA pragma_list;**'
  prefs: []
  type: TYPE_NORMAL
- en: This pragma returns a list of PRAGMA commands known to the database connection.
    <h _id="pragma_query_only" style="display:none">PRAGMA query_only</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA query_only;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA query_only =** *boolean***;**
  prefs: []
  type: TYPE_NORMAL
- en: The query_only pragma prevents data changes on database files when enabled.
    When this pragma is enabled, any attempt to CREATE, DELETE, DROP, INSERT, or UPDATE
    will result in an [SQLITE_READONLY](rescode.html#readonly) error. However, the
    database is not truly read-only. You can still run a [checkpoint](wal.html#ckpt)
    or a [COMMIT](lang_transaction.html) and the return value of the [sqlite3_db_readonly()](c3ref/db_readonly.html)
    routine is not affected.
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_quick_check" style="display:none">PRAGMA quick_check</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA** *schema.***quick_check;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA** *schema.***quick_check(***N***)**
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA *schema.***quick_check(***TABLENAME***)**
  prefs: []
  type: TYPE_NORMAL
- en: The pragma is like [integrity_check](pragma.html#pragma_integrity_check) except
    that it does not verify UNIQUE constraints and does not verify that index content
    matches table content. By skipping UNIQUE and index consistency checks, quick_check
    is able to run faster. PRAGMA quick_check runs in O(N) time whereas [PRAGMA integrity_check](pragma.html#pragma_integrity_check)
    requires O(NlogN) time where N is the total number of rows in the database. Otherwise
    the two pragmas are the same.
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_read_uncommitted" style="display:none">PRAGMA read_uncommitted</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA read_uncommitted;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA read_uncommitted =** *boolean***;**
  prefs: []
  type: TYPE_NORMAL
- en: Query, set, or clear READ UNCOMMITTED isolation. The default isolation level
    for SQLite is SERIALIZABLE. Any process or thread can select READ UNCOMMITTED
    isolation, but SERIALIZABLE will still be used except between connections that
    share a common page and schema cache. Cache sharing is enabled using the [sqlite3_enable_shared_cache()](c3ref/enable_shared_cache.html)
    API. Cache sharing is disabled by default.
  prefs: []
  type: TYPE_NORMAL
- en: See [SQLite Shared-Cache Mode](sharedcache.html) for additional information.
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_recursive_triggers" style="display:none">PRAGMA recursive_triggers</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA recursive_triggers;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA recursive_triggers =** *boolean***;**
  prefs: []
  type: TYPE_NORMAL
- en: Query, set, or clear the recursive trigger capability.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the recursive_triggers setting affects the execution of all statements
    prepared using the database connection, including those prepared before the setting
    was changed. Any existing statements prepared using the legacy [sqlite3_prepare()](c3ref/prepare.html)
    interface may fail with an [SQLITE_SCHEMA](rescode.html#schema) error after the
    recursive_triggers setting is changed.
  prefs: []
  type: TYPE_NORMAL
- en: Prior to SQLite [version 3.6.18](releaselog/3_6_18.html) (2009-09-11), recursive
    triggers were not supported. The behavior of SQLite was always as if this pragma
    was set to OFF. Support for recursive triggers was added in version 3.6.18 but
    was initially turned OFF by default, for compatibility. Recursive triggers may
    be turned on by default in future versions of SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: The depth of recursion for triggers has a hard upper limit set by the [SQLITE_MAX_TRIGGER_DEPTH](limits.html#max_trigger_depth)
    compile-time option and a run-time limit set by [sqlite3_limit](c3ref/limit.html)(db,[SQLITE_LIMIT_TRIGGER_DEPTH](c3ref/c_limit_attached.html#sqlitelimittriggerdepth),...).
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_reverse_unordered_selects" style="display:none">PRAGMA reverse_unordered_selects</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA reverse_unordered_selects;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA reverse_unordered_selects =** *boolean***;**
  prefs: []
  type: TYPE_NORMAL
- en: When enabled, this PRAGMA causes many [SELECT](lang_select.html) statements
    without an ORDER BY clause to emit their results in the reverse order from what
    they normally would. This can help debug applications that are making invalid
    assumptions about the result order. The reverse_unordered_selects pragma works
    for most SELECT statements, however the query planner may sometimes choose an
    algorithm that is not easily reversed, in which case the output will appear in
    the same order regardless of the reverse_unordered_selects setting.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite makes no guarantees about the order of results if a SELECT omits the
    ORDER BY clause. Even so, the order of results does not change from one run to
    the next, and so many applications mistakenly come to depend on the arbitrary
    output order whatever that order happens to be. However, sometimes new versions
    of SQLite will contain optimizer enhancements that will cause the output order
    of queries without ORDER BY clauses to shift. When that happens, applications
    that depend on a certain output order might malfunction. By running the application
    multiple times with this pragma both disabled and enabled, cases where the application
    makes faulty assumptions about output order can be identified and fixed early,
    reducing problems that might be caused by linking against a different version
    of SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_schema_version" style="display:none">PRAGMA schema_version</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA** *schema.***schema_version;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA** *schema.***schema_version =** *integer* ;
  prefs: []
  type: TYPE_NORMAL
- en: The schema_version pragma will get or set the value of the schema-version integer
    at offset 40 in the [database header](fileformat2.html#database_header).
  prefs: []
  type: TYPE_NORMAL
- en: SQLite automatically increments the schema-version whenever the schema changes.
    As each SQL statement runs, the schema version is checked to ensure that the schema
    has not changed since the SQL statement was [prepared](c3ref/prepare.html). Subverting
    this mechanism by using "PRAGMA schema_version=N" to change the value of the schema_version
    may cause SQL statement to run using an obsolete schema, which can lead to incorrect
    answers and/or [database corruption](howtocorrupt.html#cfgerr). It is always safe
    to read the schema_version, but changing the schema_version can cause problems.
    For this reason, attempts to change the value of schema_version are a silent no-op
    when [defensive mode](c3ref/c_dbconfig_defensive.html#sqlitedbconfigdefensive)
    is enabled for a database connection.
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning:** Misuse of this pragma can result in [database corruption](howtocorrupt.html#cfgerr).'
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of this pragma, the [VACUUM](lang_vacuum.html) command is considered
    a schema change, since [VACUUM](lang_vacuum.html) will usually alter the "rootpage"
    values for entries in the [sqlite_schema table](schematab.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also the [application_id pragma](pragma.html#pragma_application_id) and
    [user_version pragma](pragma.html#pragma_user_version). <h _id="pragma_secure_delete"
    style="display:none">PRAGMA secure_delete</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA** *schema.***secure_delete;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA** *schema.***secure_delete =** *boolean*|**FAST**
  prefs: []
  type: TYPE_NORMAL
- en: Query or change the secure-delete setting. When secure_delete is on, SQLite
    overwrites deleted content with zeros. The default setting for secure_delete is
    determined by the [SQLITE_SECURE_DELETE](compile.html#secure_delete) compile-time
    option and is normally off. The off setting for secure_delete improves performance
    by reducing the number of CPU cycles and the amount of disk I/O. Applications
    that wish to avoid leaving forensic traces after content is deleted or updated
    should enable the secure_delete pragma prior to performing the delete or update,
    or else run [VACUUM](lang_vacuum.html) after the delete or update.
  prefs: []
  type: TYPE_NORMAL
- en: The "fast" setting for secure_delete (added circa 2017-08-01) is an intermediate
    setting in between "on" and "off". When secure_delete is set to "fast", SQLite
    will overwrite deleted content with zeros only if doing so does not increase the
    amount of I/O. In other words, the "fast" setting uses more CPU cycles but does
    not use more I/O. This has the effect of purging all old content from [b-tree
    pages](fileformat2.html#btree), but leaving forensic traces on [freelist pages](fileformat2.html#freelist).
  prefs: []
  type: TYPE_NORMAL
- en: When there are [attached databases](lang_attach.html) and no database is specified
    in the pragma, all databases have their secure-delete setting altered. The secure-delete
    setting for newly attached databases is the setting of the main database at the
    time the ATTACH command is evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: When multiple database connections share the same cache, changing the secure-delete
    flag on one database connection changes it for them all.
  prefs: []
  type: TYPE_NORMAL
- en: '**Limitation:** The secure_delete pragma only causes deleted content to be
    scrubbed from ordinary tables. If [virtual tables](vtab.html) store content in
    [shadow tables](vtab.html#xshadowname), then deleting content from the virtual
    table does not necessarily remove forensic traces from the shadow tables. In particular,
    the [FTS3](fts3.html) and [FTS5](fts5.html) virtual tables that come bundled with
    SQLite might leave forensic traces in their shadow tables even if the secure_delete
    pragma is enabled.'
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_short_column_names" style="display:none">PRAGMA short_column_names</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA short_column_names;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA short_column_names =** *boolean***;**
  prefs: []
  type: TYPE_NORMAL
- en: Query or change the short-column-names flag. This flag affects the way SQLite
    names columns of data returned by [SELECT](lang_select.html) statements. See the
    [full_column_names](pragma.html#pragma_full_column_names) pragma for full details.
  prefs: []
  type: TYPE_NORMAL
- en: '**This pragma is deprecated** and exists for backwards compatibility only.
    New applications should avoid using this pragma. Older applications should discontinue
    use of this pragma at the earliest opportunity. This pragma may be omitted from
    the build when SQLite is compiled using [SQLITE_OMIT_DEPRECATED](compile.html#omit_deprecated).'
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_shrink_memory" style="display:none">PRAGMA shrink_memory</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA shrink_memory**'
  prefs: []
  type: TYPE_NORMAL
- en: This pragma causes the database connection on which it is invoked to free up
    as much memory as it can, by calling [sqlite3_db_release_memory()](c3ref/db_release_memory.html).
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_soft_heap_limit" style="display:none">PRAGMA soft_heap_limit</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA soft_heap_limit'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA soft_heap_limit=***N*
  prefs: []
  type: TYPE_NORMAL
- en: This pragma invokes the [sqlite3_soft_heap_limit64()](c3ref/hard_heap_limit64.html)
    interface with the argument N, if N is specified and is a non-negative integer.
    The soft_heap_limit pragma always returns the same integer that would be returned
    by the [sqlite3_soft_heap_limit64](c3ref/hard_heap_limit64.html)(-1) C-language
    function.
  prefs: []
  type: TYPE_NORMAL
- en: See also the [hard_heap_limit pragma](pragma.html#pragma_hard_heap_limit). <h
    _id="pragma_stats" style="display:none">PRAGMA stats</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA stats;**'
  prefs: []
  type: TYPE_NORMAL
- en: This pragma returns auxiliary information about tables and indices. The returned
    information is used during testing to help verify that the query planner is operating
    correctly. The format and meaning of this pragma will likely change from one release
    to the next. Because of its volatility, the behavior and output format of this
    pragma are deliberately undocumented.
  prefs: []
  type: TYPE_NORMAL
- en: The intended use of this pragma is only for testing and validation of SQLite.
    This pragma is subject to change without notice and is not recommended for use
    by application programs.
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_synchronous" style="display:none">PRAGMA synchronous</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA** *schema.***synchronous;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA** *schema.***synchronous =** *0 | OFF | 1 | NORMAL | 2 | FULL | 3 | EXTRA***;**
  prefs: []
  type: TYPE_NORMAL
- en: 'Query or change the setting of the "synchronous" flag. The first (query) form
    will return the synchronous setting as an integer. The second form changes the
    synchronous setting. The meanings of the various synchronous settings are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**EXTRA** (3)'
  prefs: []
  type: TYPE_NORMAL
- en: EXTRA synchronous is like FULL with the addition that the directory containing
    a [rollback journal](lockingv3.html#rollback) is synced after that journal is
    unlinked to commit a transaction in DELETE mode. EXTRA provides additional durability
    if the commit is followed closely by a power loss.
  prefs: []
  type: TYPE_NORMAL
- en: '**FULL** (2)'
  prefs: []
  type: TYPE_NORMAL
- en: When synchronous is FULL (2), the SQLite database engine will use the xSync
    method of the [VFS](vfs.html) to ensure that all content is safely written to
    the disk surface prior to continuing. This ensures that an operating system crash
    or power failure will not corrupt the database. FULL synchronous is very safe,
    but it is also slower. FULL is the most commonly used synchronous setting when
    not in [WAL mode](wal.html).
  prefs: []
  type: TYPE_NORMAL
- en: '**NORMAL** (1)'
  prefs: []
  type: TYPE_NORMAL
- en: When synchronous is NORMAL (1), the SQLite database engine will still sync at
    the most critical moments, but less often than in FULL mode. There is a very small
    (though non-zero) chance that a power failure at just the wrong time could corrupt
    the database in [journal_mode](pragma.html#pragma_journal_mode)=DELETE on an older
    filesystem. [WAL mode](wal.html) is safe from corruption with synchronous=NORMAL,
    and probably DELETE mode is safe too on modern filesystems. WAL mode is always
    consistent with synchronous=NORMAL, but WAL mode does lose durability. A transaction
    committed in WAL mode with synchronous=NORMAL might roll back following a power
    loss or system crash. Transactions are durable across application crashes regardless
    of the synchronous setting or journal mode. The synchronous=NORMAL setting is
    a good choice for most applications running in [WAL mode](wal.html).
  prefs: []
  type: TYPE_NORMAL
- en: '**OFF** (0)'
  prefs: []
  type: TYPE_NORMAL
- en: With synchronous OFF (0), SQLite continues without syncing as soon as it has
    handed data off to the operating system. If the application running SQLite crashes,
    the data will be safe, but the database [might become corrupted](howtocorrupt.html#cfgerr)
    if the operating system crashes or the computer loses power before that data has
    been written to the disk surface. On the other hand, commits can be orders of
    magnitude faster with synchronous OFF.
  prefs: []
  type: TYPE_NORMAL
- en: In [WAL](wal.html) mode when synchronous is NORMAL (1), the WAL file is synchronized
    before each [checkpoint](wal.html#ckpt) and the database file is synchronized
    after each completed [checkpoint](wal.html#ckpt) and the WAL file header is synchronized
    when a WAL file begins to be reused after a checkpoint, but no sync operations
    occur during most transactions. With synchronous=FULL in WAL mode, an additional
    sync operation of the WAL file happens after each transaction commit. The extra
    WAL sync following each transaction helps ensure that transactions are durable
    across a power loss. Transactions are consistent with or without the extra syncs
    provided by synchronous=FULL. If durability is not a concern, then synchronous=NORMAL
    is normally all one needs in WAL mode.
  prefs: []
  type: TYPE_NORMAL
- en: The TEMP schema always has synchronous=OFF since the content of of TEMP is ephemeral
    and is not expected to survive a power outage. Attempts to change the synchronous
    setting for TEMP are silently ignored.
  prefs: []
  type: TYPE_NORMAL
- en: See also the [fullfsync](pragma.html#pragma_fullfsync) and [checkpoint_fullfsync](pragma.html#pragma_checkpoint_fullfsync)
    pragmas.
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_table_info" style="display:none">PRAGMA table_info</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA** *schema.***table_info(***table-name***);**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This pragma returns one row for each normal column in the named table. Columns
    in the result set include: "name" (its name); "type" (data type if given, else
    ''''); "notnull" (whether or not the column can be NULL); "dflt_value" (the default
    value for the column); and "pk" (either zero for columns that are not part of
    the primary key, or the 1-based index of the column within the primary key).'
  prefs: []
  type: TYPE_NORMAL
- en: The "cid" column should not be taken to mean more than "rank within the current
    result set".
  prefs: []
  type: TYPE_NORMAL
- en: The table named in the table_info pragma can also be a view.
  prefs: []
  type: TYPE_NORMAL
- en: This pragma does not show information about [generated columns](gencol.html)
    or [hidden columns](vtab.html#hiddencol). Use [PRAGMA table_xinfo](pragma.html#pragma_table_xinfo)
    to get a more complete list of columns that includes generated and hidden columns.
    <h _id="pragma_table_list" style="display:none">PRAGMA table_list</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA table_list;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA** *schema.***table_list;
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA table_list(***table-name***);**
  prefs: []
  type: TYPE_NORMAL
- en: This pragma returns information about the tables and views in the schema, one
    table per row of output. The table_list pragma first appeared in SQLite version
    3.37.0 (2021-11-27). As of its initial release the columns returned by the table_list
    pragma include those listed below. Future versions of SQLite will probably add
    additional columns of output.
  prefs: []
  type: TYPE_NORMAL
- en: '**schema**: the schema in which the table or view appears (for example "main"
    or "temp").'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**name**: the name of the table or view.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**type**: the type of object - one of "table", "view", "shadow" (for [shadow
    tables](vtab.html#xshadowname)), or "virtual" for [virtual tables](vtab.html).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**ncol**: the number of columns in the table, including [generated columns](gencol.html)
    and [hidden columns](vtab.html#hiddencol).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**wr**: 1 if the table is a [WITHOUT ROWID](withoutrowid.html) table or 0 if
    is not.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**strict**: 1 if the table is a [STRICT table](stricttables.html) or 0 if it
    is not.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Additional columns will likely be added in future releases.*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The default behavior is to show all tables in all schemas. If the *schema.*
    name appears before the pragma, then only tables in that one schema are shown.
    If a *table-name* argument is supplied, then only information about that one table
    is returned. <h _id="pragma_table_xinfo" style="display:none">PRAGMA table_xinfo</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA** *schema.***table_xinfo(***table-name***);**'
  prefs: []
  type: TYPE_NORMAL
- en: This pragma returns one row for each column in the named table, including [generated
    columns](gencol.html) and [hidden columns](vtab.html#hiddencol). The output has
    the same columns as for [PRAGMA table_info](pragma.html#pragma_table_info) plus
    a column, "hidden", whose value signifies a normal column (0), a dynamic or stored
    generated column (2 or 3), or a hidden column in a virtual table (1). The rows
    for which this field is non-zero are those omitted for [PRAGMA table_info](pragma.html#pragma_table_info).
    <h _id="pragma_temp_store" style="display:none">PRAGMA temp_store</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA temp_store;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA temp_store =** *0 | DEFAULT | 1 | FILE | 2 | MEMORY***;**
  prefs: []
  type: TYPE_NORMAL
- en: Query or change the setting of the "**temp_store**" parameter. When temp_store
    is DEFAULT (0), the compile-time C preprocessor macro [SQLITE_TEMP_STORE](compile.html#temp_store)
    is used to determine where temporary tables and indices are stored. When temp_store
    is MEMORY (2) [temporary tables](inmemorydb.html#temp_db) and indices are kept
    as if they were in pure [in-memory databases](inmemorydb.html). When temp_store
    is FILE (1) [temporary tables](inmemorydb.html#temp_db) and indices are stored
    in a file. The [temp_store_directory](pragma.html#pragma_temp_store_directory)
    pragma can be used to specify the directory containing temporary files when **FILE**
    is specified. When the temp_store setting is changed, all existing temporary tables,
    indices, triggers, and views are immediately deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible for the library compile-time C preprocessor symbol [SQLITE_TEMP_STORE](compile.html#temp_store)
    to override this pragma setting. The following table summarizes the interaction
    of the [SQLITE_TEMP_STORE](compile.html#temp_store) preprocessor macro and the
    temp_store pragma:'
  prefs: []
  type: TYPE_NORMAL
- en: '| [SQLITE_TEMP_STORE](compile.html#temp_store) | PRAGMA temp_store | Storage
    used for TEMP tables and indices |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| 0 | *any* | file |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| 1 | 0 | file |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| 1 | 1 | file |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| 1 | 2 | memory |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| 2 | 0 | memory |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| 2 | 1 | file |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| 2 | 2 | memory |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| 3 | *any* | memory |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: <h _id="pragma_temp_store_directory" style="display:none">PRAGMA temp_store_directory</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA temp_store_directory;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA temp_store_directory = '***directory-name***';**
  prefs: []
  type: TYPE_NORMAL
- en: Query or change the value of the [sqlite3_temp_directory](c3ref/temp_directory.html)
    global variable, which many operating-system interface backends use to determine
    where to store [temporary tables](inmemorydb.html#temp_db) and indices.
  prefs: []
  type: TYPE_NORMAL
- en: When the temp_store_directory setting is changed, all existing temporary tables,
    indices, triggers, and viewers in the database connection that issued the pragma
    are immediately deleted. In practice, temp_store_directory should be set immediately
    after the first database connection for a process is opened. If the temp_store_directory
    is changed for one database connection while other database connections are open
    in the same process, then the behavior is undefined and probably undesirable.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the temp_store_directory setting is not threadsafe. Never change the
    temp_store_directory setting if another thread within the application is running
    any SQLite interface at the same time. Doing so results in undefined behavior.
    Changing the temp_store_directory setting writes to the [sqlite3_temp_directory](c3ref/temp_directory.html)
    global variable and that global variable is not protected by a mutex.
  prefs: []
  type: TYPE_NORMAL
- en: The value *directory-name* should be enclosed in single quotes. To revert the
    directory to the default, set the *directory-name* to an empty string, e.g., *PRAGMA
    temp_store_directory = ''*. An error is raised if *directory-name* is not found
    or is not writable.
  prefs: []
  type: TYPE_NORMAL
- en: The default directory for temporary files depends on the OS. Some OS interfaces
    may choose to ignore this variable and place temporary files in some other directory
    different from the directory specified here. In that sense, this pragma is only
    advisory.
  prefs: []
  type: TYPE_NORMAL
- en: '**This pragma is deprecated** and exists for backwards compatibility only.
    New applications should avoid using this pragma. Older applications should discontinue
    use of this pragma at the earliest opportunity. This pragma may be omitted from
    the build when SQLite is compiled using [SQLITE_OMIT_DEPRECATED](compile.html#omit_deprecated).'
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_threads" style="display:none">PRAGMA threads</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA threads;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA threads =** *N***;**
  prefs: []
  type: TYPE_NORMAL
- en: Query or change the value of the [sqlite3_limit](c3ref/limit.html)(db,[SQLITE_LIMIT_WORKER_THREADS](c3ref/c_limit_attached.html#sqlitelimitworkerthreads),...)
    limit for the current database connection. This limit sets an upper bound on the
    number of auxiliary threads that a [prepared statement](c3ref/stmt.html) is allowed
    to launch to assist with a query. The default limit is 0 unless it is changed
    using the [SQLITE_DEFAULT_WORKER_THREADS](compile.html#default_worker_threads)
    compile-time option. When the limit is zero, that means no auxiliary threads will
    be launched.
  prefs: []
  type: TYPE_NORMAL
- en: This pragma is a thin wrapper around the [sqlite3_limit](c3ref/limit.html)(db,[SQLITE_LIMIT_WORKER_THREADS](c3ref/c_limit_attached.html#sqlitelimitworkerthreads),...)
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_trusted_schema" style="display:none">PRAGMA trusted_schema</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA trusted_schema;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA trusted_schema =** *boolean***;**
  prefs: []
  type: TYPE_NORMAL
- en: The trusted_schema setting is a per-connection boolean that determines whether
    or not SQL functions and virtual tables that have not been security audited are
    allowed to be run by views, triggers, or in expressions of the schema such as
    [CHECK constraints](lang_createtable.html#ckconst), [DEFAULT clauses](lang_createtable.html#dfltval),
    [generated columns](gencol.html), [expression indexes](expridx.html), and/or [partial
    indexes](partialindex.html). This setting can also be controlled using the [sqlite3_db_config](c3ref/db_config.html)(db,[SQLITE_DBCONFIG_TRUSTED_SCHEMA](c3ref/c_dbconfig_defensive.html#sqlitedbconfigtrustedschema),...)
    C-language interface.
  prefs: []
  type: TYPE_NORMAL
- en: In order to maintain backwards compatibility, this setting is ON by default.
    There are advantages to turning it off, and most applications will be unaffected
    if it is turned off. For that reason, all applications are encouraged to switch
    this setting off on every database connection as soon as that connection is opened.
  prefs: []
  type: TYPE_NORMAL
- en: The [-DSQLITE_TRUSTED_SCHEMA=0](compile.html#trusted_schema) compile-time option
    will cause this setting to default to OFF. <h _id="pragma_user_version" style="display:none">PRAGMA
    user_version</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA** *schema.***user_version;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA** *schema.***user_version =** *integer* **;**
  prefs: []
  type: TYPE_NORMAL
- en: The user_version pragma will get or set the value of the user-version integer
    at offset 60 in the [database header](fileformat2.html#database_header). The user-version
    is an integer that is available to applications to use however they want. SQLite
    makes no use of the user-version itself.
  prefs: []
  type: TYPE_NORMAL
- en: See also the [application_id pragma](pragma.html#pragma_application_id) and
    [schema_version pragma](pragma.html#pragma_schema_version). <h _id="pragma_vdbe_addoptrace"
    style="display:none">PRAGMA vdbe_addoptrace</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA vdbe_addoptrace =** *boolean***;**'
  prefs: []
  type: TYPE_NORMAL
- en: If SQLite has been compiled with the [SQLITE_DEBUG](compile.html#debug) compile-time
    option, then the vdbe_addoptrace pragma can be used to cause a complete VDBE opcodes
    to be displayed as they are created during code generation. This feature is used
    for debugging SQLite itself. See the [VDBE documentation](vdbe.html#trace) for
    more information.
  prefs: []
  type: TYPE_NORMAL
- en: This pragma is intended for use when debugging SQLite itself. It is only available
    when the [SQLITE_DEBUG](compile.html#debug) compile-time option is used.
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_vdbe_debug" style="display:none">PRAGMA vdbe_debug</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA vdbe_debug =** *boolean***;**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If SQLite has been compiled with the [SQLITE_DEBUG](compile.html#debug) compile-time
    option, then the vdbe_debug pragma is a shorthand for three other debug-only pragmas:
    vdbe_addoptrace, vdbe_listing, and vdbe_trace. This feature is used for debugging
    SQLite itself. See the [VDBE documentation](vdbe.html#trace) for more information.'
  prefs: []
  type: TYPE_NORMAL
- en: This pragma is intended for use when debugging SQLite itself. It is only available
    when the [SQLITE_DEBUG](compile.html#debug) compile-time option is used.
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_vdbe_listing" style="display:none">PRAGMA vdbe_listing</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA vdbe_listing =** *boolean***;**'
  prefs: []
  type: TYPE_NORMAL
- en: If SQLite has been compiled with the [SQLITE_DEBUG](compile.html#debug) compile-time
    option, then the vdbe_listing pragma can be used to cause a complete listing of
    the virtual machine opcodes to appear on standard output as each statement is
    evaluated. With listing is on, the entire content of a program is printed just
    prior to beginning execution. The statement executes normally after the listing
    is printed. This feature is used for debugging SQLite itself. See the [VDBE documentation](vdbe.html#trace)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: This pragma is intended for use when debugging SQLite itself. It is only available
    when the [SQLITE_DEBUG](compile.html#debug) compile-time option is used.
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_vdbe_trace" style="display:none">PRAGMA vdbe_trace</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA vdbe_trace =** *boolean***;**'
  prefs: []
  type: TYPE_NORMAL
- en: If SQLite has been compiled with the [SQLITE_DEBUG](compile.html#debug) compile-time
    option, then the vdbe_trace pragma can be used to cause virtual machine opcodes
    to be printed on standard output as they are evaluated. This feature is used for
    debugging SQLite. See the [VDBE documentation](vdbe.html#trace) for more information.
  prefs: []
  type: TYPE_NORMAL
- en: This pragma is intended for use when debugging SQLite itself. It is only available
    when the [SQLITE_DEBUG](compile.html#debug) compile-time option is used.
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_wal_autocheckpoint" style="display:none">PRAGMA wal_autocheckpoint</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA wal_autocheckpoint;'
  prefs: []
  type: TYPE_NORMAL
- en: PRAGMA wal_autocheckpoint=***N***;**
  prefs: []
  type: TYPE_NORMAL
- en: This pragma queries or sets the [write-ahead log](wal.html) [auto-checkpoint](wal.html#ckpt)
    interval. When the [write-ahead log](wal.html) is enabled (via the [journal_mode
    pragma](pragma.html#pragma_journal_mode)) a checkpoint will be run automatically
    whenever the write-ahead log equals or exceeds *N* pages in length. Setting the
    auto-checkpoint size to zero or a negative value turns auto-checkpointing off.
  prefs: []
  type: TYPE_NORMAL
- en: This pragma is a wrapper around the [sqlite3_wal_autocheckpoint()](c3ref/wal_autocheckpoint.html)
    C interface. All automatic checkpoints are [PASSIVE](c3ref/wal_checkpoint_v2.html).
  prefs: []
  type: TYPE_NORMAL
- en: Autocheckpointing is enabled by default with an interval of 1000 or [SQLITE_DEFAULT_WAL_AUTOCHECKPOINT](compile.html#default_wal_autocheckpoint).
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_wal_checkpoint" style="display:none">PRAGMA wal_checkpoint</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA** *schema.***wal_checkpoint;**'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA** *schema.***wal_checkpoint(PASSIVE);**'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA** *schema.***wal_checkpoint(FULL);**'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA** *schema.***wal_checkpoint(RESTART);**'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA** *schema.***wal_checkpoint(TRUNCATE);**'
  prefs: []
  type: TYPE_NORMAL
- en: If the [write-ahead log](wal.html) is enabled (via the [journal_mode pragma](pragma.html#pragma_journal_mode)),
    this pragma causes a [checkpoint](wal.html#ckpt) operation to run on database
    *database*, or on all attached databases if *database* is omitted. If [write-ahead
    log](wal.html) mode is disabled, this pragma is a harmless no-op.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking this pragma without an argument is equivalent to calling the [sqlite3_wal_checkpoint()](c3ref/wal_checkpoint.html)
    C interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Invoking this pragma with an argument is equivalent to calling the [sqlite3_wal_checkpoint_v2()](c3ref/wal_checkpoint_v2.html)
    C interface with a [3rd parameter](c3ref/c_checkpoint_full.html) corresponding
    to the argument:'
  prefs: []
  type: TYPE_NORMAL
- en: PASSIVE
  prefs: []
  type: TYPE_NORMAL
- en: Checkpoint as many frames as possible without waiting for any database readers
    or writers to finish. Sync the db file if all frames in the log are checkpointed.
    This mode is the same as calling the [sqlite3_wal_checkpoint()](c3ref/wal_checkpoint.html)
    C interface. The [busy-handler callback](c3ref/busy_handler.html) is never invoked
    in this mode.
  prefs: []
  type: TYPE_NORMAL
- en: FULL
  prefs: []
  type: TYPE_NORMAL
- en: This mode blocks (invokes the [busy-handler callback](c3ref/busy_handler.html))
    until there is no database writer and all readers are reading from the most recent
    database snapshot. It then checkpoints all frames in the log file and syncs the
    database file. FULL blocks concurrent writers while it is running, but readers
    can proceed.
  prefs: []
  type: TYPE_NORMAL
- en: RESTART
  prefs: []
  type: TYPE_NORMAL
- en: This mode works the same way as FULL with the addition that after checkpointing
    the log file it blocks (calls the [busy-handler callback](c3ref/busy_handler.html))
    until all readers are finished with the log file. This ensures that the next client
    to write to the database file restarts the log file from the beginning. RESTART
    blocks concurrent writers while it is running, but allowed readers to proceed.
  prefs: []
  type: TYPE_NORMAL
- en: TRUNCATE
  prefs: []
  type: TYPE_NORMAL
- en: This mode works the same way as RESTART with the addition that the WAL file
    is truncated to zero bytes upon successful completion.
  prefs: []
  type: TYPE_NORMAL
- en: The wal_checkpoint pragma returns a single row with three integer columns. The
    first column is usually 0 but will be 1 if a RESTART or FULL or TRUNCATE checkpoint
    was blocked from completing, for example because another thread or process was
    actively using the database. In other words, the first column is 0 if the equivalent
    call to [sqlite3_wal_checkpoint_v2()](c3ref/wal_checkpoint_v2.html) would have
    returned [SQLITE_OK](rescode.html#ok) or 1 if the equivalent call would have returned
    [SQLITE_BUSY](rescode.html#busy). The second column is the number of modified
    pages that have been written to the write-ahead log file. The third column is
    the number of pages in the write-ahead log file that have been successfully moved
    back into the database file at the conclusion of the checkpoint. The second and
    third column are -1 if there is no write-ahead log, for example if this pragma
    is invoked on a database connection that is not in [WAL mode](wal.html).
  prefs: []
  type: TYPE_NORMAL
- en: <h _id="pragma_writable_schema" style="display:none">PRAGMA writable_schema</h>
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA writable_schema =** *boolean***;**'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRAGMA writable_schema = RESET**'
  prefs: []
  type: TYPE_NORMAL
- en: When this pragma is on, and the [SQLITE_DBCONFIG_DEFENSIVE](c3ref/c_dbconfig_defensive.html#sqlitedbconfigdefensive)
    flag is off, then the [sqlite_schema](schematab.html) table can be changed using
    ordinary [UPDATE](lang_update.html), [INSERT](lang_insert.html), and [DELETE](lang_delete.html)
    statements. If the argument is "RESET" then schema writing is disabled (as with
    "PRAGMA writable_schema=OFF") and, in addition, the schema is reloaded. **Warning:**
    misuse of this pragma can easily result in a [corrupt database file](howtocorrupt.html#cfgerr).
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
