- en: 1\. Overview
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1\. 概述
- en: 原文：[https://sqlite.com/wal.html](https://sqlite.com/wal.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://sqlite.com/wal.html](https://sqlite.com/wal.html)
- en: The default method by which SQLite implements [atomic commit and rollback](atomiccommit.html)
    is a [rollback journal](lockingv3.html#rollback). Beginning with [version 3.7.0](releaselog/3_7_0.html)
    (2010-07-21), a new "Write-Ahead Log" option (hereafter referred to as "WAL")
    is available.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 实现 [原子提交和回滚](atomiccommit.html) 的默认方法是使用 [回滚日志](lockingv3.html#rollback)。从
    [3.7.0 版本](releaselog/3_7_0.html)（2010-07-21）开始，新增了一种称为 "写前日志"（WAL）的选项。
- en: 'There are advantages and disadvantages to using WAL instead of a rollback journal.
    Advantages include:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 WAL 而不是回滚日志有其优缺点。优点包括：
- en: WAL is significantly faster in most scenarios.
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在大多数情况下，WAL 明显更快。
- en: WAL provides more concurrency as readers do not block writers and a writer does
    not block readers. Reading and writing can proceed concurrently.
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: WAL 提供更高的并发性，因为读者不会阻塞写者，写者也不会阻塞读者。读写可以并发进行。
- en: Disk I/O operations tends to be more sequential using WAL.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 WAL 时，磁盘 I/O 操作通常更加顺序化。
- en: WAL uses many fewer fsync() operations and is thus less vulnerable to problems
    on systems where the fsync() system call is broken.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 WAL 模式下，使用的 fsync() 操作较少，因此在 fsync() 系统调用存在问题的系统上，它不太容易出现问题。
- en: 'But there are also disadvantages:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 但是也存在一些缺点：
- en: 'WAL normally requires that the [VFS](vfs.html) support shared-memory primitives.
    (Exception: [WAL without shared memory](wal.html#noshm)) The built-in unix and
    windows VFSes support this but third-party extension VFSes for custom operating
    systems might not.'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: WAL 通常要求 [VFS](vfs.html) 支持共享内存原语。（例外情况：[无共享内存的 WAL](wal.html#noshm)）内置的 unix
    和 windows VFS 支持此功能，但是针对自定义操作系统的第三方扩展 VFS 可能不支持。
- en: All processes using a database must be on the same host computer; WAL does not
    work over a network filesystem.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用数据库的所有进程必须在同一台主机上；WAL 不适用于网络文件系统。
- en: Transactions that involve changes against multiple [ATTACHed](lang_attach.html)
    databases are atomic for each individual database, but are not atomic across all
    databases as a set.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跨多个 [ATTACHed](lang_attach.html) 数据库进行更改的事务在每个单独的数据库中是原子的，但在所有数据库作为一个集合时却不是原子的。
- en: It is not possible to change the [page_size](pragma.html#pragma_page_size) after
    entering WAL mode, either on an empty database or by using [VACUUM](lang_vacuum.html)
    or by restoring from a backup using the [backup API](backup.html). You must be
    in a rollback journal mode to change the page size.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入 WAL 模式后，无论是在空数据库上，还是通过使用 [VACUUM](lang_vacuum.html) 或通过使用 [备份 API](backup.html)
    从备份中恢复，都不能更改 [page_size](pragma.html#pragma_page_size)。更改页面大小必须处于回滚日志模式。
- en: ~~It is not possible to open [read-only WAL databases](wal.html#readonly). The
    opening process must have write privileges for "`-shm`" [wal-index](walformat.html#shm)
    shared memory file associated with the database, if that file exists, or else
    write access on the directory containing the database file if the "`-shm`" file
    does not exist.~~ Beginning with [version 3.22.0](releaselog/3_22_0.html) (2018-01-22),
    a read-only WAL-mode database file can be opened if the `-shm` and `-wal` files
    already exists or those files can be created or the [database is immutable](uri.html#uriimmutable).
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自 [版本 3.22.0](releaselog/3_22_0.html) (2018-01-22) 起，如果 `-shm` 和 `-wal` 文件已经存在，或者可以创建这些文件，或者数据库是[不可变的](uri.html#uriimmutable)，可以打开一个只读的
    WAL 模式数据库文件。
- en: WAL might be very slightly slower (perhaps 1% or 2% slower) than the traditional
    rollback-journal approach in applications that do mostly reads and seldom write.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在大多数是读取而很少写入的应用程序中，WAL 可能比传统的回滚日志方法稍微慢一些（也许慢 1% 或 2%）。
- en: There is an additional quasi-persistent "`-wal`" file and "`-shm`" shared memory
    file associated with each database, which can make SQLite less appealing for use
    as an [application file-format](appfileformat.html).
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个数据库都有一个额外的准持久化 `-wal` 文件和与之关联的 `-shm` 共享内存文件，这使得 SQLite 在作为[应用程序文件格式](appfileformat.html)时显得不太合适。
- en: There is the extra operation of [checkpointing](wal.html#ckpt) which, though
    automatic by default, is still something that application developers need to be
    mindful of.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有一个额外的操作是[检查点](wal.html#ckpt)，虽然默认情况下是自动的，但应用程序开发者仍需注意这一点。
- en: ~~WAL works best with smaller transactions. WAL does not work well for very
    large transactions. For transactions larger than about 100 megabytes, traditional
    rollback journal modes will likely be faster. For transactions in excess of a
    gigabyte, WAL mode may fail with an I/O or disk-full error. It is recommended
    that one of the rollback journal modes be used for transactions larger than a
    few dozen megabytes.~~ Beginning with [version 3.11.0](releaselog/3_11_0.html)
    (2016-02-15), WAL mode works as efficiently with large transactions as does rollback
    mode.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自 [版本 3.11.0](releaselog/3_11_0.html) (2016-02-15) 起，WAL 模式在处理大事务时与回滚模式一样高效。
- en: 2\. How WAL Works
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2\. WAL 的工作原理
- en: The traditional rollback journal works by writing a copy of the original unchanged
    database content into a separate rollback journal file and then writing changes
    directly into the database file. In the event of a crash or [ROLLBACK](lang_transaction.html),
    the original content contained in the rollback journal is played back into the
    database file to revert the database file to its original state. The [COMMIT](lang_transaction.html)
    occurs when the rollback journal is deleted.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的回滚日志工作方式是将原始未更改的数据库内容的副本写入单独的回滚日志文件，然后直接将更改写入数据库文件。在崩溃或[回滚](lang_transaction.html)时，回滚日志中包含的原始内容将播放回数据库文件，将数据库文件恢复到其原始状态。[提交](lang_transaction.html)时删除回滚日志。
- en: The WAL approach inverts this. The original content is preserved in the database
    file and the changes are appended into a separate WAL file. A [COMMIT](lang_transaction.html)
    occurs when a special record indicating a commit is appended to the WAL. Thus
    a COMMIT can happen without ever writing to the original database, which allows
    readers to continue operating from the original unaltered database while changes
    are simultaneously being committed into the WAL. Multiple transactions can be
    appended to the end of a single WAL file.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: WAL方法则相反。原始内容保留在数据库文件中，并将更改附加到单独的WAL文件中。当追加到WAL的特殊记录指示提交时，[提交](lang_transaction.html)即发生。因此，可以在不写入原始数据库的情况下执行提交，这允许读者继续从原始未更改的数据库中操作，同时将更改同时提交到WAL中。多个事务可以附加到单个WAL文件的末尾。
- en: 2.1\. Checkpointing
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1\. 检查点
- en: Of course, one wants to eventually transfer all the transactions that are appended
    in the WAL file back into the original database. Moving the WAL file transactions
    back into the database is called a "*checkpoint*".
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，最终希望将附加在WAL文件中的所有事务转移到原始数据库中。将WAL文件事务转移到数据库中称为"*检查点*"。
- en: 'Another way to think about the difference between rollback and write-ahead
    log is that in the rollback-journal approach, there are two primitive operations,
    reading and writing, whereas with a write-ahead log there are now three primitive
    operations: reading, writing, and checkpointing.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种思考回滚和预写日志之间差异的方式是，在回滚日志方法中，有两种原始操作，读取和写入，而使用预写日志则有三种原始操作：读取、写入和**检查点**。
- en: By default, SQLite does a checkpoint automatically when the WAL file reaches
    a threshold size of 1000 pages. (The [SQLITE_DEFAULT_WAL_AUTOCHECKPOINT](compile.html#default_wal_autocheckpoint)
    compile-time option can be used to specify a different default.) Applications
    using WAL do not have to do anything in order to for these checkpoints to occur.
    But if they want to, applications can adjust the automatic checkpoint threshold.
    Or they can turn off the automatic checkpoints and run checkpoints during idle
    moments or in a separate thread or process.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，SQLite在WAL文件达到1000页的阈值大小时会自动执行检查点操作。（[SQLITE_DEFAULT_WAL_AUTOCHECKPOINT](compile.html#default_wal_autocheckpoint)编译时选项可用于指定不同的默认值。）使用WAL的应用程序无需采取任何措施即可执行这些检查点。但如果它们希望，应用程序可以调整自动检查点的阈值。或者它们可以关闭自动检查点，并在空闲时段或在单独的线程或进程中运行检查点。
- en: 2.2\. Concurrency
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2\. 并发性
- en: When a read operation begins on a WAL-mode database, it first remembers the
    location of the last valid commit record in the WAL. Call this point the "end
    mark". Because the WAL can be growing and adding new commit records while various
    readers connect to the database, each reader can potentially have its own end
    mark. But for any particular reader, the end mark is unchanged for the duration
    of the transaction, thus ensuring that a single read transaction only sees the
    database content as it existed at a single point in time.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当在WAL模式数据库上开始读取操作时，首先记住WAL中最后一个有效提交记录的位置。将此点称为“结束标记”。因为WAL可以在各个读者连接到数据库时继续增长并添加新的提交记录，所以每个读者可能会有自己的结束标记。但对于任何特定的读者，在事务期间结束标记不会改变，因此确保单个读取事务只能看到数据库在某个特定时间点存在的内容。
- en: When a reader needs a page of content, it first checks the WAL to see if that
    page appears there, and if so it pulls in the last copy of the page that occurs
    in the WAL prior to the reader's end mark. If no copy of the page exists in the
    WAL prior to the reader's end mark, then the page is read from the original database
    file. Readers can exist in separate processes, so to avoid forcing every reader
    to scan the entire WAL looking for pages (the WAL file can grow to multiple megabytes,
    depending on how often checkpoints are run), a data structure called the "wal-index"
    is maintained in shared memory which helps readers locate pages in the WAL quickly
    and with a minimum of I/O. The wal-index greatly improves the performance of readers,
    but the use of shared memory means that all readers must exist on the same machine.
    This is why the write-ahead log implementation will not work on a network filesystem.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当读取者需要页面内容时，首先检查WAL，查看页面是否出现在其中，如果是，则拉取读取者结束标记之前在WAL中出现的页面的最后一个副本。如果在读取者结束标记之前的WAL中不存在页面的副本，则从原始数据库文件中读取页面。由于读取者可以存在于单独的进程中，为了避免强制每个读取者扫描整个WAL以寻找页面（WAL文件的大小可能会增长到多兆字节，这取决于检查点运行的频率），维护了一个称为“wal-index”的数据结构在共享内存中，帮助读取者快速定位WAL中的页面，并尽量减少I/O操作。wal-index大大提高了读取者的性能，但由于使用了共享内存，这意味着所有读取者必须存在于同一台机器上。这就是为什么预写式日志实现在网络文件系统上无法工作的原因。
- en: Writers merely append new content to the end of the WAL file. Because writers
    do nothing that would interfere with the actions of readers, writers and readers
    can run at the same time. However, since there is only one WAL file, there can
    only be one writer at a time.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 写入者只需将新内容追加到WAL文件的末尾。因为写入者不会执行任何会干扰读取者操作的动作，所以写入者和读取者可以同时运行。但由于只有一个WAL文件，因此一次只能有一个写入者。
- en: A checkpoint operation takes content from the WAL file and transfers it back
    into the original database file. A checkpoint can run concurrently with readers,
    however the checkpoint must stop when it reaches a page in the WAL that is past
    the end mark of any current reader. The checkpoint has to stop at that point because
    otherwise it might overwrite part of the database file that the reader is actively
    using. The checkpoint remembers (in the wal-index) how far it got and will resume
    transferring content from the WAL to the database from where it left off on the
    next invocation.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 检查点操作将WAL文件中的内容传输回原始数据库文件。检查点可以与读取者并发运行，但当检查点达到超过任何当前读取者结束标记的WAL页面时，必须停止检查点。检查点必须在那一点停止，因为否则它可能会覆盖读取者正在活跃使用的数据库文件的部分。检查点在wal-index中记住它的进展，并将在下一次调用时从离开的地方继续将WAL中的内容传输到数据库中。
- en: Thus a long-running read transaction can prevent a checkpointer from making
    progress. But presumably every read transaction will eventually end and the checkpointer
    will be able to continue.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个长时间运行的读取事务可能会阻止检查点进展。但可以假设每个读取事务最终都会结束，检查点就可以继续进行。
- en: Whenever a write operation occurs, the writer checks how much progress the checkpointer
    has made, and if the entire WAL has been transferred into the database and synced
    and if no readers are making use of the WAL, then the writer will rewind the WAL
    back to the beginning and start putting new transactions at the beginning of the
    WAL. This mechanism prevents a WAL file from growing without bound.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每当发生写操作时，写入器会检查检查点的进度，如果整个WAL已转移至数据库并已同步，并且没有读取器在使用WAL，则写入器将倒回WAL到开头，并开始将新事务放在WAL的开头。这种机制防止WAL文件无限增长。
- en: 2.3\. Performance Considerations
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3\. 性能考虑
- en: Write transactions are very fast since they only involve writing the content
    once (versus twice for rollback-journal transactions) and because the writes are
    all sequential. Further, syncing the content to the disk is not required, as long
    as the application is willing to sacrifice durability following a power loss or
    hard reboot. (Writers sync the WAL on every transaction commit if [PRAGMA synchronous](pragma.html#pragma_synchronous)
    is set to FULL but omit this sync if [PRAGMA synchronous](pragma.html#pragma_synchronous)
    is set to NORMAL.)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 写入事务非常快，因为它们只涉及写入内容一次（与回滚日志事务相比需要写入两次），并且写入是顺序的。此外，只要应用程序愿意在断电或硬重启后牺牲耐久性，就不需要将内容同步到磁盘。（如果[PRAGMA
    synchronous](pragma.html#pragma_synchronous)设置为FULL，则写入器在每个事务提交时同步WAL，但如果设置为NORMAL，则省略此同步。）
- en: On the other hand, read performance deteriorates as the WAL file grows in size
    since each reader must check the WAL file for the content and the time needed
    to check the WAL file is proportional to the size of the WAL file. The wal-index
    helps find content in the WAL file much faster, but performance still falls off
    with increasing WAL file size. Hence, to maintain good read performance it is
    important to keep the WAL file size down by running checkpoints at regular intervals.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，随着WAL文件的增长，读取性能会下降，因为每个读取器必须检查WAL文件的内容，检查所需的时间与WAL文件的大小成正比。wal-index有助于更快地查找WAL文件中的内容，但随着WAL文件大小的增加，性能仍会下降。因此，为了保持良好的读取性能，通过定期运行检查点来控制WAL文件的大小至关重要。
- en: Checkpointing does require sync operations in order to avoid the possibility
    of database corruption following a power loss or hard reboot. The WAL must be
    synced to persistent storage prior to moving content from the WAL into the database
    and the database file must by synced prior to resetting the WAL. Checkpoint also
    requires more seeking. The checkpointer makes an effort to do as many sequential
    page writes to the database as it can (the pages are transferred from WAL to database
    in ascending order) but even then there will typically be many seek operations
    interspersed among the page writes. These factors combine to make checkpoints
    slower than write transactions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Checkpointing 在避免由于断电或硬重启而导致数据库损坏的可能性时需要进行同步操作。在将 WAL 内容移动到数据库之前，必须将 WAL 同步到持久存储，并且在重置
    WAL 之前必须将数据库文件同步。Checkpoint 还需要更多的寻址操作。Checkpointer 会尽可能多地将数据库写为顺序页面（页面按升序从 WAL
    转移到数据库），但即使如此，页面写入中通常会有许多寻址操作穿插其中。这些因素结合起来使得 checkpoints 比写入事务慢。
- en: The default strategy is to allow successive write transactions to grow the WAL
    until the WAL becomes about 1000 pages in size, then to run a checkpoint operation
    for each subsequent COMMIT until the WAL is reset to be smaller than 1000 pages.
    By default, the checkpoint will be run automatically by the same thread that does
    the COMMIT that pushes the WAL over its size limit. This has the effect of causing
    most COMMIT operations to be very fast but an occasional COMMIT (those that trigger
    a checkpoint) to be much slower. If that effect is undesirable, then the application
    can disable automatic checkpointing and run the periodic checkpoints in a separate
    thread, or separate process. (Links to commands and interfaces to accomplish this
    are [shown below](#how_to_checkpoint).)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 默认策略是允许连续的写入事务增加 WAL 的大小，直到 WAL 的大小达到大约 1000 页，然后为每个后续的 COMMIT 运行一次 checkpoint
    操作，直到将 WAL 重置为小于 1000 页为止。默认情况下，checkpoint 将由执行将 WAL 推到其大小限制以上的 COMMIT 的同一线程自动运行。这使得大多数
    COMMIT 操作非常快，但偶尔会有较慢的 COMMIT（触发 checkpoint 的那些）。如果这种效果不理想，则应用程序可以禁用自动 checkpoint
    并在单独的线程或进程中运行定期 checkpoints。 （可以查看 [下面](#how_to_checkpoint) 显示的命令和接口来实现这一点。）
- en: Note that with [PRAGMA synchronous](pragma.html#pragma_synchronous) set to NORMAL,
    the checkpoint is the only operation to issue an I/O barrier or sync operation
    (fsync() on unix or FlushFileBuffers() on windows). If an application therefore
    runs checkpoint in a separate thread or process, the main thread or process that
    is doing database queries and updates will never block on a sync operation. This
    helps to prevent "latch-up" in applications running on a busy disk drive. The
    downside to this configuration is that transactions are no longer durable and
    might rollback following a power failure or hard reset.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当将[PRAGMA synchronous](pragma.html#pragma_synchronous)设置为NORMAL时，checkpoint是唯一会发出I/O屏障或同步操作（unix上的fsync()或windows上的FlushFileBuffers()）。因此，如果应用程序在单独的线程或进程中运行checkpoint，执行数据库查询和更新的主线程或进程将永远不会因为同步操作而阻塞。这有助于防止在忙碌的磁盘驱动器上运行的应用程序出现"latch-up"。这种配置的缺点是事务不再是持久的，可能会在断电或硬重置后回滚。
- en: Notice too that there is a tradeoff between average read performance and average
    write performance. To maximize the read performance, one wants to keep the WAL
    as small as possible and hence run checkpoints frequently, perhaps as often as
    every COMMIT. To maximize write performance, one wants to amortize the cost of
    each checkpoint over as many writes as possible, meaning that one wants to run
    checkpoints infrequently and let the WAL grow as large as possible before each
    checkpoint. The decision of how often to run checkpoints may therefore vary from
    one application to another depending on the relative read and write performance
    requirements of the application. The default strategy is to run a checkpoint once
    the WAL reaches 1000 pages and this strategy seems to work well in test applications
    on workstations, but other strategies might work better on different platforms
    or for different workloads.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 同样要注意的是，平均读性能和平均写性能之间存在权衡。为了最大化读性能，应该尽可能保持WAL尽可能小，并因此频繁运行checkpoint，甚至可能在每个COMMIT后运行一次。为了最大化写性能，应该将每次checkpoint的成本分摊到尽可能多的写操作上，这意味着应该不经常运行checkpoint，并允许WAL在每次checkpoint之前尽可能增长。因此，决定何时运行checkpoint的频率可能因应用程序的相对读写性能需求而异。默认策略是一旦WAL达到1000页就运行一次checkpoint，在工作站上的测试应用程序中，这种策略似乎效果很好，但在不同平台或不同工作负载下可能有更好的策略。
- en: 3\. Activating And Configuring WAL Mode
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3\. 激活和配置WAL模式
- en: 'An SQLite database connection defaults to [journal_mode=DELETE](pragma.html#pragma_journal_mode).
    To convert to WAL mode, use the following pragma:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite数据库连接默认为[journal_mode=DELETE](pragma.html#pragma_journal_mode)。要转换为WAL模式，请使用以下pragma：
- en: '[PRE0]'
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The journal_mode pragma returns a string which is the new journal mode. On success,
    the pragma will return the string "`wal`". If the conversion to WAL could not
    be completed (for example, if the [VFS](vfs.html) does not support the necessary
    shared-memory primitives) then the journaling mode will be unchanged and the string
    returned from the primitive will be the prior journaling mode (for example "`delete`").
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: pragma `journal_mode` 返回一个字符串，表示新的日志模式。成功时，该 pragma 将返回字符串 "`wal`"。如果无法完成转换为
    WAL（例如，如果 [VFS](vfs.html) 不支持必要的共享内存原语），则日志模式将保持不变，并且从原始原语返回的字符串将是先前的日志模式（例如 "`delete`"）。
- en: 3.1\. Automatic Checkpoint
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1\. 自动检查点
- en: By default, SQLite will automatically checkpoint whenever a [COMMIT](lang_transaction.html)
    occurs that causes the WAL file to be 1000 pages or more in size, or when the
    last database connection on a database file closes. The default configuration
    is intended to work well for most applications. But programs that want more control
    can force a checkpoint using the [wal_checkpoint pragma](pragma.html#pragma_wal_checkpoint)
    or by calling the [sqlite3_wal_checkpoint()](c3ref/wal_checkpoint.html) C interface.
    The automatic checkpoint threshold can be changed or automatic checkpointing can
    be completely disabled using the [wal_autocheckpoint pragma](pragma.html#pragma_wal_autocheckpoint)
    or by calling the [sqlite3_wal_autocheckpoint()](c3ref/wal_autocheckpoint.html)
    C interface. A program can also use [sqlite3_wal_hook()](c3ref/wal_hook.html)
    to register a callback to be invoked whenever any transaction commits to the WAL.
    This callback can then invoke [sqlite3_wal_checkpoint()](c3ref/wal_checkpoint.html)
    or [sqlite3_wal_checkpoint_v2()](c3ref/wal_checkpoint_v2.html) based on whatever
    criteria it thinks is appropriate. (The automatic checkpoint mechanism is implemented
    as a simple wrapper around [sqlite3_wal_hook()](c3ref/wal_hook.html).)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，SQLite 将在 WAL 文件大小达到 1000 页或更大时，或者当数据库文件上的最后一个连接关闭时，自动进行检查点。默认配置旨在适用于大多数应用程序。但是，希望获得更多控制的程序可以使用
    [wal_checkpoint pragma](pragma.html#pragma_wal_checkpoint) 强制进行检查点，或者通过调用 [sqlite3_wal_checkpoint()](c3ref/wal_checkpoint.html)
    C 接口。可以通过使用 [wal_autocheckpoint pragma](pragma.html#pragma_wal_autocheckpoint)
    或者调用 [sqlite3_wal_autocheckpoint()](c3ref/wal_autocheckpoint.html) C 接口来更改自动检查点阈值或完全禁用自动检查点。程序还可以使用
    [sqlite3_wal_hook()](c3ref/wal_hook.html) 注册回调函数，在每次事务提交到 WAL 时调用回调函数。然后，此回调函数可以根据其认为合适的任何标准调用
    [sqlite3_wal_checkpoint()](c3ref/wal_checkpoint.html) 或 [sqlite3_wal_checkpoint_v2()](c3ref/wal_checkpoint_v2.html)。（自动检查点机制实现为围绕
    [sqlite3_wal_hook()](c3ref/wal_hook.html) 的简单包装。）
- en: 3.2\. Application-Initiated Checkpoints
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2\. 应用程序启动的检查点
- en: 'An application can initiate a checkpoint using any writable database connection
    on the database simply by invoking [sqlite3_wal_checkpoint()](c3ref/wal_checkpoint.html)
    or [sqlite3_wal_checkpoint_v2()](c3ref/wal_checkpoint_v2.html). There are three
    subtypes of checkpoints that vary in their aggressiveness: PASSIVE, FULL, and
    RESTART. The default checkpoint style is PASSIVE, which does as much work as it
    can without interfering with other database connections, and which might not run
    to completion if there are concurrent readers or writers. All checkpoints initiated
    by [sqlite3_wal_checkpoint()](c3ref/wal_checkpoint.html) and by the automatic
    checkpoint mechanism are PASSIVE. FULL and RESTART checkpoints try harder to run
    the checkpoint to completion and can only be initiated by a call to [sqlite3_wal_checkpoint_v2()](c3ref/wal_checkpoint_v2.html).
    See the [sqlite3_wal_checkpoint_v2()](c3ref/wal_checkpoint_v2.html) documentation
    for additional information on FULL and RESET checkpoints.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以通过在数据库上任何可写的数据库连接上调用[sqlite3_wal_checkpoint()](c3ref/wal_checkpoint.html)或[sqlite3_wal_checkpoint_v2()](c3ref/wal_checkpoint_v2.html)来启动检查点。有三种检查点子类型，它们在执行时的严格程度不同：PASSIVE（被动）、FULL（完全）和RESTART（重启）。默认检查点样式是PASSIVE，它尽可能多地工作而不干扰其他数据库连接，并且如果有并发的读取或写入可能不会完全执行。所有由[sqlite3_wal_checkpoint()](c3ref/wal_checkpoint.html)和自动检查点机制启动的检查点都是PASSIVE。FULL和RESTART检查点会更努力地执行检查点以完成，只能通过调用[sqlite3_wal_checkpoint_v2()](c3ref/wal_checkpoint_v2.html)来启动。有关FULL和RESET检查点的更多信息，请参阅[sqlite3_wal_checkpoint_v2()](c3ref/wal_checkpoint_v2.html)文档。
- en: 3.3\. Persistence of WAL mode
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3\. WAL模式的持久性
- en: Unlike the other journaling modes, [PRAGMA journal_mode=WAL](pragma.html#pragma_journal_mode)
    is persistent. If a process sets WAL mode, then closes and reopens the database,
    the database will come back in WAL mode. In contrast, if a process sets (for example)
    PRAGMA journal_mode=TRUNCATE and then closes and reopens the database will come
    back up in the default rollback mode of DELETE rather than the previous TRUNCATE
    setting.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他日志记录模式不同，[PRAGMA journal_mode=WAL](pragma.html#pragma_journal_mode)是持久的。如果一个进程设置了WAL模式，然后关闭并重新打开数据库，数据库将以WAL模式重新打开。相比之下，如果一个进程设置（例如）PRAGMA
    journal_mode=TRUNCATE，然后关闭并重新打开数据库，数据库将以默认的回滚模式DELETE而不是之前的TRUNCATE设置重新打开。
- en: The persistence of WAL mode means that applications can be converted to using
    SQLite in WAL mode without making any changes to the application itself. One has
    merely to run "`PRAGMA journal_mode=WAL;`" on the database file(s) using the [command-line
    shell](cli.html) or other utility, then restart the application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: WAL模式的持久性意味着应用程序可以将SQLite转换为使用WAL模式而不必对应用程序本身进行任何更改。只需使用[命令行 shell](cli.html)或其他实用工具在数据库文件上运行"`PRAGMA
    journal_mode=WAL;`"，然后重新启动应用程序。
- en: The WAL journal mode will be set on all connections to the same database file
    if it is set on any one connection.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在任何一个连接上设置了WAL模式，则将在同一数据库文件的所有连接上设置WAL日志记录模式。
- en: 4\. The WAL File
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4\. WAL文件
- en: While a [database connection](c3ref/sqlite3.html) is open on a WAL-mode database,
    SQLite maintains an extra journal file called a "Write Ahead Log" or "WAL File".
    The name of this file on disk is usually the name of the database file with an
    extra "`-wal`" suffix, though different naming rules may apply if SQLite is compiled
    with [SQLITE_ENABLE_8_3_NAMES](compile.html#enable_8_3_names).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 WAL 模式下的数据库上有一个 [数据库连接](c3ref/sqlite3.html) 打开时，SQLite 会维护一个额外的日志文件，称为 "Write
    Ahead Log" 或 "WAL 文件"。这个文件在磁盘上的名称通常是数据库文件名加上额外的 "`-wal`" 后缀，尽管如果 SQLite 使用了 [SQLITE_ENABLE_8_3_NAMES](compile.html#enable_8_3_names)，可能会适用不同的命名规则。
- en: The WAL file exists for as long as any [database connection](c3ref/sqlite3.html)
    has the database open. Usually, the WAL file is deleted automatically when the
    last connection to the database closes. However, if the last process to have the
    database open exits without cleanly shutting down the database connection, or
    if the [SQLITE_FCNTL_PERSIST_WAL](c3ref/c_fcntl_begin_atomic_write.html#sqlitefcntlpersistwal)
    [file control](c3ref/file_control.html) is used, then the WAL file might be retained
    on disk after all connections to the database have been closed. The WAL file is
    part of the persistent state of the database and should be kept with the database
    if the database is copied or moved. If a database file is separated from its WAL
    file, then transactions that were previously committed to the database might be
    lost, or the database file might become corrupted. The only safe way to remove
    a WAL file is to open the database file using one of the [sqlite3_open()](c3ref/open.html)
    interfaces then immediately close the database using [sqlite3_close()](c3ref/close.html).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: WAL 文件存在于任何 [数据库连接](c3ref/sqlite3.html) 打开时。通常情况下，当最后一个连接到数据库的进程关闭时，WAL 文件会被自动删除。然而，如果最后一个拥有数据库连接的进程在没有干净关闭数据库连接的情况下退出，或者使用了
    [SQLITE_FCNTL_PERSIST_WAL](c3ref/c_fcntl_begin_atomic_write.html#sqlitefcntlpersistwal)
    [文件控制](c3ref/file_control.html)，那么 WAL 文件可能会在所有数据库连接关闭后仍然保留在磁盘上。WAL 文件是数据库的持久状态的一部分，如果数据库被复制或移动，应该与数据库一起保留。如果数据库文件与其
    WAL 文件分离，那么之前提交到数据库的事务可能会丢失，或者数据库文件可能会损坏。删除 WAL 文件的唯一安全方式是使用 [sqlite3_open()](c3ref/open.html)
    接口打开数据库文件，然后立即使用 [sqlite3_close()](c3ref/close.html) 关闭数据库。
- en: The [WAL file format](fileformat2.html#walformat) is precisely defined and is
    cross-platform.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[WAL 文件格式](fileformat2.html#walformat) 被精确定义，并且是跨平台的。'
- en: 5\. Read-Only Databases
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5\. 只读数据库
- en: Older versions of SQLite could not read a WAL-mode database that was read-only.
    In other words, write access was required in order to read a WAL-mode database.
    This constraint was relaxed beginning with SQLite [version 3.22.0](releaselog/3_22_0.html)
    (2018-01-22).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 旧版本的 SQLite 无法读取只读的 WAL 模式数据库。换句话说，要读取 WAL 模式数据库需要写入访问权限。从 SQLite [版本 3.22.0](releaselog/3_22_0.html)
    (2018-01-22) 开始，这个限制得到了放宽。
- en: 'On newer versions of SQLite, a WAL-mode database on read-only media, or a WAL-mode
    database that lacks write permission, can still be read as long as one or more
    of the following conditions are met:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在较新版本的SQLite上，WAL模式数据库在只读介质上，或者缺乏写权限的情况下，仍然可以被读取，只要满足以下一个或多个条件：
- en: The `-shm` and `-wal` files already exists and are readable
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-shm`和`-wal`文件已经存在且可读。'
- en: There is write permission on the directory containing the database so that the
    `-shm` and `-wal` files can be created.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库所在目录具有写权限，以便创建`-shm`和`-wal`文件。
- en: The database connection is opened using the [immutable query parameter](uri.html#uriimmutable).
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库连接是使用[不可变查询参数](uri.html#uriimmutable)打开的。
- en: Even though it is possible to open a read-only WAL-mode database, it is good
    practice to converted to [PRAGMA journal_mode=DELETE](pragma.html#pragma_journal_mode)
    prior to burning an SQLite database image onto read-only media.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以打开只读WAL模式数据库，但最好在将SQLite数据库映像刻录到只读介质之前将其转换为[PRAGMA journal_mode=DELETE](pragma.html#pragma_journal_mode)的良好做法。
- en: 6\. Avoiding Excessively Large WAL Files
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6\. 避免过大的WAL文件
- en: In normal cases, new content is appended to the WAL file until the WAL file
    accumulates about 1000 pages (and is thus about 4MB in size) at which point a
    checkpoint is automatically run and the WAL file is recycled. The checkpoint does
    not normally truncate the WAL file (unless the [journal_size_limit pragma](pragma.html#pragma_journal_size_limit)
    is set). Instead, it merely causes SQLite to start overwriting the WAL file from
    the beginning. This is done because it is normally faster to overwrite an existing
    file than to append. When the last connection to a database closes, that connection
    does one last checkpoint and then deletes the WAL and its associated shared-memory
    file, to clean up the disk.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常情况下，新内容将被追加到WAL文件，直到WAL文件累积约1000页（大约4MB大小），此时会自动运行一个检查点并回收WAL文件。检查点通常不会截断WAL文件（除非设置了[journal_size_limit
    pragma](pragma.html#pragma_journal_size_limit)）。相反，它仅使SQLite从头开始覆写WAL文件。这样做是因为覆盖现有文件通常比追加更快。当最后一个数据库连接关闭时，该连接会执行最后一个检查点，然后删除WAL文件及其关联的共享内存文件，以清理磁盘。
- en: So in the vast majority of cases, applications need not worry about the WAL
    file at all. SQLite will automatically take care of it. But it is possible to
    get SQLite into a state where the WAL file will grow without bound, causing excess
    disk space usage and slow queries speeds. The following bullets enumerate some
    of the ways that this can happen and how to avoid them.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在绝大多数情况下，应用程序无需担心WAL文件。SQLite会自动处理它。但是可能会导致SQLite处于一种状态，其中WAL文件会无限增长，导致磁盘空间使用过多和查询速度变慢。以下列出了一些可能发生这种情况的方式以及如何避免它们。
- en: '**Disabling the automatic checkpoint mechanism.** In its default configuration,
    SQLite will checkpoint the WAL file at the conclusion of any transaction when
    the WAL file is more than 1000 pages long. However, compile-time and run-time
    options exist that can disable or defer this automatic checkpoint. If an application
    disables the automatic checkpoint, then there is nothing to prevent the WAL file
    from growing excessively.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**禁用自动检查点机制。** 在其默认配置中，SQLite将在WAL文件超过1000页长时，在任何事务结束时检查WAL文件。但是，存在可以禁用或延迟此自动检查点的编译时和运行时选项。如果应用程序禁用了自动检查点，则没有任何东西可以防止WAL文件过度增长。'
- en: '**Checkpoint starvation.** A checkpoint is only able to run to completion,
    and reset the WAL file, if there are no other database connections using the WAL
    file. If another connection has a read transaction open, then the checkpoint cannot
    reset the WAL file because doing so might delete content out from under the reader.
    The checkpoint will do as much work as it can without upsetting the reader, but
    it cannot run to completion. The checkpoint will start up again where it left
    off after the next write transaction. This repeats until some checkpoint is able
    to complete.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查点饥饿。** 只有当没有其他数据库连接使用WAL文件时，检查点才能完成运行并重置WAL文件。如果另一个连接有一个打开的读取事务，则检查点无法重置WAL文件，因为这样做可能会在读取者下方删除内容。检查点将尽可能多地工作，而不会打扰读取者，但无法完成运行。在下一个写事务后，检查点将从上次中断的地方重新启动。这种情况重复发生，直到某个检查点能够完成。'
- en: However, if a database has many concurrent overlapping readers and there is
    always at least one active reader, then no checkpoints will be able to complete
    and hence the WAL file will grow without bound.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但是，如果数据库有许多并发的重叠读取者，并且始终至少有一个活动的读取者，则不会能够完成任何检查点，因此WAL文件将无限增长。
- en: 'This scenario can be avoided by ensuring that there are "reader gaps": times
    when no processes are reading from the database and that checkpoints are attempted
    during those times. In applications with many concurrent readers, one might also
    consider running manual checkpoints with the [SQLITE_CHECKPOINT_RESTART](c3ref/c_checkpoint_full.html)
    or [SQLITE_CHECKPOINT_TRUNCATE](c3ref/c_checkpoint_full.html) option which will
    ensure that the checkpoint runs to completion before returning. The disadvantage
    of using [SQLITE_CHECKPOINT_RESTART](c3ref/c_checkpoint_full.html) and [SQLITE_CHECKPOINT_TRUNCATE](c3ref/c_checkpoint_full.html)
    is that readers might block while the checkpoint is running.'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以通过确保存在“读取者间隙”来避免这种情况：即没有进程从数据库中读取并且在这些时间内尝试检查点。在具有许多并发读取者的应用程序中，也可以考虑使用[SQLITE_CHECKPOINT_RESTART](c3ref/c_checkpoint_full.html)或[SQLITE_CHECKPOINT_TRUNCATE](c3ref/c_checkpoint_full.html)选项手动运行检查点，这将确保检查点在返回之前完成。使用[SQLITE_CHECKPOINT_RESTART](c3ref/c_checkpoint_full.html)和[SQLITE_CHECKPOINT_TRUNCATE](c3ref/c_checkpoint_full.html)的缺点是，在检查点运行时，读取者可能会被阻塞。
- en: '**Very large write transactions.** A checkpoint can only complete when no other
    transactions are running, which means the WAL file cannot be reset in the middle
    of a write transaction. So a large change to a large database might result in
    a large WAL file. The WAL file will be checkpointed once the write transaction
    completes (assuming there are no other readers blocking it) but in the meantime,
    the file can grow very big.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非常大的写事务。** 只有当没有其他事务运行时，检查点才能完成，这意味着无法在写事务中间重置WAL文件。因此，对大型数据库进行大量更改可能导致WAL文件变得非常大。一旦写事务完成（假设没有其他读者阻塞），WAL文件将被检查点处理，但在此期间，文件可能会变得非常大。'
- en: As of SQLite [version 3.11.0](releaselog/3_11_0.html) (2016-02-15), the WAL
    file for a single transaction should be proportional in size to the transaction
    itself. Pages that are changed by the transaction should only be written into
    the WAL file once. However, with older versions of SQLite, the same page might
    be written into the WAL file multiple times if the transaction grows larger than
    the page cache.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 截至 SQLite [版本 3.11.0](releaselog/3_11_0.html)（2016-02-15），单个事务的WAL文件大小应与事务本身成比例。事务更改的页面只应写入WAL文件一次。但是，对于旧版SQLite，如果事务增长超过页面缓存，同一页面可能会多次写入WAL文件。
- en: 7\. Implementation Of Shared-Memory For The WAL-Index
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7\. 实现WAL-Index的共享内存
- en: The [wal-index](walformat.html#shm) is implemented using an ordinary file that
    is mmapped for robustness. Early (pre-release) implementations of WAL mode stored
    the wal-index in volatile shared-memory, such as files created in /dev/shm on
    Linux or /tmp on other unix systems. The problem with that approach is that processes
    with a different root directory (changed via [chroot](http://en.wikipedia.org/wiki/Chroot))
    will see different files and hence use different shared memory areas, leading
    to database corruption. Other methods for creating nameless shared memory blocks
    are not portable across the various flavors of unix. And we could not find any
    method to create nameless shared memory blocks on windows. The only way we have
    found to guarantee that all processes accessing the same database file use the
    same shared memory is to create the shared memory by mmapping a file in the same
    directory as the database itself.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[wal-index](walformat.html#shm) 是通过普通文件实现的，用于提高鲁棒性。早期（预发布）的WAL模式实现将wal-index存储在易失性共享内存中，例如Linux上创建在/dev/shm或其他Unix系统上的/tmp文件。这种方法的问题在于，具有不同根目录的进程（通过[chroot](http://en.wikipedia.org/wiki/Chroot)更改）将看到不同的文件，因此使用不同的共享内存区域，导致数据库损坏。在各种Unix系统中，创建无名称的共享内存块的其他方法并不具有可移植性。我们无法找到任何在Windows上创建无名称共享内存块的方法。确保所有访问同一数据库文件的进程使用相同共享内存的唯一方法是通过在与数据库本身相同的目录中mmapping文件来创建共享内存。'
- en: Using an ordinary disk file to provide shared memory has the disadvantage that
    it might actually do unnecessary disk I/O by writing the shared memory to disk.
    However, the developers do not think this is a major concern since the wal-index
    rarely exceeds 32 KiB in size and is never synced. Furthermore, the wal-index
    backing file is deleted when the last database connection disconnects, which often
    prevents any real disk I/O from ever happening.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用普通磁盘文件作为共享内存的缺点在于，可能会通过将共享内存写入磁盘而执行不必要的磁盘 I/O 操作。然而，开发人员认为这并不是一个主要问题，因为 wal-index
    很少超过 32 KiB 的大小，并且从不同步。此外，当最后一个数据库连接断开时，wal-index 的后备文件会被删除，这通常可以避免任何真正的磁盘 I/O
    操作发生。
- en: Specialized applications for which the default implementation of shared memory
    is unacceptable can devise alternative methods via a custom [VFS](vfs.html). For
    example, if it is known that a particular database will only be accessed by threads
    within a single process, the wal-index can be implemented using heap memory instead
    of true shared memory.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 针对默认的共享内存实现不可接受的专用应用程序可以通过自定义的 [VFS](vfs.html) 设计替代方法。例如，如果已知特定数据库只会被单一进程内的线程访问，那么可以使用堆内存而不是真正的共享内存来实现
    wal-index。
- en: 8\. Use of WAL Without Shared-Memory
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8\. 在没有共享内存的情况下使用 WAL
- en: Beginning in SQLite [version 3.7.4](releaselog/3_7_4.html) (2010-12-07), WAL
    databases can be created, read, and written even if shared memory is unavailable
    as long as the [locking_mode](pragma.html#pragma_locking_mode) is set to EXCLUSIVE
    before the first attempted access. In other words, a process can interact with
    a WAL database without using shared memory if that process is guaranteed to be
    the only process accessing the database. This feature allows WAL databases to
    be created, read, and written by legacy [VFSes](vfs.html) that lack the "version
    2" shared-memory methods xShmMap, xShmLock, xShmBarrier, and xShmUnmap on the
    [sqlite3_io_methods](c3ref/io_methods.html) object.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从 SQLite [版本 3.7.4](releaselog/3_7_4.html)（2010-12-07）开始，即使共享内存不可用，也可以创建、读取和写入
    WAL 数据库，只要在第一次尝试访问之前将 [locking_mode](pragma.html#pragma_locking_mode) 设置为 EXCLUSIVE。换句话说，如果保证只有一个进程访问数据库，那么该进程可以与
    WAL 数据库交互而不使用共享内存。此功能允许旧版的 [VFSes](vfs.html) 可以创建、读取和写入 WAL 数据库，这些 VFSes 缺乏在 [sqlite3_io_methods](c3ref/io_methods.html)
    对象上的“版本 2”共享内存方法 xShmMap、xShmLock、xShmBarrier 和 xShmUnmap。
- en: If [EXCLUSIVE locking mode](pragma.html#pragma_locking_mode) is set prior to
    the first WAL-mode database access, then SQLite never attempts to call any of
    the shared-memory methods and hence no shared-memory wal-index is ever created.
    In that case, the database connection remains in EXCLUSIVE mode as long as the
    journal mode is WAL; attempts to change the locking mode using "`PRAGMA locking_mode=NORMAL;`"
    are no-ops. The only way to change out of EXCLUSIVE locking mode is to first change
    out of WAL journal mode.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在第一个 WAL 模式数据库访问之前设置了[EXCLUSIVE 锁定模式](pragma.html#pragma_locking_mode)，那么
    SQLite 永远不会尝试调用任何共享内存方法，因此永远不会创建共享内存的 WAL 索引。在这种情况下，只要日志模式为 WAL，数据库连接就保持在 EXCLUSIVE
    模式；尝试使用 "`PRAGMA locking_mode=NORMAL;`" 来更改锁定模式将不起作用。唯一更改出 EXCLUSIVE 锁定模式的方法是先退出
    WAL 日志模式。
- en: If NORMAL locking mode is in effect for the first WAL-mode database access,
    then the shared-memory wal-index is created. This means that the underlying VFS
    must support the "version 2" shared-memory. If the VFS does not support shared-memory
    methods, then the attempt to open a database that is already in WAL mode, or the
    attempt convert a database into WAL mode, will fail. As long as exactly one connection
    is using a shared-memory wal-index, the locking mode can be changed freely between
    NORMAL and EXCLUSIVE. It is only when the shared-memory wal-index is omitted,
    when the locking mode is EXCLUSIVE prior to the first WAL-mode database access,
    that the locking mode is stuck in EXCLUSIVE.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对第一个 WAL 模式数据库访问采用了 NORMAL 锁定模式，则会创建共享内存的 WAL 索引。这意味着底层 VFS 必须支持“版本 2”共享内存方法。如果
    VFS 不支持共享内存方法，则尝试打开已经处于 WAL 模式的数据库，或者尝试将数据库转换为 WAL 模式，将会失败。只要有一个连接在使用共享内存的 WAL
    索引，锁定模式可以在 NORMAL 和 EXCLUSIVE 之间自由切换。只有在省略共享内存的 WAL 索引时，也就是在第一个 WAL 模式数据库访问之前，锁定模式才会被固定在
    EXCLUSIVE。
- en: 9\. Sometimes Queries Return SQLITE_BUSY In WAL Mode
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9\. 有时在 WAL 模式下查询会返回 SQLITE_BUSY
- en: The [second advantage of WAL-mode](wal.html#advantages) is that writers do not
    block readers and readers to do not block writers. This is mostly true. But there
    are some obscure cases where a query against a WAL-mode database can return [SQLITE_BUSY](rescode.html#busy),
    so applications should be prepared for that happenstance.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[WAL 模式的第二个优势](wal.html#advantages)是写操作不会阻塞读操作，读操作也不会阻塞写操作。这在大多数情况下是正确的。但是在一些不太常见的情况下，针对
    WAL 模式数据库的查询可能会返回[SQLITE_BUSY](rescode.html#busy)，因此应用程序应该为此偶发事件做好准备。'
- en: 'Cases where a query against a WAL-mode database can return [SQLITE_BUSY](rescode.html#busy)
    include the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WAL 模式数据库中，可能会导致查询返回[SQLITE_BUSY](rescode.html#busy)的情况包括以下几种：
- en: If another database connection has the database mode open in [exclusive locking
    mode](pragma.html#pragma_locking_mode) then all queries against the database will
    return [SQLITE_BUSY](rescode.html#busy). Both Chrome and Firefox open their database
    files in exclusive locking mode, so attempts to read Chrome or Firefox databases
    while the applications are running will run into this problem, for example.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果另一个数据库连接以[独占锁定模式](pragma.html#pragma_locking_mode)打开数据库，则所有针对该数据库的查询都将返回[SQLITE_BUSY](rescode.html#busy)。Chrome
    和 Firefox 都以独占锁定模式打开它们的数据库文件，因此在这些应用程序运行时尝试读取 Chrome 或 Firefox 数据库将会遇到此问题。
- en: When the last connection to a particular database is closing, that connection
    will acquire an exclusive lock for a short time while it cleans up the WAL and
    shared-memory files. If a separate attempt is made to open and query the database
    while the first connection is still in the middle of its cleanup process, the
    second connection might get an [SQLITE_BUSY](rescode.html#busy) error.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当最后一个连接到特定数据库关闭时，该连接将在清理WAL和共享内存文件时短暂获取独占锁定。如果在第一个连接仍在清理过程中时尝试打开和查询数据库，则第二个连接可能会遇到[SQLITE_BUSY](rescode.html#busy)错误。
- en: If the last connection to a database crashed, then the first new connection
    to open the database will start a recovery process. An exclusive lock is held
    during recovery. So if a third database connection tries to jump in and query
    while the second connection is running recovery, the third connection will get
    an [SQLITE_BUSY](rescode.html#busy) error.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果最后一个数据库连接崩溃，则第一个打开数据库的新连接将启动恢复过程。在恢复期间会持有独占锁定。因此，如果第三个数据库连接在第二个连接正在运行恢复时尝试插入并查询，则第三个连接将会遇到[SQLITE_BUSY](rescode.html#busy)错误。
- en: 10\. Backwards Compatibility
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10\. 向后兼容性
- en: The database file format is unchanged for WAL mode. However, the WAL file and
    the [wal-index](walformat.html#shm) are new concepts and so older versions of
    SQLite will not know how to recover a crashed SQLite database that was operating
    in WAL mode when the crash occurred. To prevent older versions of SQLite (prior
    to version 3.7.0, 2010-07-22) from trying to recover a WAL-mode database (and
    making matters worse) the database file format version numbers (bytes 18 and 19
    in the [database header](fileformat2.html#database_header)) are increased from
    1 to 2 in WAL mode. Thus, if an older version of SQLite attempts to connect to
    an SQLite database that is operating in WAL mode, it will report an error along
    the lines of "file is encrypted or is not a database".
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: WAL 模式下数据库文件格式未更改。但是，WAL 文件和[wal-index](walformat.html#shm)是新概念，因此旧版本的 SQLite
    不会知道如何恢复在发生崩溃时正在 WAL 模式下运行的 SQLite 数据库。为防止旧版本的 SQLite （早于版本 3.7.0，2010-07-22）尝试恢复
    WAL 模式数据库（并使情况更糟），数据库文件格式版本号（在[数据库头部](fileformat2.html#database_header)的第 18 和
    19 字节）在 WAL 模式下从 1 增加到 2。因此，如果旧版本的 SQLite 尝试连接处于 WAL 模式的 SQLite 数据库，它将报告类似于“文件已加密或不是数据库”的错误。
- en: 'One can explicitly change out of WAL mode using a pragma such as this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用如下的 pragma 明确退出 WAL 模式：
- en: '[PRE1]'
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Deliberately changing out of WAL mode changes the database file format version
    numbers back to 1 so that older versions of SQLite can once again access the database
    file.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 退出 WAL 模式会将数据库文件格式版本号改回 1，这样旧版 SQLite 就能再次访问数据库文件。
