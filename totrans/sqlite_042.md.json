["```sql\nCREATE VIRTUAL TABLE enrondata1 USING fts3(content TEXT);     /* FTS3 table */\nCREATE TABLE enrondata2(content TEXT);                        /* Ordinary table */\n\n```", "```sql\nSELECT count(*) FROM enrondata1 WHERE content MATCH 'linux';  /* 0.03 seconds */\nSELECT count(*) FROM enrondata2 WHERE content LIKE '%linux%'; /* 22.5 seconds */\n\n```", "```sql\n*-- Create an FTS table named \"data\" with one column - \"content\":*\nCREATE VIRTUAL TABLE data USING fts3();\n\n*-- Create an FTS table named \"pages\" with three columns:*\nCREATE VIRTUAL TABLE pages USING fts4(title, keywords, body);\n\n*-- Create an FTS table named \"mail\" with two columns. Datatypes\n-- and column constraints are specified along with each column. These\n-- are completely ignored by FTS and SQLite.* \nCREATE VIRTUAL TABLE mail USING fts3(\n  subject VARCHAR(256) NOT NULL,\n  body TEXT CHECK(length(body)<10240)\n);\n\n```", "```sql\n*-- Create an FTS table named \"papers\" with two columns that uses*\n*-- the tokenizer \"porter\".*\nCREATE VIRTUAL TABLE papers USING fts3(author, document, tokenize=porter);\n\n*-- Create an FTS table with a single column - \"content\" - that uses*\n*-- the \"simple\" tokenizer.*\nCREATE VIRTUAL TABLE data USING fts4(tokenize=simple);\n\n*-- Create an FTS table with two columns that uses the \"icu\" tokenizer.*\n*-- The qualifier \"en_AU\" is passed to the tokenizer implementation*\nCREATE VIRTUAL TABLE names USING fts3(a, b, tokenize=icu en_AU);\n\n```", "```sql\n*-- Create, then immediately drop, an FTS4 table.*\nCREATE VIRTUAL TABLE data USING fts4();\nDROP TABLE data;\n\n```", "```sql\n*-- Create an FTS table*\nCREATE VIRTUAL TABLE pages USING fts4(title, body);\n\n*-- Insert a row with a specific docid value.*\nINSERT INTO pages(docid, title, body) VALUES(53, 'Home Page', 'SQLite is a software...');\n\n*-- Insert a row and allow FTS to assign a docid value using the same algorithm as*\n*-- SQLite uses for ordinary tables. In this case the new docid will be 54,*\n*-- one greater than the largest docid currently present in the table.*\nINSERT INTO pages(title, body) VALUES('Download', 'All SQLite source code...');\n\n*-- Change the title of the row just inserted.*\nUPDATE pages SET title = 'Download SQLite' WHERE rowid = 54;\n\n*-- Delete the entire table contents.*\nDELETE FROM pages;\n\n*-- The following is an error. It is not possible to assign non-NULL values to both*\n*-- the rowid and docid columns of an FTS table.*\nINSERT INTO pages(rowid, docid, title, body) VALUES(1, 2, 'A title', 'A document body');\n\n```", "```sql\n*-- Optimize the internal structure of FTS table \"docs\".*\nINSERT INTO docs(docs) VALUES('optimize');\n\n```", "```sql\n*-- The examples in this block assume the following FTS table:*\nCREATE VIRTUAL TABLE mail USING fts3(subject, body);\n\nSELECT * FROM mail WHERE rowid = 15;                *-- Fast. Rowid lookup.*\nSELECT * FROM mail WHERE body MATCH 'sqlite';       *-- Fast. Full-text query.*\nSELECT * FROM mail WHERE mail MATCH 'search';       *-- Fast. Full-text query.*\nSELECT * FROM mail WHERE rowid BETWEEN 15 AND 20;   *-- Fast. Rowid lookup.*\nSELECT * FROM mail WHERE subject = 'database';      *-- Slow. Linear scan.*\nSELECT * FROM mail WHERE subject MATCH 'database';  *-- Fast. Full-text query.*\n\n```", "```sql\n*-- Example schema*\nCREATE VIRTUAL TABLE mail USING fts3(subject, body);\n\n*-- Example table population*\nINSERT INTO mail(docid, subject, body) VALUES(1, 'software feedback', 'found it too slow');\nINSERT INTO mail(docid, subject, body) VALUES(2, 'software feedback', 'no feedback');\nINSERT INTO mail(docid, subject, body) VALUES(3, 'slow lunch order',  'was a software problem');\n\n*-- Example queries*\nSELECT * FROM mail WHERE subject MATCH 'software';    *-- Selects rows 1 and 2*\nSELECT * FROM mail WHERE body    MATCH 'feedback';    *-- Selects row 2*\nSELECT * FROM mail WHERE mail    MATCH 'software';    *-- Selects rows 1, 2 and 3*\nSELECT * FROM mail WHERE mail    MATCH 'slow';        *-- Selects rows 1 and 3*\n\n```", "```sql\n*-- Example schema*\nCREATE VIRTUAL TABLE docs USING fts4(content);\n\n*-- Example queries*\nSELECT * FROM docs WHERE docs MATCH 'sqlite';              *-- OK.*\nSELECT * FROM docs WHERE docs.docs MATCH 'sqlite';         *-- OK.*\nSELECT * FROM docs WHERE main.docs.docs MATCH 'sqlite';    *-- OK.*\nSELECT * FROM docs WHERE main.docs MATCH 'sqlite';         *-- Error.*\n\n```", "```sql\n-DSQLITE_ENABLE_FTS3\n-DSQLITE_ENABLE_FTS3_PARENTHESIS\n\n```", "```sql\nCPPFLAGS=\"-DSQLITE_ENABLE_FTS3 -DSQLITE_ENABLE_FTS3_PARENTHESIS\" ./configure <configure options>\n\n```", "```sql\n-DSQLITE_ENABLE_ICU\n\n```", "```sql\n*-- Virtual table declaration*\nCREATE VIRTUAL TABLE docs USING fts3(title, body);\n\n*-- Query for all documents containing the term \"linux\":*\nSELECT * FROM docs WHERE docs MATCH 'linux';\n\n*-- Query for all documents containing a term with the prefix \"lin\". This will match*\n*-- all documents that contain \"linux\", but also those that contain terms \"linear\",*\n*--\"linker\", \"linguistic\" and so on.*\nSELECT * FROM docs WHERE docs MATCH 'lin*';\n\n```", "```sql\n*-- Query the database for documents for which the term \"linux\" appears in*\n*-- the document title, and the term \"problems\" appears in either the title*\n*-- or body of the document.*\nSELECT * FROM docs WHERE docs MATCH 'title:linux problems';\n\n*-- Query the database for documents for which the term \"linux\" appears in*\n*-- the document title, and the term \"driver\" appears in the body of the document*\n*-- (\"driver\" may also appear in the title, but this alone will not satisfy the*\n*-- query criteria).*\nSELECT * FROM docs WHERE body MATCH 'title:linux driver';\n\n```", "```sql\n*-- All documents for which \"linux\" is the first token of at least one*\n*-- column.*\nSELECT * FROM docs WHERE docs MATCH '^linux';\n\n*-- All documents for which the first token in column \"title\" begins with \"lin\".*\nSELECT * FROM docs WHERE body MATCH 'title: ^lin*';\n\n```", "```sql\n*-- Query for all documents that contain the phrase \"linux applications\".*\nSELECT * FROM docs WHERE docs MATCH '\"linux applications\"';\n\n*-- Query for all documents that contain a phrase that matches \"lin* app*\". As well as*\n*-- \"linux applications\", this will match common phrases such as \"linoleum appliances\"*\n*-- or \"link apprentice\".*\nSELECT * FROM docs WHERE docs MATCH '\"lin* app*\"';\n\n```", "```sql\n*-- Virtual table declaration.*\nCREATE VIRTUAL TABLE docs USING fts4();\n\n*-- Virtual table data.*\nINSERT INTO docs VALUES('SQLite is an ACID compliant embedded relational database management system');\n\n*-- Search for a document that contains the terms \"sqlite\" and \"database\" with*\n*-- not more than 10 intervening terms. This matches the only document in*\n*-- table docs (since there are only six terms between \"SQLite\" and \"database\"*\n*-- in the document)*.\nSELECT * FROM docs WHERE docs MATCH 'sqlite NEAR database';\n\n*-- Search for a document that contains the terms \"sqlite\" and \"database\" with*\n*-- not more than 6 intervening terms. This also matches the only document in*\n*-- table docs. Note that the order in which the terms appear in the document*\n*-- does not have to be the same as the order in which they appear in the query.*\nSELECT * FROM docs WHERE docs MATCH 'database NEAR/6 sqlite';\n\n*-- Search for a document that contains the terms \"sqlite\" and \"database\" with*\n*-- not more than 5 intervening terms. This query matches no documents.*\nSELECT * FROM docs WHERE docs MATCH 'database NEAR/5 sqlite';\n\n*-- Search for a document that contains the phrase \"ACID compliant\" and the term*\n*-- \"database\" with not more than 2 terms separating the two. This matches the*\n*-- document stored in table docs.*\nSELECT * FROM docs WHERE docs MATCH 'database NEAR/2 \"ACID compliant\"';\n\n*-- Search for a document that contains the phrase \"ACID compliant\" and the term*\n*-- \"sqlite\" with not more than 2 terms separating the two. This also matches*\n*-- the only document stored in table docs.*\nSELECT * FROM docs WHERE docs MATCH '\"ACID compliant\" NEAR/2 sqlite';\n\n```", "```sql\n*-- The following query selects documents that contains an instance of the term* \n*-- \"sqlite\" separated by two or fewer terms from an instance of the term \"acid\",*\n*-- which is in turn separated by two or fewer terms from an instance of the term*\n*-- \"relational\".*\nSELECT * FROM docs WHERE docs MATCH 'sqlite NEAR/2 acid NEAR/2 relational';\n\n*-- This query matches no documents. There is an instance of the term \"sqlite\" with*\n*-- sufficient proximity to an instance of \"acid\" but it is not sufficiently close*\n*-- to an instance of the term \"relational\".*\nSELECT * FROM docs WHERE docs MATCH 'acid NEAR/2 sqlite NEAR/2 relational';\n\n```", "```sql\n*-- Virtual table declaration*\nCREATE VIRTUAL TABLE docs USING fts3();\n\n*-- Virtual table data*\nINSERT INTO docs(docid, content) VALUES(1, 'a database is a software system');\nINSERT INTO docs(docid, content) VALUES(2, 'sqlite is a software system');\nINSERT INTO docs(docid, content) VALUES(3, 'sqlite is a database');\n\n*-- Return the set of documents that contain the term \"sqlite\", and the*\n*-- term \"database\". This query will return the document with docid 3 only.*\nSELECT * FROM docs WHERE docs MATCH 'sqlite AND database';\n\n*-- Again, return the set of documents that contain both \"sqlite\" and*\n*-- \"database\". This time, use an implicit AND operator. Again, document*\n*-- 3 is the only document matched by this query.* \nSELECT * FROM docs WHERE docs MATCH 'database sqlite';\n\n*-- Query for the set of documents that contains either \"sqlite\" or \"database\".*\n*-- All three documents in the database are matched by this query.*\nSELECT * FROM docs WHERE docs MATCH 'sqlite OR database';\n\n*-- Query for all documents that contain the term \"database\", but do not contain*\n*-- the term \"sqlite\". Document 1 is the only document that matches this criteria.*\nSELECT * FROM docs WHERE docs MATCH 'database NOT sqlite';\n\n*-- The following query matches no documents. Because \"and\" is in lowercase letters,*\n*-- it is interpreted as a basic term query instead of an operator. Operators must*\n*-- be specified using capital letters. In practice, this query will match any documents*\n*-- that contain each of the three terms \"database\", \"and\" and \"sqlite\" at least once.*\n*-- No documents in the example data above match this criteria.*\nSELECT * FROM docs WHERE docs MATCH 'database and sqlite';\n\n```", "```sql\n*-- Return the docid values associated with all documents that contain the*\n*-- two terms \"sqlite\" and \"database\", and/or contain the term \"library\".*\nSELECT docid FROM docs WHERE docs MATCH 'sqlite AND database OR library';\n\n*-- This query is equivalent to the above.*\nSELECT docid FROM docs WHERE docs MATCH 'sqlite AND database'\n  UNION\nSELECT docid FROM docs WHERE docs MATCH 'library';\n\n*-- Query for the set of documents that contains the term \"linux\", and at least*\n*-- one of the phrases \"sqlite database\" and \"sqlite library\".*\nSELECT docid FROM docs WHERE docs MATCH '(\"sqlite database\" OR \"sqlite library\") AND linux';\n\n*-- This query is equivalent to the above.*\nSELECT docid FROM docs WHERE docs MATCH 'linux'\n  INTERSECT\nSELECT docid FROM (\n  SELECT docid FROM docs WHERE docs MATCH '\"sqlite library\"'\n    UNION\n  SELECT docid FROM docs WHERE docs MATCH '\"sqlite database\"'\n);\n\n```", "```sql\n*-- Search for the set of documents that contain the term \"sqlite\" but do*\n*-- not contain the term \"database\".*\nSELECT * FROM docs WHERE docs MATCH 'sqlite -database';\n\n```", "```sql\n*-- Search for documents that contain at least one of the terms \"database\"*\n*-- and \"sqlite\", and also contain the term \"library\". Because of the differences*\n*-- in operator precedences, this query would have a different interpretation using*\n*-- the enhanced query syntax.*\nSELECT * FROM docs WHERE docs MATCH 'sqlite OR database library';\n\n```", "```sql\nSELECT offsets(mail) FROM mail WHERE mail MATCH <full-text query expression>;\nSELECT snippet(mail) FROM mail WHERE mail MATCH <full-text query expression>;\nSELECT matchinfo(mail) FROM mail WHERE mail MATCH <full-text query expression>;\n\n```", "```sql\nCREATE VIRTUAL TABLE mail USING fts3(subject, body);\nINSERT INTO mail VALUES('hello world', 'This message is a hello world message.');\nINSERT INTO mail VALUES('urgent: serious', 'This mail is seen as a more serious mail');\n\n*-- The following query returns a single row (as it matches only the first*\n*-- entry in table \"mail\". The text returned by the offsets function is*\n*-- \"0 0 6 5 1 0 24 5\".*\n*--*\n*-- The first set of four integers in the result indicate that column 0*\n*-- contains an instance of term 0 (\"world\") at byte offset 6\\. The term instance*\n*-- is 5 bytes in size. The second set of four integers shows that column 1*\n*-- of the matched row contains an instance of term 0 (\"world\") at byte offset*\n*-- 24\\. Again, the term instance is 5 bytes in size.*\nSELECT offsets(mail) FROM mail WHERE mail MATCH 'world';\n\n*-- The following query returns also matches only the first row in table \"mail\".*\n*-- In this case the returned text is \"1 0 5 7 1 0 30 7\".*\nSELECT offsets(mail) FROM mail WHERE mail MATCH 'message';\n\n*-- The following query matches the second row in table \"mail\". It returns the*\n*-- text \"1 0 28 7 1 1 36 4\". Only those occurrences of terms \"serious\" and \"mail\"*\n*-- that are part of an instance of the phrase \"serious mail\" are identified; the*\n*-- other occurrences of \"serious\" and \"mail\" are ignored.*\nSELECT offsets(mail) FROM mail WHERE mail MATCH '\"serious mail\"';\n\n```", "```sql\nNote: In this block of examples, newlines and whitespace characters have\nbeen inserted into the document inserted into the FTS table, and the expected\nresults described in SQL comments. This is done to enhance readability only,\nthey would not be present in actual SQLite commands or output.\n\n*-- Create and populate an FTS table.*\nCREATE VIRTUAL TABLE text USING fts4();\nINSERT INTO text VALUES('\n  During 30 Nov-1 Dec, 2-3oC drops. Cool in the upper portion, minimum temperature 14-16oC\n  and cool elsewhere, minimum temperature 17-20oC. Cold to very cold on mountaintops,\n  minimum temperature 6-12oC. Northeasterly winds 15-30 km/hr. After that, temperature\n  increases. Northeasterly winds 15-30 km/hr.\n');\n\n*-- The following query returns the text value:*\n*--*\n*--   \"<b>...</b>cool elsewhere, minimum temperature 17-20oC. <b>Cold</b> to very* \n*--    <b>cold</b> on mountaintops, minimum temperature 6<b>...</b>\".*\n*--*\nSELECT snippet(text) FROM text WHERE text MATCH 'cold';\n\n*-- The following query returns the text value:*\n*--*\n*--   \"...the upper portion, [minimum] [temperature] 14-16oC and cool elsewhere,*\n*--    [minimum] [temperature] 17-20oC. Cold...\"*\n*--*\nSELECT snippet(text, '[', ']', '...') FROM text WHERE text MATCH '\"min* tem*\"'\n\n```", "```sql\n          hits_this_row  = array[3 * (c + p*cols) + 0]\n          hits_all_rows  = array[3 * (c + p*cols) + 1]\n          docs_with_hits = array[3 * (c + p*cols) + 2]\n\n```", "```sql\n          a OR (b AND c)\n\n```", "```sql\n          \"a c d\"\n\n```", "```sql\n          hits_for_phrase_p_column_c  = array[c + p*cols]\n\n```", "```sql\n    p_is_in_c = array[p * ((nCol+31)/32)] & (1 << (c % 32))\n\n```", "```sql\n*-- Create and populate an FTS4 table with two columns:*\nCREATE VIRTUAL TABLE t1 USING fts4(a, b);\nINSERT INTO t1 VALUES('transaction default models default', 'Non transaction reads');\nINSERT INTO t1 VALUES('the default transaction', 'these semantics present');\nINSERT INTO t1 VALUES('single request', 'default data');\n\n*-- In the following query, no format string is specified and so it defaults*\n*-- to \"pcx\". It therefore returns a single row consisting of a single blob*\n*-- value 80 bytes in size (20 32-bit integers - 1 for \"p\", 1 for \"c\" and*\n*-- 3*2*3 for \"x\"). If each block of 4 bytes in* the blob is interpreted\n*-- as an unsigned integer in machine byte-order, the values will be:*\n*--*\n*--     3 2  1 3 2  0 1 1  1 2 2  0 1 1  0 0 0  1 1 1*\n*--*\n*-- The row returned corresponds to the second entry inserted into table t1.*\n*-- The first two integers in the blob show that the query contained three*\n*-- phrases and the table being queried has two columns. The next block of*\n*-- three integers describes column 0 (in this case column \"a\") and phrase*\n*-- 0 (in this case \"default\"). The current row contains 1 hit for \"default\"*\n*-- in column 0, of a total of 3 hits for \"default\" that occur in column*\n*-- 0 of any table row. The 3 hits are spread across 2 different rows.*\n*--*\n*-- The next set of three integers (0 1 1) pertain to the hits for \"default\"*\n*-- in column 1 of the table (0 in this row, 1 in all rows, spread across* \n*-- 1 rows).*\n*--*\nSELECT matchinfo(t1) FROM t1 WHERE t1 MATCH 'default transaction \"these semantics\"';\n\n*-- The format string for this query is \"ns\". The output array will therefore*\n*-- contain 3 integer values - 1 for \"n\" and 2 for \"s\". The query returns*\n*-- two rows (the first two rows in the table match). The values returned are:*\n*--*\n*--     3  1 1*\n*--     3  2 0*\n*--*\n*-- The first value in the matchinfo array returned for both rows is 3 (the* \n*-- number of rows in the table). The following two values are the lengths* \n*-- of the longest common subsequence of phrase matches in each column.*\nSELECT matchinfo(t1, 'ns') FROM t1 WHERE t1 MATCH 'default transaction';\n\n```", "```sql\nSELECT docid, matchinfo(tbl) FROM tbl WHERE tbl MATCH <query expression>;\nSELECT docid, offsets(tbl) FROM tbl WHERE tbl MATCH <query expression>;\n\n```", "```sql\n*-- Create an FTS4 table*\nCREATE VIRTUAL TABLE ft USING fts4(x, y);\n\n*-- Create an fts4aux table to access the full-text index for table \"ft\"*\nCREATE VIRTUAL TABLE ft_terms USING fts4aux(ft);\n\n*-- Create a TEMP fts4aux table accessing the \"ft\" table in \"main\"*\nCREATE VIRTUAL TABLE temp.ft_terms_2 USING fts4aux(main,ft);\n\n```", "```sql\nINSERT INTO ft(x, y) VALUES('Apple banana', 'Cherry');\nINSERT INTO ft(x, y) VALUES('Banana Date Date', 'cherry');\nINSERT INTO ft(x, y) VALUES('Cherry Elderberry', 'Elderberry');\n\n*-- The following query returns this data:*\n*--*\n*--     apple       |  *  |  1  |  1*\n*--     apple       |  0  |  1  |  1*\n*--     banana      |  *  |  2  |  2*\n*--     banana      |  0  |  2  |  2*\n*--     cherry      |  *  |  3  |  3*\n*--     cherry      |  0  |  1  |  1*\n*--     cherry      |  1  |  2  |  2*\n*--     date        |  *  |  1  |  2*\n*--     date        |  0  |  1  |  2*\n*--     elderberry  |  *  |  1  |  2*\n*--     elderberry  |  0  |  1  |  1*\n*--     elderberry  |  1  |  1  |  1*\n*--*\nSELECT term, col, documents, occurrences FROM ft_terms;\n\n```", "```sql\n*-- Create a reduced-footprint FTS4 table.*\nCREATE VIRTUAL TABLE papers USING fts4(author, document, matchinfo=fts3);\n\n```", "```sql\n*-- An error. FTS4 does not recognize the directive \"xyz=abc\".*\nCREATE VIRTUAL TABLE papers USING fts4(author, document, xyz=abc);\n\n*-- Create an FTS3 table with three columns - \"author\", \"document\"*\n*-- and \"xyz\".*\nCREATE VIRTUAL TABLE papers USING fts3(author, document, xyz=abc);\n\n*-- An error. FTS4 does not allow multiple tokenize=* directives*\nCREATE VIRTUAL TABLE papers USING fts4(tokenize=porter, tokenize=simple);\n\n*-- Create an FTS3 table with a single column named \"tokenize\". The*\n*-- table uses the \"porter\" tokenizer.*\nCREATE VIRTUAL TABLE papers USING fts3(tokenize=porter, tokenize=simple);\n\n*-- An error. Cannot create a table with two columns named \"tokenize\".*\nCREATE VIRTUAL TABLE papers USING fts3(tokenize=porter, tokenize=simple, tokenize=icu);\n\n```", "```sql\n*-- Create an FTS4 table that stores data in compressed form. This*\n*-- assumes that the scalar functions zip() and unzip() have been (or*\n*-- will be) added to the database handle.*\nCREATE VIRTUAL TABLE papers USING fts4(author, document, compress=zip, uncompress=unzip);\n\n```", "```sql\nCREATE VIRTUAL TABLE t1 USING fts4(content=\"\", a, b, c);\n\n```", "```sql\n*-- This statement is Ok:*\nINSERT INTO t1(docid, a, b, c) VALUES(1, 'a b c', 'd e f', 'g h i');\n\n*-- This statement causes an error, as no docid value has been provided:*\nINSERT INTO t1(a, b, c) VALUES('j k l', 'm n o', 'p q r');\n\n```", "```sql\n*-- The following statements are Ok:*\nSELECT docid FROM t1 WHERE t1 MATCH 'xxx';\nSELECT docid FROM t1 WHERE a MATCH 'xxx';\nSELECT matchinfo(t1) FROM t1 WHERE t1 MATCH 'xxx';\n\n*-- The following statements all cause errors, as the value of columns*\n*-- other than docid are required to evaluate them.*\nSELECT * FROM t1;\nSELECT a, b FROM t1 WHERE t1 MATCH 'xxx';\nSELECT docid FROM t1 WHERE a LIKE 'xxx%';\nSELECT snippet(t1) FROM t1 WHERE t1 MATCH 'xxx';\n\n```", "```sql\nCREATE TABLE t2(id INTEGER PRIMARY KEY, a, b, c);\nCREATE VIRTUAL TABLE t3 USING fts4(content=\"t2\", a, c);\n\n```", "```sql\nCREATE TABLE t2(id INTEGER PRIMARY KEY, a, b, c);\nCREATE VIRTUAL TABLE t3 USING fts4(content=\"t2\", b, c);\n\nINSERT INTO t2 VALUES(2, 'a b', 'c d', 'e f');\nINSERT INTO t2 VALUES(3, 'g h', 'i j', 'k l');\nINSERT INTO t3(docid, b, c) SELECT id, b, c FROM t2;\n*-- The following query returns a single row with two columns containing\n-- the text values \"i j\" and \"k l\".\n--\n-- The query uses the full-text index to discover that the MATCH\n-- term matches the row with docid=3\\. It then retrieves the values\n-- of columns b and c from the row with rowid=3 in the content table\n-- to return.\n--*\nSELECT * FROM t3 WHERE t3 MATCH 'k';\n\n*-- Following the UPDATE, the query still returns a single row, this\n-- time containing the text values \"xxx\" and \"yyy\". This is because the\n-- full-text index still indicates that the row with docid=3 matches\n-- the FTS4 query 'k', even though the documents stored in the content\n-- table have been modified.\n--*\nUPDATE t2 SET b = 'xxx', c = 'yyy' WHERE rowid = 3;\nSELECT * FROM t3 WHERE t3 MATCH 'k';\n\n*-- Following the DELETE below, the query returns one row containing two\n-- NULL values. NULL values are returned because FTS is unable to find\n-- a row with rowid=3 within the content table.\n--*\nDELETE FROM t2;\nSELECT * FROM t3 WHERE t3 MATCH 'k';\n\n```", "```sql\nCREATE TABLE t1_real(id INTEGER PRIMARY KEY, a, b, c, d);\nCREATE VIRTUAL TABLE t1_fts USING fts4(content=\"t1_real\", b, c);\n\n*-- This works. When the row is removed from the FTS table, FTS retrieves\n-- the row with rowid=123 and tokenizes it in order to determine the entries\n-- that must be removed from the full-text index.\n--*\nDELETE FROM t1_fts WHERE rowid = 123;\nDELETE FROM t1_real WHERE rowid = 123;\n\n-- *This **does not work**. By the time the FTS table is updated, the row\n-- has already been deleted from the underlying content table. As a result\n-- FTS is unable to determine the entries to remove from the FTS index and\n-- so the index and content table are left out of sync.\n--*\nDELETE FROM t1_real WHERE rowid = 123;\nDELETE FROM t1_fts WHERE rowid = 123;\n\n```", "```sql\nCREATE TRIGGER t2_bu BEFORE UPDATE ON t2 BEGIN\n  DELETE FROM t3 WHERE docid=old.rowid;\nEND;\nCREATE TRIGGER t2_bd BEFORE DELETE ON t2 BEGIN\n  DELETE FROM t3 WHERE docid=old.rowid;\nEND;\n\nCREATE TRIGGER t2_au AFTER UPDATE ON t2 BEGIN\n  INSERT INTO t3(docid, b, c) VALUES(new.rowid, new.b, new.c);\nEND;\nCREATE TRIGGER t2_ai AFTER INSERT ON t2 BEGIN\n  INSERT INTO t3(docid, b, c) VALUES(new.rowid, new.b, new.c);\nEND;\n\n```", "```sql\nINSERT INTO t3(t3) VALUES('rebuild');\n\n```", "```sql\nCREATE VIRTUAL TABLE t1 USING fts4(x, y, languageid=\"lid\")\n\n```", "```sql\nSELECT * FROM t1 WHERE t1 MATCH 'abc' AND lid=5;\n\n```", "```sql\n*-- Create an FTS4 table for which only the contents of columns c2 and c4*\n*-- are tokenized and added to the inverted index.*\nCREATE VIRTUAL TABLE t1 USING fts4(c1, c2, c3, c4, notindexed=c1, notindexed=c3);\n\n```", "```sql\n*-- Create an FTS4 table with indexes to optimize 2 and 4 byte prefix queries.*\nCREATE VIRTUAL TABLE t1 USING fts4(c1, c2, prefix=\"2,4\");\n\n*-- The following two queries are both optimized using the prefix indexes.*\nSELECT * FROM t1 WHERE t1 MATCH 'ab*';\nSELECT * FROM t1 WHERE t1 MATCH 'abcd*';\n\n*-- The following two queries are both partially optimized using the prefix*\n*-- indexes. The optimization is not as pronounced as it is for the queries*\n*-- above, but still an improvement over no prefix indexes at all.*\nSELECT * FROM t1 WHERE t1 MATCH 'a*';\nSELECT * FROM t1 WHERE t1 MATCH 'abc*';\n\n```", "```sql\n*-- Create a table using the simple tokenizer. Insert a document into it.*\nCREATE VIRTUAL TABLE simple USING fts3(tokenize=simple);\nINSERT INTO simple VALUES('Right now they''re very frustrated');\n\n*-- The first of the following two queries matches the document stored in*\n*-- table \"simple\". The second does not.*\nSELECT * FROM simple WHERE simple MATCH 'Frustrated';\nSELECT * FROM simple WHERE simple MATCH 'Frustration';\n\n*-- Create a table using the porter tokenizer. Insert the same document into it*\nCREATE VIRTUAL TABLE porter USING fts3(tokenize=porter);\nINSERT INTO porter VALUES('Right now they''re very frustrated');\n\n*-- Both of the following queries match the document stored in table \"porter\".*\nSELECT * FROM porter WHERE porter MATCH 'Frustrated';\nSELECT * FROM porter WHERE porter MATCH 'Frustration';\n\n```", "```sql\nCREATE VIRTUAL TABLE thai_text USING fts3(text, tokenize=icu th_TH)\n\n```", "```sql\n*-- Create tables that remove **all**diacritics from Latin script characters*\n*-- as part of tokenization.*\nCREATE VIRTUAL TABLE txt1 USING fts4(tokenize=unicode61);\nCREATE VIRTUAL TABLE txt2 USING fts4(tokenize=unicode61 \"remove_diacritics=2\");\n\n*-- Create a table that does not remove diacritics from Latin script*\n*-- characters as part of tokenization.*\nCREATE VIRTUAL TABLE txt3 USING fts4(tokenize=unicode61 \"remove_diacritics=0\");\n\n```", "```sql\n*-- Create a table that uses the unicode61 tokenizer, but considers \".\"*\n*-- and \"=\" characters to be part of tokens, and capital \"X\" characters to*\n*-- function as separators.*\nCREATE VIRTUAL TABLE txt3 USING fts4(tokenize=unicode61 \"tokenchars=.=\" \"separators=X\");\n\n*-- Create a table that considers space characters (codepoint 32) to be*\n*-- a token character*\nCREATE VIRTUAL TABLE txt4 USING fts4(tokenize=unicode61 \"tokenchars= \");\n\n```", "```sql\n*-- Create a table that uses the unicode61 tokenizer, but considers \".\"*\n*-- and \"=\" characters to be part of tokens, and capital \"X\" characters to*\n*-- function as separators. Both of the \"tokenchars=\" options are processed*\n*-- The \"separators=\" option ignores the \".\" passed to it, as \".\" is by*\n*-- default a separator character, even though it has been marked as a token*\n*-- character by an earlier \"tokenchars=\" option.*\nCREATE VIRTUAL TABLE txt5 USING fts4(\n    tokenize=unicode61 \"tokenchars=.\" \"separators=X.\" \"tokenchars==\"\n);\n\n```", "```sql\nSELECT fts3_tokenizer(<tokenizer-name>);\nSELECT fts3_tokenizer(<tokenizer-name>, <sqlite3_tokenizer_module ptr>);\n\n```", "```sql\n*/*\n** Register a tokenizer implementation with FTS3 or FTS4.\n*/*\nint registerTokenizer(\n  sqlite3 *db,\n  char *zName,\n  const sqlite3_tokenizer_module *p\n){\n  int rc;\n  sqlite3_stmt *pStmt;\n  const char *zSql = \"SELECT fts3_tokenizer(?1, ?2)\";\n\n  rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);\n  if( rc!=SQLITE_OK ){\n    return rc;\n  }\n\n  sqlite3_bind_text(pStmt, 1, zName, -1, SQLITE_STATIC);\n  sqlite3_bind_blob(pStmt, 2, &p, sizeof(p), SQLITE_STATIC);\n  sqlite3_step(pStmt);\n\n  return sqlite3_finalize(pStmt);\n}\n\n*/*\n** Query FTS for the tokenizer implementation named zName.\n*/*\nint queryTokenizer(\n  sqlite3 *db,\n  char *zName,\n  const sqlite3_tokenizer_module **pp\n){\n  int rc;\n  sqlite3_stmt *pStmt;\n  const char *zSql = \"SELECT fts3_tokenizer(?)\";\n\n  *pp = 0;\n  rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);\n  if( rc!=SQLITE_OK ){\n    return rc;\n  }\n\n  sqlite3_bind_text(pStmt, 1, zName, -1, SQLITE_STATIC);\n  if( SQLITE_ROW==sqlite3_step(pStmt) ){\n    if( sqlite3_column_type(pStmt, 0)==SQLITE_BLOB ){\n      memcpy(pp, sqlite3_column_blob(pStmt, 0), sizeof(*pp));\n    }\n  }\n\n  return sqlite3_finalize(pStmt);\n}\n\n```", "```sql\nCREATE VIRTUAL TABLE tok1 USING fts3tokenize('porter');\n\n```", "```sql\nCREATE VIRTUAL TABLE text1 USING fts4(tokenize=icu en_AU);\nCREATE VIRTUAL TABLE tokens1 USING fts3tokenize(icu, en_AU);\n\nCREATE VIRTUAL TABLE text2 USING fts4(tokenize=unicode61 \"tokenchars=@.\" \"separators=123\");\nCREATE VIRTUAL TABLE tokens2 USING fts3tokenize(unicode61, \"tokenchars=@.\", \"separators=123\");\n\n```", "```sql\nSELECT token, start, end, position\n  FROM tok1\n WHERE input='This is a test sentence.';\n\n```", "```sql\nthi|0|4|0\nis|5|7|1\na|8|9|2\ntest|10|14|3\nsentenc|15|23|4\n\n```", "```sql\nSELECT substr(input, start+1, end-start), token, position\n  FROM tok1\n WHERE input='This is a test sentence.';\n\n```", "```sql\n*-- Virtual table declaration*\nCREATE VIRTUAL TABLE abc USING fts4(a NUMBER, b TEXT, c);\n\n*-- Corresponding %_content table declaration*\nCREATE TABLE abc_content(docid INTEGER PRIMARY KEY, c0a, c1b, c2c);\n\n```", "```sql\nCREATE TABLE %_stat(\n  id INTEGER PRIMARY KEY,\n  value BLOB\n);\n\nCREATE TABLE %_docsize(\n  docid INTEGER PRIMARY KEY,\n  size BLOB\n);\n\n```", "```sql\nCREATE TABLE %_segments(\n  blockid INTEGER PRIMARY KEY,       *-- B-tree node id*\n  block blob                         *-- B-tree node data*\n);\n\nCREATE TABLE %_segdir(\n  level INTEGER,\n  idx INTEGER,\n  start_block INTEGER,               *-- Blockid of first node in %_segments*\n  leaves_end_block INTEGER,          *-- Blockid of last leaf node in %_segments*\n  end_block INTEGER,                 *-- Blockid of last node in %_segments*\n  root BLOB,                         *-- B-tree root node*\n  PRIMARY KEY(level, idx)\n);\n\n```", "```sql\n    INSERT INTO fts_table(col) VALUES(char(0xfeff)||'text...');\n\n    ```", "```sql\n    INSERT INTO fts_table(col) VALUES(CAST(X'FEFF' AS TEXT));\n\n    ```", "```sql\n*-- This example (and all others in this section) assumes the following schema*\nCREATE VIRTUAL TABLE documents USING fts3(title, content);\n\n*-- Assuming the application has supplied an SQLite user function named \"countintegers\"*\n*-- that returns the number of space-separated integers contained in its only argument,*\n*-- the following query could be used to return the titles of the 10 documents that contain*\n*-- the greatest number of instances of the users query terms. Hopefully, these 10*\n*-- documents will be those that the users considers more or less the most \"relevant\".*\nSELECT title FROM documents\n  WHERE documents MATCH <query>\n  ORDER BY countintegers(offsets(documents)) DESC\n  LIMIT 10 OFFSET 0\n\n```", "```sql\n*-- If the application supplies an SQLite user function called \"rank\" that*\n*-- interprets the blob of data returned by matchinfo and returns a numeric*\n*-- relevancy based on it, then the following SQL may be used to return the*\n*-- titles of the 10 most relevant documents in the dataset for a users query.*\nSELECT title FROM documents\n  WHERE documents MATCH <query>\n  ORDER BY rank(matchinfo(documents)) DESC\n  LIMIT 10 OFFSET 0\n\n```", "```sql\nSELECT title FROM documents JOIN (\n    SELECT docid, rank(matchinfo(documents)) AS rank\n    FROM documents\n    WHERE documents MATCH <query>\n    ORDER BY rank DESC\n    LIMIT 10 OFFSET 0\n) AS ranktable USING(docid)\nORDER BY ranktable.rank DESC\n\n```", "```sql\n*-- This table stores the static weight assigned to each document in FTS table*\n*-- \"documents\". For each row in the documents table there is a corresponding row*\n*-- with the same docid value in this table.*\nCREATE TABLE documents_data(docid INTEGER PRIMARY KEY, weight);\n\n*-- This query is similar to the one in the block above, except that:*\n*--*\n*--   1\\. It returns a \"snippet\" of text along with the document title for display. So*\n*--      that the snippet function may be used, the \"WHERE ... MATCH ...\" clause from*\n*--      the sub-query is duplicated in the outer query.*\n*--*\n*--   2\\. The sub-query joins the documents table with the document_data table, so that*\n*--      implementation of the rank function has access to the static weight assigned*\n*--      to each document.*\nSELECT title, snippet(documents) FROM documents JOIN (\n    SELECT docid, rank(matchinfo(documents), documents_data.weight) AS rank\n    FROM documents JOIN documents_data USING(docid)\n    WHERE documents MATCH <query>\n    ORDER BY rank DESC\n    LIMIT 10 OFFSET 0\n) AS ranktable USING(docid)\nWHERE documents MATCH <query>\nORDER BY ranktable.rank DESC\n\n```", "```sql\n*/**\n*** SQLite user defined function to use with matchinfo() to calculate the*\n*** relevancy of an FTS match. The value returned is the relevancy score*\n*** (a real value greater than or equal to zero). A larger value indicates* \n*** a more relevant document.*\n****\n*** The overall relevancy returned is the sum of the relevancies of each* \n*** column value in the FTS table. The relevancy of a column value is the*\n*** sum of the following for each reportable phrase in the FTS query:*\n****\n***   (<hit count> / <global hit count>) * <column weight>*\n****\n*** where <hit count> is the number of instances of the phrase in the*\n*** column value of the current row and <global hit count> is the number*\n*** of instances of the phrase in the same column of all rows in the FTS*\n*** table. The <column weight> is a weighting factor assigned to each*\n*** column by the caller (see below).*\n****\n*** The first argument to this function must be the return value of the FTS* \n*** matchinfo() function. Following this must be one argument for each column* \n*** of the FTS table containing a numeric weight factor for the corresponding* \n*** column. Example:*\n****\n***     CREATE VIRTUAL TABLE documents USING fts3(title, content)*\n****\n*** The following query returns the docids of documents that match the full-text*\n*** query <query> sorted from most to least relevant. When calculating*\n*** relevance, query term instances in the 'title' column are given twice the*\n*** weighting of those in the 'content' column.*\n****\n***     SELECT docid FROM documents* \n***     WHERE documents MATCH <query>* \n***     ORDER BY rank(matchinfo(documents), 1.0, 0.5) DESC*\n**/*\nstatic void rankfunc(sqlite3_context *pCtx, int nVal, sqlite3_value **apVal){\n  int *aMatchinfo;                */* Return value of matchinfo() */*\n  int nMatchinfo;                 */* Number of elements in aMatchinfo[] */*\n  int nCol = 0;                   */* Number of columns in the table */*\n  int nPhrase = 0;                */* Number of phrases in the query */*\n  int iPhrase;                    */* Current phrase */*\n  double score = 0.0;             */* Value to return */*\n\n  assert( sizeof(int)==4 );\n\n */* Check that the number of arguments passed to this function is correct.*\n *** If not, jump to wrong_number_args. Set aMatchinfo to point to the array*\n *** of unsigned integer values returned by FTS function matchinfo. Set*\n *** nPhrase to contain the number of reportable phrases in the users full-text*\n *** query, and nCol to the number of columns in the table. Then check that the*\n *** size of the matchinfo blob is as expected. Return an error if it is not.*\n **/*\n  if( nVal<1 ) goto wrong_number_args;\n  aMatchinfo = (unsigned int *)sqlite3_value_blob(apVal[0]);\n  nMatchinfo = sqlite3_value_bytes(apVal[0]) / sizeof(int);\n  if( nMatchinfo>=2 ){\n    nPhrase = aMatchinfo[0];\n    nCol = aMatchinfo[1];\n  }\n  if( nMatchinfo!=(2+3*nCol*nPhrase) ){\n    sqlite3_result_error(pCtx,\n      \"invalid matchinfo blob passed to function rank()\", -1);\n    return;\n  }\n  if( nVal!=(1+nCol) ) goto wrong_number_args;\n\n */* Iterate through each phrase in the users query. */*\n  for(iPhrase=0; iPhrase<nPhrase; iPhrase++){\n    int iCol;                     */* Current column */*\n\n */* Now iterate through each column in the users query. For each column,*\n *** increment the relevancy score by:*\n ****\n ***   (<hit count> / <global hit count>) * <column weight>*\n ****\n *** aPhraseinfo[] points to the start of the data for phrase iPhrase. So*\n *** the hit count and global hit counts for each column are found in* \n *** aPhraseinfo[iCol*3] and aPhraseinfo[iCol*3+1], respectively.*\n **/*\n    int *aPhraseinfo = &aMatchinfo[2 + iPhrase*nCol*3];\n    for(iCol=0; iCol<nCol; iCol++){\n      int nHitCount = aPhraseinfo[3*iCol];\n      int nGlobalHitCount = aPhraseinfo[3*iCol+1];\n      double weight = sqlite3_value_double(apVal[iCol+1]);\n      if( nHitCount>0 ){\n        score += ((double)nHitCount / (double)nGlobalHitCount) * weight;\n      }\n    }\n  }\n\n  sqlite3_result_double(pCtx, score);\n  return;\n\n */* Jump here if the wrong number of arguments are passed to this function */*\nwrong_number_args:\n  sqlite3_result_error(pCtx, \"wrong number of arguments to function rank()\", -1);\n}\n\n```"]