["```sql\nCREATE VIRTUAL TABLE tablename USING modulename;\n\n```", "```sql\nCREATE VIRTUAL TABLE tablename USING modulename(arg1, arg2, ...);\n\n```", "```sql\nCREATE VIRTUAL TABLE temp.tablename USING module(arg1, ...);\n\n```", "```sql\nSELECT * FROM dbstat;\n\n```", "```sql\ntypedef struct sqlite3_vtab sqlite3_vtab;\ntypedef struct sqlite3_index_info sqlite3_index_info;\ntypedef struct sqlite3_vtab_cursor sqlite3_vtab_cursor;\ntypedef struct sqlite3_module sqlite3_module;\n\n```", "```sql\nstruct sqlite3_vtab {\n  const sqlite3_module *pModule;\n  int nRef;\n  char *zErrMsg;\n};\n\n```", "```sql\nstruct sqlite3_vtab_cursor {\n  sqlite3_vtab *pVtab;\n};\n\n```", "```sql\nint sqlite3_create_module(\n  sqlite3 *db,               /* SQLite connection to register module with */\n  const char *zName,         /* Name of the module */\n  const sqlite3_module *,    /* Methods for the module */\n  void *                     /* Client data for xCreate/xConnect */\n);\nint sqlite3_create_module_v2(\n  sqlite3 *db,               /* SQLite connection to register module with */\n  const char *zName,         /* Name of the module */\n  const sqlite3_module *,    /* Methods for the module */\n  void *,                    /* Client data for xCreate/xConnect */\n  void(*xDestroy)(void*)     /* Client data destructor function */\n);\n\n```", "```sql\nstruct sqlite3_module {\n  int iVersion;\n  int (*xCreate)(sqlite3*, void *pAux,\n               int argc, char *const*argv,\n               sqlite3_vtab **ppVTab,\n               char **pzErr);\n  int (*xConnect)(sqlite3*, void *pAux,\n               int argc, char *const*argv,\n               sqlite3_vtab **ppVTab,\n               char **pzErr);\n  int (*xBestIndex)(sqlite3_vtab *pVTab, sqlite3_index_info*);\n  int (*xDisconnect)(sqlite3_vtab *pVTab);\n  int (*xDestroy)(sqlite3_vtab *pVTab);\n  int (*xOpen)(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor);\n  int (*xClose)(sqlite3_vtab_cursor*);\n  int (*xFilter)(sqlite3_vtab_cursor*, int idxNum, const char *idxStr,\n                int argc, sqlite3_value **argv);\n  int (*xNext)(sqlite3_vtab_cursor*);\n  int (*xEof)(sqlite3_vtab_cursor*);\n  int (*xColumn)(sqlite3_vtab_cursor*, sqlite3_context*, int);\n  int (*xRowid)(sqlite3_vtab_cursor*, sqlite_int64 *pRowid);\n  int (*xUpdate)(sqlite3_vtab *, int, sqlite3_value **, sqlite_int64 *);\n  int (*xBegin)(sqlite3_vtab *pVTab);\n  int (*xSync)(sqlite3_vtab *pVTab);\n  int (*xCommit)(sqlite3_vtab *pVTab);\n  int (*xRollback)(sqlite3_vtab *pVTab);\n  int (*xFindFunction)(sqlite3_vtab *pVtab, int nArg, const char *zName,\n                     void (**pxFunc)(sqlite3_context*,int,sqlite3_value**),\n                     void **ppArg);\n  int (*xRename)(sqlite3_vtab *pVtab, const char *zNew);\n  /* The methods above are in version 1 of the sqlite_module object. Those \n  ** below are for version 2 and greater. */\n  int (*xSavepoint)(sqlite3_vtab *pVTab, int);\n  int (*xRelease)(sqlite3_vtab *pVTab, int);\n  int (*xRollbackTo)(sqlite3_vtab *pVTab, int);\n  /* The methods above are in versions 1 and 2 of the sqlite_module object.\n  ** Those below are for version 3 and greater. */\n  int (*xShadowName)(const char*);\n  /* The methods above are in versions 1 through 3 of the sqlite_module object.\n  ** Those below are for version 4 and greater. */\n  int (*xIntegrity)(sqlite3_vtab *pVTab, const char *zSchema,\n                    const char *zTabName, int mFlags, char **pzErr);\n};\n\n```", "```sql\nint (*xCreate)(sqlite3 *db, void *pAux,\n             int argc, char *const*argv,\n             sqlite3_vtab **ppVTab,\n             char **pzErr);\n\n```", "```sql\nint sqlite3_declare_vtab(sqlite3 *db, const char *zCreateTable)\n\n```", "```sql\nint sqlite3_vtab_config(sqlite3 *db, int op, ...);\n\n```", "```sql\nCREATE TABLE x(a HIDDEN VARCHAR(12), b INTEGER, c INTEGER Hidden);\n\n```", "```sql\nCREATE TABLE generate_series(\n  value,\n  start HIDDEN,\n  stop HIDDEN,\n  step HIDDEN\n);\n\n```", "```sql\nSELECT value FROM generate_series(5,50);\n\n```", "```sql\nSELECT value FROM generate_series WHERE start=5 AND stop=50;\n\n```", "```sql\nint (*xConnect)(sqlite3*, void *pAux,\n             int argc, char *const*argv,\n             sqlite3_vtab **ppVTab,\n             char **pzErr);\n\n```", "```sql\nint (*xBestIndex)(sqlite3_vtab *pVTab, sqlite3_index_info*);\n\n```", "```sql\nstruct sqlite3_index_info {\n  /* Inputs */\n  const int nConstraint;     /* Number of entries in aConstraint */\n  const struct sqlite3_index_constraint {\n     int iColumn;              /* Column constrained.  -1 for ROWID */\n     unsigned char op;         /* Constraint operator */\n     unsigned char usable;     /* True if this constraint is usable */\n     int iTermOffset;          /* Used internally - xBestIndex should ignore */\n  } *const aConstraint;      /* Table of WHERE clause constraints */\n  const int nOrderBy;        /* Number of terms in the ORDER BY clause */\n  const struct sqlite3_index_orderby {\n     int iColumn;              /* Column number */\n     unsigned char desc;       /* True for DESC.  False for ASC. */\n  } *const aOrderBy;         /* The ORDER BY clause */\n\n  /* Outputs */\n  struct sqlite3_index_constraint_usage {\n    int argvIndex;           /* if >0, constraint is part of argv to xFilter */\n    unsigned char omit;      /* Do not code a test for this constraint */\n  } *const aConstraintUsage;\n  int idxNum;                /* Number used to identify the index */\n  char *idxStr;              /* String, possibly obtained from sqlite3_malloc */\n  int needToFreeIdxStr;      /* Free idxStr using sqlite3_free() if true */\n  int orderByConsumed;       /* True if output is already ordered */\n  double estimatedCost;      /* Estimated cost of using this index */\n  /* Fields below are only available in SQLite 3.8.2 and later */\n  sqlite3_int64 estimatedRows;    /* Estimated number of rows returned */\n  /* Fields below are only available in SQLite 3.9.0 and later */\n  int idxFlags;              /* Mask of SQLITE_INDEX_SCAN_* flags */\n  /* Fields below are only available in SQLite 3.10.0 and later */\n  sqlite3_uint64 colUsed;    /* Input: Mask of columns used by statement */\n};\n\n```", "```sql\n#define SQLITE_INDEX_CONSTRAINT_EQ         2\n#define SQLITE_INDEX_CONSTRAINT_GT         4\n#define SQLITE_INDEX_CONSTRAINT_LE         8\n#define SQLITE_INDEX_CONSTRAINT_LT        16\n#define SQLITE_INDEX_CONSTRAINT_GE        32\n#define SQLITE_INDEX_CONSTRAINT_MATCH     64\n#define SQLITE_INDEX_CONSTRAINT_LIKE      65  /* 3.10.0 and later */\n#define SQLITE_INDEX_CONSTRAINT_GLOB      66  /* 3.10.0 and later */\n#define SQLITE_INDEX_CONSTRAINT_REGEXP    67  /* 3.10.0 and later */\n#define SQLITE_INDEX_CONSTRAINT_NE        68  /* 3.21.0 and later */\n#define SQLITE_INDEX_CONSTRAINT_ISNOT     69  /* 3.21.0 and later */\n#define SQLITE_INDEX_CONSTRAINT_ISNOTNULL 70  /* 3.21.0 and later */\n#define SQLITE_INDEX_CONSTRAINT_ISNULL    71  /* 3.21.0 and later */\n#define SQLITE_INDEX_CONSTRAINT_IS        72  /* 3.21.0 and later */\n#define SQLITE_INDEX_CONSTRAINT_LIMIT     73  /* 3.38.0 and later */\n#define SQLITE_INDEX_CONSTRAINT_OFFSET    74  /* 3.38.0 and later */\n#define SQLITE_INDEX_CONSTRAINT_FUNCTION 150  /* 3.25.0 and later */\n#define SQLITE_INDEX_SCAN_UNIQUE           1  /* Scan visits at most 1 row */\n\n```", "```sql\nconst char *sqlite3_vtab_collation(sqlite3_index_info*, int i);\n\n```", "```sql\na = 5\n\n```", "```sql\nx BETWEEN 10 AND 100 AND 999>y\n\n```", "```sql\nx >= 10\nx <= 100\ny < 999\n\n```", "```sql\nSELECT * FROM realtab, tablevaluedfunc(realtab.x);\n\n```", "```sql\nSELECT * FROM realtab, tablevaluedfunc\n WHERE tablevaluedfunc.param1 = realtab.x;\n\n```", "```sql\nint (*xDisconnect)(sqlite3_vtab *pVTab);\n\n```", "```sql\nint (*xDestroy)(sqlite3_vtab *pVTab);\n\n```", "```sql\nint (*xOpen)(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor);\n\n```", "```sql\nint (*xClose)(sqlite3_vtab_cursor*);\n\n```", "```sql\nint (*xEof)(sqlite3_vtab_cursor*);\n\n```", "```sql\nint (*xFilter)(sqlite3_vtab_cursor*, int idxNum, const char *idxStr,\n              int argc, sqlite3_value **argv);\n\n```", "```sql\nint (*xNext)(sqlite3_vtab_cursor*);\n\n```", "```sql\nint (*xColumn)(sqlite3_vtab_cursor*, sqlite3_context*, int N);\n\n```", "```sql\nint (*xRowid)(sqlite3_vtab_cursor *pCur, sqlite_int64 *pRowid);\n\n```", "```sql\nint (*xUpdate)(\n  sqlite3_vtab *pVTab,\n  int argc,\n  sqlite3_value **argv,\n  sqlite_int64 *pRowid\n);\n\n```", "```sql\nint (*xFindFunction)(\n  sqlite3_vtab *pVtab,\n  int nArg,\n  const char *zName,\n  void (**pxFunc)(sqlite3_context*,int,sqlite3_value**),\n  void **ppArg\n);\n\n```", "```sql\nSELECT * FROM geopolytab WHERE geopoly_overlap(_shape, $query_polygon);\nSELECT * FROM geopolytab WHERE geopoly_within(_shape, $query_polygon);\n\n```", "```sql\nint (*xBegin)(sqlite3_vtab *pVTab);\n\n```", "```sql\nint (*xSync)(sqlite3_vtab *pVTab);\n\n```", "```sql\nint (*xCommit)(sqlite3_vtab *pVTab);\n\n```", "```sql\nint (*xRollback)(sqlite3_vtab *pVTab);\n\n```", "```sql\nint (*xRename)(sqlite3_vtab *pVtab, const char *zNew);\n\n```", "```sql\nint (*xSavepoint)(sqlite3_vtab *pVtab, int);\nint (*xRelease)(sqlite3_vtab *pVtab, int);\nint (*xRollbackTo)(sqlite3_vtab *pVtab, int);\n\n```"]