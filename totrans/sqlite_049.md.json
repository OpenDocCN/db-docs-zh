["```sql\nCREATE TABLE artist(\n  artistid    INTEGER PRIMARY KEY, \n  artistname  TEXT\n);\nCREATE TABLE track(\n  trackid     INTEGER,\n  trackname   TEXT, \n  trackartist INTEGER     -- Must map to an artist.artistid!\n);\n\n```", "```sql\nCREATE TABLE track(\n  trackid     INTEGER, \n  trackname   TEXT, \n  trackartist INTEGER,\n  FOREIGN KEY(trackartist) REFERENCES artist(artistid)\n);\n\n```", "```sql\ntrackartist IS NULL OR EXISTS(SELECT 1 FROM artist WHERE artistid=trackartist)\n\n```", "```sql\nsqlite> SELECT * FROM artist;\nartistid  artistname       \n--------  -----------------\n1         Dean Martin      \n2         Frank Sinatra    \n\nsqlite> SELECT * FROM track;\ntrackid  trackname          trackartist\n-------  -----------------  -----------\n11       That's Amore       1  \n12       Christmas Blues    1  \n13       My Way             2  \n\nsqlite> *-- This fails because the value inserted into the trackartist column (3)*\nsqlite> *-- does not correspond to row in the artist table.*\nsqlite> INSERT INTO track VALUES(14, 'Mr. Bojangles', 3);\nSQL error: foreign key constraint failed\n\nsqlite> *-- This succeeds because a NULL is inserted into trackartist. A*\nsqlite> *-- corresponding row in the artist table is not required in this case.*\nsqlite> INSERT INTO track VALUES(14, 'Mr. Bojangles', NULL);\n\nsqlite> *-- Trying to modify the trackartist field of the record after it has* \nsqlite> *-- been inserted does not work either, since the new value of trackartist (3)*\nsqlite> *-- Still does not correspond to any row in the artist table.*\nsqlite> UPDATE track SET trackartist = 3 WHERE trackname = 'Mr. Bojangles';\nSQL error: foreign key constraint failed\n\nsqlite> *-- Insert the required row into the artist table. It is then possible to*\nsqlite> *-- update the inserted row to set trackartist to 3 (since a corresponding*\nsqlite> *-- row in the artist table now exists).*\nsqlite> INSERT INTO artist VALUES(3, 'Sammy Davis Jr.');\nsqlite> UPDATE track SET trackartist = 3 WHERE trackname = 'Mr. Bojangles';\n\nsqlite> *-- Now that \"Sammy Davis Jr.\" (artistid = 3) has been added to the database,*\nsqlite> *-- it is possible to INSERT new tracks using this artist without violating*\nsqlite> *-- the foreign key constraint:*\nsqlite> INSERT INTO track VALUES(15, 'Boogie Woogie', 3);\n\n```", "```sql\nsqlite> *-- Attempting to delete the artist record for \"Frank Sinatra\" fails, since*\nsqlite> *-- the track table contains a row that refer to it.*\nsqlite> DELETE FROM artist WHERE artistname = 'Frank Sinatra';\nSQL error: foreign key constraint failed\n\nsqlite> *-- Delete all the records from the track table that refer to the artist*\nsqlite> *-- \"Frank Sinatra\". Only then is it possible to delete the artist.*\nsqlite> DELETE FROM track WHERE trackname = 'My Way';\nsqlite> DELETE FROM artist WHERE artistname = 'Frank Sinatra';\n\nsqlite> *-- Try to update the artistid of a row in the artist table while there*\nsqlite> *-- exists records in the track table that refer to it.* \nsqlite> UPDATE artist SET artistid=4 WHERE artistname = 'Dean Martin';\nSQL error: foreign key constraint failed\n\nsqlite> *-- Once all the records that refer to a row in the artist table have*\nsqlite> *-- been deleted, it is possible to modify the artistid of the row.*\nsqlite> DELETE FROM track WHERE trackname IN('That''s Amore', 'Christmas Blues');\nsqlite> UPDATE artist SET artistid=4 WHERE artistname = 'Dean Martin';\n\n```", "```sql\nsqlite> PRAGMA foreign_keys = ON;\n\n```", "```sql\nsqlite> PRAGMA foreign_keys;\n0\nsqlite> PRAGMA foreign_keys = ON;\nsqlite> PRAGMA foreign_keys;\n1\nsqlite> PRAGMA foreign_keys = OFF;\nsqlite> PRAGMA foreign_keys;\n0\n\n```", "```sql\nCREATE TABLE parent(a PRIMARY KEY, b UNIQUE, c, d, e, f);\nCREATE UNIQUE INDEX i1 ON parent(c, d);\nCREATE INDEX i2 ON parent(e);\nCREATE UNIQUE INDEX i3 ON parent(f COLLATE nocase);\n\nCREATE TABLE child1(f, g REFERENCES parent(a));                        *-- Ok*\nCREATE TABLE child2(h, i REFERENCES parent(b));                        *-- Ok*\nCREATE TABLE child3(j, k, FOREIGN KEY(j, k) REFERENCES parent(c, d));  *-- Ok*\nCREATE TABLE child4(l, m REFERENCES parent(e));                        *-- Error!*\nCREATE TABLE child5(n, o REFERENCES parent(f));                        *-- Error!*\nCREATE TABLE child6(p, q, FOREIGN KEY(p, q) REFERENCES parent(b, c));  *-- Error!*\nCREATE TABLE child7(r REFERENCES parent(c));                           *-- Error!*\n\n```", "```sql\nCREATE TABLE parent2(a, b, PRIMARY KEY(a,b));\n\nCREATE TABLE child8(x, y, FOREIGN KEY(x,y) REFERENCES parent2);        *-- Ok*\nCREATE TABLE child9(x REFERENCES parent2);                             *-- Error!*\nCREATE TABLE child10(x,y,z, FOREIGN KEY(x,y,z) REFERENCES parent2);    *-- Error!*\n\n```", "```sql\nSELECT rowid FROM track WHERE trackartist = ?\n\n```", "```sql\nSELECT rowid FROM <child-table> WHERE <child-key> = :parent_key_value\n\n```", "```sql\nCREATE TABLE artist(\n  artistid    INTEGER PRIMARY KEY, \n  artistname  TEXT\n);\nCREATE TABLE track(\n  trackid     INTEGER,\n  trackname   TEXT, \n  trackartist INTEGER REFERENCES artist\n);\nCREATE INDEX trackindex ON track(trackartist);\n\n```", "```sql\nCREATE TABLE album(\n  albumartist TEXT,\n  albumname TEXT,\n  albumcover BINARY,\n  PRIMARY KEY(albumartist, albumname)\n);\n\nCREATE TABLE song(\n  songid     INTEGER,\n  songartist TEXT,\n  songalbum TEXT,\n  songname   TEXT,\n  FOREIGN KEY(songartist, songalbum) REFERENCES album(albumartist, albumname)\n);\n\n```", "```sql\nDEFERRABLE INITIALLY DEFERRED                *-- A deferred foreign key constraint*\n\n```", "```sql\nNOT DEFERRABLE INITIALLY DEFERRED            *-- An immediate foreign key constraint*\nNOT DEFERRABLE INITIALLY IMMEDIATE           *-- An immediate foreign key constraint*\nNOT DEFERRABLE                               *-- An immediate foreign key constraint*\nDEFERRABLE INITIALLY IMMEDIATE               *-- An immediate foreign key constraint*\nDEFERRABLE                                   *-- An immediate foreign key constraint*\n\n```", "```sql\n*-- Database schema. Both tables are initially empty.* \nCREATE TABLE artist(\n  artistid    INTEGER PRIMARY KEY, \n  artistname  TEXT\n);\nCREATE TABLE track(\n  trackid     INTEGER,\n  trackname   TEXT, \n  trackartist INTEGER REFERENCES artist(artistid) DEFERRABLE INITIALLY DEFERRED\n);\n\nsqlite3> *-- If the foreign key constraint were immediate, this INSERT would*\nsqlite3> *-- cause an error (since as there is no row in table artist with*\nsqlite3> *-- artistid=5). But as the constraint is deferred and there is an*\nsqlite3> *-- open transaction, no error occurs.*\nsqlite3> BEGIN;\nsqlite3>   INSERT INTO track VALUES(1, 'White Christmas', 5);\n\nsqlite3> *-- The following COMMIT fails, as the database is in a state that*\nsqlite3> *-- does not satisfy the deferred foreign key constraint. The*\nsqlite3> *-- transaction remains open.*\nsqlite3> COMMIT;\nSQL error: foreign key constraint failed\n\nsqlite3> *-- After inserting a row into the artist table with artistid=5, the*\nsqlite3> *-- deferred foreign key constraint is satisfied. It is then possible*\nsqlite3> *-- to commit the transaction without error.*\nsqlite3>   INSERT INTO artist VALUES(5, 'Bing Crosby');\nsqlite3> COMMIT;\n\n```", "```sql\n*-- Database schema*\nCREATE TABLE artist(\n  artistid    INTEGER PRIMARY KEY, \n  artistname  TEXT\n);\nCREATE TABLE track(\n  trackid     INTEGER,\n  trackname   TEXT, \n  trackartist INTEGER REFERENCES artist(artistid) ON UPDATE CASCADE\n);\n\nsqlite> SELECT * FROM artist;\nartistid  artistname       \n--------  -----------------\n1         Dean Martin      \n2         Frank Sinatra    \n\nsqlite> SELECT * FROM track;\ntrackid  trackname          trackartist\n-------  -----------------  -----------\n11       That's Amore       1\n12       Christmas Blues    1\n13       My Way             2  \n\nsqlite> *-- Update the artistid column of the artist record for \"Dean Martin\".*\nsqlite> *-- Normally, this would raise a constraint, as it would orphan the two*\nsqlite> *-- dependent records in the track table. However, the ON UPDATE CASCADE clause*\nsqlite> *-- attached to the foreign key definition causes the update to \"cascade\"*\nsqlite> *-- to the child table, preventing the foreign key constraint violation.*\nsqlite> UPDATE artist SET artistid = 100 WHERE artistname = 'Dean Martin';\n\nsqlite> SELECT * FROM artist;\nartistid  artistname       \n--------  -----------------\n2         Frank Sinatra    \n100       Dean Martin      \n\nsqlite> SELECT * FROM track;\ntrackid  trackname          trackartist\n-------  -----------------  -----------\n11       That's Amore       100\n12       Christmas Blues    100  \n13       My Way             2  \n\n```", "```sql\n*-- Database schema*\nCREATE TABLE artist(\n  artistid    INTEGER PRIMARY KEY, \n  artistname  TEXT\n);\nCREATE TABLE track(\n  trackid     INTEGER,\n  trackname   TEXT, \n  trackartist INTEGER DEFAULT 0 REFERENCES artist(artistid) ON DELETE SET DEFAULT\n);\n\nsqlite> SELECT * FROM artist;\nartistid  artistname       \n--------  -----------------\n3         Sammy Davis Jr.\n\nsqlite> SELECT * FROM track;\ntrackid  trackname          trackartist\n-------  -----------------  -----------\n14       Mr. Bojangles      3\n\nsqlite> *-- Deleting the row from the parent table causes the child key*\nsqlite> *-- value of the dependent row to be set to integer value 0\\. However, this*\nsqlite> *-- value does not correspond to any row in the parent table. Therefore*\nsqlite> *-- the foreign key constraint is violated and an is exception thrown.*\nsqlite> DELETE FROM artist WHERE artistname = 'Sammy Davis Jr.';\nSQL error: foreign key constraint failed\n\nsqlite> *-- This time, the value 0 does correspond to a parent table row. And*\nsqlite> *-- so the DELETE statement does not violate the foreign key constraint*\nsqlite> *-- and no exception is thrown.*\nsqlite> INSERT INTO artist VALUES(0, 'Unknown Artist');\nsqlite> DELETE FROM artist WHERE artistname = 'Sammy Davis Jr.';\n\nsqlite> SELECT * FROM artist;\nartistid  artistname       \n--------  -----------------\n0         Unknown Artist\n\nsqlite> SELECT * FROM track;\ntrackid  trackname          trackartist\n-------  -----------------  -----------\n14       Mr. Bojangles      0\n\n```", "```sql\nCREATE TRIGGER on_delete_set_default AFTER DELETE ON artist BEGIN\n  UPDATE child SET trackartist = 0 WHERE trackartist = old.artistid;\nEND;\n\n```", "```sql\n*-- Database schema*\nCREATE TABLE parent(x PRIMARY KEY);\nCREATE TABLE child(y REFERENCES parent ON UPDATE SET NULL);\n\nsqlite> SELECT * FROM parent;\nx\n----\nkey\n\nsqlite> SELECT * FROM child;\ny\n----\nkey\n\nsqlite> *-- Since the following UPDATE statement does not actually modify*\nsqlite> *-- the parent key value, the ON UPDATE action is not performed and*\nsqlite> *-- the child key value is not set to NULL.*\nsqlite> UPDATE parent SET x = 'key';\nsqlite> SELECT IFNULL(y, 'null') FROM child;\ny\n----\nkey\n\nsqlite> *-- This time, since the UPDATE statement does modify the parent key*\nsqlite> *-- value, the ON UPDATE action is performed and the child key is set*\nsqlite> *-- to NULL.*\nsqlite> UPDATE parent SET x = 'key2';\nsqlite> SELECT IFNULL(y, 'null') FROM child;\ny\n----\nnull\n\n```"]