- en: 1\. Overview
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1\. 概述
- en: 原文：[https://sqlite.com/json1.html](https://sqlite.com/json1.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://sqlite.com/json1.html](https://sqlite.com/json1.html)
- en: By default, SQLite supports thirty functions and two operators for dealing with
    JSON values. There are also two [table-valued functions](vtab.html#tabfunc2) that
    can be used to decompose a JSON string.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，SQLite 支持三十个函数和两个运算符以处理 JSON 值。还有两个[表值函数](vtab.html#tabfunc2)，用于分解 JSON
    字符串。
- en: 'There are twenty-six scalar functions and operators:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 共有二十六个标量函数和运算符：
- en: '[json](#jmini)(*json*)'
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[json](#jmini)(*json*)'
- en: '[jsonb](#jminib)(*json*)'
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[jsonb](#jminib)(*json*)'
- en: '[json_array](#jarray)(*value1*,*value2*,...)'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[json_array](#jarray)(*value1*,*value2*,...)'
- en: '[jsonb_array](#jarrayb)(*value1*,*value2*,...)'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[jsonb_array](#jarrayb)(*value1*,*value2*,...)'
- en: '[json_array_length](#jarraylen)(*json*)'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[json_array_length](#jarraylen)(*json*)'
- en: '[json_array_length](#jarraylen)(*json*,*path*)'
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[json_array_length](#jarraylen)(*json*,*path*)'
- en: '[json_error_position](#jerr)(*json*)'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[json_error_position](#jerr)(*json*)'
- en: '[json_extract](#jex)(*json*,*path*,...)'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[json_extract](#jex)(*json*,*path*,...)'
- en: '[jsonb_extract](#jexb)(*json*,*path*,...)'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[jsonb_extract](#jexb)(*json*,*path*,...)'
- en: '*json* [->](#jptr) *path*'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*json* [->](#jptr) *path*'
- en: '*json* [->>](#jptr) *path*'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*json* [->>](#jptr) *path*'
- en: '[json_insert](#jins)(*json*,*path*,*value*,...)'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[json_insert](#jins)(*json*,*path*,*value*,...)'
- en: '[jsonb_insert](#jinsb)(*json*,*path*,*value*,...)'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[jsonb_insert](#jinsb)(*json*,*path*,*value*,...)'
- en: '[json_object](#jobj)(*label1*,*value1*,...)'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[json_object](#jobj)(*label1*,*value1*,...)'
- en: '[jsonb_object](#jobjb)(*label1*,*value1*,...)'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[jsonb_object](#jobjb)(*label1*,*value1*,...)'
- en: '[json_patch](#jpatch)(*json*1,json2)'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[json_patch](#jpatch)(*json*1,json2)'
- en: '[jsonb_patch](#jpatchb)(*json*1,json2)'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[jsonb_patch](#jpatchb)(*json*1,json2)'
- en: '[json_pretty](#jpretty)(*json*)'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[json_pretty](#jpretty)(*json*)'
- en: '[json_remove](#jrm)(*json*,*path*,...)'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[json_remove](#jrm)(*json*,*path*,...)'
- en: '[jsonb_remove](#jrmb)(*json*,*path*,...)'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[jsonb_remove](#jrmb)(*json*,*path*,...)'
- en: '[json_replace](#jrepl)(*json*,*path*,*value*,...)'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[json_replace](#jrepl)(*json*,*path*,*value*,...)'
- en: '[jsonb_replace](#jreplb)(*json*,*path*,*value*,...)'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[jsonb_replace](#jreplb)(*json*,*path*,*value*,...)'
- en: '[json_set](#jset)(*json*,*path*,*value*,...)'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[json_set](#jset)(*json*,*path*,*value*,...)'
- en: '[jsonb_set](#jsetb)(*json*,*path*,*value*,...)'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[jsonb_set](#jsetb)(*json*,*path*,*value*,...)'
- en: '[json_type](#jtype)(*json*)'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[json_type](#jtype)(*json*)'
- en: '[json_type](#jtype)(*json*,*path*)'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[json_type](#jtype)(*json*,*path*)'
- en: '[json_valid](#jvalid)(*json*)'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[json_valid](#jvalid)(*json*)'
- en: '[json_valid](#jvalid)(*json*,flags)'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[json_valid](#jvalid)(*json*,flags)'
- en: '[json_quote](#jquote)(*value*)'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[json_quote](#jquote)(*value*)'
- en: 'There are four [aggregate SQL functions](lang_aggfunc.html):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 共有四个[聚合 SQL 函数](lang_aggfunc.html)：
- en: '[json_group_array](#jgrouparray)(*value*)'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[json_group_array](#jgrouparray)(*value*)'
- en: '[jsonb_group_array](#jgrouparrayb)(*value*)'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[jsonb_group_array](#jgrouparrayb)(*value*)'
- en: '[json_group_object](#jgroupobject)(*label*,*value*)'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[json_group_object](#jgroupobject)(*label*,*value*)'
- en: '[jsonb_group_object](#jgroupobjectb)(name,*value*)'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[jsonb_group_object](#jgroupobjectb)(name,*value*)'
- en: 'The two [table-valued functions](vtab.html#tabfunc2) are:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 两个[表值函数](vtab.html#tabfunc2)包括：
- en: '[json_each](#jeach)(*json*)'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[json_each](#jeach)(*json*)'
- en: '[json_each](#jeach)(*json*,*path*)'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[json_each](#jeach)(*json*,*path*)'
- en: '[json_tree](#jtree)(*json*)'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[json_tree](#jtree)(*json*)'
- en: '[json_tree](#jtree)(*json*,*path*)'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[json_tree](#jtree)(*json*,*path*)'
- en: 2\. Compiling in JSON Support
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2\. 编译 JSON 支持
- en: The JSON functions and operators are built into SQLite by default, as of SQLite
    version 3.38.0 (2022-02-22). They can be omitted by adding the -DSQLITE_OMIT_JSON
    compile-time option. Prior to version 3.38.0, the JSON functions were an extension
    that would only be included in builds if the -DSQLITE_ENABLE_JSON1 compile-time
    option was included. In other words, the JSON functions went from being opt-in
    with SQLite version 3.37.2 and earlier to opt-out with SQLite version 3.38.0 and
    later.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 从 SQLite 版本 3.38.0（2022-02-22）起，默认情况下内置 JSON 函数。可以通过添加 -DSQLITE_OMIT_JSON 编译选项来省略它们。在版本
    3.38.0 之前，JSON 函数是一个扩展，只有在包含 -DSQLITE_ENABLE_JSON1 编译选项的构建中才会包括它们。换句话说，JSON 函数从
    SQLite 版本 3.37.2 及更早版本的选择性支持变为 SQLite 版本 3.38.0 及更高版本的默认支持。
- en: 3\. Interface Overview
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3\. 接口概览
- en: SQLite stores JSON as ordinary text. Backwards compatibility constraints mean
    that SQLite is only able to store values that are NULL, integers, floating-point
    numbers, text, and BLOBs. It is not possible to add a new "JSON" type.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 将 JSON 存储为普通文本。由于向后兼容性约束，SQLite 只能存储 NULL、整数、浮点数、文本和 BLOB 值。不可能添加新的“JSON”类型。
- en: 3.1\. JSON arguments
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1\. JSON 参数
- en: For functions that accept JSON as their first argument, that argument can be
    a JSON object, array, number, string, or null. SQLite numeric values and NULL
    values are interpreted as JSON numbers and nulls, respectively. SQLite text values
    can be understood as JSON objects, arrays, or strings. If an SQLite text value
    that is not a well-formed JSON object, array, or string is passed into JSON function,
    that function will usually throw an error. (Exceptions to this rule are [json_valid()](json1.html#jvalid),
    [json_quote()](json1.html#jquote), and [json_error_position()](json1.html#jerr).)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于将 JSON 作为其第一个参数接受的函数，该参数可以是 JSON 对象、数组、数字、字符串或 null。SQLite 数字值和 NULL 值分别被解释为
    JSON 数字和 null。SQLite 文本值可以理解为 JSON 对象、数组或字符串。如果将不是格式良好的 JSON 对象、数组或字符串的 SQLite
    文本值传递给 JSON 函数，则该函数通常会抛出错误。（此规则的例外包括 [json_valid()](json1.html#jvalid)、[json_quote()](json1.html#jquote)
    和 [json_error_position()](json1.html#jerr)。）
- en: These routines understand all [rfc-8259 JSON syntax](https://www.rfc-editor.org/rfc/rfc8259.txt)
    and also [JSON5 extensions](https://spec.json5.org/). JSON text generated by these
    routines always strictly conforms to the [canonical JSON definition](https://json.org)
    and does not contain any JSON5 or other extensions. The ability to read and understand
    JSON5 was added in version 3.42.0 (2023-05-16). Prior versions of SQLite would
    only read canonical JSON.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例程理解所有 [rfc-8259 JSON 语法](https://www.rfc-editor.org/rfc/rfc8259.txt)，以及 [JSON5
    扩展](https://spec.json5.org/)。这些例程生成的 JSON 文本始终严格遵循 [canonical JSON 定义](https://json.org)，不包含任何
    JSON5 或其他扩展。在版本 3.42.0（2023-05-16）中增加了读取和理解 JSON5 的功能。SQLite 的早期版本只能读取规范 JSON。
- en: 3.2\. JSONB
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2\. JSONB
- en: Beginning with version 3.45.0 (2024-01-15), SQLite allows its internal "parse
    tree" representation of JSON to be stored on disk, as a BLOB, in a format that
    we call "JSONB". By storing SQLite's internal binary representation of JSON directly
    in the database, applications can bypass the overhead of parsing and rendering
    JSON when reading and updating JSON values. The internal JSONB format also uses
    slightly less disk space then text JSON.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 3.45.0（2024-01-15）开始，SQLite 允许将其内部的 JSON 的 "解析树" 表示存储在磁盘上，作为 BLOB，以一种我们称之为
    "JSONB" 的格式。通过直接在数据库中存储 SQLite 的内部二进制表示的 JSON，应用程序可以在读取和更新 JSON 值时绕过解析和渲染 JSON
    的开销。内部的 JSONB 格式在磁盘空间上也比文本 JSON 少一些。
- en: Any SQL function parameter that accepts text JSON as an input will also accept
    a BLOB in the JSONB format. The function will operate the same in either case,
    except that it will run faster when the input is JSONB, since it does not need
    to run the JSON parser.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 任何接受文本 JSON 作为输入的 SQL 函数参数也将接受 JSONB 格式的 BLOB。无论输入是 JSON 还是 JSONB，函数的操作都相同，只是在输入为
    JSONB 时速度更快，因为无需运行 JSON 解析器。
- en: Most SQL functions that return JSON text have a corresponding function that
    returns the equivalent JSONB. The functions that return JSON in the text format
    begin with "`json_`" and functions that return the binary JSONB format begin with
    "`jsonb_`".
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数返回 JSON 文本的 SQL 函数都有对应的返回等效 JSONB 的函数。返回文本格式 JSON 的函数以 "`json_`" 开头，返回二进制
    JSONB 格式的函数以 "`jsonb_`" 开头。
- en: 3.2.1\. The JSONB format
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1\. JSONB 格式
- en: JSONB is a binary representation of JSON used by SQLite and is intended for
    internal use by SQLite only. Applications should not use JSONB outside of SQLite
    nor try to reverse-engineer the JSONB format.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: JSONB 是 SQLite 使用的 JSON 的二进制表示，仅供 SQLite 内部使用。应用程序不应在 SQLite 外部使用 JSONB，也不应尝试逆向工程
    JSONB 格式。
- en: The "JSONB" name is inspired by [PostgreSQL](https://postgresql.org), but the
    on-disk format for SQLite's JSONB is not the same as PostgreSQL's. The two formats
    have the same name, but are not binary compatible. The PostgreSQL JSONB format
    claims to offer O(1) lookup of elements in objects and arrays. SQLite's JSONB
    format makes no such claim. SQLite's JSONB has O(N) time complexity for most operations
    in SQLite, just like text JSON. The advantage of JSONB in SQLite is that it is
    smaller and faster than text JSON - potentially several times faster. There is
    space in the on-disk JSONB format to add enhancements and future versions of SQLite
    might include options to provide O(1) lookup of elements in JSONB, but no such
    capability is currently available.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: “JSONB”这个名称灵感来自于[PostgreSQL](https://postgresql.org)，但SQLite的JSONB的磁盘格式与PostgreSQL的格式不同。这两种格式有相同的名称，但二进制不兼容。PostgreSQL的JSONB格式声称可以在对象和数组中以O(1)的时间复杂度查找元素。SQLite的JSONB格式没有这样的声明。在SQLite中，SQLite的JSONB在大多数操作中具有O(N)的时间复杂度，就像文本JSON一样。SQLite的JSONB比文本JSON更小更快，潜在的速度可能快几倍。在磁盘上的JSONB格式中有空间来添加增强功能，未来的SQLite版本可能包括提供JSONB中元素O(1)查找的选项，但目前没有这样的能力。
- en: 3.2.2\. Handling of malformed JSONB
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.2\. 处理格式错误的JSONB
- en: 'The JSONB that is generated by SQLite will always be well-formed. If you follow
    recommended practice and treat JSONB as an opaque BLOB, then you will not have
    any problems. But JSONB is just a BLOB, so a mischievous programmer could devise
    BLOBs that are similar to JSONB but that are technically malformed. When misformatted
    JSONB is feed into JSON functions, any of the following might happen:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite生成的JSONB将始终是格式良好的。如果按照建议的做法将JSONB视为不透明的BLOB，那么您将不会遇到任何问题。但是JSONB只是一个BLOB，因此一个恶意的程序员可能会设计类似于JSONB但技术上不正确的BLOB。当将格式不正确的JSONB输入JSON函数时，可能会发生以下情况之一：
- en: The SQL statement might abort with a "malformed JSON" error.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL语句可能会因为“格式错误的JSON”而中止。
- en: The correct answer might be returned, if the malformed parts of the JSONB blob
    do not impact the answer.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果JSONB blob的格式错误的部分不影响答案，可能会返回正确的答案。
- en: A goofy or nonsensical answer might be returned.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能会返回一个荒谬或不合理的答案。
- en: 'The way in which SQLite handles invalid JSONB might change from one version
    of SQLite to the next. The system follows the garbage-in/garbage-out rule: If
    you feed the JSON functions invalid JSONB, you get back an invalid answer. If
    you are in doubt about the validity of our JSONB, use the [json_valid()](json1.html#jvalid)
    function to verify it.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite处理无效的JSONB的方式可能会从一个版本变化到下一个版本。系统遵循垃圾进/垃圾出的原则：如果您向JSON函数提供无效的JSONB，将返回一个无效的答案。如果您对JSONB的有效性存有疑问，请使用[json_valid()](json1.html#jvalid)函数来验证它。
- en: 'We do make this one promise: Malformed JSONB will never cause a memory error
    or similar problem that might lead to a vulnerability. Invalid JSONB might lead
    to crazy answers, or it might cause queries to abort, but it won''t cause a crash.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实做出这样一个承诺：格式错误的JSONB不会引起内存错误或类似问题，可能导致漏洞。无效的JSONB可能会导致不合理的答案，或者可能会导致查询中止，但不会导致崩溃。
- en: 3.3\. PATH arguments
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3\. PATH参数
- en: For functions that accept PATH arguments, that PATH must be well-formed or else
    the function will throw an error. A well-formed PATH is a text value that begins
    with exactly one '$' character followed by zero or more instances of ".*objectlabel*"
    or "[*arrayindex*]".
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于接受PATH参数的函数，该路径必须格式良好，否则函数将抛出错误。格式良好的PATH是以一个'$'字符开头，后面跟随零个或多个实例的“.*objectlabel*”或“[*arrayindex*]”文本值。
- en: 'The *arrayindex* is usually a non-negative integer *N*. In that case, the array
    element selected is the *N*-th element of the array, starting with zero on the
    left. The *arrayindex* can also be of the form "**#-***N*" in which case the element
    selected is the *N*-th from the right. The last element of the array is "**#-1**".
    Think of the "#" characters as the "number of elements in the array". Then the
    expression "#-1" evaluates to the integer that corresponds to the last entry in
    the array. It is sometimes useful for the array index to be just the **#** character,
    for example when appending a value to an existing JSON array:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*arrayindex*通常是非负整数*N*。在这种情况下，所选的数组元素是数组的第*N*个元素，从左边开始从零开始计数。*arrayindex*也可以是形式为“**#-***N*”，在这种情况下，所选的元素是从右边开始的第*N*个元素。数组的最后一个元素是“**#-1**”。把“#”字符看作是“数组中的元素数量”。然后表达式“#-1”评估为对应于数组中最后一个条目的整数。当追加值到现有JSON数组时，数组索引仅为“#”字符可能是有用的：'
- en: json_set('[0,1,2]','$[#]','new') → '[0,1,2,"new"]'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_set('[0,1,2]','$[#]','new') → '[0,1,2,"new"]'
- en: 3.4\. VALUE arguments
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4\. VALUE参数
- en: For functions that accept "*value*" arguments (also shown as "*value1*" and
    "*value2*"), those arguments are usually understood to be literal strings that
    are quoted and become JSON string values in the result. Even if the input *value*
    strings look like well-formed JSON, they are still interpreted as literal strings
    in the result.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于接受 "*value*" 参数的函数（也显示为 "*value1*" 和 "*value2*"），这些参数通常被理解为被引用的字面字符串，并在结果中成为
    JSON 字符串值。即使输入的 *value* 字符串看起来像格式良好的 JSON，它们在结果中仍然被解释为字面字符串。
- en: However, if a *value* argument comes directly from the result of another JSON
    function or from [the -> operator](json1.html#jptr) (but not [the ->> operator](json1.html#jptr)),
    then the argument is understood to be actual JSON and the complete JSON is inserted
    rather than a quoted string.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果 *value* 参数直接来自另一个 JSON 函数的结果或者来自 [-> 运算符](json1.html#jptr)（但不是 [->> 运算符](json1.html#jptr)），那么该参数被理解为实际的
    JSON，完整的 JSON 将被插入而不是一个带引号的字符串。
- en: 'For example, in the following call to json_object(), the *value* argument looks
    like a well-formed JSON array. However, because it is just ordinary SQL text,
    it is interpreted as a literal string and added to the result as a quoted string:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在以下调用 json_object() 中，*value* 参数看起来像一个格式良好的 JSON 数组。然而，因为它只是普通的 SQL 文本，它被解释为字面字符串并作为带引号的字符串添加到结果中：
- en: json_object('ex','[52,3.14159]') → '{"ex":"[52,3.14159]"}'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_object('ex','[52,3.14159]') → '{"ex":"[52,3.14159]"}'
- en: json_object('ex',('[52,3.14159]'->>'$')) → '{"ex":"[52,3.14159]"}'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_object('ex',('[52,3.14159]'->>'$')) → '{"ex":"[52,3.14159]"}'
- en: 'But if the *value* argument in the outer json_object() call is the result of
    another JSON function like [json()](json1.html#jmini) or [json_array()](json1.html#jarray),
    then the value is understood to be actual JSON and is inserted as such:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果外部 json_object() 调用中的 *value* 参数是另一个 JSON 函数（如 [json()](json1.html#jmini)
    或 [json_array()](json1.html#jarray)）的结果，那么该值被理解为实际的 JSON，并作为这样插入：
- en: json_object('ex',json('[52,3.14159]')) → '{"ex":[52,3.14159]}'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_object('ex',json('[52,3.14159]')) → '{"ex":[52,3.14159]}'
- en: json_object('ex',json_array(52,3.14159)) → '{"ex":[52,3.14159]}'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_object('ex',json_array(52,3.14159)) → '{"ex":[52,3.14159]}'
- en: json_object('ex','[52,3.14159]'->'$') → '{"ex":[52,3.14159]}'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_object('ex','[52,3.14159]'->'$') → '{"ex":[52,3.14159]}'
- en: 'To be clear: "*json*" arguments are always interpreted as JSON regardless of
    where the value for that argument comes from. But "*value*" arguments are only
    interpreted as JSON if those arguments come directly from another JSON function
    or [the -> operator](json1.html#jptr).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 明确一点：无论 *json* 参数的值来自何处，它们始终被解释为 JSON。但是，*value* 参数仅在该参数直接来自另一个 JSON 函数或 [->
    运算符](json1.html#jptr) 时才被解释为 JSON。
- en: Within JSON value arguments interpreted as JSON strings, Unicode escape sequences
    are not treated as equivalent to the characters or escaped control characters
    represented by the expressed Unicode code point. Such escape sequences are not
    translated or specially treated; they are treated as plain text by SQLite's JSON
    functions.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在被解释为 JSON 字符串的 JSON 值参数中，Unicode 转义序列不被视为等同于所表示的字符或转义的控制字符。这些转义序列不被翻译或特殊处理；它们被
    SQLite 的 JSON 函数视为普通文本。
- en: 3.5\. Compatibility
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5\. 兼容性
- en: The current implementation of this JSON library uses a recursive descent parser.
    In order to avoid using excess stack space, any JSON input that has more than
    1000 levels of nesting is considered invalid. Limits on nesting depth are allowed
    for compatible implementations of JSON by [RFC-8259 section 9](https://tools.ietf.org/html/rfc8259#section-9).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 JSON 库的当前实现使用递归下降解析器。为了避免使用过多的堆栈空间，任何具有超过 1000 层嵌套的 JSON 输入都被视为无效。JSON 嵌套深度的限制允许兼容的实现按照
    [RFC-8259 第 9 节](https://tools.ietf.org/html/rfc8259#section-9) 进行。
- en: 3.6\. JSON5 Extensions
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.6\. JSON5 扩展
- en: Beginning in version 3.42.0 (2023-05-16), these routines will read and interpret
    input JSON text that includes [JSON5](https://spec.json5.org/) extensions. However,
    JSON text generated by these routines will always be strictly conforming to the
    [canonical definition of JSON](https://json.org).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 3.42.0（2023-05-16）开始，这些例程将读取并解释包含 [JSON5](https://spec.json5.org/) 扩展的输入
    JSON 文本。然而，这些例程生成的 JSON 文本始终严格符合 [JSON 的规范定义](https://json.org)。
- en: 'Here is a synopsis of JSON5 extensions (adapted from the [JSON5 specification](https://spec.json5.org/#introduction)):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 JSON5 扩展的简介（改编自 [JSON5 规范](https://spec.json5.org/#introduction)）：
- en: Object keys may be unquoted identifiers.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象键可以是未引用的标识符。
- en: Objects may have a single trailing comma.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象可能有单个尾随逗号。
- en: Arrays may have a single trailing comma.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组可能有单个尾随逗号。
- en: Strings may be single quoted.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串可以用单引号括起来。
- en: Strings may span multiple lines by escaping new line characters.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串可以通过转义换行符跨越多行。
- en: Strings may include new character escapes.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串可以包含新的字符转义序列。
- en: Numbers may be hexadecimal.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字可以是十六进制。
- en: Numbers may have a leading or trailing decimal point.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字可能具有前导或尾随小数点。
- en: Numbers may be "Infinity", "-Infinity", and "NaN".
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字可以是"Infinity"、"-Infinity"和"NaN"。
- en: Numbers may begin with an explicit plus sign.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字可以以显式加号开头。
- en: Single (//...) and multi-line (/*...*/) comments are allowed.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用单行（//...）和多行（/*...*/）注释。
- en: Additional white space characters are allowed.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许额外的空白字符。
- en: 'To convert string X from JSON5 into canonical JSON, invoke "[json(X)](json1.html#jmini)".
    The output of the "[json()](json1.html#jmini)" function will be canonical JSON
    regardless of any JSON5 extensions that are present in the input. For backwards
    compatibility, the [json_valid(X)](json1.html#jvalid) function without a "flags"
    argument continues to report false for inputs that are not canonical JSON, even
    if the input is JSON5 that the function is able to understand. To determine whether
    or not an input string is valid JSON5, include the 0x02 bit in the "flags" argument
    to json_valid: "`json_valid(X,2)`".'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要将JSON5中的字符串X转换为规范JSON，请调用"[json(X)](json1.html#jmini)"。"[json()](json1.html#jmini)"函数的输出将始终是规范JSON，无论输入中是否存在任何JSON5扩展。为了向后兼容，不带"flags"参数的[json_valid(X)](json1.html#jvalid)函数仍然对非规范JSON的输入报告false，即使该函数能够理解JSON5。要确定输入字符串是否有效的JSON5，请在json_valid的"flags"参数中包含0x02位："`json_valid(X,2)`"。
- en: 'These routines understand all of JSON5, plus a little more. SQLite extends
    the JSON5 syntax in these two ways:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例程理解所有的JSON5，并且稍微扩展。SQLite在以下两个方面扩展了JSON5语法：
- en: Strict JSON5 requires that unquoted object keys must be ECMAScript 5.1 IdentifierNames.
    But large unicode tables and lots of code is required in order to determine whether
    or not a key is an ECMAScript 5.1 IdentifierName. For this reason, SQLite allows
    object keys to include any unicode characters greater than U+007f that are not
    whitespace characters. This relaxed definition of "identifier" greatly simplifies
    the implementation and allows the JSON parser to be smaller and run faster.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 严格的JSON5要求未引用的对象键必须是ECMAScript 5.1标识符名。但是，为了确定键是否为ECMAScript 5.1标识符名，需要大量的Unicode表和大量的代码。因此，SQLite允许对象键包含任何大于U+007f且不是空白字符的Unicode字符。这种放宽对“标识符”的定义大大简化了实现，并允许JSON解析器更小、运行更快。
- en: JSON5 allows floating-point infinities to be expressed as "`Infinity`", "`-Infinity`",
    or "`+Infinity`" in exactly that case - the initial "I" is capitalized and all
    other characters are lower case. SQLite also allows the abbreviation "`Inf`" to
    be used in place of "`Infinity`" and it allows both keywords to appear in any
    combination of upper and lower case letters. Similarly, JSON5 allows "NaN" for
    not-a-number. SQLite extends this to also allow "QNaN" and "SNaN" in any combination
    of upper and lower case letters. Note that SQLite interprets NaN, QNaN, and SNaN
    as just an alternative spellings for "null". This extension has been added because
    (we are told) there exists a lot of JSON in the wild that includes these non-standard
    representations for infinity and not-a-number.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JSON5允许用"`Infinity`"、"`-Infinity`"或"`+Infinity`"表示浮点无穷大，这种情况下，“I”要大写，其他字符要小写。SQLite还允许缩写"`Inf`"代替"`Infinity`"，并且允许这两个关键词以任何大小写组合出现。类似地，JSON5允许使用"NaN"表示非数值。SQLite将其扩展到还允许"QNaN"和"SNaN"以任何大小写形式出现。注意，SQLite将NaN、QNaN和SNaN解释为"null"的替代拼写形式。这一扩展是因为（据说）在野外存在许多包含这些非标准表示的JSON。
- en: 3.7\. Performance Considerations
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.7\. 性能考虑
- en: Most JSON functions do their internal processing using JSONB. So if the input
    is text, they first most translate the input text into JSONB. If the input is
    already in the JSONB format, no translation is needed, that step can be skipped,
    and performance is faster.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数JSON函数使用JSONB进行内部处理。因此，如果输入是文本，则它们首先将输入文本转换为JSONB。如果输入已经是JSONB格式，则不需要转换，可以跳过该步骤，从而提高性能。
- en: For that reason, when an argument to one JSON function is supplied by another
    JSON function, it is usually more efficient to use the "`jsonb_`" variant for
    the function used as the argument.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当一个JSON函数的参数由另一个JSON函数提供时，通常更高效的方法是使用作为参数使用的"`jsonb_`"变体。
- en: '`... json_insert(A,''$.b'',json(C)) ...`   ← Less efficient.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`... json_insert(A,''$.b'',json(C)) ...`   ← 效率较低。'
- en: '`... json_insert(A,''$.b'',jsonb(C)) ...`   ← More efficient.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`... json_insert(A,''$.b'',jsonb(C)) ...`   ← 效率更高。'
- en: The [aggregate JSON SQL functions](json1.html#jgroupobjectb) are an exception
    to this rule. Those functions all do their processing using text instead of JSONB.
    So for the aggregate JSON SQL functions, it is more efficient for the arguments
    to be supplied using "`json_`" functions than "`jsonb_`" functions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[聚合 JSON SQL 函数](json1.html#jgroupobjectb) 是此规则的一个例外。这些函数都使用文本而不是 JSONB 进行处理。因此，对于聚合
    JSON SQL 函数，使用 "`json_`" 函数而不是 "`jsonb_`" 函数来提供参数更为有效。'
- en: '`... json_group_array(json(A))) ...`   ← More efficient.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`... json_group_array(json(A))) ...`   ← 效率更高。'
- en: '`... json_group_array(jsonb(A))) ...`   ← Less efficient.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`... json_group_array(jsonb(A))) ...`   ← 效率较低。'
- en: 3.8\. The JSON BLOB Input Bug
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.8\. JSON BLOB 输入 Bug
- en: If a JSON input is a BLOB that is not JSONB and that looks like text JSON when
    cast to text, then it is accepted as text JSON. This is actually a long-standing
    bug in the original implementation that the SQLite developers were unaware of.
    The documentation stated that a BLOB input to a JSON function should raise an
    error. But in the actual implementation, the input would be accepted as long as
    the BLOB content was a valid JSON string in the text encoding of the database.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个 JSON 输入是一个不是 JSONB 类型的 BLOB，并且在转换为文本时看起来像文本 JSON，那么它将被接受为文本 JSON。这实际上是原始实现中的一个长期存在的
    bug，SQLite 的开发人员对此并不知情。文档中声明，将 BLOB 输入到 JSON 函数应该引发错误。但实际上的实现中，只要 BLOB 内容在数据库的文本编码中是一个有效的
    JSON 字符串，就会被接受。
- en: 'This JSON BLOB input bug was accidentally fixed when the JSON routines were
    reimplemented for the 3.45.0 release (2024-01-15). That caused breakage in applications
    that had come to depend on the old behavior. (In defense of those applications:
    they were often lured into using BLOBs as JSON by the [readfile()](cli.html#fileio)
    SQL function available in the [CLI](cli.html). Readfile() was used to read JSON
    from disk files, but readfile() returns a BLOB. And that worked for them, so why
    not just do it?)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当 JSON 例程在 3.45.0 版本（2024-01-15）重新实现时，意外修复了此 JSON BLOB 输入 bug。这导致依赖旧行为的应用程序出现了故障。（为了那些应用程序辩护：它们经常被诱导使用
    BLOBs 作为 JSON，因为在 [CLI](cli.html) 中可用的 [readfile()](cli.html#fileio) SQL 函数可以从磁盘文件中读取
    JSON。但 readfile() 返回一个 BLOB，并且对它们有效，那么为什么不这样做呢？）
- en: For backwards compatibility, the (formerly incorrect) legacy behavior of interpreting
    BLOBs as text JSON if no other interpretation works is hereby documented and is
    be officially supported in version 3.45.1 (2024-01-30) and all subsequent releases.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向后兼容，如果没有其他解释适用，则现在记录的（先前不正确的）旧行为解释 BLOBs 为文本 JSON，并且在版本 3.45.1（2024-01-30）及其所有后续版本中官方支持。
- en: 4\. Function Details
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4\. 函数详情
- en: 'The following sections provide additional detail on the operation of the various
    JSON functions and operators:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的部分提供了关于各种 JSON 函数和操作的详细信息：
- en: 4.1\. The json() function
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1\. json() 函数
- en: The json(X) function verifies that its argument X is a valid JSON string or
    JSONB blob and returns a minified version of that JSON string with all unnecessary
    whitespace removed. If X is not a well-formed JSON string or JSONB blob, then
    this routine throws an error.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: json(X) 函数验证其参数 X 是否是有效的 JSON 字符串或 JSONB BLOB，并返回该 JSON 字符串的缩减版本，去除所有不必要的空白。如果
    X 不是格式良好的 JSON 字符串或 JSONB BLOB，则此例程会抛出错误。
- en: If the input is JSON5 text, then it is converted into canonical RFC-8259 text
    prior to being returned.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入是 JSON5 文本，则在返回之前将其转换为规范的 RFC-8259 文本。
- en: If the argument X to json(X) contains JSON objects with duplicate labels, then
    it is undefined whether or not the duplicates are preserved. The current implementation
    preserves duplicates. However, future enhancements to this routine may choose
    to silently remove duplicates.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 json(X) 的参数 X 包含具有重复标签的 JSON 对象，则未定义是否保留重复项。当前实现保留重复项。但是，此例程的未来增强可能会选择静默删除重复项。
- en: 'Example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: 'json('' { "this" : "is", "a": [ "test" ] } '') → ''{"this":"is","a":["test"]}'''
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'json('' { "this" : "is", "a": [ "test" ] } '') → ''{"this":"is","a":["test"]}'''
- en: 4.2\. The jsonb() function
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2\. jsonb() 函数
- en: The jsonb(X) function returns the binary JSONB representation of the JSON provided
    as argument X. An error is raised if X is TEXT that does not have valid JSON syntax.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: jsonb(X) 函数返回作为参数 X 提供的 JSON 的二进制 JSONB 表示。如果 X 是不具有有效 JSON 语法的 TEXT，则会引发错误。
- en: If X is a BLOB and appears to be JSONB, then this routine simply returns a copy
    of X. Only the outer-most element of the JSONB input is examined, however. The
    deep structure of the JSONB is not validated.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 X 是 BLOB 类型并且看起来是 JSONB，则此例程简单地返回 X 的副本。然而，只检查 JSONB 输入的最外层元素。不验证 JSONB 的深层结构。
- en: 4.3\. The json_array() function
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3\. json_array() 函数
- en: The json_array() SQL function accepts zero or more arguments and returns a well-formed
    JSON array that is composed from those arguments. If any argument to json_array()
    is a BLOB then an error is thrown.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: json_array() SQL 函数接受零个或多个参数，并返回一个由这些参数组成的格式良好的 JSON 数组。如果 json_array() 的任何参数是
    BLOB 类型，则会抛出错误。
- en: An argument with SQL type TEXT is normally converted into a quoted JSON string.
    However, if the argument is the output from another json1 function, then it is
    stored as JSON. This allows calls to json_array() and [json_object()](json1.html#jobj)
    to be nested. The [json()](json1.html#jmini) function can also be used to force
    strings to be recognized as JSON.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 类型为 TEXT 的参数通常会被转换为带引号的 JSON 字符串。但是，如果参数是另一个 json1 函数的输出，则会以 JSON 格式存储。这允许嵌套调用
    json_array() 和 [json_object()](json1.html#jobj)。[json()](json1.html#jmini) 函数也可以用来强制字符串被识别为
    JSON。
- en: 'Examples:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '示例:'
- en: json_array(1,2,'3',4) → '[1,2,"3",4]'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_array(1,2,'3',4) → '[1,2,"3",4]'
- en: json_array('[1,2]') → '["[1,2]"]'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_array('[1,2]') → '["[1,2]"]'
- en: json_array(json_array(1,2)) → '[[1,2]]'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_array(json_array(1,2)) → '[[1,2]]'
- en: json_array(1,null,'3','[4,5]','{"six":7.7}') → '[1,null,"3","[4,5]","{\"six\":7.7}"]'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_array(1,null,'3','[4,5]','{"six":7.7}') → '[1,null,"3","[4,5]","{\"six\":7.7}"]'
- en: json_array(1,null,'3',json('[4,5]'),json('{"six":7.7}')) → '[1,null,"3",[4,5],{"six":7.7}]'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_array(1,null,'3',json('[4,5]'),json('{"six":7.7}')) → '[1,null,"3",[4,5],{"six":7.7}]'
- en: 4.4\. The jsonb_array() function
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4\. jsonb_array() 函数
- en: The jsonb_array() SQL function works just like the [json_array()](json1.html#jarray)
    function except that it returns the constructed JSON array in the SQLite's private
    JSONB format rather than in the standard RFC 8259 text format.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: jsonb_array() SQL 函数的工作方式与 [json_array()](json1.html#jarray) 函数相同，只是它返回 SQLite
    的私有 JSONB 格式构造的 JSON 数组，而不是标准的 RFC 8259 文本格式。
- en: 4.5\. The json_array_length() function
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5\. json_array_length() 函数
- en: The json_array_length(X) function returns the number of elements in the JSON
    array X, or 0 if X is some kind of JSON value other than an array. The json_array_length(X,P)
    locates the array at path P within X and returns the length of that array, or
    0 if path P locates an element in X that is not a JSON array, and NULL if path
    P does not locate any element of X. Errors are thrown if either X is not well-formed
    JSON or if P is not a well-formed path.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: json_array_length(X) 函数返回 JSON 数组 X 中的元素数量，如果 X 是除数组之外的某种 JSON 值，则返回 0。json_array_length(X,P)
    在 X 中定位路径 P 处的数组，并返回该数组的长度，如果路径 P 定位到 X 中非 JSON 数组的元素，则返回 0，如果路径 P 没有定位到 X 的任何元素，则返回
    NULL。如果 X 不是格式良好的 JSON 或者 P 不是格式良好的路径，则会抛出错误。
- en: 'Examples:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '示例:'
- en: json_array_length('[1,2,3,4]') → 4
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_array_length('[1,2,3,4]') → 4
- en: json_array_length('[1,2,3,4]', '$') → 4
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_array_length('[1,2,3,4]', '$') → 4
- en: json_array_length('[1,2,3,4]', '$[2]') → 0
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_array_length('[1,2,3,4]', '$[2]') → 0
- en: json_array_length('{"one":[1,2,3]}') → 0
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_array_length('{"one":[1,2,3]}') → 0
- en: json_array_length('{"one":[1,2,3]}', '$.one') → 3
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_array_length('{"one":[1,2,3]}', '$.one') → 3
- en: json_array_length('{"one":[1,2,3]}', '$.two') → NULL
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_array_length('{"one":[1,2,3]}', '$.two') → NULL
- en: 4.6\. The json_error_position() function
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6\. json_error_position() 函数
- en: The json_error_position(X) function returns 0 if the input X is a well-formed
    JSON or JSON5 string. If the input X contains one or more syntax errors, then
    this function returns the character position of the first syntax error. The left-most
    character is position 1.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: json_error_position(X) 函数如果输入 X 是格式良好的 JSON 或 JSON5 字符串，则返回 0。如果输入 X 包含一个或多个语法错误，则该函数返回第一个语法错误的字符位置。最左边的字符位置是
    1。
- en: If the input X is a BLOB, then this routine returns 0 if X is a well-formed
    JSONB blob. If the return value is positive, then it represents the *approximate*
    1-based position in the BLOB of the first detected error.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入 X 是 BLOB，则此例程返回 0 如果 X 是格式良好的 JSONB BLOB。如果返回值为正数，则表示检测到的第一个错误的*大致*基于 1
    的位置。
- en: The json_error_position() function was added with SQLite version 3.42.0 (2023-05-16).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: json_error_position() 函数是在 SQLite 版本 3.42.0 (2023-05-16) 中添加的。
- en: 4.7\. The json_extract() function
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.7\. json_extract() 函数
- en: The json_extract(X,P1,P2,...) extracts and returns one or more values from the
    well-formed JSON at X. If only a single path P1 is provided, then the SQL datatype
    of the result is NULL for a JSON null, INTEGER or REAL for a JSON numeric value,
    an INTEGER zero for a JSON false value, an INTEGER one for a JSON true value,
    the dequoted text for a JSON string value, and a text representation for JSON
    object and array values. If there are multiple path arguments (P1, P2, and so
    forth) then this routine returns SQLite text which is a well-formed JSON array
    holding the various values.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: json_extract(X,P1,P2,...) 函数从 X 中提取并返回一个或多个值，这些值是形式良好的 JSON。如果只提供了单个路径 P1，则结果的
    SQL 数据类型是 JSON null 时为 NULL，JSON 数值时为 INTEGER 或 REAL，JSON false 时为 INTEGER 0，JSON
    true 时为 INTEGER 1，JSON 字符串值的去引号文本，以及 JSON 对象和数组值的文本表示。如果有多个路径参数（P1、P2 等），则此函数返回一个
    SQLite 文本，其中包含各个值的形式良好的 JSON 数组。
- en: 'Examples:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: json_extract('{"a":2,"c":[4,5,{"f":7}]}', '$') → '{"a":2,"c":[4,5,{"f":7}]}'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_extract('{"a":2,"c":[4,5,{"f":7}]}', '$') → '{"a":2,"c":[4,5,{"f":7}]}'
- en: json_extract('{"a":2,"c":[4,5,{"f":7}]}', '$.c') → '[4,5,{"f":7}]'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_extract('{"a":2,"c":[4,5,{"f":7}]}', '$.c') → '[4,5,{"f":7}]'
- en: json_extract('{"a":2,"c":[4,5,{"f":7}]}', '$.c[2]') → '{"f":7}'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_extract('{"a":2,"c":[4,5,{"f":7}]}', '$.c[2]') → '{"f":7}'
- en: json_extract('{"a":2,"c":[4,5,{"f":7}]}', '$.c[2].f') → 7
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_extract('{"a":2,"c":[4,5,{"f":7}]}', '$.c[2].f') → 7
- en: json_extract('{"a":2,"c":[4,5],"f":7}','$.c','$.a') → '[[4,5],2]'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_extract('{"a":2,"c":[4,5],"f":7}','$.c','$.a') → '[[4,5],2]'
- en: json_extract('{"a":2,"c":[4,5],"f":7}','$.c[#-1]') → 5
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_extract('{"a":2,"c":[4,5],"f":7}','$.c[#-1]') → 5
- en: json_extract('{"a":2,"c":[4,5,{"f":7}]}', '$.x') → NULL
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_extract('{"a":2,"c":[4,5,{"f":7}]}', '$.x') → NULL
- en: json_extract('{"a":2,"c":[4,5,{"f":7}]}', '$.x', '$.a') → '[null,2]'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_extract('{"a":2,"c":[4,5,{"f":7}]}', '$.x', '$.a') → '[null,2]'
- en: json_extract('{"a":"xyz"}', '$.a') → 'xyz'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_extract('{"a":"xyz"}', '$.a') → 'xyz'
- en: json_extract('{"a":null}', '$.a') → NULL
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_extract('{"a":null}', '$.a') → NULL
- en: There is a subtle incompatibility between the json_extract() function in SQLite
    and the json_extract() function in MySQL. The MySQL version of json_extract()
    always returns JSON. The SQLite version of json_extract() only returns JSON if
    there are two or more PATH arguments (because the result is then a JSON array)
    or if the single PATH argument references an array or object. In SQLite, if json_extract()
    has only a single PATH argument and that PATH references a JSON null or a string
    or a numeric value, then json_extract() returns the corresponding SQL NULL, TEXT,
    INTEGER, or REAL value.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 中的 json_extract() 函数与 MySQL 中的 json_extract() 函数之间存在微妙的不兼容性。MySQL 版本的
    json_extract() 总是返回 JSON。SQLite 版本的 json_extract() 只有在有两个或更多 PATH 参数时才返回 JSON（因为结果是一个
    JSON 数组），或者如果单个 PATH 参数引用了数组或对象。在 SQLite 中，如果 json_extract() 只有一个单独的 PATH 参数，并且该
    PATH 引用了 JSON 的 null、字符串或数值，则 json_extract() 返回相应的 SQL NULL、TEXT、INTEGER 或 REAL
    值。
- en: 'The difference between MySQL json_extract() and SQLite json_extract() really
    only stands out when accessing individual values within the JSON that are strings
    or NULLs. The following table demonstrates the difference:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL json_extract() 和 SQLite json_extract() 之间的区别只有在访问 JSON 中的字符串或 NULL 值时才显著。以下表格展示了这种差异：
- en: '| Operation | SQLite Result | MySQL Result |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| Operation | SQLite Result | MySQL Result |'
- en: '| json_extract(''{"a":null,"b":"xyz"}'',''$.a'') | NULL | ''null'' |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| json_extract(''{"a":null,"b":"xyz"}'',''$.a'') | NULL | ''null'' |'
- en: '| json_extract(''{"a":null,"b":"xyz"}'',''$.b'') | ''xyz'' | ''"xyz"'' |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| json_extract(''{"a":null,"b":"xyz"}'',''$.b'') | ''xyz'' | ''"xyz"'' |'
- en: 4.8\. The jsonb_extract() function
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.8\. The jsonb_extract() function
- en: The jsonb_extract() function works the same as the [json_extract()](json1.html#jex)
    function, except in cases where json_extract() would normally return a text JSON
    array object, this routine returns the array or object in the JSONB format. For
    the common case where a text, numeric, null, or boolean JSON element is returned,
    this routine works exactly the same as json_extract().
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: jsonb_extract() 函数与 [json_extract()](json1.html#jex) 函数的工作方式相同，除了在 json_extract()
    通常返回文本 JSON 数组对象的情况下，此函数以 JSONB 格式返回数组或对象。对于返回文本、数值、null 或布尔值的常见情况，此函数与 json_extract()
    完全相同。
- en: 4.9\. The -> and ->> operators
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.9\. The -> and ->> operators
- en: Beginning with SQLite version 3.38.0 (2022-02-22), the -> and ->> operators
    are available for extracting subcomponents of JSON. The SQLite implementation
    of -> and ->> strives to be compatible with both MySQL and PostgreSQL. The ->
    and ->> operators take a JSON string or JSONB blob as their left operand and a
    PATH expression or object field label or array index as their right operand. The
    -> operator returns a text JSON representation of the selected subcomponent or
    NULL if that subcomponent does not exist. The ->> operator returns an SQL TEXT,
    INTEGER, REAL, or NULL value that represents the selected subcomponent, or NULL
    if the subcomponent does not exist.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 自 SQLite 版本 3.38.0（2022-02-22）起，**->** 和 **->>** 操作符可用于提取 JSON 的子组件。SQLite 的
    **->** 和 **->>** 实现力求与 MySQL 和 PostgreSQL 兼容。**->** 和 **->>** 操作符以 JSON 字符串或 JSONB
    blob 作为其左操作数，并以 PATH 表达式或对象字段标签或数组索引作为其右操作数。**->** 操作符返回所选子组件的文本 JSON 表示或 NULL（如果该子组件不存在）。**->>**
    操作符返回表示所选子组件的 SQL TEXT、INTEGER、REAL 或 NULL 值，如果子组件不存在，则返回 NULL。
- en: Both the -> and ->> operators select the same subcomponent of the JSON to their
    left. The difference is that -> always returns a JSON representation of that subcomponent
    and the ->> operator always returns an SQL representation of that subcomponent.
    Thus, these operators are subtly different from a two-argument [json_extract()](json1.html#jex)
    function call. A call to json_extract() with two arguments will return a JSON
    representation of the subcomponent if and only if the subcomponent is a JSON array
    or object, and will return an SQL representation of the subcomponent if the subcomponent
    is a JSON null, string, or numeric value.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**->** 和 **->>** 操作符选择其左侧 JSON 的相同子组件。不同之处在于 **->** 始终返回该子组件的 JSON 表示，而 **->>**
    操作符始终返回该子组件的 SQL 表示。因此，这些操作符与双参数 [json_extract()](json1.html#jex) 函数调用略有不同。调用
    json_extract() 时，如果子组件是 JSON 数组或对象，则返回其 JSON 表示，否则返回其 SQL 表示（如果子组件是 JSON null、字符串或数值）。'
- en: When the -> operator returns JSON, it always returns the RFC 8565 text representation
    of that JSON, not JSONB. Use the [jsonb_extract()](json1.html#jexb) function if
    you need a subcomponent in the JSONB format.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当 **->** 操作符返回 JSON 时，它始终返回该 JSON 的 RFC 8565 文本表示，而不是 JSONB。如果需要 JSONB 格式中的子组件，请使用
    [jsonb_extract()](json1.html#jexb) 函数。
- en: The right-hand operand to the -> and ->> operators can be a well-formed JSON
    path expression. This is the form used by MySQL. For compatibility with PostgreSQL,
    the -> and ->> operators also accept a text object label or integer array index
    as their right-hand operand. If the right operand is a text label X, then it is
    interpreted as the JSON path '$.X'. If the right operand is an integer value N,
    then it is interpreted as the JSON path '$[N]'.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**->** 和 **->>** 操作符的右操作数可以是形成良好的 JSON 路径表达式。这是 MySQL 使用的形式。为了与 PostgreSQL
    兼容，**->** 和 **->>** 操作符还接受右操作数作为文本对象标签或整数数组索引。如果右操作数是文本标签 X，则其解释为 JSON 路径 ''$.X''。如果右操作数是整数值
    N，则其解释为 JSON 路径 ''$[N]''。'
- en: 'Examples:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '''{"a":2,"c":[4,5,{"f":7}]}'' -> ''$'' → ''{"a":2,"c":[4,5,{"f":7}]}'''
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''{"a":2,"c":[4,5,{"f":7}]}'' -> ''$'' → ''{"a":2,"c":[4,5,{"f":7}]}'''
- en: '''{"a":2,"c":[4,5,{"f":7}]}'' -> ''$.c'' → ''[4,5,{"f":7}]'''
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''{"a":2,"c":[4,5,{"f":7}]}'' -> ''$.c'' → ''[4,5,{"f":7}]'''
- en: '''{"a":2,"c":[4,5,{"f":7}]}'' -> ''c'' → ''[4,5,{"f":7}]'''
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''{"a":2,"c":[4,5,{"f":7}]}'' -> ''c'' → ''[4,5,{"f":7}]'''
- en: '''{"a":2,"c":[4,5,{"f":7}]}'' -> ''$.c[2]'' → ''{"f":7}'''
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''{"a":2,"c":[4,5,{"f":7}]}'' -> ''$.c[2]'' → ''{"f":7}'''
- en: '''{"a":2,"c":[4,5,{"f":7}]}'' -> ''$.c[2].f'' → ''7'''
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''{"a":2,"c":[4,5,{"f":7}]}'' -> ''$.c[2].f'' → ''7'''
- en: '''{"a":2,"c":[4,5,{"f":7}]}'' ->> ''$.c[2].f'' → 7'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''{"a":2,"c":[4,5,{"f":7}]}'' ->> ''$.c[2].f'' → 7'
- en: '''{"a":2,"c":[4,5,{"f":7}]}'' -> ''c'' -> 2 ->> ''f'' → 7'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''{"a":2,"c":[4,5,{"f":7}]}'' -> ''c'' -> 2 ->> ''f'' → 7'
- en: '''{"a":2,"c":[4,5],"f":7}'' -> ''$.c[#-1]'' → ''5'''
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''{"a":2,"c":[4,5],"f":7}'' -> ''$.c[#-1]'' → ''5'''
- en: '''{"a":2,"c":[4,5,{"f":7}]}'' -> ''$.x'' → NULL'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''{"a":2,"c":[4,5,{"f":7}]}'' -> ''$.x'' → NULL'
- en: '''[11,22,33,44]'' -> 3 → ''44'''
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''[11,22,33,44]'' -> 3 → ''44'''
- en: '''[11,22,33,44]'' ->> 3 → 44'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''[11,22,33,44]'' ->> 3 → 44'
- en: '''{"a":"xyz"}'' -> ''$.a'' → ''"xyz"'''
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''{"a":"xyz"}'' -> ''$.a'' → ''"xyz"'''
- en: '''{"a":"xyz"}'' ->> ''$.a'' → ''xyz'''
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''{"a":"xyz"}'' ->> ''$.a'' → ''xyz'''
- en: '''{"a":null}'' -> ''$.a'' → ''null'''
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''{"a":null}'' -> ''$.a'' → ''null'''
- en: '''{"a":null}'' ->> ''$.a'' → NULL'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''{"a":null}'' ->> ''$.a'' → NULL'
- en: 4.10\. The json_insert(), json_replace, and json_set() functions
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.10\. json_insert()、json_replace 和 json_set() 函数
- en: The json_insert(), json_replace, and json_set() functions all take a single
    JSON value as their first argument followed by zero or more pairs of path and
    value arguments, and return a new JSON string formed by updating the input JSON
    by the path/value pairs. The functions differ only in how they deal with creating
    new values and overwriting preexisting values.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: json_insert()、json_replace和json_set()函数的第一个参数始终是原始JSON，后面跟随零个或多个路径和值参数对，返回通过路径/值对更新输入JSON形成的新JSON字符串。这些函数在处理创建新值和覆盖现有值时略有不同。
- en: '| Function | Overwrite if already exists? | Create if does not exist? |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| Function | 如果已存在则覆盖？ | 如果不存在则创建？ |'
- en: '| json_insert() | No | Yes |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| json_insert() | 否 | 是 |'
- en: '| json_replace() | Yes | No |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| json_replace() | 是 | 否 |'
- en: '| json_set() | Yes | Yes |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| json_set() | 是 | 是 |'
- en: The json_insert(), json_replace(), and json_set() functions always take an odd
    number of arguments. The first argument is always the original JSON to be edited.
    Subsequent arguments occur in pairs with the first element of each pair being
    a path and the second element being the value to insert or replace or set on that
    path.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: json_insert()、json_replace()和json_set()函数始终接受奇数个参数。第一个参数始终是要编辑的原始JSON。随后的参数成对出现，每对的第一个元素是路径，第二个元素是要在该路径上插入、替换或设置的值。
- en: Edits occur sequentially from left to right. Changes caused by prior edits can
    affect the path search for subsequent edits.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑按从左到右的顺序依次发生。先前的编辑引起的更改可能会影响后续编辑的路径搜索。
- en: If the value of a path/value pair is an SQLite TEXT value, then it is normally
    inserted as a quoted JSON string, even if the string looks like valid JSON. However,
    if the value is the result of another json function (such as [json()](json1.html#jmini)
    or [json_array()](json1.html#jarray) or [json_object()](json1.html#jobj)) or if
    it is the result of [the -> operator](json1.html#jptr), then it is interpreted
    as JSON and is inserted as JSON retaining all of its substructure. Values that
    are the result of [the ->> operator](json1.html#jptr) are always interpreted as
    TEXT and are inserted as a JSON string even if they look like valid JSON.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果路径/值对的值是SQLite TEXT值，则通常会作为带引号的JSON字符串插入，即使该字符串看起来像有效的JSON。但是，如果值是另一个json函数（例如[json()](json1.html#jmini)或[json_array()](json1.html#jarray)或[json_object()](json1.html#jobj)的结果，或者它是[->运算符](json1.html#jptr)的结果，则将其解释为JSON并插入为保留其所有子结构的JSON。使用[->>运算符](json1.html#jptr)的值始终被解释为TEXT，并且即使它看起来像有效的JSON，也被插入为JSON字符串。
- en: These routines throw an error if the first JSON argument is not well-formed
    or if any PATH argument is not well-formed or if any argument is a BLOB.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例程如果第一个JSON参数格式不正确或任何路径参数格式不正确或任何参数是BLOB，则会抛出错误。
- en: 'To append an element onto the end of an array, using json_insert() with an
    array index of "#". Examples:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要将元素追加到数组的末尾，可以使用带有数组索引"#的json_insert()。例如：
- en: json_insert('[1,2,3,4]','$[#]',99) → '[1,2,3,4,99]'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_insert('[1,2,3,4]','$[#]',99) → '[1,2,3,4,99]'
- en: json_insert('[1,[2,3],4]','$[1][#]',99) → '[1,[2,3,99],4]'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_insert('[1,[2,3],4]','$[1][#]',99) → '[1,[2,3,99],4]'
- en: 'Other examples:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 其他例子：
- en: json_insert('{"a":2,"c":4}', '$.a', 99) → '{"a":2,"c":4}'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_insert('{"a":2,"c":4}', '$.a', 99) → '{"a":2,"c":4}'
- en: json_insert('{"a":2,"c":4}', '$.e', 99) → '{"a":2,"c":4,"e":99}'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_insert('{"a":2,"c":4}', '$.e', 99) → '{"a":2,"c":4,"e":99}'
- en: json_replace('{"a":2,"c":4}', '$.a', 99) → '{"a":99,"c":4}'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_replace('{"a":2,"c":4}', '$.a', 99) → '{"a":99,"c":4}'
- en: json_replace('{"a":2,"c":4}', '$.e', 99) → '{"a":2,"c":4}'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_replace('{"a":2,"c":4}', '$.e', 99) → '{"a":2,"c":4}'
- en: json_set('{"a":2,"c":4}', '$.a', 99) → '{"a":99,"c":4}'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_set('{"a":2,"c":4}', '$.a', 99) → '{"a":99,"c":4}'
- en: json_set('{"a":2,"c":4}', '$.e', 99) → '{"a":2,"c":4,"e":99}'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_set('{"a":2,"c":4}', '$.e', 99) → '{"a":2,"c":4,"e":99}'
- en: json_set('{"a":2,"c":4}', '$.c', '[97,96]') → '{"a":2,"c":"[97,96]"}'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_set('{"a":2,"c":4}', '$.c', '[97,96]') → '{"a":2,"c":"[97,96]"}'
- en: json_set('{"a":2,"c":4}', '$.c', json('[97,96]')) → '{"a":2,"c":[97,96]}'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_set('{"a":2,"c":4}', '$.c', json('[97,96]')) → '{"a":2,"c":[97,96]}'
- en: json_set('{"a":2,"c":4}', '$.c', json_array(97,96)) → '{"a":2,"c":[97,96]}'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_set('{"a":2,"c":4}', '$.c', json_array(97,96)) → '{"a":2,"c":[97,96]}'
- en: 4.11\. The jsonb_insert(), jsonb_replace, and jsonb_set() functions
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.11\. The jsonb_insert(), jsonb_replace, and jsonb_set() functions
- en: The jsonb_insert(), jsonb_replace(), and jsonb_set() functions work the same
    as [json_insert()](json1.html#jins), [json_replace()](json1.html#jrepl), and [json_set()](json1.html#jset),
    respectively, except that "`jsonb_`" versions return their result in the binary
    JSONB format.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: jsonb_insert()、jsonb_replace()和jsonb_set()函数与它们对应的[json_insert()](json1.html#jins)、[json_replace()](json1.html#jrepl)和[json_set()](json1.html#jset)函数相同，唯一的区别在于"`jsonb_`"版本以二进制JSONB格式返回其结果。
- en: 4.12\. The json_object() function
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.12\. The json_object() function
- en: The json_object() SQL function accepts zero or more pairs of arguments and returns
    a well-formed JSON object that is composed from those arguments. The first argument
    of each pair is the label and the second argument of each pair is the value. If
    any argument to json_object() is a BLOB then an error is thrown.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: json_object() SQL 函数接受零个或多个参数对，并返回由这些参数组成的格式正确的 JSON 对象。每一对参数的第一个参数是标签，第二个参数是值。如果
    json_object() 的任何参数是 BLOB，则会抛出错误。
- en: The json_object() function currently allows duplicate labels without complaint,
    though this might change in a future enhancement.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: json_object() 函数当前允许重复的标签而不报错，但这可能在将来的增强版本中更改。
- en: An argument with SQL type TEXT it is normally converted into a quoted JSON string
    even if the input text is well-formed JSON. However, if the argument is the direct
    result from another JSON function or [the -> operator](json1.html#jptr) (but not
    [the ->> operator](json1.html#jptr)), then it is treated as JSON and all of its
    JSON type information and substructure is preserved. This allows calls to json_object()
    and [json_array()](json1.html#jarray) to be nested. The [json()](json1.html#jmini)
    function can also be used to force strings to be recognized as JSON.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 一个带有 SQL 类型 TEXT 的参数通常会被转换为带引号的 JSON 字符串，即使输入文本是格式良好的 JSON。但是，如果参数是来自另一个 JSON
    函数或 [-> 操作符](json1.html#jptr) 的直接结果（但不包括 [->> 操作符](json1.html#jptr)），则将其视为 JSON
    并保留其所有的 JSON 类型信息和子结构。这允许嵌套调用 json_object() 和 [json_array()](json1.html#jarray)。也可以使用
    [json()](json1.html#jmini) 函数将字符串强制识别为 JSON。
- en: 'Examples:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: json_object('a',2,'c',4) → '{"a":2,"c":4}'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_object('a',2,'c',4) → '{"a":2,"c":4}'
- en: json_object('a',2,'c','{e:5}') → '{"a":2,"c":"{e:5}"}'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_object('a',2,'c','{e:5}') → '{"a":2,"c":"{e:5}"}'
- en: json_object('a',2,'c',json_object('e',5)) → '{"a":2,"c":{"e":5}}'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_object('a',2,'c',json_object('e',5)) → '{"a":2,"c":{"e":5}}'
- en: 4.13\. The jsonb_object() function
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.13\. jsonb_object() 函数
- en: The jsonb_object() function works just like the [json_object()](json1.html#jobj)
    function except that the generated object is returned in the binary JSONB format.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: jsonb_object() 函数与 [json_object()](json1.html#jobj) 函数的工作方式完全相同，只是生成的对象以二进制
    JSONB 格式返回。
- en: 4.14\. The json_patch() function
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.14\. json_patch() 函数
- en: The json_patch(T,P) SQL function runs the [RFC-7396](https://tools.ietf.org/html/rfc7396)
    MergePatch algorithm to apply patch P against input T. The patched copy of T is
    returned.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: json_patch(T,P) SQL 函数运行 [RFC-7396](https://tools.ietf.org/html/rfc7396) MergePatch
    算法，对输入 T 应用修补 P。返回修补后的 T 的副本。
- en: MergePatch can add, modify, or delete elements of a JSON Object, and so for
    JSON Objects, the json_patch() routine is a generalized replacement for [json_set()](json1.html#jset)
    and [json_remove()](json1.html#jrm). However, MergePatch treats JSON Array objects
    as atomic. MergePatch cannot append to an Array nor modify individual elements
    of an Array. It can only insert, replace, or delete the whole Array as a single
    unit. Hence, json_patch() is not as useful when dealing with JSON that includes
    Arrays, especially Arrays with lots of substructure.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: MergePatch 可以添加、修改或删除 JSON 对象的元素，因此对于 JSON 对象，json_patch() 例程是 [json_set()](json1.html#jset)
    和 [json_remove()](json1.html#jrm) 的通用替代。但是，MergePatch 将 JSON 数组对象视为原子。MergePatch
    无法向数组追加或修改单个数组元素。它只能插入、替换或删除整个数组作为单个单位。因此，在处理包含数组的 JSON 时，特别是包含大量子结构的数组时，json_patch()
    并不那么有用。
- en: 'Examples:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: json_patch('{"a":1,"b":2}','{"c":3,"d":4}') → '{"a":1,"b":2,"c":3,"d":4}'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_patch('{"a":1,"b":2}','{"c":3,"d":4}') → '{"a":1,"b":2,"c":3,"d":4}'
- en: json_patch('{"a":[1,2],"b":2}','{"a":9}') → '{"a":9,"b":2}'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_patch('{"a":[1,2],"b":2}','{"a":9}') → '{"a":9,"b":2}'
- en: json_patch('{"a":[1,2],"b":2}','{"a":null}') → '{"b":2}'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_patch('{"a":[1,2],"b":2}','{"a":null}') → '{"b":2}'
- en: json_patch('{"a":1,"b":2}','{"a":9,"b":null,"c":8}') → '{"a":9,"c":8}'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_patch('{"a":1,"b":2}','{"a":9,"b":null,"c":8}') → '{"a":9,"c":8}'
- en: json_patch('{"a":{"x":1,"y":2},"b":3}','{"a":{"y":9},"c":8}') → '{"a":{"x":1,"y":9},"b":3,"c":8}'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_patch('{"a":{"x":1,"y":2},"b":3}','{"a":{"y":9},"c":8}') → '{"a":{"x":1,"y":9},"b":3,"c":8}'
- en: 4.15\. The jsonb_patch() function
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.15\. jsonb_patch() 函数
- en: The jsonb_patch() function works just like the [json_patch()](json1.html#jpatch)
    function except that the patched JSON is returned in the binary JSONB format.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: jsonb_patch() 函数与 [json_patch()](json1.html#jpatch) 函数的工作方式完全相同，只是返回的修补 JSON
    是二进制 JSONB 格式。
- en: 4.16\. The json_pretty() function
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.16\. json_pretty() 函数
- en: The json_pretty() function works like [json()](json1.html#jmini) except that
    it adds extra whitespace to make the JSON result easier for humans to read. The
    first argument is the JSON or JSONB that is to be pretty-printed. The optional
    second argument is a text string that is used for indentation. If the second argument
    is omitted or is NULL, then indentation is four spaces per level.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: json_pretty()函数的工作方式类似于[json()](json1.html#jmini)，但它添加额外的空格以使JSON结果更易于人类阅读。第一个参数是要漂亮打印的JSON或JSONB。可选的第二个参数是用于缩进的文本字符串。如果省略第二个参数或其为NULL，则每级缩进为四个空格。
- en: The json_pretty() function was added with SQLite version 3.46.0 (2024-05-23).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: json_pretty()函数是在SQLite版本3.46.0（2024-05-23）中添加的。
- en: 4.17\. The json_remove() function
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.17\. json_remove()函数
- en: The json_remove(X,P,...) function takes a single JSON value as its first argument
    followed by zero or more path arguments. The json_remove(X,P,...) function returns
    a copy of the X parameter with all the elements identified by path arguments removed.
    Paths that select elements not found in X are silently ignored.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: json_remove(X,P,...)函数以单个JSON值作为其第一个参数，后跟零个或多个路径参数。json_remove(X,P,...)函数返回X参数的副本，其中移除了所有由路径参数标识的元素。选择X中不存在的元素的路径会被静默忽略。
- en: Removals occurs sequentially from left to right. Changes caused by prior removals
    can affect the path search for subsequent arguments.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 删除操作从左到右依次进行。之前的删除会影响后续参数的路径搜索。
- en: If the json_remove(X) function is called with no path arguments, then it returns
    the input X reformatted, with excess whitespace removed.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用json_remove(X)函数时没有路径参数，则返回重新格式化的输入X，删除多余的空白。
- en: The json_remove() function throws an error if the first argument is not well-formed
    JSON or if any later argument is not a well-formed path.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: json_remove()函数如果第一个参数不是格式良好的JSON，或者任何后续参数不是格式良好的路径，则会抛出错误。
- en: 'Examples:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 'Examples:'
- en: json_remove('[0,1,2,3,4]','$[2]') → '[0,1,3,4]'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_remove('[0,1,2,3,4]','$[2]') → '[0,1,3,4]'
- en: json_remove('[0,1,2,3,4]','$[2]','$[0]') → '[1,3,4]'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_remove('[0,1,2,3,4]','$[2]','$[0]') → '[1,3,4]'
- en: json_remove('[0,1,2,3,4]','$[0]','$[2]') → '[1,2,4]'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_remove('[0,1,2,3,4]','$[0]','$[2]') → '[1,2,4]'
- en: json_remove('[0,1,2,3,4]','$[#-1]','$[0]') → '[1,2,3]'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_remove('[0,1,2,3,4]','$[#-1]','$[0]') → '[1,2,3]'
- en: json_remove('{"x":25,"y":42}') → '{"x":25,"y":42}'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_remove('{"x":25,"y":42}') → '{"x":25,"y":42}'
- en: json_remove('{"x":25,"y":42}','$.z') → '{"x":25,"y":42}'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_remove('{"x":25,"y":42}','$.z') → '{"x":25,"y":42}'
- en: json_remove('{"x":25,"y":42}','$.y') → '{"x":25}'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_remove('{"x":25,"y":42}','$.y') → '{"x":25}'
- en: json_remove('{"x":25,"y":42}','$') → NULL
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_remove('{"x":25,"y":42}','$') → NULL
- en: 4.18\. The jsonb_remove() function
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.18\. jsonb_remove()函数
- en: The jsonb_remove() function works just like the [json_remove()](json1.html#jrm)
    function except that the edited JSON result is returned in the binary JSONB format.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: jsonb_remove()函数与json_remove()函数的工作方式完全相同，只是编辑后的JSON结果以二进制JSONB格式返回。
- en: 4.19\. The json_type() function
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.19\. json_type()函数
- en: 'The json_type(X) function returns the "type" of the outermost element of X.
    The json_type(X,P) function returns the "type" of the element in X that is selected
    by path P. The "type" returned by json_type() is one of the following SQL text
    values: ''null'', ''true'', ''false'', ''integer'', ''real'', ''text'', ''array'',
    or ''object''. If the path P in json_type(X,P) selects an element that does not
    exist in X, then this function returns NULL.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: json_type(X)函数返回X的最外层元素的“类型”。json_type(X,P)函数返回路径P选择的X中的元素的“类型”。json_type()返回的“类型”是以下SQL文本值之一：'null'、'true'、'false'、'integer'、'real'、'text'、'array'或'object'。如果json_type(X,P)中的路径P选择了X中不存在的元素，则该函数返回NULL。
- en: The json_type() function throws an error if its first argument is not well-formed
    JSON or JSONB or if its second argument is not a well-formed JSON path.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: json_type()函数如果其第一个参数不是格式良好的JSON或JSONB，或者第二个参数不是格式良好的JSON路径，则会抛出错误。
- en: 'Examples:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 'Examples:'
- en: json_type('{"a":[2,3.5,true,false,null,"x"]}') → 'object'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_type('{"a":[2,3.5,true,false,null,"x"]}') → 'object'
- en: json_type('{"a":[2,3.5,true,false,null,"x"]}','$') → 'object'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_type('{"a":[2,3.5,true,false,null,"x"]}','$') → 'object'
- en: json_type('{"a":[2,3.5,true,false,null,"x"]}','$.a') → 'array'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_type('{"a":[2,3.5,true,false,null,"x"]}','$.a') → 'array'
- en: json_type('{"a":[2,3.5,true,false,null,"x"]}','$.a[0]') → 'integer'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_type('{"a":[2,3.5,true,false,null,"x"]}','$.a[0]') → 'integer'
- en: json_type('{"a":[2,3.5,true,false,null,"x"]}','$.a[1]') → 'real'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_type('{"a":[2,3.5,true,false,null,"x"]}','$.a[1]') → 'real'
- en: json_type('{"a":[2,3.5,true,false,null,"x"]}','$.a[2]') → 'true'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_type('{"a":[2,3.5,true,false,null,"x"]}','$.a[2]') → 'true'
- en: json_type('{"a":[2,3.5,true,false,null,"x"]}','$.a[3]') → 'false'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_type('{"a":[2,3.5,true,false,null,"x"]}','$.a[3]') → 'false'
- en: json_type('{"a":[2,3.5,true,false,null,"x"]}','$.a[4]') → 'null'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_type('{"a":[2,3.5,true,false,null,"x"]}','$.a[4]') → 'null'
- en: json_type('{"a":[2,3.5,true,false,null,"x"]}','$.a[5]') → 'text'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_type('{"a":[2,3.5,true,false,null,"x"]}','$.a[5]') → 'text'
- en: json_type('{"a":[2,3.5,true,false,null,"x"]}','$.a[6]') → NULL
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_type('{"a":[2,3.5,true,false,null,"x"]}','$.a[6]') → NULL
- en: 4.20\. The json_valid() function
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.20\. json_valid() 函数
- en: 'The json_valid(X,Y) function return 1 if the argument X is well-formed JSON,
    or returns 0 if X is not well-formed. The Y parameter is an integer bitmask that
    defines what is meant by "well-formed". The following bits of Y are currently
    defined:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: json_valid(X,Y) 函数如果参数 X 是格式良好的 JSON，则返回 1，如果 X 不符合规范，则返回 0。Y 参数是一个整数位掩码，定义了何为“格式良好”。当前定义的
    Y 位如下：
- en: '**0x01** → The input is text that strictly complies with canonical RFC-8259
    JSON, without any extensions.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**0x01** → 输入是严格遵循 RFC-8259 规范的文本，没有任何扩展。'
- en: '**0x02** → The input is text that is JSON with [JSON5](json1.html#json5) extensions
    described above.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**0x02** → 输入是具有上述[JSON5](json1.html#json5)扩展的 JSON 文本。'
- en: '**0x04** → The input is a BLOB that superficially appears to be [JSONB](json1.html#jsonbx).'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**0x04** → 输入是一个看起来表面上像[JSONB](json1.html#jsonbx)的 BLOB。'
- en: '**0x08** → The input is a BLOB that strictly conforms to the internal [JSONB](json1.html#jsonbx)
    format.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**0x08** → 输入是严格符合内部[JSONB](json1.html#jsonbx)格式的 BLOB。'
- en: 'By combining bits, the following useful values of Y can be derived:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 通过组合位，可以得出以下 Y 的有用值：
- en: '**1** → X is RFC-8259 JSON text'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** → X 是 RFC-8259 JSON 文本'
- en: '**2** → X is [JSON5](json1.html#json5) text'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** → X 是[JSON5](json1.html#json5)文本'
- en: '**4** → X is probably [JSONB](json1.html#jsonbx)'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**4** → X 可能是[JSONB](json1.html#jsonbx)'
- en: '**5** → X is RFC-8259 JSON text or [JSONB](json1.html#jsonbx)'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**5** → X 是 RFC-8259 JSON 文本或[JSONB](json1.html#jsonbx)'
- en: '**6** → X is [JSON5](json1.html#json5) text or [JSONB](json1.html#jsonbx) ←
    *This is probably the value you want*'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**6** → X 是[JSON5](json1.html#json5)文本或[JSONB](json1.html#jsonbx) ← *这可能是您想要的值*'
- en: '**8** → X is strictly conforming [JSONB](json1.html#jsonbx)'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**8** → X 是严格符合[JSONB](json1.html#jsonbx)'
- en: '**9** → X is RFC-8259 or strictly conforming [JSONB](json1.html#jsonbx)'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**9** → X 是 RFC-8259 或严格符合[JSONB](json1.html#jsonbx)'
- en: '**10** → X is JSON5 or strictly conforming [JSONB](json1.html#jsonbx)'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**10** → X 是 JSON5 或严格符合[JSONB](json1.html#jsonbx)'
- en: The Y parameter is optional. If omitted, it defaults to 1, which means that
    the default behavior is to return true only if the input X is strictly conforming
    RFC-8259 JSON text without any extensions. This makes the one-argument version
    of json_valid() compatible with older versions of SQLite, prior to the addition
    of support for [JSON5](json1.html#json5) and [JSONB](json1.html#jsonbx).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Y 参数是可选的。如果省略，则默认为 1，这意味着默认行为是仅当输入 X 严格符合 RFC-8259 JSON 文本且没有任何扩展时返回 true。这使得
    json_valid() 的单参数版本与 SQLite 的旧版本兼容，在支持[JSON5](json1.html#json5)和[JSONB](json1.html#jsonbx)之前。
- en: The difference between 0x04 and 0x08 bits in the Y parameter is that 0x04 only
    examines the outer wrapper of the BLOB to see if it superficially looks like [JSONB](json1.html#jsonbx).
    This is sufficient for must purposes and is very fast. The 0x08 bit does a thorough
    examination of all internal details of the BLOB. The 0x08 bit takes time that
    is linear in the size of the X input and is much slower. The 0x04 bit is recommended
    for most purposes.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**0x04** → Y 参数中的 0x04 位仅检查 BLOB 的外包装，看起来是否表面上像是[JSONB](json1.html#jsonbx)。对于大多数情况来说这是足够的，且速度非常快。0x08
    位则彻底检查 BLOB 的所有内部细节，这会随着输入 X 的大小线性增长而变慢。推荐大多数情况使用 0x04 位。'
- en: If you just want to know if a value is a plausible input to one of the other
    JSON functions, a Y value of 6 is probably what you want to use.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想知道一个值是否是其他 JSON 函数的合理输入，那么 Y 值为 6 可能是您想要使用的。
- en: Any Y value less than 1 or greater than 15 raises an error, for the latest version
    of json_valid(). However, future versions of json_valid() might be enhanced to
    accept flag values outside of this range, having new meanings that we have not
    yet thought of.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最新版本的 json_valid()，任何小于 1 或大于 15 的 Y 值会引发错误。然而，未来版本的 json_valid() 可能会增强以接受超出此范围的标志值，具有我们尚未考虑的新含义。
- en: If either X or Y inputs to json_valid() are NULL, then the function returns
    NULL.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 json_valid() 的 X 或 Y 输入为 NULL，则函数返回 NULL。
- en: 'Examples:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: json_valid('{"x":35}') → 1
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_valid('{"x":35}') → 1
- en: json_valid('{x:35}') → 0
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_valid('{x:35}') → 0
- en: json_valid('{x:35}',6) → 1
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_valid('{x:35}',6) → 1
- en: json_valid('{"x":35') → 0
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_valid('{"x":35') → 0
- en: json_valid(NULL) → NULL
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_valid(NULL) → NULL
- en: 4.21\. The json_quote() function
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.21\. json_quote() 函数
- en: The json_quote(X) function converts the SQL value X (a number or a string) into
    its corresponding JSON representation. If X is a JSON value returned by another
    JSON function, then this function is a no-op.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`json_quote(X)` 函数将 SQL 值 X（数字或字符串）转换为其对应的 JSON 表示。如果 X 是另一个 JSON 函数返回的 JSON
    值，则此函数不起作用。'
- en: 'Examples:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: json_quote(3.14159) → 3.14159
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`json_quote(3.14159)` → 3.14159'
- en: json_quote('verdant') → '"verdant"'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_quote('verdant') → '"verdant"'
- en: json_quote('[1]') → '"[1]"'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_quote('[1]') → '"[1]"'
- en: json_quote(json('[1]')) → '[1]'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_quote(json('[1]')) → '[1]'
- en: json_quote('[1,') → '"[1,"'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json_quote('[1,') → '"[1,"'
- en: 4.22\. Array and object aggregate functions
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.22\. 数组和对象的聚合函数
- en: The json_group_array(X) function is an [aggregate SQL function](lang_aggfunc.html)
    that returns a JSON array comprised of all X values in the aggregation. Similarly,
    the json_group_object(NAME,VALUE) function returns a JSON object comprised of
    all NAME/VALUE pairs in the aggregation. The "`jsonb_`" variants are the same
    except that they return their result in the binary [JSONB](json1.html#jsonbx)
    format.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`json_group_array(X)` 函数是一个[聚合 SQL 函数](lang_aggfunc.html)，返回聚合中所有 X 值组成的 JSON
    数组。类似地，`json_group_object(NAME,VALUE)` 函数返回聚合中所有 NAME/VALUE 对组成的 JSON 对象。"`jsonb_`"
    变体与它们相同，只是它们以二进制[JSONB](json1.html#jsonbx)格式返回其结果。'
- en: 4.23\. The json_each() and json_tree() table-valued functions
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.23\. `json_each()` 和 `json_tree()` 表值函数
- en: The json_each(X) and json_tree(X) [table-valued functions](vtab.html#tabfunc2)
    walk the JSON value provided as their first argument and return one row for each
    element. The json_each(X) function only walks the immediate children of the top-level
    array or object, or just the top-level element itself if the top-level element
    is a primitive value. The json_tree(X) function recursively walks through the
    JSON substructure starting with the top-level element.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`json_each(X)` 和 `json_tree(X)` 表值函数遍历其第一个参数提供的 JSON 值，并为每个元素返回一行。`json_each(X)`
    函数仅遍历顶级数组或对象的直接子元素，或者如果顶级元素本身是原始值，则仅遍历顶级元素本身。`json_tree(X)` 函数递归遍历从顶级元素开始的 JSON
    子结构。'
- en: The json_each(X,P) and json_tree(X,P) functions work just like their one-argument
    counterparts except that they treat the element identified by path P as the top-level
    element.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`json_each(X,P)` 和 `json_tree(X,P)` 函数的工作方式与它们的单参数版本相同，除了它们将由路径 P 标识的元素视为顶级元素。'
- en: 'The schema for the table returned by json_each() and json_tree() is as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`json_each()` 和 `json_tree()` 返回的表的模式如下：'
- en: '[PRE0]'
  id: totrans-308
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The "key" column is the integer array index for elements of a JSON array and
    the text label for elements of a JSON object. The key column is NULL in all other
    cases.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '"key" 列是 JSON 数组元素的整数数组索引和 JSON 对象元素的文本标签。在所有其他情况下，键列为 NULL。'
- en: The "atom" column is the SQL value corresponding to primitive elements - elements
    other than JSON arrays and objects. The "atom" column is NULL for a JSON array
    or object. The "value" column is the same as the "atom" column for primitive JSON
    elements but takes on the text JSON value for arrays and objects.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '"atom" 列是对应于原始元素的 SQL 值 - JSON 数组和对象以外的元素。对于 JSON 数组或对象，"atom" 列为 NULL。"value"
    列对于原始 JSON 元素与 "atom" 列相同，但对于数组和对象，它采用文本 JSON 值。'
- en: The "type" column is an SQL text value taken from ('null', 'true', 'false',
    'integer', 'real', 'text', 'array', 'object') according to the type of the current
    JSON element.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '"type" 列是从（''null'', ''true'', ''false'', ''integer'', ''real'', ''text'',
    ''array'', ''object''）中选取的 SQL 文本值，根据当前 JSON 元素的类型而定。'
- en: The "id" column is an integer that identifies a specific JSON element within
    the complete JSON string. The "id" integer is an internal housekeeping number,
    the computation of which might change in future releases. The only guarantee is
    that the "id" column will be different for every row.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '"id" 列是标识完整 JSON 字符串中特定 JSON 元素的整数。"id" 整数是一个内部管理编号，其计算可能会在未来版本中更改。唯一的保证是每一行的
    "id" 列都不同。'
- en: The "parent" column is always NULL for json_each(). For json_tree(), the "parent"
    column is the "id" integer for the parent of the current element, or NULL for
    the top-level JSON element or the element identified by the root path in the second
    argument.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '"parent" 列对于 `json_each()` 总是 NULL。对于 `json_tree()`，"parent" 列是当前元素的父元素的 "id"
    整数，或者对于顶级 JSON 元素或第二个参数中根路径标识的元素为 NULL。'
- en: The "fullkey" column is a text path that uniquely identifies the current row
    element within the original JSON string. The complete key to the true top-level
    element is returned even if an alternative starting point is provided by the "root"
    argument.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '"fullkey" 列是唯一标识原始 JSON 字符串中当前行元素的文本路径。即使通过 "root" 参数提供了替代起始点，也会返回到真正顶级元素的完整键。'
- en: The "path" column is the path to the array or object container that holds the
    current row, or the path to the current row in the case where the iteration starts
    on a primitive type and thus only provides a single row of output.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '"path" 列是指向包含当前行的数组或对象容器的路径，或者在迭代从基本类型开始且仅提供单行输出的情况下，是指向当前行的路径。'
- en: 4.23.1\. Examples using json_each() and json_tree()
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.23.1\. 使用 json_each() 和 json_tree() 的示例
- en: 'Suppose the table "CREATE TABLE user(name,phone)" stores zero or more phone
    numbers as a JSON array object in the user.phone field. To find all users who
    have any phone number with a 704 area code:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 假设表 "CREATE TABLE user(name,phone)" 将零个或多个电话号码存储为用户的 JSON 数组对象。要找到所有具有任何 704
    区号电话号码的用户：
- en: '[PRE1]'
  id: totrans-318
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now suppose the user.phone field contains plain text if the user has only a
    single phone number and a JSON array if the user has multiple phone numbers. The
    same question is posed: "Which users have a phone number in the 704 area code?"
    But now the json_each() function can only be called for those users that have
    two or more phone numbers since json_each() requires well-formed JSON as its first
    argument:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设用户的 phone 字段包含纯文本（如果用户只有一个电话号码）和 JSON 数组（如果用户有多个电话号码）。提出同样的问题："哪些用户的电话号码在
    704 区号内？"但现在 json_each() 函数只能对那些拥有两个或更多电话号码的用户调用，因为 json_each() 要求其第一个参数是格式良好的
    JSON：
- en: '[PRE2]'
  id: totrans-320
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Consider a different database with "CREATE TABLE big(json JSON)". To see a
    complete line-by-line decomposition of the data:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个不同的数据库，有 "CREATE TABLE big(json JSON)"。要查看数据的完整逐行分解：
- en: '[PRE3]'
  id: totrans-322
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the previous, the "type NOT IN (''object'',''array'')" term of the WHERE
    clause suppresses containers and only lets through leaf elements. The same effect
    could be achieved this way:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的例子中，WHERE 子句中的 "type NOT IN ('object','array')" 条件抑制了容器，只允许叶子元素通过。可以通过以下方式实现相同效果：
- en: '[PRE4]'
  id: totrans-324
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Suppose each entry in the BIG table is a JSON object with a '$.id' field that
    is a unique identifier and a '$.partlist' field that can be a deeply nested object.
    You want to find the id of every entry that contains one or more references to
    uuid '6fa5181e-5721-11e5-a04e-57f3d7b32808' anywhere in its '$.partlist'.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 BIG 表中的每个条目都是一个 JSON 对象，其中包含一个 '$.id' 字段作为唯一标识符，以及一个 '$.partlist' 字段，可以是深度嵌套的对象。您希望找到包含其
    '$.partlist' 中任何位置对 uuid '6fa5181e-5721-11e5-a04e-57f3d7b32808' 的引用的每个条目的 id。
- en: '[PRE5]'
  id: totrans-326
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE5]'
