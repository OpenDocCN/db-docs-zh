- en: 1\. Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://sqlite.com/vtab.html](https://sqlite.com/vtab.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A virtual table is an object that is registered with an open SQLite [database
    connection](c3ref/sqlite3.html). From the perspective of an SQL statement, the
    virtual table object looks like any other table or view. But behind the scenes,
    queries and updates on a virtual table invoke callback methods of the virtual
    table object instead of reading and writing on the database file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The virtual table mechanism allows an application to publish interfaces that
    are accessible from SQL statements as if they were tables. SQL statements can
    do almost anything to a virtual table that they can do to a real table, with the
    following exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: One cannot create a trigger on a virtual table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One cannot create additional indices on a virtual table. (Virtual tables can
    have indices but that must be built into the virtual table implementation. Indices
    cannot be added separately using [CREATE INDEX](lang_createindex.html) statements.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One cannot run [ALTER TABLE ... ADD COLUMN](lang_altertable.html) commands against
    a virtual table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Individual virtual table implementations might impose additional constraints.
    For example, some virtual implementations might provide read-only tables. Or some
    virtual table implementations might allow [INSERT](lang_insert.html) or [DELETE](lang_delete.html)
    but not [UPDATE](lang_update.html). Or some virtual table implementations might
    limit the kinds of UPDATEs that can be made.
  prefs: []
  type: TYPE_NORMAL
- en: A virtual table might represent an in-memory data structures. Or it might represent
    a view of data on disk that is not in the SQLite format. Or the application might
    compute the content of the virtual table on demand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some existing and postulated uses for virtual tables:'
  prefs: []
  type: TYPE_NORMAL
- en: A [full-text search](fts3.html) interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spatial indices using [R-Trees](rtree.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introspect the disk content of an SQLite database file (the [dbstat virtual
    table](dbstat.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read and/or write the content of a comma-separated value (CSV) file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access the filesystem of the host computer as if it were a database table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling SQL manipulation of data in statistics packages like R
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the [list of virtual tables](vtablist.html) page for a longer list of actual
    virtual table implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 1.1\. Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A virtual table is created using a [CREATE VIRTUAL TABLE](lang_createvtab.html)
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**[create-virtual-table-stmt:](syntax/create-virtual-table-stmt.html)**'
  prefs: []
  type: TYPE_NORMAL
- en: <svg class="pikchr" viewBox="0 0 624.096 259.848"><text x="74" y="17" text-anchor="middle"
    fill="rgb(0,0,0)" dominant-baseline="central">CREATE</text> <text x="183" y="17"
    text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">VIRTUAL</text>
    <text x="286" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">TABLE</text>
    <text x="372" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">IF</text>
    <text x="435" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">NOT</text>
    <text x="521" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">EXISTS</text>
    <text x="95" y="92" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">schema-name</text>
    <text x="197" y="92" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)"
    dominant-baseline="central">.</text> <text x="300" y="92" text-anchor="middle"
    fill="rgb(0,0,0)" dominant-baseline="central">table-name</text> <text x="67" y="204"
    text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">USING</text>
    <text x="187" y="204" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">module-name</text>
    <text x="300" y="204" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)"
    dominant-baseline="central">(</text> <text x="432" y="204" text-anchor="middle"
    fill="rgb(0,0,0)" dominant-baseline="central">module-argument</text> <text x="563"
    y="204" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)" dominant-baseline="central">)</text>
    <text x="432" y="242" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)"
    dominant-baseline="central">,</text></svg>
  prefs: []
  type: TYPE_NORMAL
- en: The CREATE VIRTUAL TABLE statement creates a new table called table-name derived
    from the class module-name. The module-name is the name that is registered for
    the virtual table by the [sqlite3_create_module()](c3ref/create_module.html) interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'One can also provide comma-separated arguments to the module following the
    module name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The format of the arguments to the module is very general. Each module-argument
    may contain keywords, string literals, identifiers, numbers, and punctuation.
    Each module-argument is passed as written (as text) into the [constructor method](vtab.html#xcreate)
    of the virtual table implementation when the virtual table is created and that
    constructor is responsible for parsing and interpreting the arguments. The argument
    syntax is sufficiently general that a virtual table implementation can, if it
    wants to, interpret its arguments as [column definitions](lang_createtable.html#tablecoldef)
    in an ordinary [CREATE TABLE](lang_createtable.html) statement. The implementation
    could also impose some other interpretation on the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Once a virtual table has been created, it can be used like any other table with
    the exceptions noted above and imposed by specific virtual table implementations.
    A virtual table is destroyed using the ordinary [DROP TABLE](lang_droptable.html)
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.1\. Temporary virtual tables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is no "CREATE TEMP VIRTUAL TABLE" statement. To create a temporary virtual
    table, add the "temp" schema before the virtual table name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 1.1.2\. Eponymous virtual tables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some virtual tables exist automatically in the "main" schema of every database
    connection in which their module is registered, even without a [CREATE VIRTUAL
    TABLE](lang_createvtab.html) statement. Such virtual tables are called "eponymous
    virtual tables". To use an eponymous virtual table, simply use the module name
    as if it were a table. Eponymous virtual tables exist in the "main" schema only,
    so they will not work if prefixed with a different schema name.
  prefs: []
  type: TYPE_NORMAL
- en: An example of an eponymous virtual table is the [dbstat virtual table](dbstat.html).
    To use the dbstat virtual table as an eponymous virtual table, simply query against
    the "dbstat" module name, as if it were an ordinary table. (Note that SQLite must
    be compiled with the [SQLITE_ENABLE_DBSTAT_VTAB](compile.html#enable_dbstat_vtab)
    option to include the dbstat virtual table in the build.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: A virtual table is eponymous if its [xCreate](vtab.html#xcreate) method is the
    exact same function as the [xConnect](vtab.html#xconnect) method, or if the [xCreate](vtab.html#xcreate)
    method is NULL. The [xCreate](vtab.html#xcreate) method is called when a virtual
    table is first created using the [CREATE VIRTUAL TABLE](lang_createvtab.html)
    statement. The [xConnect](vtab.html#xconnect) method is invoked whenever a database
    connection attaches to or reparses a schema. When these two methods are the same,
    that indicates that the virtual table has no persistent state that needs to be
    created and destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.3\. Eponymous-only virtual tables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the [xCreate](vtab.html#xcreate) method is NULL, then [CREATE VIRTUAL TABLE](lang_createvtab.html)
    statements are prohibited for that virtual table, and the virtual table is an
    "eponymous-only virtual table". Eponymous-only virtual tables are useful as [table-valued
    functions](vtab.html#tabfunc2).
  prefs: []
  type: TYPE_NORMAL
- en: Note that prior to [version 3.9.0](releaselog/3_9_0.html) (2015-10-14), SQLite
    did not check the xCreate method for NULL before invoking it. So if an eponymous-only
    virtual table is registered with SQLite [version 3.8.11.1](releaselog/3_8_11_1.html)
    (2015-07-29) or earlier and a [CREATE VIRTUAL TABLE](lang_createvtab.html) command
    is attempted against that virtual table module, a jump to a NULL pointer will
    occur, resulting in a crash.
  prefs: []
  type: TYPE_NORMAL
- en: 1.2\. Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Several new C-level objects are used by the virtual table implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The [sqlite3_module](c3ref/module.html) structure defines a module object used
    to implement a virtual table. Think of a module as a class from which one can
    construct multiple virtual tables having similar properties. For example, one
    might have a module that provides read-only access to comma-separated-value (CSV)
    files on disk. That one module can then be used to create several virtual tables
    where each virtual table refers to a different CSV file.
  prefs: []
  type: TYPE_NORMAL
- en: The module structure contains methods that are invoked by SQLite to perform
    various actions on the virtual table such as creating new instances of a virtual
    table or destroying old ones, reading and writing data, searching for and deleting,
    updating, or inserting rows. The module structure is explained in more detail
    below.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each virtual table instance is represented by an [sqlite3_vtab](c3ref/vtab.html)
    structure. The sqlite3_vtab structure looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Virtual table implementations will normally subclass this structure to add additional
    private and implementation-specific fields. The nRef field is used internally
    by the SQLite core and should not be altered by the virtual table implementation.
    The virtual table implementation may pass error message text to the core by putting
    an error message string in zErrMsg. Space to hold this error message string must
    be obtained from an SQLite memory allocation function such as [sqlite3_mprintf()](c3ref/mprintf.html)
    or [sqlite3_malloc()](c3ref/free.html). Prior to assigning a new value to zErrMsg,
    the virtual table implementation must free any preexisting content of zErrMsg
    using [sqlite3_free()](c3ref/free.html). Failure to do this will result in a memory
    leak. The SQLite core will free and zero the content of zErrMsg when it delivers
    the error message text to the client application or when it destroys the virtual
    table. The virtual table implementation only needs to worry about freeing the
    zErrMsg content when it overwrites the content with a new, different error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [sqlite3_vtab_cursor](c3ref/vtab_cursor.html) structure represents a pointer
    to a specific row of a virtual table. This is what an sqlite3_vtab_cursor looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Once again, practical implementations will likely subclass this structure to
    add additional private fields.
  prefs: []
  type: TYPE_NORMAL
- en: The [sqlite3_index_info](c3ref/index_info.html) structure is used to pass information
    into and out of the xBestIndex method of the module that implements a virtual
    table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before a [CREATE VIRTUAL TABLE](lang_createvtab.html) statement can be run,
    the module specified in that statement must be registered with the database connection.
    This is accomplished using either of the [sqlite3_create_module()](c3ref/create_module.html)
    or [sqlite3_create_module_v2()](c3ref/create_module.html) interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The [sqlite3_create_module()](c3ref/create_module.html) and [sqlite3_create_module_v2()](c3ref/create_module.html)
    routines associates a module name with an [sqlite3_module](c3ref/module.html)
    structure and a separate client data that is specific to each module. The only
    difference between the two create_module methods is that the _v2 method includes
    an extra parameter that specifies a destructor for client data pointer. The module
    structure is what defines the behavior of a virtual table. The module structure
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The module structure defines all of the methods for each virtual table object.
    The module structure also contains the iVersion field which defines the particular
    edition of the module table structure. Currently, iVersion is always 4 or less,
    but in future releases of SQLite the module structure definition might be extended
    with additional methods and in that case the maximum iVersion value will be increased.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the module structure consists of methods used to implement various
    features of the virtual table. Details on what each of these methods do are provided
    in the sequel.
  prefs: []
  type: TYPE_NORMAL
- en: 1.3\. Virtual Tables And Shared Cache
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Prior to SQLite [version 3.6.17](releaselog/3_6_17.html) (2009-08-10), the virtual
    table mechanism assumes that each [database connection](c3ref/sqlite3.html) kept
    its own copy of the database schema. Hence, the virtual table mechanism could
    not be used in a database that has [shared cache mode](sharedcache.html) enabled.
    The [sqlite3_create_module()](c3ref/create_module.html) interface would return
    an error if [shared cache mode](sharedcache.html) is enabled. That restriction
    was relaxed beginning with SQLite [version 3.6.17](releaselog/3_6_17.html).
  prefs: []
  type: TYPE_NORMAL
- en: 1.4\. Creating New Virtual Table Implementations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create your own virtual table:'
  prefs: []
  type: TYPE_NORMAL
- en: Write all necessary methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of the [sqlite3_module](c3ref/module.html) structure containing
    pointers to all the methods from step 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register your [sqlite3_module](c3ref/module.html) structure using one of the
    [sqlite3_create_module()](c3ref/create_module.html) or [sqlite3_create_module_v2()](c3ref/create_module.html)
    interfaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run a [CREATE VIRTUAL TABLE](lang_createvtab.html) command that specifies the
    new module in the USING clause.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The only really hard part is step 1\. You might want to start with an existing
    virtual table implementation and modify it to suit your needs. The [SQLite source
    tree](https://sqlite.org/src/dir?ci=trunk&type=tree) contains many virtual table
    implementations that are suitable for copying, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[templatevtab.c](https://sqlite.org/src/file/ext/misc/templatevtab.c)** →
    A virtual table created specifically to serve as a template for other custom virtual
    tables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[series.c](https://sqlite.org/src/file/ext/misc/series.c)** → Implementation
    of the generate_series() table-valued function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[json.c](https://sqlite.org/src/file/src/json.c)** → Contains the sources
    for the [json_each()](json1.html#jeach) and [json_tree()](json1.html#jtree) table-valued
    functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[csv.c](https://sqlite.org/src/file/ext/misc/csv.c)** → A virtual table that
    reads CSV files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are [many other virtual table implementations](vtablist.html) in the SQLite
    source tree that can be used as examples. Locate these other virtual table implementations
    by searching for "sqlite3_create_module".
  prefs: []
  type: TYPE_NORMAL
- en: You might also want to implement your new virtual table as a [loadable extension](loadext.html).
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Virtual Table Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 2.1\. The xCreate Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The xCreate method is called to create a new instance of a virtual table in
    response to a [CREATE VIRTUAL TABLE](lang_createvtab.html) statement. If the xCreate
    method is the same pointer as the [xConnect](vtab.html#xconnect) method, then
    the virtual table is an [eponymous virtual table](vtab.html#epovtab). If the xCreate
    method is omitted (if it is a NULL pointer) then the virtual table is an [eponymous-only
    virtual table](vtab.html#epoonlyvtab).
  prefs: []
  type: TYPE_NORMAL
- en: The db parameter is a pointer to the SQLite [database connection](c3ref/sqlite3.html)
    that is executing the [CREATE VIRTUAL TABLE](lang_createvtab.html) statement.
    The pAux argument is the copy of the client data pointer that was the fourth argument
    to the [sqlite3_create_module()](c3ref/create_module.html) or [sqlite3_create_module_v2()](c3ref/create_module.html)
    call that registered the [virtual table module](c3ref/module.html). The argv parameter
    is an array of argc pointers to null terminated strings. The first string, argv[0],
    is the name of the module being invoked. The module name is the name provided
    as the second argument to [sqlite3_create_module()](c3ref/create_module.html)
    and as the argument to the USING clause of the [CREATE VIRTUAL TABLE](lang_createvtab.html)
    statement that is running. The second, argv[1], is the name of the database in
    which the new virtual table is being created. The database name is "main" for
    the primary database, or "temp" for TEMP database, or the name given at the end
    of the [ATTACH](lang_attach.html) statement for attached databases. The third
    element of the array, argv[2], is the name of the new virtual table, as specified
    following the TABLE keyword in the [CREATE VIRTUAL TABLE](lang_createvtab.html)
    statement. If present, the fourth and subsequent strings in the argv[] array report
    the arguments to the module name in the [CREATE VIRTUAL TABLE](lang_createvtab.html)
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: The job of this method is to construct the new virtual table object (an [sqlite3_vtab](c3ref/vtab.html)
    object) and return a pointer to it in *ppVTab.
  prefs: []
  type: TYPE_NORMAL
- en: 'As part of the task of creating a new [sqlite3_vtab](c3ref/vtab.html) structure,
    this method must invoke [sqlite3_declare_vtab()](c3ref/declare_vtab.html) to tell
    the SQLite core about the columns and datatypes in the virtual table. The [sqlite3_declare_vtab()](c3ref/declare_vtab.html)
    API has the following prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The first argument to [sqlite3_declare_vtab()](c3ref/declare_vtab.html) must
    be the same [database connection](c3ref/sqlite3.html) pointer as the first parameter
    to this method. The second argument to [sqlite3_declare_vtab()](c3ref/declare_vtab.html)
    must a zero-terminated UTF-8 string that contains a well-formed [CREATE TABLE](lang_createtable.html)
    statement that defines the columns in the virtual table and their data types.
    The name of the table in this CREATE TABLE statement is ignored, as are all constraints.
    Only the column names and datatypes matter. The CREATE TABLE statement string
    need not to be held in persistent memory. The string can be deallocated and/or
    reused as soon as the [sqlite3_declare_vtab()](c3ref/declare_vtab.html) routine
    returns.
  prefs: []
  type: TYPE_NORMAL
- en: 'The xConnect method can also optionally request special features for the virtual
    table by making one or more calls to the [sqlite3_vtab_config()](c3ref/vtab_config.html)
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Calls to sqlite3_vtab_config() are optional. But for maximum security, it is
    recommended that virtual table implementations invoke "[sqlite3_vtab_config](c3ref/vtab_config.html)(db,
    [SQLITE_VTAB_DIRECTONLY](c3ref/c_vtab_constraint_support.html#sqlitevtabdirectonly))"
    if the virtual table will not be used from inside of triggers or views.
  prefs: []
  type: TYPE_NORMAL
- en: The xCreate method need not initialize the pModule, nRef, and zErrMsg fields
    of the [sqlite3_vtab](c3ref/vtab.html) object. The SQLite core will take care
    of that chore.
  prefs: []
  type: TYPE_NORMAL
- en: The xCreate should return [SQLITE_OK](rescode.html#ok) if it is successful in
    creating the new virtual table, or [SQLITE_ERROR](rescode.html#error) if it is
    not successful. If not successful, the [sqlite3_vtab](c3ref/vtab.html) structure
    must not be allocated. An error message may optionally be returned in *pzErr if
    unsuccessful. Space to hold the error message string must be allocated using an
    SQLite memory allocation function like [sqlite3_malloc()](c3ref/free.html) or
    [sqlite3_mprintf()](c3ref/mprintf.html) as the SQLite core will attempt to free
    the space using [sqlite3_free()](c3ref/free.html) after the error has been reported
    up to the application.
  prefs: []
  type: TYPE_NORMAL
- en: If the xCreate method is omitted (left as a NULL pointer) then the virtual table
    is an [eponymous-only virtual table](vtab.html#epoonlyvtab). New instances of
    the virtual table cannot be created using [CREATE VIRTUAL TABLE](lang_createvtab.html)
    and the virtual table can only be used via its module name. Note that SQLite versions
    prior to 3.9.0 (2015-10-14) do not understand eponymous-only virtual tables and
    will segfault if an attempt is made to [CREATE VIRTUAL TABLE](lang_createvtab.html)
    on an eponymous-only virtual table because the xCreate method was not checked
    for null.
  prefs: []
  type: TYPE_NORMAL
- en: If the xCreate method is the exact same pointer as the [xConnect](vtab.html#xconnect)
    method, that indicates that the virtual table does not need to initialize backing
    store. Such a virtual table can be used as an [eponymous virtual table](vtab.html#epovtab)
    or as a named virtual table using [CREATE VIRTUAL TABLE](lang_createvtab.html)
    or both.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1.1\. Hidden columns in virtual tables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If a column datatype contains the special keyword "HIDDEN" (in any combination
    of upper and lower case letters) then that keyword it is omitted from the column
    datatype name and the column is marked as a hidden column internally. A hidden
    column differs from a normal column in three respects:'
  prefs: []
  type: TYPE_NORMAL
- en: Hidden columns are not listed in the dataset returned by "[PRAGMA table_info](pragma.html#pragma_table_info)",
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hidden columns are not included in the expansion of a "*" expression in the
    result set of a [SELECT](lang_select.html), and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hidden columns are not included in the implicit column-list used by an [INSERT](lang_insert.html)
    statement that lacks an explicit column-list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, if the following SQL is passed to [sqlite3_declare_vtab()](c3ref/declare_vtab.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Then the virtual table would be created with two hidden columns, and with datatypes
    of "VARCHAR(12)" and "INTEGER".
  prefs: []
  type: TYPE_NORMAL
- en: An example use of hidden columns can be seen in the [FTS3](fts3.html) virtual
    table implementation, where every FTS virtual table contains an [FTS hidden column](fts3.html#hiddencol)
    that is used to pass information from the virtual table into [FTS auxiliary functions](fts3.html#snippet)
    and to the [FTS MATCH](fts3.html#full_text_index_queries) operator.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1.2\. Table-valued functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A [virtual table](vtab.html) that contains [hidden columns](vtab.html#hiddencol)
    can be used like a table-valued function in the FROM clause of a [SELECT](lang_select.html)
    statement. The arguments to the table-valued function become constraints on the
    HIDDEN columns of the virtual table.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the "generate_series" extension (located in the [ext/misc/series.c](https://www.sqlite.org/src/artifact?ci=trunk&filename=ext/misc/series.c)
    file in the [source tree](https://www.sqlite.org/src/tree?ci=trunk)) implements
    an [eponymous virtual table](vtab.html#epovtab) with the following schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The [sqlite3_module.xBestIndex](vtab.html#xbestindex) method in the implementation
    of this table checks for equality constraints against the HIDDEN columns, and
    uses those as input parameters to determine the range of integer "value" outputs
    to generate. Reasonable defaults are used for any unconstrained columns. For example,
    to list all integers between 5 and 50:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous query is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Arguments on the virtual table name are matched to [hidden columns](vtab.html#hiddencol)
    in order. The number of arguments can be less than the number of hidden columns,
    in which case the latter hidden columns are unconstrained. However, an error results
    if there are more arguments than there are hidden columns in the virtual table.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1.3\. WITHOUT ROWID Virtual Tables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Beginning with SQLite [version 3.14.0](releaselog/3_14.html) (2016-08-08), the
    CREATE TABLE statement that is passed into [sqlite3_declare_vtab()](c3ref/declare_vtab.html)
    may contain a [WITHOUT ROWID](withoutrowid.html) clause. This is useful for cases
    where the virtual table rows cannot easily be mapped into unique integers. A CREATE
    TABLE statement that includes WITHOUT ROWID must define one or more columns as
    the PRIMARY KEY. Every column of the PRIMARY KEY must individually be NOT NULL
    and all columns for each row must be collectively unique.
  prefs: []
  type: TYPE_NORMAL
- en: Note that SQLite does not enforce the PRIMARY KEY for a WITHOUT ROWID virtual
    table. Enforcement is the responsibility of the underlying virtual table implementation.
    But SQLite does assume that the PRIMARY KEY constraint is valid - that the identified
    columns really are UNIQUE and NOT NULL - and it uses that assumption to optimize
    queries against the virtual table.
  prefs: []
  type: TYPE_NORMAL
- en: The rowid column is not accessible on a WITHOUT ROWID virtual table (of course).
  prefs: []
  type: TYPE_NORMAL
- en: The [xUpdate](vtab.html#xupdate) method was originally designed around having
    a [ROWID](lang_createtable.html#rowid) as a single value. The [xUpdate](vtab.html#xupdate)
    method has been expanded to accommodate an arbitrary PRIMARY KEY in place of the
    ROWID, but the PRIMARY KEY must still be only one column. For this reason, SQLite
    will reject any WITHOUT ROWID virtual table that has more than one PRIMARY KEY
    column and a non-NULL xUpdate method.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2\. The xConnect Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The xConnect method is very similar to [xCreate](vtab.html#xcreate). It has
    the same parameters and constructs a new [sqlite3_vtab](c3ref/vtab.html) structure
    just like xCreate. And it must also call [sqlite3_declare_vtab()](c3ref/declare_vtab.html)
    like xCreate. It should also make all of the same [sqlite3_vtab_config()](c3ref/vtab_config.html)
    calls as xCreate.
  prefs: []
  type: TYPE_NORMAL
- en: The difference is that xConnect is called to establish a new connection to an
    existing virtual table whereas xCreate is called to create a new virtual table
    from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: The xCreate and xConnect methods are only different when the virtual table has
    some kind of backing store that must be initialized the first time the virtual
    table is created. The xCreate method creates and initializes the backing store.
    The xConnect method just connects to an existing backing store. When xCreate and
    xConnect are the same, the table is an [eponymous virtual table](vtab.html#epovtab).
  prefs: []
  type: TYPE_NORMAL
- en: As an example, consider a virtual table implementation that provides read-only
    access to existing comma-separated-value (CSV) files on disk. There is no backing
    store that needs to be created or initialized for such a virtual table (since
    the CSV files already exist on disk) so the xCreate and xConnect methods will
    be identical for that module.
  prefs: []
  type: TYPE_NORMAL
- en: Another example is a virtual table that implements a full-text index. The xCreate
    method must create and initialize data structures to hold the dictionary and posting
    lists for that index. The xConnect method, on the other hand, only has to locate
    and use an existing dictionary and posting lists that were created by a prior
    xCreate call.
  prefs: []
  type: TYPE_NORMAL
- en: The xConnect method must return [SQLITE_OK](rescode.html#ok) if it is successful
    in creating the new virtual table, or [SQLITE_ERROR](rescode.html#error) if it
    is not successful. If not successful, the [sqlite3_vtab](c3ref/vtab.html) structure
    must not be allocated. An error message may optionally be returned in *pzErr if
    unsuccessful. Space to hold the error message string must be allocated using an
    SQLite memory allocation function like [sqlite3_malloc()](c3ref/free.html) or
    [sqlite3_mprintf()](c3ref/mprintf.html) as the SQLite core will attempt to free
    the space using [sqlite3_free()](c3ref/free.html) after the error has been reported
    up to the application.
  prefs: []
  type: TYPE_NORMAL
- en: The xConnect method is required for every virtual table implementation, though
    the [xCreate](vtab.html#xcreate) and xConnect pointers of the [sqlite3_module](c3ref/module.html)
    object may point to the same function if the virtual table does not need to initialize
    backing store.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3\. The xBestIndex Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SQLite uses the xBestIndex method of a virtual table module to determine the
    best way to access the virtual table. The xBestIndex method has a prototype like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The SQLite core communicates with the xBestIndex method by filling in certain
    fields of the [sqlite3_index_info](c3ref/index_info.html) structure and passing
    a pointer to that structure into xBestIndex as the second parameter. The xBestIndex
    method fills out other fields of this structure which forms the reply. The [sqlite3_index_info](c3ref/index_info.html)
    structure looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note the warnings on the "estimatedRows", "idxFlags", and colUsed fields. These
    fields were added with SQLite versions 3.8.2, 3.9.0, and 3.10.0, respectively.
    Any extension that reads or writes these fields must first check that the version
    of the SQLite library in use is greater than or equal to appropriate version -
    perhaps comparing the value returned from [sqlite3_libversion_number()](c3ref/libversion.html)
    against constants 3008002, 3009000, and/or 3010000\. The result of attempting
    to access these fields in an sqlite3_index_info structure created by an older
    version of SQLite are undefined.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, there are some defined constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the [sqlite3_vtab_collation()](c3ref/vtab_collation.html) interface to
    find the name of the [collating sequence](datatype3.html#collation) that should
    be used when evaluating the i-th constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The SQLite core calls the xBestIndex method when it is compiling a query that
    involves a virtual table. In other words, SQLite calls this method when it is
    running [sqlite3_prepare()](c3ref/prepare.html) or the equivalent. By calling
    this method, the SQLite core is saying to the virtual table that it needs to access
    some subset of the rows in the virtual table and it wants to know the most efficient
    way to do that access. The xBestIndex method replies with information that the
    SQLite core can then use to conduct an efficient search of the virtual table.
  prefs: []
  type: TYPE_NORMAL
- en: While compiling a single SQL query, the SQLite core might call xBestIndex multiple
    times with different settings in [sqlite3_index_info](c3ref/index_info.html).
    The SQLite core will then select the combination that appears to give the best
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: Before calling this method, the SQLite core initializes an instance of the [sqlite3_index_info](c3ref/index_info.html)
    structure with information about the query that it is currently trying to process.
    This information derives mainly from the WHERE clause and ORDER BY or GROUP BY
    clauses of the query, but also from any ON or USING clauses if the query is a
    join. The information that the SQLite core provides to the xBestIndex method is
    held in the part of the structure that is marked as "Inputs". The "Outputs" section
    is initialized to zero.
  prefs: []
  type: TYPE_NORMAL
- en: The information in the [sqlite3_index_info](c3ref/index_info.html) structure
    is ephemeral and may be overwritten or deallocated as soon as the xBestIndex method
    returns. If the xBestIndex method needs to remember any part of the [sqlite3_index_info](c3ref/index_info.html)
    structure, it should make a copy. Care must be take to store the copy in a place
    where it will be deallocated, such as in the idxStr field with needToFreeIdxStr
    set to 1.
  prefs: []
  type: TYPE_NORMAL
- en: Note that xBestIndex will always be called before [xFilter](vtab.html#xfilter),
    since the idxNum and idxStr outputs from xBestIndex are required inputs to xFilter.
    However, there is no guarantee that xFilter will be called following a successful
    xBestIndex.
  prefs: []
  type: TYPE_NORMAL
- en: The xBestIndex method is required for every virtual table implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.1\. Inputs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main thing that the SQLite core is trying to communicate to the virtual
    table is the constraints that are available to limit the number of rows that need
    to be searched. The aConstraint[] array contains one entry for each constraint.
    There will be exactly nConstraint entries in that array.
  prefs: []
  type: TYPE_NORMAL
- en: Each constraint will usually correspond to a term in the WHERE clause or in
    a USING or ON clause that is of the form
  prefs: []
  type: TYPE_NORMAL
- en: column OP EXPR
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Where "column" is a column in the virtual table, OP is an operator like "="
    or "<", and EXPR is an arbitrary expression. So, for example, if the WHERE clause
    contained a term like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then one of the constraints would be on the "a" column with operator "=" and
    an expression of "5". Constraints need not have a literal representation of the
    WHERE clause. The query optimizer might make transformations to the WHERE clause
    in order to extract as many constraints as it can. So, for example, if the WHERE
    clause contained something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The query optimizer might translate this into three separate constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: For each such constraint, the aConstraint[].iColumn field indicates which column
    appears on the left-hand side of the constraint. The first column of the virtual
    table is column 0\. The rowid of the virtual table is column -1\. The aConstraint[].op
    field indicates which operator is used. The SQLITE_INDEX_CONSTRAINT_* constants
    map integer constants into operator values. Columns occur in the order they were
    defined by the call to [sqlite3_declare_vtab()](c3ref/declare_vtab.html) in the
    [xCreate](vtab.html#xcreate) or [xConnect](vtab.html#xconnect) method. Hidden
    columns are counted when determining the column index.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the [xFindFunction()](vtab.html#xfindfunction) method for the virtual table
    is defined, and if xFindFunction() sometimes returns [SQLITE_INDEX_CONSTRAINT_FUNCTION](c3ref/c_index_constraint_eq.html)
    or larger, then the constraints might also be of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: FUNCTION( column, EXPR)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this case the aConstraint[].op value is the same as the value returned by
    [xFindFunction()](vtab.html#xfindfunction) for FUNCTION.
  prefs: []
  type: TYPE_NORMAL
- en: The aConstraint[] array contains information about all constraints that apply
    to the virtual table. But some of the constraints might not be usable because
    of the way tables are ordered in a join. The xBestIndex method must therefore
    only consider constraints that have an aConstraint[].usable flag which is true.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to WHERE clause constraints, the SQLite core also tells the xBestIndex
    method about the ORDER BY clause. (In an aggregate query, the SQLite core might
    put in GROUP BY clause information in place of the ORDER BY clause information,
    but this fact should not make any difference to the xBestIndex method.) If all
    terms of the ORDER BY clause are columns in the virtual table, then nOrderBy will
    be the number of terms in the ORDER BY clause and the aOrderBy[] array will identify
    the column for each term in the order by clause and whether or not that column
    is ASC or DESC.
  prefs: []
  type: TYPE_NORMAL
- en: In SQLite [version 3.10.0](releaselog/3_10_0.html) (2016-01-06) and later, the
    colUsed field is available to indicate which fields of the virtual table are actually
    used by the statement being prepared. If the lowest bit of colUsed is set, that
    means that the first column is used. The second lowest bit corresponds to the
    second column. And so forth. If the most significant bit of colUsed is set, that
    means that one or more columns other than the first 63 columns are used. If column
    usage information is needed by the [xFilter](vtab.html#xfilter) method, then the
    required bits must be encoded into either the output idxNum field or idxStr content.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.1.1\. LIKE, GLOB, REGEXP, and MATCH functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For the LIKE, GLOB, REGEXP, and MATCH operators, the aConstraint[].iColumn
    value is the virtual table column that is the left operand of the operator. However,
    if these operators are expressed as function calls instead of operators, then
    the aConstraint[].iColumn value references the virtual table column that is the
    second argument to that function:'
  prefs: []
  type: TYPE_NORMAL
- en: LIKE(*EXPR*, *column*)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: GLOB(*EXPR*, *column*)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: REGEXP(*EXPR*, *column*)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: MATCH(*EXPR*, *column*)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Hence, as far as the xBestIndex() method is concerned, the following two forms
    are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '*column* LIKE *EXPR*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: LIKE(*EXPR*,*column*)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This special behavior of looking at the second argument of a function only occurs
    for the LIKE, GLOB, REGEXP, and MATCH functions. For all other functions, the
    aConstraint[].iColumn value references the first argument of the function.
  prefs: []
  type: TYPE_NORMAL
- en: This special feature of LIKE, GLOB, REGEXP, and MATCH does not apply to the
    [xFindFunction()](vtab.html#xfindfunction) method, however. The [xFindFunction()](vtab.html#xfindfunction)
    method always keys off of the left operand of an LIKE, GLOB, REGEXP, or MATCH
    operator but off of the first argument to function-call equivalents of those operators.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.1.2\. LIMIT and OFFSET
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When aConstraint[].op is one of SQLITE_INDEX_CONSTRAINT_LIMIT or SQLITE_INDEX_CONSTRAINT_OFFSET,
    that indicates that there is a LIMIT or OFFSET clause on the SQL query statement
    that is using the virtual table. The LIMIT and OFFSET operators have no left operand,
    and so when aConstraint[].op is one of SQLITE_INDEX_CONSTRAINT_LIMIT or SQLITE_INDEX_CONSTRAINT_OFFSET
    then the aConstraint[].iColumn value is meaningless and should not be used.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.1.3\. Right-hand side values of constraints
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The [sqlite3_vtab_rhs_value()](c3ref/vtab_rhs_value.html) interface can be used
    to try to access the right-hand operand of a constraint. However, the value of
    a right-hand operator might not be known at the time that the xBestIndex method
    is run, so the sqlite3_vtab_rhs_value() call might not be successful. Usually
    the right operand of a constraint is only available to xBestIndex if it is coded
    as a literal value in the input SQL. If the right operand is coded as an expression
    or a [host parameter](c3ref/bind_blob.html), it probably will not be accessible
    to xBestIndex. Some operators, such as [SQLITE_INDEX_CONSTRAINT_ISNULL](c3ref/c_index_constraint_eq.html)
    and [SQLITE_INDEX_CONSTRAINT_ISNOTNULL](c3ref/c_index_constraint_eq.html) have
    no right-hand operand. The sqlite3_vtab_rhs_value() interface always returns [SQLITE_NOTFOUND](rescode.html#notfound)
    for such operators.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.2\. Outputs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Given all of the information above, the job of the xBestIndex method it to figure
    out the best way to search the virtual table.
  prefs: []
  type: TYPE_NORMAL
- en: The xBestIndex method conveys an indexing strategy to the [xFilter](vtab.html#xfilter)
    method through the idxNum and idxStr fields. The idxNum value and idxStr string
    content are arbitrary as far as the SQLite core is concerned and can have any
    meaning as long as xBestIndex and xFilter agree on what that meaning is. The SQLite
    core just copies the information from xBestIndex through to the [xFilter](vtab.html#xfilter)
    method, assuming only that the char sequence referenced via idxStr is NUL terminated.
  prefs: []
  type: TYPE_NORMAL
- en: The idxStr value may be a string obtained from an SQLite memory allocation function
    such as [sqlite3_mprintf()](c3ref/mprintf.html). If this is the case, then the
    needToFreeIdxStr flag must be set to true so that the SQLite core will know to
    call [sqlite3_free()](c3ref/free.html) on that string when it has finished with
    it, and thus avoid a memory leak. The idxStr value may also be a static constant
    string, in which case the needToFreeIdxStr boolean should remain false.
  prefs: []
  type: TYPE_NORMAL
- en: The estimatedCost field should be set to the estimated number of disk access
    operations required to execute this query against the virtual table. The SQLite
    core will often call xBestIndex multiple times with different constraints, obtain
    multiple cost estimates, then choose the query plan that gives the lowest estimate.
    The SQLite core initializes estimatedCost to a very large value prior to invoking
    xBestIndex, so if xBestIndex determines that the current combination of parameters
    is undesirable, it can leave the estimatedCost field unchanged to discourage its
    use.
  prefs: []
  type: TYPE_NORMAL
- en: If the current version of SQLite is 3.8.2 or greater, the estimatedRows field
    may be set to an estimate of the number of rows returned by the proposed query
    plan. If this value is not explicitly set, the default estimate of 25 rows is
    used.
  prefs: []
  type: TYPE_NORMAL
- en: If the current version of SQLite is 3.9.0 or greater, the idxFlags field may
    be set to SQLITE_INDEX_SCAN_UNIQUE to indicate that the virtual table will return
    only zero or one rows given the input constraints. Additional bits of the idxFlags
    field might be understood in later versions of SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: The aConstraintUsage[] array contains one element for each of the nConstraint
    constraints in the inputs section of the [sqlite3_index_info](c3ref/index_info.html)
    structure. The aConstraintUsage[] array is used by xBestIndex to tell the core
    how it is using the constraints.
  prefs: []
  type: TYPE_NORMAL
- en: The xBestIndex method may set aConstraintUsage[].argvIndex entries to values
    greater than zero. Exactly one entry should be set to 1, another to 2, another
    to 3, and so forth up to as many or as few as the xBestIndex method wants. The
    EXPR of the corresponding constraints will then be passed in as the argv[] parameters
    to xFilter.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if the aConstraint[3].argvIndex is set to 1, then when xFilter
    is called, the argv[0] passed to xFilter will have the EXPR value of the aConstraint[3]
    constraint.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.2.1\. Omit constraint checking in bytecode
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'By default, the SQLite generates [bytecode](opcode.html) that will double checks
    all constraints on each row of the virtual table to verify that they are satisfied.
    If the virtual table can guarantee that a constraint will always be satisfied,
    it can try to suppress that double-check by setting aConstraintUsage[].omit. However,
    with some exceptions, this is only a hint and there is no guarantee that the redundant
    check of the constraint will be suppressed. Key points:'
  prefs: []
  type: TYPE_NORMAL
- en: The omit flag is only honored if the argvIndex value for the constraint is greater
    than 0 and less than or equal to 16\. Constraint checking is never suppressed
    for constraints that do not pass their right operand into the xFilter method.
    The current implementation is only able to suppress redundant constraint checking
    for the first 16 values passed to xFilter, though that limitation might be increased
    in future releases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The omit flag is always honored for [SQLITE_INDEX_CONSTRAINT_OFFSET](c3ref/c_index_constraint_eq.html)
    constraints as long as argvIndex is greater than 0\. Setting the omit flag on
    an SQLITE_INDEX_CONSTRAINT_OFFSET constraint indicates to SQLite that the virtual
    table will itself suppress the first N rows of output, where N is the right operand
    of the OFFSET operator. If the virtual table implementation sets omit on an SQLITE_INDEX_CONSTRAINT_OFFSET
    constraint but then fails to suppress the first N rows of output, an incorrect
    answer will result from the overall query.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.3.2.2\. ORDER BY and orderByConsumed
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the virtual table will output rows in the order specified by the ORDER BY
    clause, then the orderByConsumed flag may be set to true. If the output is not
    automatically in the correct order then orderByConsumed must be left in its default
    false setting. This will indicate to the SQLite core that it will need to do a
    separate sorting pass over the data after it comes out of the virtual table. Setting
    orderByConsumed is an optimization. A query will always get the correct answer
    if orderByConsumed is left at its default value (0). Unnecessary sort operations
    might be avoided resulting in a faster query if orderByConsumed is set, but setting
    orderByConsumed incorrectly can result in an incorrect answer. It is suggested
    that new virtual table implementations leave the orderByConsumed value unset initially,
    and then after everything else is known to be working correctly, go back and attempt
    to optimize by setting orderByConsumed where appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes the orderByConsumed flag can be safely set even if the outputs from
    the virtual table are not strictly in the order specified by nOrderBy and aOrderBy.
    If the [sqlite3_vtab_distinct()](c3ref/vtab_distinct.html) interface returns 1
    or 2, that indicates that the ordering can be relaxed. See the documentation on
    [sqlite3_vtab_distinct()](c3ref/vtab_distinct.html) for further information.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.3\. Return Value
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The xBestIndex method should return SQLITE_OK on success. If any kind of fatal
    error occurs, an appropriate error code (ex: [SQLITE_NOMEM](rescode.html#nomem))
    should be returned instead.'
  prefs: []
  type: TYPE_NORMAL
- en: If xBestIndex returns [SQLITE_CONSTRAINT](rescode.html#constraint), that does
    not indicate an error. Rather, SQLITE_CONSTRAINT indicates that the particular
    combination of input parameters specified is insufficient for the virtual table
    to do its job. This is logically the same as setting the estimatedCost to infinity.
    If every call to xBestIndex for a particular query plan returns SQLITE_CONSTRAINT,
    that means there is no way for the virtual table to be safely used, and the [sqlite3_prepare()](c3ref/prepare.html)
    call will fail with a "no query solution" error.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.4\. Enforcing Required Parameters On Table-Valued Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The SQLITE_CONSTRAINT return from xBestIndex is useful for [table-valued functions](vtab.html#tabfunc2)
    that have required parameters. If the aConstraint[].usable field is false for
    one of the required parameter, then the xBestIndex method should return SQLITE_CONSTRAINT.
    If a required field does not appear in the aConstraint[] array at all, that means
    that the corresponding parameter is omitted from the input SQL. In that case,
    xBestIndex should set an error message in pVTab->zErrMsg and return SQLITE_ERROR.
    To summarize:'
  prefs: []
  type: TYPE_NORMAL
- en: The aConstraint[].usable value for a required parameter is false → return SQLITE_CONSTRAINT.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A required parameter does not appears anywhere in the aConstraint[] array →
    Set an error message in pVTab->zErrMsg and return SQLITE_ERROR
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following example will better illustrate the use of SQLITE_CONSTRAINT as
    a return value from xBestIndex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming that the first hidden column of "tablevaluedfunc" is "param1", the
    query above is semantically equivalent to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The query planner must decide between many possible implementations of this
    query, but two plans in particular are of note:'
  prefs: []
  type: TYPE_NORMAL
- en: Scan all rows of realtab and for each row, find rows in tablevaluedfunc where
    param1 is equal to realtab.x
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scan all rows of tablevalued func and for each row find rows in realtab where
    x is equal to tablevaluedfunc.param1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The xBestIndex method will be invoked once for each of the potential plans above.
    For plan 1, the aConstraint[].usable flag for the SQLITE_CONSTRAINT_EQ constraint
    on the param1 column will be true because the right-hand side value for the "param1
    = ?" constraint will be known, since it is determined by the outer realtab loop.
    But for plan 2, the aConstraint[].usable flag for "param1 = ?" will be false because
    the right-hand side value is determined by an inner loop and is thus an unknown
    quantity. Because param1 is a required input to the table-valued functions, the
    xBestIndex method should return SQLITE_CONSTRAINT when presented with plan 2,
    indicating that a required input is missing. This forces the query planner to
    select plan 1.
  prefs: []
  type: TYPE_NORMAL
- en: 2.4\. The xDisconnect Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This method releases a connection to a virtual table. Only the [sqlite3_vtab](c3ref/vtab.html)
    object is destroyed. The virtual table is not destroyed and any backing store
    associated with the virtual table persists. This method undoes the work of [xConnect](vtab.html#xconnect).
  prefs: []
  type: TYPE_NORMAL
- en: This method is a destructor for a connection to the virtual table. Contrast
    this method with [xDestroy](vtab.html#sqlite3_module.xDestroy). The xDestroy is
    a destructor for the entire virtual table.
  prefs: []
  type: TYPE_NORMAL
- en: The xDisconnect method is required for every virtual table implementation, though
    it is acceptable for the xDisconnect and [xDestroy](vtab.html#sqlite3_module.xDestroy)
    methods to be the same function if that makes sense for the particular virtual
    table.
  prefs: []
  type: TYPE_NORMAL
- en: 2.5\. The xDestroy Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This method releases a connection to a virtual table, just like the [xDisconnect](vtab.html#xdisconnect)
    method, and it also destroys the underlying table implementation. This method
    undoes the work of [xCreate](vtab.html#xcreate).
  prefs: []
  type: TYPE_NORMAL
- en: The [xDisconnect](vtab.html#xdisconnect) method is called whenever a database
    connection that uses a virtual table is closed. The xDestroy method is only called
    when a [DROP TABLE](lang_droptable.html) statement is executed against the virtual
    table.
  prefs: []
  type: TYPE_NORMAL
- en: The xDestroy method is required for every virtual table implementation, though
    it is acceptable for the [xDisconnect](vtab.html#xdisconnect) and xDestroy methods
    to be the same function if that makes sense for the particular virtual table.
  prefs: []
  type: TYPE_NORMAL
- en: 2.6\. The xOpen Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The xOpen method creates a new cursor used for accessing (read and/or writing)
    a virtual table. A successful invocation of this method will allocate the memory
    for the [sqlite3_vtab_cursor](c3ref/vtab_cursor.html) (or a subclass), initialize
    the new object, and make *ppCursor point to the new object. The successful call
    then returns [SQLITE_OK](rescode.html#ok).
  prefs: []
  type: TYPE_NORMAL
- en: For every successful call to this method, the SQLite core will later invoke
    the [xClose](vtab.html#xclose) method to destroy the allocated cursor.
  prefs: []
  type: TYPE_NORMAL
- en: The xOpen method need not initialize the pVtab field of the [sqlite3_vtab_cursor](c3ref/vtab_cursor.html)
    structure. The SQLite core will take care of that chore automatically.
  prefs: []
  type: TYPE_NORMAL
- en: A virtual table implementation must be able to support an arbitrary number of
    simultaneously open cursors.
  prefs: []
  type: TYPE_NORMAL
- en: When initially opened, the cursor is in an undefined state. The SQLite core
    will invoke the [xFilter](vtab.html#xfilter) method on the cursor prior to any
    attempt to position or read from the cursor.
  prefs: []
  type: TYPE_NORMAL
- en: The xOpen method is required for every virtual table implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 2.7\. The xClose Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The xClose method closes a cursor previously opened by [xOpen](vtab.html#xopen).
    The SQLite core will always call xClose once for each cursor opened using xOpen.
  prefs: []
  type: TYPE_NORMAL
- en: This method must release all resources allocated by the corresponding xOpen
    call. The routine will not be called again even if it returns an error. The SQLite
    core will not use the [sqlite3_vtab_cursor](c3ref/vtab_cursor.html) again after
    it has been closed.
  prefs: []
  type: TYPE_NORMAL
- en: The xClose method is required for every virtual table implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 2.8\. The xEof Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The xEof method must return false (zero) if the specified cursor currently points
    to a valid row of data, or true (non-zero) otherwise. This method is called by
    the SQL engine immediately after each [xFilter](vtab.html#xfilter) and [xNext](vtab.html#xnext)
    invocation.
  prefs: []
  type: TYPE_NORMAL
- en: The xEof method is required for every virtual table implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 2.9\. The xFilter Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This method begins a search of a virtual table. The first argument is a cursor
    opened by [xOpen](vtab.html#xopen). The next two arguments define a particular
    search index previously chosen by [xBestIndex](vtab.html#xbestindex). The specific
    meanings of idxNum and idxStr are unimportant as long as xFilter and xBestIndex
    agree on what that meaning is.
  prefs: []
  type: TYPE_NORMAL
- en: The xBestIndex function may have requested the values of certain expressions
    using the aConstraintUsage[].argvIndex values of the [sqlite3_index_info](c3ref/index_info.html)
    structure. Those values are passed to xFilter using the argc and argv parameters.
  prefs: []
  type: TYPE_NORMAL
- en: If the virtual table contains one or more rows that match the search criteria,
    then the cursor must be left point at the first row. Subsequent calls to [xEof](vtab.html#xeof)
    must return false (zero). If there are no rows match, then the cursor must be
    left in a state that will cause the [xEof](vtab.html#xeof) to return true (non-zero).
    The SQLite engine will use the [xColumn](vtab.html#xcolumn) and [xRowid](vtab.html#xrowid)
    methods to access that row content. The [xNext](vtab.html#xnext) method will be
    used to advance to the next row.
  prefs: []
  type: TYPE_NORMAL
- en: This method must return [SQLITE_OK](rescode.html#ok) if successful, or an sqlite
    [error code](rescode.html) if an error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: The xFilter method is required for every virtual table implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 2.10\. The xNext Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The xNext method advances a [virtual table cursor](c3ref/vtab_cursor.html) to
    the next row of a result set initiated by [xFilter](vtab.html#xfilter). If the
    cursor is already pointing at the last row when this routine is called, then the
    cursor no longer points to valid data and a subsequent call to the [xEof](vtab.html#xeof)
    method must return true (non-zero). If the cursor is successfully advanced to
    another row of content, then subsequent calls to [xEof](vtab.html#xeof) must return
    false (zero).
  prefs: []
  type: TYPE_NORMAL
- en: This method must return [SQLITE_OK](rescode.html#ok) if successful, or an sqlite
    [error code](rescode.html) if an error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: The xNext method is required for every virtual table implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 2.11\. The xColumn Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The SQLite core invokes this method in order to find the value for the N-th
    column of the current row. N is zero-based so the first column is numbered 0\.
    The xColumn method may return its result back to SQLite using one of the following
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[sqlite3_result_blob()](c3ref/result_blob.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[sqlite3_result_double()](c3ref/result_blob.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[sqlite3_result_int()](c3ref/result_blob.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[sqlite3_result_int64()](c3ref/result_blob.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[sqlite3_result_null()](c3ref/result_blob.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[sqlite3_result_text()](c3ref/result_blob.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[sqlite3_result_text16()](c3ref/result_blob.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[sqlite3_result_text16le()](c3ref/result_blob.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[sqlite3_result_text16be()](c3ref/result_blob.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[sqlite3_result_zeroblob()](c3ref/result_blob.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the xColumn method implementation calls none of the functions above, then
    the value of the column defaults to an SQL NULL.
  prefs: []
  type: TYPE_NORMAL
- en: To raise an error, the xColumn method should use one of the result_text() methods
    to set the error message text, then return an appropriate [error code](rescode.html).
    The xColumn method must return [SQLITE_OK](rescode.html#ok) on success.
  prefs: []
  type: TYPE_NORMAL
- en: The xColumn method is required for every virtual table implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 2.12\. The xRowid Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: A successful invocation of this method will cause *pRowid to be filled with
    the [rowid](lang_createtable.html#rowid) of row that the [virtual table cursor](c3ref/vtab_cursor.html)
    pCur is currently pointing at. This method returns [SQLITE_OK](rescode.html#ok)
    on success. It returns an appropriate [error code](rescode.html) on failure.
  prefs: []
  type: TYPE_NORMAL
- en: The xRowid method is required for every virtual table implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 2.13\. The xUpdate Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: All changes to a virtual table are made using the xUpdate method. This one method
    can be used to insert, delete, or update.
  prefs: []
  type: TYPE_NORMAL
- en: The argc parameter specifies the number of entries in the argv array. The value
    of argc will be 1 for a pure delete operation or N+2 for an insert or replace
    or update where N is the number of columns in the table. In the previous sentence,
    N includes any hidden columns.
  prefs: []
  type: TYPE_NORMAL
- en: Every argv entry will have a non-NULL value in C but may contain the SQL value
    NULL. In other words, it is always true that `argv[i]!=0` for **i** between 0
    and `argc-1`. However, it might be the case that `sqlite3_value_type(argv[i])==SQLITE_NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: The argv[0] parameter is the [rowid](lang_createtable.html#rowid) of a row in
    the virtual table to be deleted. If argv[0] is an SQL NULL, then no deletion occurs.
  prefs: []
  type: TYPE_NORMAL
- en: The argv[1] parameter is the rowid of a new row to be inserted into the virtual
    table. If argv[1] is an SQL NULL, then the implementation must choose a rowid
    for the newly inserted row. Subsequent argv[] entries contain values of the columns
    of the virtual table, in the order that the columns were declared. The number
    of columns will match the table declaration that the [xConnect](vtab.html#xconnect)
    or [xCreate](vtab.html#xcreate) method made using the [sqlite3_declare_vtab()](c3ref/declare_vtab.html)
    call. All hidden columns are included.
  prefs: []
  type: TYPE_NORMAL
- en: When doing an insert without a rowid (argc>1, argv[1] is an SQL NULL), on a
    virtual table that uses ROWID (but not on a [WITHOUT ROWID virtual table](vtab.html#worid)),
    the implementation must set *pRowid to the rowid of the newly inserted row; this
    will become the value returned by the [sqlite3_last_insert_rowid()](c3ref/last_insert_rowid.html)
    function. Setting this value in all the other cases is a harmless no-op; the SQLite
    engine ignores the *pRowid return value if argc==1 or argv[1] is not an SQL NULL.
  prefs: []
  type: TYPE_NORMAL
- en: Each call to xUpdate will fall into one of cases shown below. Not that references
    to **argv[i]** mean the SQL value held within the argv[i] object, not the argv[i]
    object itself.
  prefs: []
  type: TYPE_NORMAL
- en: '**argc = 1'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: argv[0] ≠ NULL**
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'DELETE: The single row with rowid or PRIMARY KEY equal to argv[0] is deleted.
    No insert occurs.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**argc > 1'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: argv[0] = NULL**
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'INSERT: A new row is inserted with column values taken from argv[2] and following.
    In a rowid virtual table, if argv[1] is an SQL NULL, then a new unique rowid is
    generated automatically. The argv[1] will be NULL for a [WITHOUT ROWID virtual
    table](vtab.html#worid), in which case the implementation should take the PRIMARY
    KEY value from the appropriate column in argv[2] and following.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**argc > 1'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: argv[0] ≠ NULL
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: argv[0] = argv[1]**
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'UPDATE: The row with rowid or PRIMARY KEY argv[0] is updated with new values
    in argv[2] and following parameters.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**argc > 1'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: argv[0] ≠ NULL
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: argv[0] ≠ argv[1]**
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'UPDATE with rowid or PRIMARY KEY change: The row with rowid or PRIMARY KEY
    argv[0] is updated with the rowid or PRIMARY KEY in argv[1] and new values in
    argv[2] and following parameters. This will occur when an SQL statement updates
    a rowid, as in the statement:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[UPDATE](lang_update.html) table SET rowid=rowid+1 WHERE ...;'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: The xUpdate method must return [SQLITE_OK](rescode.html#ok) if and only if it
    is successful. If a failure occurs, the xUpdate must return an appropriate [error
    code](rescode.html). On a failure, the pVTab->zErrMsg element may optionally be
    replaced with error message text stored in memory allocated from SQLite using
    functions such as [sqlite3_mprintf()](c3ref/mprintf.html) or [sqlite3_malloc()](c3ref/free.html).
  prefs: []
  type: TYPE_NORMAL
- en: If the xUpdate method violates some constraint of the virtual table (including,
    but not limited to, attempting to store a value of the wrong datatype, attempting
    to store a value that is too large or too small, or attempting to change a read-only
    value) then the xUpdate must fail with an appropriate [error code](rescode.html).
  prefs: []
  type: TYPE_NORMAL
- en: If the xUpdate method is performing an UPDATE, then [sqlite3_value_nochange(X)](c3ref/value_blob.html)
    can be used to discover which columns of the virtual table were actually modified
    by the UPDATE statement. The [sqlite3_value_nochange(X)](c3ref/value_blob.html)
    interface returns true for columns that do not change. On every UPDATE, SQLite
    will first invoke [xColumn](vtab.html#xcolumn) separately for each unchanging
    column in the table to obtain the value for that column. The [xColumn](vtab.html#xcolumn)
    method can check to see if the column is unchanged at the SQL level by invoking
    [sqlite3_vtab_nochange()](c3ref/vtab_nochange.html). If [xColumn](vtab.html#xcolumn)
    sees that the column is not being modified, it should return without setting a
    result using one of the [sqlite3_result_xxxxx()](c3ref/result_blob.html) interfaces.
    Only in that case [sqlite3_value_nochange()](c3ref/value_blob.html) will be true
    within the xUpdate method. If [xColumn](vtab.html#xcolumn) does invoke one or
    more [sqlite3_result_xxxxx()](c3ref/result_blob.html) interfaces, then SQLite
    understands that as a change in the value of the column and the [sqlite3_value_nochange()](c3ref/value_blob.html)
    call for that column within xUpdate will return false.
  prefs: []
  type: TYPE_NORMAL
- en: There might be one or more [sqlite3_vtab_cursor](c3ref/vtab_cursor.html) objects
    open and in use on the virtual table instance and perhaps even on the row of the
    virtual table when the xUpdate method is invoked. The implementation of xUpdate
    must be prepared for attempts to delete or modify rows of the table out from other
    existing cursors. If the virtual table cannot accommodate such changes, the xUpdate
    method must return an [error code](rescode.html).
  prefs: []
  type: TYPE_NORMAL
- en: The xUpdate method is optional. If the xUpdate pointer in the [sqlite3_module](c3ref/module.html)
    for a virtual table is a NULL pointer, then the virtual table is read-only.
  prefs: []
  type: TYPE_NORMAL
- en: 2.14\. The xFindFunction Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This method is called during [sqlite3_prepare()](c3ref/prepare.html) to give
    the virtual table implementation an opportunity to overload functions. This method
    may be set to NULL in which case no overloading occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a function uses a column from a virtual table as its first argument, this
    method is called to see if the virtual table would like to overload the function.
    The first three parameters are inputs: the virtual table, the number of arguments
    to the function, and the name of the function. If no overloading is desired, this
    method returns 0\. To overload the function, this method writes the new function
    implementation into *pxFunc and writes user data into *ppArg and returns either
    1 or a number between [SQLITE_INDEX_CONSTRAINT_FUNCTION](c3ref/c_index_constraint_eq.html)
    and 255.'
  prefs: []
  type: TYPE_NORMAL
- en: Historically, the return value from xFindFunction() was either zero or one.
    Zero means that the function is not overloaded and one means that it is overload.
    The ability to return values of [SQLITE_INDEX_CONSTRAINT_FUNCTION](c3ref/c_index_constraint_eq.html)
    or greater was added in version 3.25.0 (2018-09-15). If xFindFunction returns
    [SQLITE_INDEX_CONSTRAINT_FUNCTION](c3ref/c_index_constraint_eq.html) or greater,
    than means that the function takes two arguments and the function can be used
    as a boolean in the WHERE clause of a query and that the virtual table is able
    to exploit that function to speed up the query result. When xFindFunction returns
    [SQLITE_INDEX_CONSTRAINT_FUNCTION](c3ref/c_index_constraint_eq.html) or larger,
    the value returned becomes the [sqlite3_index_info](c3ref/index_info.html).aConstraint.op
    value for one of the constraints passed into [xBestIndex()](vtab.html#xbestindex).
    The first argument to the function is the column identified by aConstraint[].iColumn
    field of the constraint and the second argument to the function is the value that
    will be passed into [xFilter()](vtab.html#xfilter) (if the aConstraintUsage[].argvIndex
    value is set) or the value returned from [sqlite3_vtab_rhs_value()](c3ref/vtab_rhs_value.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The [Geopoly module](geopoly.html) is an example of a virtual table that makes
    use of [SQLITE_INDEX_CONSTRAINT_FUNCTION](c3ref/c_index_constraint_eq.html) to
    improve performance. The xFindFunction() method for Geopoly returns SQLITE_INDEX_CONSTRAINT_FUNCTION
    for the [geopoly_overlap()](geopoly.html#goverlap) SQL function and it returns
    SQLITE_INDEX_CONSTRAINT_FUNCTION+1 for the [geopoly_within()](geopoly.html#gwithin)
    SQL function. This permits search optimizations for queries such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note that infix functions ([LIKE](lang_expr.html#like), [GLOB](lang_expr.html#glob),
    [REGEXP](lang_expr.html#regexp), and [MATCH](lang_expr.html#match)) reverse the
    order of their arguments. So "like(A,B)" would normally work the same as "B like
    A". However, xFindFunction() always looks a the left-most argument, not the first
    logical argument. Hence, for the form "B like A", SQLite looks at the left operand
    "B" and if that operand is a virtual table column it invokes the xFindFunction()
    method on that virtual table. But if the form "like(A,B)" is used instead, then
    SQLite checks the A term to see if it is column of a virtual table and if so it
    invokes the xFindFunction() method for the virtual table of column A.
  prefs: []
  type: TYPE_NORMAL
- en: The function pointer returned by this routine must be valid for the lifetime
    of the [sqlite3_vtab](c3ref/vtab.html) object given in the first parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 2.15\. The xBegin Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This method begins a transaction on a virtual table. This is method is optional.
    The xBegin pointer of [sqlite3_module](c3ref/module.html) may be NULL.
  prefs: []
  type: TYPE_NORMAL
- en: This method is always followed by one call to either the [xCommit](vtab.html#xcommit)
    or [xRollback](vtab.html#xrollback) method. Virtual table transactions do not
    nest, so the xBegin method will not be invoked more than once on a single virtual
    table without an intervening call to either [xCommit](vtab.html#xcommit) or [xRollback](vtab.html#xrollback).
    Multiple calls to other methods can and likely will occur in between the xBegin
    and the corresponding [xCommit](vtab.html#xcommit) or [xRollback](vtab.html#xrollback).
  prefs: []
  type: TYPE_NORMAL
- en: 2.16\. The xSync Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This method signals the start of a two-phase commit on a virtual table. This
    is method is optional. The xSync pointer of [sqlite3_module](c3ref/module.html)
    may be NULL.
  prefs: []
  type: TYPE_NORMAL
- en: This method is only invoked after call to the [xBegin](vtab.html#xBegin) method
    and prior to an [xCommit](vtab.html#xcommit) or [xRollback](vtab.html#xrollback).
    In order to implement two-phase commit, the xSync method on all virtual tables
    is invoked prior to invoking the [xCommit](vtab.html#xcommit) method on any virtual
    table. If any of the xSync methods fail, the entire transaction is rolled back.
  prefs: []
  type: TYPE_NORMAL
- en: 2.17\. The xCommit Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This method causes a virtual table transaction to commit. This is method is
    optional. The xCommit pointer of [sqlite3_module](c3ref/module.html) may be NULL.
  prefs: []
  type: TYPE_NORMAL
- en: A call to this method always follows a prior call to [xBegin](vtab.html#xBegin)
    and [xSync](vtab.html#xsync).
  prefs: []
  type: TYPE_NORMAL
- en: 2.18\. The xRollback Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This method causes a virtual table transaction to rollback. This is method is
    optional. The xRollback pointer of [sqlite3_module](c3ref/module.html) may be
    NULL.
  prefs: []
  type: TYPE_NORMAL
- en: A call to this method always follows a prior call to [xBegin](vtab.html#xBegin).
  prefs: []
  type: TYPE_NORMAL
- en: 2.19\. The xRename Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This method provides notification that the virtual table implementation that
    the virtual table will be given a new name. If this method returns [SQLITE_OK](rescode.html#ok)
    then SQLite renames the table. If this method returns an [error code](rescode.html)
    then the renaming is prevented.
  prefs: []
  type: TYPE_NORMAL
- en: The xRename method is optional. If omitted, then the virtual table may not be
    renamed using the ALTER TABLE RENAME command.
  prefs: []
  type: TYPE_NORMAL
- en: The [PRAGMA legacy_alter_table](pragma.html#pragma_legacy_alter_table) setting
    is enabled prior to invoking this method, and the value for legacy_alter_table
    is restored after this method finishes. This is necessary for the correct operation
    of virtual tables that make use of [shadow tables](vtab.html#xshadowname) where
    the shadow tables must be renamed to match the new virtual table name. If the
    legacy_alter_format is off, then the xConnect method will be invoked for the virtual
    table every time the xRename method tries to change the name of the shadow table.
  prefs: []
  type: TYPE_NORMAL
- en: 2.20\. The xSavepoint, xRelease, and xRollbackTo Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: These methods provide the virtual table implementation an opportunity to implement
    nested transactions. They are always optional and will only be called in SQLite
    [version 3.7.7](releaselog/3_7_7.html) (2011-06-23) and later.
  prefs: []
  type: TYPE_NORMAL
- en: When xSavepoint(X,N) is invoked, that is a signal to the virtual table X that
    it should save its current state as savepoint N. A subsequent call to xRollbackTo(X,R)
    means that the state of the virtual table should return to what it was when xSavepoint(X,R)
    was last called. The call to xRollbackTo(X,R) will invalidate all savepoints with
    N>R; none of the invalided savepoints will be rolled back or released without
    first being reinitialized by a call to xSavepoint(). A call to xRelease(X,M) invalidates
    all savepoints where N>=M.
  prefs: []
  type: TYPE_NORMAL
- en: None of the xSavepoint(), xRelease(), or xRollbackTo() methods will ever be
    called except in between calls to xBegin() and either xCommit() or xRollback().
  prefs: []
  type: TYPE_NORMAL
- en: 2.21\. The xShadowName Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some virtual table implementations (ex: [FTS3](fts3.html), [FTS5](fts5.html),
    and [RTREE](rtree.html)) make use of real (non-virtual) database tables to store
    content. For example, when content is inserted into the FTS3 virtual table, the
    data is ultimately stored in real tables named "%_content", "%_segdir", "%_segments",
    "%_stat", and "%_docsize" where "%" is the name of the original virtual table.
    This auxiliary real tables that store content for a virtual table are called "shadow
    tables". See ([1](fts3.html#*shadowtab)), ([2](fts5.html#fts5shadowtables)), and
    ([3](rtree.html#xshadow)) for additional information.'
  prefs: []
  type: TYPE_NORMAL
- en: The xShadowName method exists to allow SQLite to determine whether a certain
    real table is in fact a shadow table for a virtual table.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLite understands a real table to be a shadow table if all of the following
    are true:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the table contains one or more "_" characters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The part of the name prior to the last "_" exactly matches the name of a virtual
    table that was created using [CREATE VIRTUAL TABLE](lang_createvtab.html). (Shadow
    tables are not recognized for [eponymous virtual tables](vtab.html#epovtab) and
    [table-valued functions](vtab.html#tabfunc2).)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The virtual table contains an xShadowName method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The xShadowName method returns true when its input is the part of the table
    name past the last "_" character.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If SQLite recognizes a table as a shadow table, and if the [SQLITE_DBCONFIG_DEFENSIVE](c3ref/c_dbconfig_defensive.html#sqlitedbconfigdefensive)
    flag is set, then the shadow table is read-only for ordinary SQL statements. The
    shadow table can still be written, but only by SQL that is invoked from within
    one of the methods of some virtual table implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The whole point of the xShadowName method is to protect the content of shadow
    tables from being corrupted by hostile SQL. Every virtual table implementation
    that uses shadow tables should be able to detect and cope with corrupted shadow
    table content. However, bugs in particular virtual table implementation might
    allow a deliberately corrupted shadow table to cause a crash or other malfunction.
    The xShadowName mechanism seeks to avoid zero-day exploits by preventing ordinary
    SQL statements from deliberately corrupting shadow tables.
  prefs: []
  type: TYPE_NORMAL
- en: Shadow tables are read/write by default. Shadow tables only become read-only
    when the [SQLITE_DBCONFIG_DEFENSIVE](c3ref/c_dbconfig_defensive.html#sqlitedbconfigdefensive)
    flag is set using [sqlite3_db_config()](c3ref/db_config.html). Shadow tables need
    to be read/write by default in order to maintain backwards compatibility. For
    example, the SQL text generated by the [.dump](cli.html#dump) command of the [CLI](cli.html)
    writes directly into shadow tables.
  prefs: []
  type: TYPE_NORMAL
- en: 2.22\. The xIntegrity Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the iVersion for an sqlite3_module is 4 or more and the xIntegrity method
    is not NULL, then the [PRAGMA integrity_check](pragma.html#pragma_integrity_check)
    and [PRAGMA quick_check](pragma.html#pragma_quick_check) commands will invoke
    xIntegrity as part of its processing. If the xIntegrity method writes an error
    message string into the fifth parameter, then PRAGMA integrity_check will report
    that error as part of its output. So, in other words, the xIntegrity method allows
    the [PRAGMA integrity_check](pragma.html#pragma_integrity_check) command to verify
    the integrity of content stored in a virtual table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The xIntegrity method is called with five parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**pVTab** → A pointer to the [sqlite3_vtab](c3ref/vtab.html) object that is
    the virtual table being checked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**zSchema** → The name of the schema ("main", "temp", etc.) in which the virtual
    table is defined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**zTabName** → The name of the virtual table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**mFlags** → A flag to indicate whether this is an "integrity_check" or a "quick_check".
    Currently, this parameter will always be either 0 or 1, though future versions
    of SQLite might use other bits of the integer to indicate additional processing
    options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pzErr** → This parameter points to a "char*" that is initialized to NULL.
    The xIntegrity() implementation should make *pzErr point to an error string obtained
    from sqlite3_malloc() or equivalent if it finds any problems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The xIntegrity method should normally return SQLITE_OK - even if it finds problems
    in the content of the virtual table. Any other error code means that the xIntegrity
    method itself encountered problems while trying to evaluate the virtual table
    content. So, for example, if the inverted index for [FTS5](fts5.html) is found
    to be internally inconsistent, then the xIntegrity method should write an appropriate
    error message into the pzErr parameter and return SQLITE_OK. But if the xIntegrity
    method is unable to complete its evaluation of the virtual table content due to
    running out of memory, then it should return SQLITE_NOMEM.
  prefs: []
  type: TYPE_NORMAL
- en: If an error message is generated, space to hold the error message string should
    be obtained from [sqlite3_malloc64()](c3ref/free.html) or the equivalent. Ownership
    of the error message string will pass to the SQLite core when xIntegrity returns.
    The core will make sure that [sqlite3_free()](c3ref/free.html) is invoked to reclaim
    the memory which it has finished with the error message. The PRAGMA integrity_check
    command that invokes the xIntegrity method does not change the returned error
    message. The xIntegrity method itself should include the name of the virtual table
    as part of the message. The zSchema and zName parameters are provided to make
    that easier.
  prefs: []
  type: TYPE_NORMAL
- en: The mFlags parameter is currently a boolean value (either 0 or 1) that indicates
    if the xIntegrity method was called due to [PRAGMA integrity_check](pragma.html#pragma_integrity_check)
    (mFlags==0) or due to [PRAGMA quick_check](pragma.html#pragma_quick_check) (mFlags==1).
    Generally speaking, the xIntegrity method should do whatever validity checking
    it can accomplish in linear time regardless, but only do checking that requires
    superlinear time if `(mFlags&1)==0`. Future versions of SQLite might use higher-order
    bits of the mFlags parameter to indicate additional processing options.
  prefs: []
  type: TYPE_NORMAL
- en: Support for the xIntegrity method was added in SQLite version 3.44.0 (2023-11-01).
    In that same release, the xIntegrity method was added to many built-in virtual
    tables, such as [FTS3](fts3.html), [FTS5](fts5.html), and [RTREE](rtree.html)
    so that the content of those tables will henceforth be automatically checked for
    consistency when [PRAGMA integrity_check](pragma.html#pragma_integrity_check)
    is run.
  prefs: []
  type: TYPE_NORMAL
