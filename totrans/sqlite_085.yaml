- en: 1\. Introduction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1\. 引言
- en: 原文：[https://sqlite.com/optoverview.html](https://sqlite.com/optoverview.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://sqlite.com/optoverview.html](https://sqlite.com/optoverview.html)
- en: This document provides an overview of how the query planner and optimizer for
    SQLite works.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本文档概述了 SQLite 查询规划器和优化器的工作原理。
- en: Given a single SQL statement, there might be dozens, hundreds, or even thousands
    of ways to implement that statement, depending on the complexity of the statement
    itself and of the underlying database schema. The task of the query planner is
    to select the algorithm that minimizes disk I/O and CPU overhead.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个单个 SQL 语句，根据语句本身的复杂性和底层数据库模式的复杂性，可能会有几十个、几百个，甚至上千种实现该语句的方式。查询规划器的任务是选择最小化磁盘
    I/O 和 CPU 开销的算法。
- en: Additional background information is available in the [indexing tutorial](queryplanner.html)
    document. The [Next Generation Query Planner](queryplanner-ng.html) document provides
    more detail on how the [join order](optoverview.html#joins) is chosen.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的背景信息可在[索引教程](queryplanner.html)文档中找到。[下一代查询规划器](queryplanner-ng.html)文档详细描述了如何选择[连接顺序](optoverview.html#joins)。
- en: 2\. WHERE Clause Analysis
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2\. WHERE 子句分析
- en: 'Prior to analysis, the following transformations are made to shift all join
    constraints into the WHERE clause:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析之前，会进行以下转换，将所有连接约束移到 WHERE 子句中：
- en: All NATURAL joins are converted into joins with a USING clause.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有自然连接都转换为带有 USING 子句的连接。
- en: All USING clauses (including ones created by the previous step) are converted
    into equivalent ON clauses.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有 USING 子句（包括前面步骤创建的）都会转换为等效的 ON 子句。
- en: All ON clauses (include ones created by the previous step) are added as new
    conjuncts (AND-connected terms) in the WHERE clause.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有 ON 子句（包括前面步骤创建的）都作为 WHERE 子句中的新连接项（AND 连接的术语）添加。
- en: SQLite makes no distinction between join constraints that occur in the WHERE
    clause and constraints in the ON clause of an inner join, since that distinction
    does not affect the outcome. However, there is a difference between ON clause
    constraints and WHERE clause constraints for outer joins. Therefore, when SQLite
    moves an ON clause constraint from an outer join over to the WHERE clause it adds
    special tags to the Abstract Syntax Tree (AST) to indicate that the constraint
    came from an outer join and from which outer join it came. There is no way to
    add those tags in pure SQL text. Hence, the SQL input must use ON clauses on outer
    joins. But in the internal AST, all constraints are part of the WHERE clause,
    because having everything in one place simplifies processing.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 在 WHERE 子句中出现的连接约束和内连接的 ON 子句中的约束之间没有区别，因为这个区别不影响结果。然而，对于外连接，ON 子句约束和
    WHERE 子句约束之间存在差异。因此，当 SQLite 将来自外连接的 ON 子句约束移动到 WHERE 子句时，它会向抽象语法树（AST）添加特殊标记，指示该约束来自外连接及其来源。在纯
    SQL 文本中无法添加这些标记。因此，SQL 输入必须在外连接上使用 ON 子句。但在内部 AST 中，所有约束都是 WHERE 子句的一部分，因为将所有内容放在一个地方简化了处理过程。
- en: After all constraints have been shifted into the WHERE clause, The WHERE clause
    is broken up into conjuncts (hereafter called "terms"). In other words, the WHERE
    clause is broken up into pieces separated from the others by an AND operator.
    If the WHERE clause is composed of constraints separated by the OR operator (disjuncts)
    then the entire clause is considered to be a single "term" to which the [OR-clause
    optimization](#or_opt) is applied.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有约束已转移到 WHERE 子句之后，WHERE 子句被分解为多个联结（以下简称为“条件”）。换句话说，WHERE 子句被分解为由 AND 运算符分隔的片段。如果
    WHERE 子句由 OR 运算符分隔的约束（析取式）组成，则整个子句被视为单个“条件”，适用于 [OR 子句优化](#or_opt)。
- en: 'All terms of the WHERE clause are analyzed to see if they can be satisfied
    using indexes. To be usable by an index a term must usually be of one of the following
    forms:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: WHERE 子句的所有条件都会被分析，以确定它们是否可以通过索引满足。要被索引使用，条件通常必须满足以下形式之一：
- en: '[PRE0]'
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If an index is created using a statement like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用类似以下语句创建索引：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Then the index might be used if the initial columns of the index (columns a,
    b, and so forth) appear in WHERE clause terms. The initial columns of the index
    must be used with the **=** or **IN** or **IS** operators. The right-most column
    that is used can employ inequalities. For the right-most column of an index that
    is used, there can be up to two inequalities that must sandwich the allowed values
    of the column between two extremes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果索引的初始列（例如列 a、b 等）出现在 WHERE 子句的条件中，则可能会使用该索引。索引的初始列必须与 **=** 或 **IN** 或 **IS**
    操作符一起使用。使用的索引最右列可以包含不等式。对于使用的索引最右列，可以有多达两个不等式，这些不等式必须将该列的允许值夹在两个极端值之间。
- en: It is not necessary for every column of an index to appear in a WHERE clause
    term in order for that index to be used. However, there cannot be gaps in the
    columns of the index that are used. Thus for the example index above, if there
    is no WHERE clause term that constrains column c, then terms that constrain columns
    a and b can be used with the index but not terms that constrain columns d through
    z. Similarly, index columns will not normally be used (for indexing purposes)
    if they are to the right of a column that is constrained only by inequalities.
    (See the [skip-scan optimization](optoverview.html#skipscan) below for the exception.)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 并非必须在 WHERE 子句的每个条件中出现索引的每一列才能使用该索引。但是，索引使用的列之间不能有间隔。因此，对于上述示例的索引，如果没有约束列 c
    的 WHERE 子句条件，则约束列 a 和 b 的条件可以与索引一起使用，但不能约束列 d 到 z 的条件。类似地，如果索引列位于仅通过不等式约束的列右侧，则通常不会使用索引列（用于索引目的）。（有关例外情况，请参见下面的
    [跳过扫描优化](optoverview.html#skipscan)。）
- en: In the case of [indexes on expressions](expridx.html), whenever the word "column"
    is used in the foregoing text, one can substitute "indexed expression" (meaning
    a copy of the expression that appears in the [CREATE INDEX](lang_createindex.html)
    statement) and everything will work the same.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在[表达式索引](expridx.html)的情况下，每当前文中出现"列"一词时，可以将其替换为"索引表达式"（即出现在[CREATE INDEX](lang_createindex.html)语句中的表达式的副本），所有内容将依然有效。
- en: 2.1\. Index Term Usage Examples
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1\. 索引术语使用示例
- en: 'For the index above and WHERE clause like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述索引和类似的 WHERE 子句：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first four columns a, b, c, and d of the index would be usable since those
    four columns form a prefix of the index and are all bound by equality constraints.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 索引的前四列 a、b、c 和 d 可以使用，因为这四列形成了索引的前缀，并且都受到等式约束的限制。
- en: 'For the index above and WHERE clause like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述索引和类似的 WHERE 子句：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Only columns a, b, and c of the index would be usable. The d column would not
    be usable because it occurs to the right of c and c is constrained only by inequalities.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 只有索引的列 a、b 和 c 可以使用。列 d 无法使用，因为它位于 c 的右侧，并且 c 只受到不等式约束的限制。
- en: 'For the index above and WHERE clause like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述索引和类似的 WHERE 子句：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Only columns a and b of the index would be usable. The d column would not be
    usable because column c is not constrained and there can be no gaps in the set
    of columns that usable by the index.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 只有索引的列 a 和 b 可以使用。列 d 无法使用，因为列 c 没有约束，并且索引使用的列集中不应有空缺。
- en: 'For the index above and WHERE clause like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述索引和类似的 WHERE 子句：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The index is not usable at all because the left-most column of the index (column
    "a") is not constrained. Assuming there are no other indexes, the query above
    would result in a full table scan.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 整个索引都无法使用，因为索引的最左列（列 "a"）没有约束。假设没有其他索引，上述查询将导致全表扫描。
- en: 'For the index above and WHERE clause like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述索引和类似的 WHERE 子句：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The index is not usable because the WHERE clause terms are connected by OR instead
    of AND. This query would result in a full table scan. However, if three additional
    indexes where added that contained columns b, c, and d as their left-most columns,
    then the [OR-clause optimization](#or_opt) might apply.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 WHERE 子句中的术语由 OR 而不是 AND 连接，因此索引无法使用。此查询将导致全表扫描。但是，如果添加了另外三个包含列 b、c 和 d 作为最左列的索引，那么可能会应用
    [OR 子句优化](#or_opt)。
- en: 3\. The BETWEEN Optimization
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3\. BETWEEN 优化
- en: 'If a term of the WHERE clause is of the following form:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 WHERE 子句的一个术语具有以下形式：
- en: '[PRE7]'
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then two "virtual" terms are added as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后添加两个"虚拟"术语如下：
- en: '[PRE8]'
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Virtual terms are used for analysis only and do not cause any byte-code to be
    generated. If both virtual terms end up being used as constraints on an index,
    then the original BETWEEN term is omitted and the corresponding test is not performed
    on input rows. Thus if the BETWEEN term ends up being used as an index constraint
    no tests are ever performed on that term. On the other hand, the virtual terms
    themselves never causes tests to be performed on input rows. Thus if the BETWEEN
    term is not used as an index constraint and instead must be used to test input
    rows, the *expr1* expression is only evaluated once.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟项仅用于分析，并且不会生成任何字节码。如果两个虚拟项最终都被用作索引的约束条件，那么原始的**BETWEEN**条件将被省略，并且对输入行不执行相应的测试。因此，如果**BETWEEN**条件最终被用作索引约束，那么该条件上的测试将永远不会执行。另一方面，虚拟项本身永远不会导致对输入行执行测试。因此，如果**BETWEEN**条件未被用作索引约束，而必须用于测试输入行时，*expr1*表达式只会被评估一次。
- en: 4\. OR Optimizations
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4\. OR 优化
- en: WHERE clause constraints that are connected by OR instead of AND can be handled
    in two different ways.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过OR而不是AND连接的WHERE子句约束可以以两种不同的方式处理。
- en: 4.1\. Converting OR-connected constraint into an IN operator
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1\. 将OR连接的约束转换为IN运算符
- en: 'If a term consists of multiple subterms containing a common column name and
    separated by OR, like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个项由包含公共列名且由OR分隔的多个子项组成，如下所示：
- en: '[PRE9]'
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then that term is rewritten as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后该项被重写如下：
- en: '[PRE10]'
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The rewritten term then might go on to constrain an index using the normal rules
    for **IN** operators. Note that *column* must be the same column in every OR-connected
    subterm, although the column can occur on either the left or the right side of
    the **=** operator.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然后重写的项可能继续使用常规的**IN**运算符规则来约束索引。请注意，*column*必须是每个OR连接子项中相同的列，尽管该列可以出现在**=**运算符的左侧或右侧。
- en: 4.2\. Evaluating OR constraints separately and taking the UNION of the result
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2\. 单独评估OR约束并取其结果的并集
- en: 'If and only if the previously described conversion of OR to an IN operator
    does not work, the second OR-clause optimization is attempted. Suppose the OR
    clause consists of multiple subterms as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当且仅当先前描述的OR转换为IN运算符不起作用时，尝试第二个OR子句优化。假设OR子句由多个子项组成如下：
- en: '[PRE11]'
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Individual subterms might be a single comparison expression like **a=5** or
    **x>y** or they can be LIKE or BETWEEN expressions, or a subterm can be a parenthesized
    list of AND-connected sub-subterms. Each subterm is analyzed as if it were itself
    the entire WHERE clause in order to see if the subterm is indexable by itself.
    If every subterm of an OR clause is separately indexable then the OR clause might
    be coded such that a separate index is used to evaluate each term of the OR clause.
    One way to think about how SQLite uses separate indexes for each OR clause term
    is to imagine that the WHERE clause where rewritten as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 个别子项可以是单个比较表达式，如**a=5**或**x>y**，也可以是LIKE或BETWEEN表达式，或者子项可以是AND连接的子子项的括号列表。每个子项都被分析，就好像它本身是整个WHERE子句，以便查看该子项是否可以单独建立索引。如果OR子句的每个子项都可以单独建立索引，那么OR子句可能被编码为使用单独的索引来评估OR子句的每个项。想象SQLite如何对每个OR子句项使用单独索引的一种方式是将WHERE子句重写如下：
- en: '[PRE12]'
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The rewritten expression above is conceptual; WHERE clauses containing OR are
    not really rewritten this way. The actual implementation of the OR clause uses
    a mechanism that is more efficient and that works even for [WITHOUT ROWID](withoutrowid.html)
    tables or tables in which the "rowid" is inaccessible. Nevertheless, the essence
    of the implementation is captured by the statement above: Separate indexes are
    used to find candidate result rows from each OR clause term and the final result
    is the union of those rows.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 上述重写表达式是概念性的；包含OR的WHERE子句并不真的被这样重写。OR子句的实际实现使用了一种更高效的机制，即使对于[WITHOUT ROWID](withoutrowid.html)表或"rowid"不可访问的表也能工作。然而，上述语句捕捉到了实现的本质：使用单独的索引来查找每个OR子句项的候选结果行，最终结果是这些行的并集。
- en: Note that in most cases, SQLite will only use a single index for each table
    in the FROM clause of a query. The second OR-clause optimization described here
    is the exception to that rule. With an OR-clause, a different index might be used
    for each subterm in the OR-clause.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在大多数情况下，SQLite在查询的FROM子句中每个表只使用单个索引。这里描述的第二个OR子句优化是这一规则的例外。对于OR子句，每个子项可能会使用不同的索引。
- en: For any given query, the fact that the OR-clause optimization described here
    can be used does not guarantee that it will be used. SQLite uses a cost-based
    query planner that estimates the CPU and disk I/O costs of various competing query
    plans and chooses the plan that it thinks will be the fastest. If there are many
    OR terms in the WHERE clause or if some of the indexes on individual OR-clause
    subterms are not very selective, then SQLite might decide that it is faster to
    use a different query algorithm, or even a full-table scan. Application developers
    can use the [EXPLAIN QUERY PLAN](lang_explain.html) prefix on a statement to get
    a high-level overview of the chosen query strategy.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何给定的查询，这里描述的OR子句优化能够使用并不保证它会被使用。SQLite使用基于成本的查询规划器，估算各种竞争查询计划的CPU和磁盘I/O成本，并选择它认为是最快的计划。如果WHERE子句中有许多OR项，或者一些OR子句子项的索引选择性不太高，则SQLite可能会决定更快地使用不同的查询算法，甚至是全表扫描。应用程序开发人员可以在语句上使用[EXPLAIN
    QUERY PLAN](lang_explain.html)前缀，以获取所选查询策略的高级概述。
- en: 5\. The LIKE Optimization
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5\. LIKE优化
- en: 'A WHERE-clause term that uses the [LIKE](lang_expr.html#like) or [GLOB](lang_expr.html#glob)
    operator can sometimes be used with an index to do a range search, almost as if
    the LIKE or GLOB were an alternative to a [BETWEEN](lang_expr.html#between) operator.
    There are many conditions on this optimization:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[LIKE](lang_expr.html#like)或[GLOB](lang_expr.html#glob)运算符的WHERE子句项有时可以与索引一起使用，进行范围搜索，几乎就像LIKE或GLOB是[BETWEEN](lang_expr.html#between)运算符的替代品一样。关于这种优化有很多条件：
- en: The right-hand side of the LIKE or GLOB must be either a string literal or a
    [parameter](lang_expr.html#varparam) bound to a string literal that does not begin
    with a wildcard character.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LIKE或GLOB的右侧必须是字符串文字或绑定到不以通配符字符开头的字符串文字的[参数](lang_expr.html#varparam)。
- en: 'It must not be possible to make the LIKE or GLOB operator true by having a
    numeric value (instead of a string or blob) on the left-hand side. This means
    that either:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用数字值（而不是字符串或二进制大对象）来使LIKE或GLOB运算符为真是不可能的。这意味着：
- en: the left-hand side of the LIKE or GLOB operator is the name of an indexed column
    with [TEXT affinity](datatype3.html#affinity), or
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: LIKE或GLOB运算符的左侧是具有[TEXT亲和性](datatype3.html#affinity)的索引列的名称，或者
- en: 'the right-hand side pattern argument does not begin with a minus sign ("-")
    or a digit.This constraint arises from the fact that numbers do not sort in lexicographical
    order. For example: 9<10 but ''9''>''10''.'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右侧的模式参数不能以减号（"-"）或数字开头。这个约束是由于数字在词典排序中不排序。例如：9<10但'9'>'10'。
- en: The built-in functions used to implement LIKE and GLOB must not have been overloaded
    using the [sqlite3_create_function()](c3ref/create_function.html) API.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于实现LIKE和GLOB的内置函数不能使用[sqlite3_create_function()](c3ref/create_function.html)
    API进行重载。
- en: For the GLOB operator, the column must be indexed using the built-in BINARY
    collating sequence.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于GLOB运算符，必须使用内置的BINARY排序序列对列进行索引。
- en: For the LIKE operator, if [case_sensitive_like](pragma.html#pragma_case_sensitive_like)
    mode is enabled then the column must indexed using BINARY collating sequence,
    or if [case_sensitive_like](pragma.html#pragma_case_sensitive_like) mode is disabled
    then the column must indexed using built-in NOCASE collating sequence.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 LIKE 操作符，如果启用了 [case_sensitive_like](pragma.html#pragma_case_sensitive_like)
    模式，则必须使用 BINARY 校对序列对列进行索引，或者如果禁用了 [case_sensitive_like](pragma.html#pragma_case_sensitive_like)
    模式，则必须使用内置的 NOCASE 校对序列进行索引。
- en: If the ESCAPE option is used, the ESCAPE character must be ASCII, or a single-byte
    character in UTF-8.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果使用了 ESCAPE 选项，则 ESCAPE 字符必须是 ASCII 或 UTF-8 中的单字节字符。
- en: 'The LIKE operator has two modes that can be set by a [pragma](pragma.html#pragma_case_sensitive_like).
    The default mode is for LIKE comparisons to be insensitive to differences of case
    for latin1 characters. Thus, by default, the following expression is true:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: LIKE 操作符有两种模式，可以通过 [pragma](pragma.html#pragma_case_sensitive_like) 进行设置。默认模式是对
    latin1 字符的大小写差异不敏感。因此，默认情况下，以下表达式为真：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If the case_sensitive_like pragma is enabled as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 case_sensitive_like pragma 被启用如下：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Then the LIKE operator pays attention to case and the example above would evaluate
    to false. Note that case insensitivity only applies to latin1 characters - basically
    the upper and lower case letters of English in the lower 127 byte codes of ASCII.
    International character sets are case sensitive in SQLite unless an application-defined
    [collating sequence](datatype3.html#collation) and [like() SQL function](lang_corefunc.html#like)
    are provided that take non-ASCII characters into account. If an application-defined
    collating sequence and/or like() SQL function are provided, the LIKE optimization
    described here will never be taken.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 LIKE 操作符会区分大小写，并且上述示例将评估为假。请注意，大小写不敏感仅适用于 latin1 字符 - 基本上是 ASCII 的 127 字节代码中的英语大写和小写字母。SQLite
    中的国际字符集是区分大小写的，除非提供了应用定义的 [校对序列](datatype3.html#collation) 和 [like() SQL 函数](lang_corefunc.html#like)，以考虑非
    ASCII 字符。如果提供了应用定义的校对序列和/或 like() SQL 函数，则此处描述的 LIKE 优化将永远不会生效。
- en: The LIKE operator is case insensitive by default because this is what the SQL
    standard requires. You can change the default behavior at compile time by using
    the [SQLITE_CASE_SENSITIVE_LIKE](compile.html#case_sensitive_like) command-line
    option to the compiler.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: LIKE 操作符默认情况下不区分大小写，因为这是 SQL 标准要求的。您可以通过编译时使用 [SQLITE_CASE_SENSITIVE_LIKE](compile.html#case_sensitive_like)
    命令行选项来改变默认行为。
- en: The LIKE optimization might occur if the column named on the left of the operator
    is indexed using the built-in BINARY collating sequence and case_sensitive_like
    is turned on. Or the optimization might occur if the column is indexed using the
    built-in NOCASE collating sequence and the case_sensitive_like mode is off. These
    are the only two combinations under which LIKE operators will be optimized.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果左侧命名的列使用内置的 BINARY 校对顺序进行索引，并且 case_sensitive_like 已打开，则可能发生 LIKE 优化。或者如果该列使用内置的
    NOCASE 校对顺序进行索引，并且 case_sensitive_like 模式已关闭，则可能发生优化。这是仅有的两种情况，LIKE 运算符将在其下被优化。
- en: The GLOB operator is always case sensitive. The column on the left side of the
    GLOB operator must always use the built-in BINARY collating sequence or no attempt
    will be made to optimize that operator with indexes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: GLOB 运算符始终区分大小写。GLOB 运算符左侧的列必须始终使用内置的 BINARY 校对顺序，否则不会尝试使用索引来优化该运算符。
- en: The LIKE optimization will only be attempted if the right-hand side of the GLOB
    or LIKE operator is either literal string or a [parameter](lang_expr.html#varparam)
    that has been [bound](c3ref/bind_blob.html) to a string literal. The string literal
    must not begin with a wildcard; if the right-hand side begins with a wildcard
    character then this optimization is not attempted. If the right-hand side is a
    [parameter](lang_expr.html#varparam) that is bound to a string, then this optimization
    is only attempted if the [prepared statement](c3ref/stmt.html) containing the
    expression was compiled with [sqlite3_prepare_v2()](c3ref/prepare.html) or [sqlite3_prepare16_v2()](c3ref/prepare.html).
    The LIKE optimization is not attempted if the right-hand side is a [parameter](lang_expr.html#varparam)
    and the statement was prepared using [sqlite3_prepare()](c3ref/prepare.html) or
    [sqlite3_prepare16()](c3ref/prepare.html).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 仅当 GLOB 或 LIKE 运算符的右侧是文字字符串或已绑定到字符串文字的 [参数](lang_expr.html#varparam) 时，才会尝试
    LIKE 优化。字符串文字不能以通配符开头；如果右侧以通配符字符开头，则不会尝试此优化。如果右侧是绑定到字符串的 [参数](lang_expr.html#varparam)，则仅在包含该表达式的
    [预处理语句](c3ref/stmt.html) 使用 [sqlite3_prepare_v2()](c3ref/prepare.html) 或 [sqlite3_prepare16_v2()](c3ref/prepare.html)
    编译时才会尝试此优化。如果右侧是 [参数](lang_expr.html#varparam)，并且使用 [sqlite3_prepare()](c3ref/prepare.html)
    或 [sqlite3_prepare16()](c3ref/prepare.html) 准备语句，则不会尝试 LIKE 优化。
- en: 'Suppose the initial sequence of non-wildcard characters on the right-hand side
    of the LIKE or GLOB operator is *x*. We are using a single character to denote
    this non-wildcard prefix but the reader should understand that the prefix can
    consist of more than 1 character. Let *y* be the smallest string that is the same
    length as /x/ but which compares greater than *x*. For example, if *x* is `''hello''`
    then *y* would be `''hellp''`. The LIKE and GLOB optimizations consist of adding
    two virtual terms like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在 LIKE 或 GLOB 操作符右侧的非通配符字符初始序列为*x*。我们使用单个字符来表示这个非通配符前缀，但读者应理解该前缀可以由多个字符组成。让*y*成为与/x/相同长度但大于*x*的最小字符串。例如，如果*x*是`'hello'`，那么*y*将是`'hellp'`。像这样的
    LIKE 和 GLOB 优化包括添加两个虚拟术语：
- en: '[PRE15]'
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Under most circumstances, the original LIKE or GLOB operator is still tested
    against each input row even if the virtual terms are used to constrain an index.
    This is because we do not know what additional constraints may be imposed by characters
    to the right of the *x* prefix. However, if there is only a single global wildcard
    to the right of *x*, then the original LIKE or GLOB test is disabled. In other
    words, if the pattern is like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，即使使用虚拟术语来约束索引，原始的 LIKE 或 GLOB 操作符仍然对每个输入行进行测试。这是因为我们不知道*x*前缀右侧可能施加的额外约束。但是，如果在*x*的右侧只有一个全局通配符，则会禁用原始的
    LIKE 或 GLOB 测试。换句话说，如果模式如下所示：
- en: '[PRE16]'
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE16]'
- en: then the original LIKE or GLOB tests are disabled when the virtual terms constrain
    an index because in that case we know that all of the rows selected by the index
    will pass the LIKE or GLOB test.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 那么当虚拟术语约束索引时，原始的 LIKE 或 GLOB 测试被禁用，因为在这种情况下，我们知道索引选中的所有行都将通过 LIKE 或 GLOB 测试。
- en: Note that when the right-hand side of a LIKE or GLOB operator is a [parameter](lang_expr.html#varparam)
    and the statement is prepared using [sqlite3_prepare_v2()](c3ref/prepare.html)
    or [sqlite3_prepare16_v2()](c3ref/prepare.html) then the statement is automatically
    reparsed and recompiled on the first [sqlite3_step()](c3ref/step.html) call of
    each run if the binding to the right-hand side parameter has changed since the
    previous run. This reparse and recompile is essentially the same action that occurs
    following a schema change. The recompile is necessary so that the query planner
    can examine the new value bound to the right-hand side of the LIKE or GLOB operator
    and determine whether or not to employ the optimization described above.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当 LIKE 或 GLOB 操作符右侧是[参数](lang_expr.html#varparam)，并且语句是使用[sqlite3_prepare_v2()](c3ref/prepare.html)或[sqlite3_prepare16_v2()](c3ref/prepare.html)准备的时，如果与上一次运行时的绑定到右侧参数发生了变化，语句将在每次运行的第一个[sqlite3_step()](c3ref/step.html)调用时自动重新解析和重新编译。这种重新解析和重新编译本质上与架构更改后发生的操作相同。重新编译是必要的，以便查询规划器可以检查绑定到
    LIKE 或 GLOB 操作符右侧的新值，并确定是否应用上述优化。
- en: 6\. The Skip-Scan Optimization
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6\. 跳跃扫描优化
- en: The general rule is that indexes are only useful if there are WHERE-clause constraints
    on the left-most columns of the index. However, in some cases, SQLite is able
    to use an index even if the first few columns of the index are omitted from the
    WHERE clause but later columns are included.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一般规则是，只有在索引的最左列上有 WHERE 子句约束时，索引才是有用的。然而，在某些情况下，即使省略了索引的前几列于 WHERE 子句中，但后续列包含在内，SQLite
    也能够使用该索引。
- en: 'Consider a table such as the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个如下所示的表：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The people table has one entry for each person in a large organization. Each
    person is either a "student" or a "teacher", as determined by the "role" field.
    The table also records the height in centimeters of each person. The role and
    height are indexed. Notice that the left-most column of the index is not very
    selective - it only contains two possible values.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: people 表中每个人在大型组织中都有一条记录。每个人通过 "role" 字段确定是 "student" 还是 "teacher"。表还记录了每个人的身高（单位：厘米）。角色和身高都被索引了。注意，索引的最左列不是非常选择性高
    - 它只包含两个可能的值。
- en: 'Now consider a query to find the names of everyone in the organization that
    is 180cm tall or taller:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一个查询，以找出组织中所有身高达到或超过180cm的人的姓名：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Because the left-most column of the index does not appear in the WHERE clause
    of the query, one is tempted to conclude that the index is not usable here. However,
    SQLite is able to use the index. Conceptually, SQLite uses the index as if the
    query were more like the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于查询的 WHERE 子句中没有索引的最左列，人们很容易得出结论认为此处无法使用索引。然而，SQLite 可以使用该索引。从概念上讲，SQLite 使用索引的方式类似于以下查询：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Or this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 或者这样：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The alternative query formulations shown above are conceptual only. SQLite
    does not really transform the query. The actual query plan is like this: SQLite
    locates the first possible value for "role", which it can do by rewinding the
    "people_idx1" index to the beginning and reading the first record. SQLite stores
    this first "role" value in an internal variable that we will here call "$role".
    Then SQLite runs a query like: "SELECT name FROM people WHERE role=$role AND height>=180".
    This query has an equality constraint on the left-most column of the index and
    so the index can be used to resolve that query. Once that query is finished, SQLite
    then uses the "people_idx1" index to locate the next value of the "role" column,
    using code that is logically similar to "SELECT role FROM people WHERE role>$role
    LIMIT 1". This new "role" value overwrites the $role variable, and the process
    repeats until all possible values for "role" have been examined.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 上述的替代查询形式仅是概念性的。SQLite 实际上并没有转换查询。实际的查询计划如下：SQLite 定位到"role"的第一个可能的值，它可以通过倒回"people_idx1"索引到开头并读取第一条记录来实现。SQLite
    将这个第一个"role"值存储在一个我们称之为"$role"的内部变量中。然后，SQLite 运行像这样的查询："SELECT name FROM people
    WHERE role=$role AND height>=180"。这个查询对索引的最左列有一个相等约束，因此可以使用索引解析该查询。一旦完成了该查询，SQLite
    就使用"people_idx1"索引来定位"role"列的下一个值，使用的逻辑上类似于"SELECT role FROM people WHERE role>$role
    LIMIT 1"的代码。这个新的"role"值覆盖了$role变量，这个过程重复，直到"role"的所有可能值都被检查完为止。
- en: We call this kind of index usage a "skip-scan" because the database engine is
    basically doing a full scan of the index but it optimizes the scan (making it
    less than "full") by occasionally skipping ahead to the next candidate value.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这种索引使用方式称为"跳跃扫描"，因为数据库引擎基本上对索引进行全面扫描，但通过偶尔跳过到下一个候选值来优化扫描（使其不完全"全面"）。
- en: SQLite might use a skip-scan on an index if it knows that the first one or more
    columns contain many duplication values. If there are too few duplicates in the
    left-most columns of the index, then it would be faster to simply step ahead to
    the next value, and thus do a full table scan, than to do a binary search on an
    index to locate the next left-column value.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 SQLite 知道索引的第一个或多个列包含许多重复值，它可能会在索引上使用跳跃扫描。如果索引的最左边列中重复值太少，那么简单地跳到下一个值，从而进行全表扫描，会比在索引上进行二分搜索定位到下一个左列值更快。
- en: The only way that SQLite can know that there are many duplicates in the left-most
    columns of an index is if the [ANALYZE](lang_analyze.html) command has been run
    on the database. Without the results of ANALYZE, SQLite has to guess at the "shape"
    of the data in the table, and the default guess is that there are an average of
    10 duplicates for every value in the left-most column of the index. Skip-scan
    only becomes profitable (it only gets to be faster than a full table scan) when
    the number of duplicates is about 18 or more. Hence, a skip-scan is never used
    on a database that has not been analyzed.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 只有在数据库上运行了 [ANALYZE](lang_analyze.html) 命令后才能知道索引的左侧列中存在许多重复项。没有进行 ANALYZE
    的结果，SQLite 必须猜测表中数据的“形状”，默认的猜测是索引的左侧列中每个值平均有 10 个重复项。只有在重复项约为 18 或更多时，跳跃扫描才会变得有利（即比完整表扫描更快）。因此，在未经分析的数据库上从不使用跳跃扫描。
- en: 7\. Joins
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7\. 连接
- en: SQLite implements joins as nested loops. The default order of the nested loops
    in a join is for the left-most table in the FROM clause to form the outer loop
    and the right-most table to form the inner loop. However, SQLite will nest the
    loops in a different order if doing so will help it to select better indexes.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 将连接实现为嵌套循环。连接中嵌套循环的默认顺序是 FROM 子句中最左侧的表形成外层循环，最右侧的表形成内层循环。然而，如果改变循环顺序有助于选择更好的索引，SQLite
    将会以不同的顺序嵌套循环。
- en: Inner joins can be freely reordered. However outer joins are neither commutative
    nor associative and hence will not be reordered. Inner joins to the left and right
    of an outer join might be reordered if the optimizer thinks that is advantageous
    but outer joins are always evaluated in the order in which they occur.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 内连接可以自由重新排序。然而外连接既不可交换也不可结合，因此不会重新排序。外连接左右两侧的内连接可能会被优化器重新排序，但外连接始终按照出现的顺序进行评估。
- en: SQLite [treats the CROSS JOIN operator specially](lang_select.html#crossjoin).
    The CROSS JOIN operator is commutative, in theory. However, SQLite chooses to
    never reorder tables in a CROSS JOIN. This provides a mechanism by which the programmer
    can force SQLite to choose a particular loop nesting order.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite [特别对待 CROSS JOIN 运算符](lang_select.html#crossjoin)。理论上，CROSS JOIN 运算符是可交换的。然而，SQLite
    选择永远不会重新排列 CROSS JOIN 中的表。这为程序员提供了一种机制，可以强制 SQLite 选择特定的循环嵌套顺序。
- en: When selecting the order of tables in a join, SQLite uses an efficient polynomial-time
    algorithm graph algorithm described in the [Next Generation Query Planner](queryplanner-ng.html)
    document. Because of this, SQLite is able to plan queries with 50- or 60-way joins
    in a matter of microseconds
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择连接中的表顺序时，SQLite 使用了一个高效的多项式时间算法图算法，详见[下一代查询计划器](queryplanner-ng.html)文档。因此，SQLite
    能够在微秒级别内规划具有 50 或 60 个表连接的查询。
- en: 'Join reordering is automatic and usually works well enough that programmers
    do not have to think about it, especially if [ANALYZE](lang_analyze.html) has
    been used to gather statistics about the available indexes, though occasionally
    some hints from the programmer are needed. Consider, for example, the following
    schema:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 连接重新排序是自动的，通常运行良好，程序员无需考虑它，特别是如果已经使用[ANALYZE](lang_analyze.html)收集了关于可用索引的统计信息，尽管偶尔需要程序员提供一些提示。例如，考虑以下架构：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The schema above defines a directed graph with the ability to store a name
    at each node. Now consider a query against this schema:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 上述架构定义了一个有向图，可以在每个节点上存储名称。现在考虑针对此架构的查询：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This query asks for is all information about edges that go from nodes labeled
    "alice" to nodes labeled "bob". The query optimizer in SQLite has basically two
    choices on how to implement this query. (There are actually six different choices,
    but we will only consider two of them here.) Pseudocode below demonstrating these
    two choices.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询请求的是从标记为"alice"的节点到标记为"bob"的节点的所有边的信息。SQLite中的查询优化器基本上有两种实现此查询的选择。 （实际上有六种不同的选择，但我们在这里只考虑其中的两种。）下面的伪代码展示了这两种选择。
- en: 'Option 1:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '选项 1:'
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Option 2:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '选项 2:'
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The same indexes are used to speed up every loop in both implementation options.
    The only difference in these two query plans is the order in which the loops are
    nested.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种实现选项中的每个循环都使用相同的索引来加快速度。这两个查询计划唯一的区别是循环嵌套的顺序。
- en: So which query plan is better? It turns out that the answer depends on what
    kind of data is found in the node and edge tables.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 那么哪个查询计划更好呢？结果表明答案取决于节点和边表中存在什么类型的数据。
- en: Let the number of alice nodes be M and the number of bob nodes be N. Consider
    two scenarios. In the first scenario, M and N are both 2 but there are thousands
    of edges on each node. In this case, option 1 is preferred. With option 1, the
    inner loop checks for the existence of an edge between a pair of nodes and outputs
    the result if found. Because there are only 2 alice and bob nodes each, the inner
    loop only has to run four times and the query is very quick. Option 2 would take
    much longer here. The outer loop of option 2 only executes twice, but because
    there are a large number of edges leaving each alice node, the middle loop has
    to iterate many thousands of times. It will be much slower. So in the first scenario,
    we prefer to use option 1.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让alice节点的数量为M，bob节点的数量为N。考虑两种情况。在第一种情况下，M和N都是2，但每个节点上有数千条边。在这种情况下，更喜欢选项1。使用选项1，内循环检查节点对之间是否存在边，并在找到时输出结果。因为alice和bob节点只有2个，所以内循环只需运行四次，查询非常快。选项2在这里会花费更多时间。选项2的外部循环仅执行两次，但因为每个alice节点离开的边很多，中间循环必须迭代多次数千次。这将慢得多。因此在第一种情况下，我们更喜欢使用选项1。
- en: Now consider the case where M and N are both 3500\. Alice nodes are abundant.
    This time suppose each of these nodes is connected by only one or two edges. Now
    option 2 is preferred. With option 2, the outer loop still has to run 3500 times,
    but the middle loop only runs once or twice for each outer loop and the inner
    loop will only run once for each middle loop, if at all. So the total number of
    iterations of the inner loop is around 7000\. Option 1, on the other hand, has
    to run both its outer loop and its middle loop 3500 times each, resulting in 12
    million iterations of the middle loop. Thus in the second scenario, option 2 is
    nearly 2000 times faster than option 1.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑 M 和 N 都是 3500 的情况。Alice 节点非常丰富。这时假设每个节点只通过一两条边连接。现在选项 2 更好。选择选项 2 时，外部循环仍然需要运行
    3500 次，但中间循环每次仅需运行一两次，而内部循环每次可能根本不需要运行。因此，内部循环的总迭代次数约为 7000 次。另一方面，选项 1 需要分别运行外部循环和中间循环
    3500 次，导致中间循环的迭代次数达到 1200 万次。因此，在第二种情况下，选项 2 几乎比选项 1 快了将近 2000 倍。
- en: So you can see that depending on how the data is structured in the table, either
    query plan 1 or query plan 2 might be better. Which plan does SQLite choose by
    default? As of version 3.6.18, without running [ANALYZE](lang_analyze.html), SQLite
    will choose option 2. If the [ANALYZE](lang_analyze.html) command is run in order
    to gather statistics, a different choice might be made if the statistics indicate
    that the alternative is likely to run faster.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以看到，根据表中数据的结构，查询计划 1 或查询计划 2 可能更好。SQLite 默认选择哪个查询计划呢？截至 3.6.18 版本，在未执行[ANALYZE](lang_analyze.html)时，SQLite
    将选择选项 2。如果运行[ANALYZE](lang_analyze.html)命令以收集统计信息，则根据统计数据显示可能会选择不同的更快选项。
- en: 7.1\. Manual Control Of Join Order
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1\. 手动控制连接顺序
- en: SQLite almost always picks the best join order automatically. It is very rare
    that a developer needs to intervene to give the query planner hints about the
    best join order. The best policy is to make use of [PRAGMA optimize](pragma.html#pragma_optimize)
    to ensure that the query planner has access to up-to-date statistics on the shape
    of the data in the database.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 几乎总是会自动选择最佳的连接顺序。开发者很少需要干预查询规划器以提供关于最佳连接顺序的提示。最佳策略是利用[PRAGMA optimize](pragma.html#pragma_optimize)确保查询规划器可以访问数据库中数据形状的最新统计信息。
- en: This section describes techniques by which developers can control the join order
    in SQLite, to work around any performance problems that may arise. However, the
    use of these techniques is not recommended, except as a last resort.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了开发者可以控制 SQLite 中连接顺序的技术，以解决可能出现的任何性能问题。然而，除非迫不得已，不建议使用这些技术。
- en: If you do encounter a situation where SQLite is picking a suboptimal join order
    even after running [PRAGMA optimize](pragma.html#pragma_optimize), please report
    your situation on the [SQLite Community Forum](https://sqlite.org/forum) so that
    the SQLite maintainers can make new refinements to the query planner such that
    manual intervention is not required.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在运行[PRAGMA optimize](pragma.html#pragma_optimize)之后，SQLite仍然选择了次优的连接顺序，请在[SQLite社区论坛](https://sqlite.org/forum)上报告您的情况，以便SQLite的维护人员对查询优化器进行新的优化，从而避免需要手动干预。
- en: 7.1.1\. Manual Control Of Query Plans Using SQLITE_STAT Tables
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.1\. 使用 SQLITE_STAT 表手动控制查询计划
- en: SQLite provides the ability for advanced programmers to exercise control over
    the query plan chosen by the optimizer. One method for doing this is to fudge
    the [ANALYZE](lang_analyze.html) results in the [sqlite_stat1](fileformat2.html#stat1tab)
    table.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite允许高级程序员对优化器选择的查询计划进行控制。其中一种方法是在[sqlite_stat1](fileformat2.html#stat1tab)表中调整[ANALYZE](lang_analyze.html)的结果。
- en: 7.1.2\. Manual Control of Query Plans using CROSS JOIN
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.2\. 使用CROSS JOIN手动控制查询计划
- en: Programmers can force SQLite to use a particular loop nesting order for a join
    by using the CROSS JOIN operator instead of just JOIN, INNER JOIN, NATURAL JOIN,
    or a "," join. Though CROSS JOINs are commutative in theory, SQLite chooses to
    never reorder the tables in a CROSS JOIN. Hence, the left table of a CROSS JOIN
    will always be in an outer loop relative to the right table.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员可以通过使用CROSS JOIN操作符而非JOIN、INNER JOIN、NATURAL JOIN或逗号连接来强制SQLite使用特定的循环嵌套顺序。尽管CROSS
    JOIN在理论上是可交换的，但SQLite选择永远不会重新排序CROSS JOIN中的表。因此，CROSS JOIN的左表始终相对于右表处于外部循环。
- en: 'In the following query, the optimizer is free to reorder the tables of FROM
    clause any way it sees fit:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下查询中，优化器可以自由地重新排序FROM子句中的表：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the following logically equivalent formulation of the same query, the substitution
    of "CROSS JOIN" for the "," means that the order of tables must be N1, E, N2.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个查询的逻辑等效形式中，将","替换为"CROSS JOIN"意味着表的顺序必须是N1、E、N2。
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the latter query, the query plan must be [option 2](#option2). Note that
    you must use the keyword "CROSS" in order to disable the table reordering optimization;
    INNER JOIN, NATURAL JOIN, JOIN, and other similar combinations work just like
    a comma join in that the optimizer is free to reorder tables as it sees fit. (Table
    reordering is also disabled on an outer join, but that is because outer joins
    are not associative or commutative. Reordering tables in OUTER JOIN changes the
    result.)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在后一个查询中，查询计划必须是[option 2](#option2)。请注意，您必须使用关键字"CROSS"以禁用表重排序优化；INNER JOIN、NATURAL
    JOIN、JOIN和其他类似组合的行为与逗号连接相同，优化器可以根据需要重新排序表。（在外连接中也禁用了表重排序，但这是因为外连接不是可结合或可交换的。重新排序OUTER
    JOIN中的表会改变结果。）
- en: See "[The Fossil NGQP Upgrade Case Study](queryplanner-ng.html#fossilcasestudy)"
    for another real-world example of using CROSS JOIN to manually control the nesting
    order of a join. The [query planner checklist](queryplanner-ng.html#howtofix)
    found later in the same document provides further guidance on manual control of
    the query planner.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 参见 "[The Fossil NGQP Upgrade Case Study](queryplanner-ng.html#fossilcasestudy)"，这是另一个使用
    CROSS JOIN 手动控制连接嵌套顺序的真实案例。文档后面的 [query planner checklist](queryplanner-ng.html#howtofix)
    提供了关于手动控制查询规划器的进一步指导。
- en: 8\. Choosing Between Multiple Indexes
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8\. 在多个索引之间进行选择
- en: 'Each table in the FROM clause of a query can use at most one index (except
    when the [OR-clause optimization](#or_opt) comes into play) and SQLite strives
    to use at least one index on each table. Sometimes, two or more indexes might
    be candidates for use on a single table. For example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 查询的 FROM 子句中的每个表最多可以使用一个索引（除非涉及到 [OR-clause optimization](#or_opt)）。SQLite 努力确保每个表至少使用一个索引。有时，同一表可能会有两个或更多个索引可供选择。例如：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: For the SELECT statement above, the optimizer can use the ex2i1 index to lookup
    rows of ex2 that contain x=5 and then test each row against the y=6 term. Or it
    can use the ex2i2 index to lookup rows of ex2 that contain y=6 then test each
    of those rows against the x=5 term.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述的 SELECT 语句，优化器可以使用 ex2i1 索引来查找包含 x=5 的 ex2 表中的行，然后对每一行测试 y=6 条件。或者它可以使用
    ex2i2 索引来查找包含 y=6 的 ex2 表中的行，然后对每一行测试 x=5 条件。
- en: When faced with a choice of two or more indexes, SQLite tries to estimate the
    total amount of work needed to perform the query using each option. It then selects
    the option that gives the least estimated work.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当面对两个或更多索引选择时，SQLite 会尝试估计使用每个选项执行查询所需的总工作量。然后选择估计工作量最少的选项。
- en: To help the optimizer get a more accurate estimate of the work involved in using
    various indexes, the user may optionally run the [ANALYZE](lang_analyze.html)
    command. The [ANALYZE](lang_analyze.html) command scans all indexes of database
    where there might be a choice between two or more indexes and gathers statistics
    on the selectiveness of those indexes. The statistics gathered by this scan are
    stored in special database tables names shows names all begin with "**sqlite_stat**".
    The content of these tables is not updated as the database changes so after making
    significant changes it might be prudent to rerun [ANALYZE](lang_analyze.html).
    The results of an ANALYZE command are only available to database connections that
    are opened after the ANALYZE command completes.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助优化器更准确地估计使用各种索引所涉及的工作量，用户可以选择运行 [ANALYZE](lang_analyze.html) 命令。[ANALYZE](lang_analyze.html)
    命令会扫描数据库中所有可能存在两个或多个索引选择的地方，并收集这些索引的选择性统计信息。此扫描收集的统计信息存储在名为 "**sqlite_stat**"
    的特殊数据库表中。这些表的内容在数据库更改后不会更新，因此在进行重大更改后重新运行 [ANALYZE](lang_analyze.html) 可能是明智的选择。ANALYZE
    命令的结果仅对于在执行 ANALYZE 命令完成后打开的数据库连接可用。
- en: The various **sqlite_stat***N* tables contain information on how selective the
    various indexes are. For example, the [sqlite_stat1](fileformat2.html#stat1tab)
    table might indicate that an equality constraint on column x reduces the search
    space to 10 rows on average, whereas an equality constraint on column y reduces
    the search space to 3 rows on average. In that case, SQLite would prefer to use
    index ex2i2 since that index is more selective.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 各种 **sqlite_stat***N* 表包含了有关各种索引选择性的信息。例如，[sqlite_stat1](fileformat2.html#stat1tab)
    表可能表明，对列 x 的等值约束平均将搜索空间减少到 10 行，而对列 y 的等值约束平均将搜索空间减少到 3 行。在这种情况下，SQLite 更倾向于使用
    ex2i2 索引，因为该索引更具选择性。
- en: 8.1\. Disqualifying WHERE Clause Terms using Unary-"+"
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1\. 使用一元 "+" 禁用 WHERE 子句条件
- en: '*Note: Disqualifying WHERE clause terms this way is not recommended. This is
    a work-around. Only do this as a last resort to get the performance you need.
    If you find a situation where this work-around is necessary, please report the
    situation on the [SQLite Community Forum](https://sqlite.org/forum) so that the
    SQLite maintainers can try to improve the query planner such that the work-around
    is no longer required for your situation.*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意：不推荐以这种方式禁用 WHERE 子句条件。这是一种解决方法。只有在迫不得已需要提高性能时才这样做。如果发现有必要使用这种解决方法的情况，请在
    [SQLite Community Forum](https://sqlite.org/forum) 上报告情况，以便 SQLite 的维护者可以尽力改进查询规划器，以便在您的情况下不再需要这种解决方法。*'
- en: 'Terms of the WHERE clause can be manually disqualified for use with indexes
    by prepending a unary **+** operator to the column name. The unary **+** is a
    no-op and will not generate any byte code in the prepared statement. However,
    the unary **+** operator will prevent the term from constraining an index. So,
    in the example above, if the query were rewritten as:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: WHERE 子句的条件可以通过在列名前添加一元运算符 **+** 来手动禁用索引使用。这个一元 **+** 是一个空操作，在预编译语句中不会生成任何字节码。然而，这个一元
    **+** 运算符将阻止条件限制索引。因此，在上面的例子中，如果查询被重写为：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The **+** operator on the **x** column will prevent that term from constraining
    an index. This would force the use of the ex2i2 index.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对列 **x** 使用 **+** 运算符将阻止该条件限制索引。这将强制使用 ex2i2 索引。
- en: Note that the unary **+** operator also removes [type affinity](datatype3.html#affinity)
    from an expression, and in some cases this can cause subtle changes in the meaning
    of an expression. In the example above, if column **x** has [TEXT affinity](datatype3.html#affinity)
    then the comparison "x=5" will be done as text. The **+** operator removes the
    affinity. So the comparison "**+x=5**" will compare the text in column **x** with
    the numeric value 5 and will always be false.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一元 **+** 运算符也会从表达式中移除 [类型亲和性](datatype3.html#affinity)，在某些情况下，这可能会导致表达式含义上的细微变化。在上面的例子中，如果列
    **x** 具有 [TEXT 亲和性](datatype3.html#affinity)，那么比较 "x=5" 将作为文本进行。**+** 运算符移除了亲和性。因此，比较
    "**+x=5**" 将会将列 **x** 中的文本与数值 5 进行比较，并且始终为假。
- en: 8.2\. Range Queries
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2\. 范围查询
- en: 'Consider a slightly different scenario:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个略有不同的情况：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Further suppose that column x contains values spread out between 0 and 1,000,000
    and column y contains values that span between 0 and 1,000\. In that scenario,
    the range constraint on column x should reduce the search space by a factor of
    10,000 whereas the range constraint on column y should reduce the search space
    by a factor of only 10\. So the ex2i1 index should be preferred.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步假设列 x 包含的值分布在 0 到 1,000,000 之间，而列 y 包含的值则在 0 到 1,000 之间。在这种情况下，对列 x 的范围约束应该将搜索空间减少
    10,000 倍，而对列 y 的范围约束仅应该将搜索空间减少 10 倍。因此，应优先选择 ex2i1 索引。
- en: SQLite will make this determination, but only if it has been compiled with [SQLITE_ENABLE_STAT3](compile.html#enable_stat3)
    or [SQLITE_ENABLE_STAT4](compile.html#enable_stat4). The [SQLITE_ENABLE_STAT3](compile.html#enable_stat3)
    and [SQLITE_ENABLE_STAT4](compile.html#enable_stat4) options causes the [ANALYZE](lang_analyze.html)
    command to collect a histogram of column content in the [sqlite_stat3](fileformat2.html#stat3tab)
    or [sqlite_stat4](fileformat2.html#stat4tab) tables and to use this histogram
    to make a better guess at the best query to use for range constraints such as
    the above. The main difference between STAT3 and STAT4 is that STAT3 records histogram
    data for only the left-most column of an index whereas STAT4 records histogram
    data for all columns of an index. For single-column indexes, STAT3 and STAT4 work
    the same.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 将做出此决定，但前提是已使用 [SQLITE_ENABLE_STAT3](compile.html#enable_stat3) 或 [SQLITE_ENABLE_STAT4](compile.html#enable_stat4)
    进行编译。[SQLITE_ENABLE_STAT3](compile.html#enable_stat3) 和 [SQLITE_ENABLE_STAT4](compile.html#enable_stat4)
    选项导致 [ANALYZE](lang_analyze.html) 命令在 [sqlite_stat3](fileformat2.html#stat3tab)
    或 [sqlite_stat4](fileformat2.html#stat4tab) 表中收集列内容的直方图，并使用这些直方图更好地猜测用于上述范围约束的最佳查询。STAT3
    和 STAT4 主要的区别在于，STAT3 仅记录索引的最左列的直方图数据，而 STAT4 则记录索引的所有列的直方图数据。对于单列索引，STAT3 和 STAT4
    的工作方式相同。
- en: The histogram data is only useful if the right-hand side of the constraint is
    a simple compile-time constant or [parameter](lang_expr.html#varparam) and not
    an expression.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果约束条件的右侧是简单的编译时常量或 [参数](lang_expr.html#varparam)，而不是表达式，则直方图数据才有用。
- en: 'Another limitation of the histogram data is that it only applies to the left-most
    column on an index. Consider this scenario:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图数据的另一个限制是，它仅适用于索引的最左列。考虑以下情况：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here the inequalities are on columns x and y which are not the left-most index
    columns. Hence, the histogram data which is collected no left-most column of indexes
    is useless in helping to choose between the range constraints on columns x and
    y.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的不等式是在列 x 和 y 上，它们不是最左侧的索引列。因此，直方图数据收集的不是索引的最左列时，无助于帮助选择列 x 和 y 上的范围约束。
- en: 9\. Covering Indexes
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9\. 覆盖索引
- en: When doing an indexed lookup of a row, the usual procedure is to do a binary
    search on the index to find the index entry, then extract the [rowid](lang_createtable.html#rowid)
    from the index and use that [rowid](lang_createtable.html#rowid) to do a binary
    search on the original table. Thus a typical indexed lookup involves two binary
    searches. If, however, all columns that were to be fetched from the table are
    already available in the index itself, SQLite will use the values contained in
    the index and will never look up the original table row. This saves one binary
    search for each row and can make many queries run twice as fast.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在对行进行索引查找时，通常的过程是在索引上进行二分搜索以找到索引条目，然后从索引中提取 [rowid](lang_createtable.html#rowid)，并使用该
    [rowid](lang_createtable.html#rowid) 在原始表上进行二分搜索。因此，典型的索引查找涉及两次二分搜索。然而，如果从表中提取的所有列在索引本身中已经可用，SQLite
    将使用索引中包含的值，从而永远不会查找原始表行。这为每行节省了一次二分搜索，可以使许多查询运行速度加快一倍。
- en: When an index contains all of the data needed for a query and when the original
    table never needs to be consulted, we call that index a "covering index".
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个索引包含查询所需的所有数据，并且原始表从不需要被查询时，我们称该索引为“覆盖索引”。
- en: 10\. ORDER BY Optimizations
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10\. ORDER BY 优化
- en: SQLite attempts to use an index to satisfy the ORDER BY clause of a query when
    possible. When faced with the choice of using an index to satisfy WHERE clause
    constraints or satisfying an ORDER BY clause, SQLite does the same cost analysis
    described above and chooses the index that it believes will result in the fastest
    answer.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 会尽可能使用索引来满足查询中的 ORDER BY 子句。当面临使用索引来满足 WHERE 子句约束或满足 ORDER BY 子句的选择时，SQLite
    会进行与上述相同的成本分析，并选择它认为会导致最快答案的索引。
- en: SQLite will also attempt to use indexes to help satisfy GROUP BY clauses and
    the DISTINCT keyword. If the nested loops of the join can be arranged such that
    rows that are equivalent for the GROUP BY or for the DISTINCT are consecutive,
    then the GROUP BY or DISTINCT logic can determine if the current row is part of
    the same group or if the current row is distinct simply by comparing the current
    row to the previous row. This can be much faster than the alternative of comparing
    each row to all prior rows.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 还会尝试使用索引来帮助满足 GROUP BY 子句和 DISTINCT 关键字。如果连接的嵌套循环可以安排使得 GROUP BY 或 DISTINCT
    中等效的行是连续的，那么 GROUP BY 或 DISTINCT 逻辑可以通过将当前行与前一行进行比较来确定当前行是否属于同一组或是否是不同的。这比将每行与所有先前行进行比较的替代方法要快得多。
- en: 10.1\. Partial ORDER BY via Index
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1\. 通过索引实现部分 ORDER BY
- en: If a query contains an ORDER BY clause with multiple terms, it might be that
    SQLite can use indexes to cause rows to come out in the order of some prefix of
    the terms in the ORDER BY but that later terms in the ORDER BY are not satisfied.
    In that case, SQLite does block sorting. Suppose the ORDER BY clause has four
    terms and the natural order of the query results in rows appearing in order of
    the first two terms. As each row is output by the query engine and enters the
    sorter, the outputs in the current row corresponding to the first two terms of
    the ORDER BY are compared against the previous row. If they have changed, the
    current sort is finished and output and a new sort is started. This results in
    a slightly faster sort. Even bigger advantages are that many fewer rows need to
    be held in memory, reducing memory requirements, and outputs can begin to appear
    before the core query has run to completion.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个查询包含带有多个条件的 ORDER BY 子句，可能会导致 SQLite 使用索引使得行按照 ORDER BY 中某些前缀的顺序输出，但是 ORDER
    BY 中的后续条件却无法满足。在这种情况下，SQLite 会进行阻塞排序。假设 ORDER BY 子句有四个条件，并且查询结果的自然顺序导致行按照前两个条件的顺序出现。当每行由查询引擎输出并进入排序器时，当前行中与
    ORDER BY 前两个条件相对应的输出会与前一行进行比较。如果它们发生了变化，则当前排序完成并输出，并开始新的排序。这样可以实现稍快的排序。更大的优势是，需要在内存中保存的行数大大减少，从而降低了内存需求，并且在核心查询完成之前可以开始输出。
- en: 11\. Subquery Flattening
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11\. 子查询展开
- en: When a subquery occurs in the FROM clause of a SELECT, the simplest behavior
    is to evaluate the subquery into a transient table, then run the outer SELECT
    against the transient table. Such a plan can be suboptimal since the transient
    table will not have any indexes and the outer query (which is likely a join) will
    be forced to either do full table scan on the transient table or else construct
    a [query-time index](optoverview.html#autoindex) on the transient table, neither
    or which is likely to be particularly fast.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当子查询出现在 SELECT 的 FROM 子句中时，最简单的行为是将子查询评估为临时表，然后对临时表运行外部 SELECT。这样的计划可能是次优的，因为临时表将没有任何索引，外部查询（很可能是连接）将被迫在临时表上执行全表扫描，或者在临时表上构建一个
    [查询时索引](optoverview.html#autoindex)，这两者都不太可能特别快。
- en: 'To overcome this problem, SQLite attempts to flatten subqueries in the FROM
    clause of a SELECT. This involves inserting the FROM clause of the subquery into
    the FROM clause of the outer query and rewriting expressions in the outer query
    that refer to the result set of the subquery. For example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，SQLite 试图展开 SELECT 的 FROM 子句中的子查询。这涉及将子查询的 FROM 子句插入到外部查询的 FROM 子句中，并重写外部查询中引用子查询结果集的表达式。例如：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Would be rewritten using query flattening as:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用查询展开进行重写如下：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There is a long list of conditions that must all be met in order for query flattening
    to occur. Some of the constraints are marked as obsolete by italic text. These
    extra constraints are retained in the documentation to preserve the numbering
    of the other constraints.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 必须满足一长串条件才能进行查询展开。一些约束通过斜体文本标记为过时。为了保留其他约束的编号，这些额外约束在文档中保留。
- en: Casual readers are not expected to understand all of these rules. The point
    here is that flattening rules are subtle and complex. There have been multiple
    bugs over the years caused by over-aggressive query flattening. On the other hand,
    performance of complex queries and/or queries involving views tends to suffer
    if query flattening is more conservative.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 普通读者不必理解所有这些规则。这里的重点是展开规则是微妙且复杂的。多年来，由于过于激进的查询展开，已经出现了多个 bug。另一方面，复杂查询和/或涉及视图的查询在展开规则更为保守时性能往往会受到影响。
- en: '*(Obsolete)*'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*(过时)*'
- en: '*(Obsolete)*'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*(过时)*'
- en: If the subquery is the right operand of a LEFT JOIN then
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果子查询是 LEFT JOIN 的右操作数，则
- en: the subquery may not be a join, and
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子查询不能是联接，并且
- en: the FROM clause of the subquery may not contain a virtual table, and
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子查询的 FROM 子句不能包含虚拟表，并且
- en: the outer query may not be DISTINCT.
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 外部查询不能是 DISTINCT。
- en: The subquery is not DISTINCT.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子查询不是 DISTINCT。
- en: '*(Obsolete - subsumed into constraint 4)*'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*(过时 - 已被第 4 条约束取代)*'
- en: '*(Obsolete)*'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*(过时)*'
- en: The subquery has a FROM clause.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子查询有一个 FROM 子句。
- en: The subquery does not use LIMIT or the outer query is not a join.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子查询不使用 LIMIT 或外部查询不是联接。
- en: The subquery does not use LIMIT or the outer query does not use aggregates.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子查询不使用 LIMIT 或外部查询不使用聚合函数。
- en: '*(Obsolete)*'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*(过时)*'
- en: The subquery and the outer query do not both have ORDER BY clauses.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子查询和外部查询不会同时具有 ORDER BY 子句。
- en: '*(Obsolete - subsumed into constraint 3)*'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*(过时 - 已被第 3 条约束取代)*'
- en: The subquery and outer query do not both use LIMIT.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子查询和外部查询不会同时使用 LIMIT。
- en: The subquery does not use OFFSET.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子查询不使用 OFFSET。
- en: If the outer query is part of a compound select, then the subquery may not have
    a LIMIT clause.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果外部查询是复合选择的一部分，则子查询不能有 LIMIT 子句。
- en: If the outer query is an aggregate, then the subquery may not contain ORDER
    BY.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果外部查询是聚合查询，则子查询不能包含 ORDER BY。
- en: If the sub-query is a compound SELECT, then
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果子查询是复合 SELECT，则
- en: all compound operators must be UNION ALL, and
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有复合运算符必须是 UNION ALL，并且
- en: no terms with the subquery compound may be aggregate or DISTINCT, and
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子查询复合中没有术语可以是聚合函数或 DISTINCT，并且
- en: every term within the subquery must have a FROM clause, and
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子查询中的每个项必须有一个 FROM 子句，并且
- en: the outer query may not be an aggregateor DISTINCT query.
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 外部查询不能是聚合查询或 DISTINCT 查询。
- en: the subquery may not contain window functions.
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子查询不能包含窗口函数。
- en: the subquery must not be the right-hand side of a LEFT JOIN.
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子查询不得位于 LEFT JOIN 的右侧。
- en: either the subquery is the first element of the outer query or there are not
    RIGHT or FULL JOINs in any arm of the subquery.
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果子查询是外部查询的第一个元素，或者子查询的任何分支都不包含 RIGHT 或 FULL JOINs。
- en: the corresponding result set expressions in all arms of the compound subquery
    must have the same [affinity](datatype3.html#affinity).The parent and sub-query
    may contain WHERE clauses. Subject to rules (11), (12) and (13), they may also
    contain ORDER BY, LIMIT and OFFSET clauses.
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复合子查询的所有分支中对应的结果集表达式必须具有相同的 [亲和性](datatype3.html#affinity)。父查询和子查询可能包含 WHERE
    子句。在规则（11）、（12）和（13）的约束下，它们也可以包含 ORDER BY、LIMIT 和 OFFSET 子句。
- en: If the sub-query is a compound select, then all terms of the ORDER by clause
    of the parent must be simple references to columns of the sub-query.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果子查询是复合选择，则父查询的 ORDER BY 子句中的所有术语必须是对子查询列的简单引用。
- en: If the subquery uses LIMIT then the outer query may not have a WHERE clause.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果子查询使用 LIMIT，则外部查询可能不具有 WHERE 子句。
- en: If the sub-query is a compound select, then it must not use an ORDER BY clause.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果子查询是复合选择，则不能使用 ORDER BY 子句。
- en: If the subquery uses LIMIT, then the outer query may not be DISTINCT.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果子查询使用 LIMIT，则外部查询可能不是 DISTINCT。
- en: The subquery may not be a recursive CTE.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子查询可能不是递归的公共表达式（CTE）。
- en: If the outer query is a recursive CTE, then the sub-query may not be a compound
    query.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果外部查询是递归的公共表达式（CTE），则子查询可能不是复合查询。
- en: '*(Obsolete)*'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*(已废弃)*'
- en: Neither the subquery nor the outer query may contain a [window function](windowfunctions.html)
    in the result set nor the ORDER BY clause.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子查询和外部查询都不能在结果集或 ORDER BY 子句中包含窗口函数。
- en: The subquery may not be the right operand of a RIGHT or FULL OUTER JOIN.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子查询可能不是 RIGHT 或 FULL OUTER JOIN 的右操作数。
- en: 'The subquery may not contain a FULL or RIGHT JOIN unless it is the first element
    of the parent query. Two subcases:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果子查询不是父查询的第一个元素，则子查询可能不包含 FULL 或 RIGHT JOIN。有两个子情况：
- en: the subquery is not a compound query.
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子查询不是复合查询。
- en: the subquery is a compound query and the RIGHT JOIN occurs in any arm of the
    compound query. (See also (17g)).
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子查询是一个复合查询，并且 RIGHT JOIN 出现在复合查询的任何分支中。（另见（17g））。
- en: The subquery is not a MATERIALIZED CTE.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子查询不是材料化 CTE。
- en: Query flattening is an important optimization when views are used as each use
    of a view is translated into a subquery.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图用作每次使用视图时，查询展开是一个重要的优化，因为每次使用视图都被转换为一个子查询。
- en: 12\. Subquery Co-routines
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12\. 子查询协程
- en: 'SQLite implements FROM-clause subqueries in one of three ways:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 实现 FROM 子句子查询的方式有三种：
- en: '[Flatten](optoverview.html#flattening) the subquery into its outer query'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[展平](optoverview.html#flattening)子查询到其外部查询中'
- en: Evaluate the subquery into a transient table that exists for the duration of
    the one SQL statement that is being evaluated, then run the outer query against
    that transient table.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将子查询评估为一个存在于正在评估的 SQL 语句的持续时间内的临时表，然后对该临时表运行外部查询。
- en: Evaluate the subquery in a co-routine that runs in parallel with the outer query,
    providing rows to the outer query as needed.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与外部查询并行运行的协程中评估子查询，根据需要向外部查询提供行。
- en: 'This section describes the third technique: implementing the subquery as a
    co-routine.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述第三种技术：将子查询实现为协程。
- en: A co-routine is like a subroutine in that it runs in the same thread as the
    caller and eventually returns control back to the caller. The difference is that
    a co-routine also has the ability to return before it has finished, and then resume
    where it left off the next time it is called.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 协程类似于子例程，因为它在与调用者相同的线程中运行，并最终将控制返回给调用者。不同之处在于，协程还具有在完成之前返回并在下次调用时恢复执行的能力。
- en: When a subquery is implemented as a co-routine, byte-code is generated to implement
    the subquery as if it were a standalone query, except instead of returning rows
    of results back to the application, the co-routine yields control back to the
    caller after each row is computed. The caller can then use that one computed row
    as part of its computation, then invoke the co-routine again when it is ready
    for the next row.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当将子查询实现为协程时，生成字节码以将子查询实现为独立查询，但不是将结果行返回给应用程序，而是在计算每行后将控制返回给调用者。调用者可以将计算的一行作为其计算的一部分，然后在准备好下一行时再次调用协程。
- en: Co-routines are better than storing the complete result set of the subquery
    in a transient table because co-routines use less memory. With a co-routine, only
    a single row of the result needs to be remembered, whereas all rows of the result
    must be stored for a transient table. Also, because the co-routine does not need
    to run to completion before the outer query begins its work, the first rows of
    output can appear much sooner, and if the overall query is abandoned before it
    has finished, less work is done overall.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 协程优于将子查询的完整结果集存储在临时表中，因为协程使用的内存更少。使用协程时，只需要记住结果的单行，而对于临时表，必须存储所有结果行。此外，由于协程在外部查询开始工作之前不必运行到完成，因此输出的第一行可以更快地出现，如果整体查询在完成之前被放弃，那么总体工作量也会减少。
- en: On the other hand, if the result of the subquery must be scanned multiple times
    (because, for example, it is just one table in a join) then it is better to use
    a transient table to remember the entire result of the subquery, in order to avoid
    computing the subquery more than once.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果必须多次扫描子查询的结果（例如，它只是连接中的一个表），那么最好使用临时表来记住子查询的整个结果，以避免多次计算子查询。
- en: 12.1\. Using Co-routines to Defer Work until after the Sorting
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.1\. 使用协程延迟工作直到排序后。
- en: 'As of SQLite version 3.21.0 (2017-10-24), the query planner will always prefer
    to use a co-routine to implement FROM-clause subqueries that contains an ORDER
    BY clause and that are not part of a join when the result set of the outer query
    is "complex". This feature allows applications to shift expensive computations
    from before the sorter until after the sorter, which can result in faster operation.
    For example, consider this query:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 截至SQLite版本3.21.0（2017-10-24），查询规划器将始终倾向于使用协程来实现包含ORDER BY子句的FROM子句子查询，当外部查询结果集是“复杂”的一部分时。此功能允许应用程序将昂贵的计算从排序器之前移至排序器之后，这可能会导致更快的操作。例如，考虑以下查询：
- en: '[PRE33]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The goal of this query is to compute some value for the five most recent entries
    in the table. In the query above, the "expensive_function()" is invoked prior
    to the sort and thus is invoked on every row of the table, even rows that are
    ultimately omitted due to the LIMIT clause. A co-routine can be used to work around
    this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询的目标是计算表中最近五个条目的某些值。在上述查询中，“expensive_function()”在排序之前被调用，因此在表的每一行上都会被调用，即使最终由于LIMIT子句而被省略的行也是如此。可以使用协程来解决这个问题：
- en: '[PRE34]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the revised query, the subquery implemented by a co-routine computes the
    five most recent values for "a". Those five values are passed from the co-routine
    up into the outer query where the "expensive_function()" is invoked on only the
    specific rows that the application cares about.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在修订后的查询中，由协程实现的子查询计算了“a”的最近五个值。这五个值从协程传递到外部查询，在那里只有应用程序关心的特定行上才调用了“expensive_function()”。
- en: The query planner in future versions of SQLite might grow smart enough to make
    transformations such as the above automatically, in both directions. That is to
    say, future versions of SQLite might transform queries of the first form into
    the second, or queries written the second way into the first. As of SQLite version
    3.22.0 (2018-01-22), the query planner will flatten the subquery if the outer
    query does not make use of any user-defined functions or subqueries in its result
    set. For the examples shown above, however, SQLite implements each of the queries
    as written.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 未来版本的SQLite查询规划器可能会变得足够智能，自动执行类似上述的转换，无论是从第一种形式到第二种形式，还是从第二种形式到第一种形式。截至SQLite版本3.22.0（2018-01-22），如果外部查询结果集中不使用任何用户定义的函数或子查询，查询规划器将会展平子查询。但是，对于上述示例，SQLite会按照查询的原样实现每个查询。
- en: 13\. The MIN/MAX Optimization
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13\. 最小/最大值优化
- en: 'Queries that contain a single MIN() or MAX() aggregate function whose argument
    is the left-most column of an index might be satisfied by doing a single index
    lookup rather than by scanning the entire table. Examples:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 包含单个MIN()或MAX()聚合函数，并且其参数是索引中最左侧列的查询可能只需执行单个索引查找，而不是扫描整个表。例如：
- en: '[PRE35]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 14\. Automatic Query-Time Indexes
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14\. 自动查询时间索引
- en: 'When no indexes are available to aid the evaluation of a query, SQLite might
    create an automatic index that lasts only for the duration of a single SQL statement.
    Automatic indexes are also sometimes called "Query-time indexes". Since the cost
    of constructing the automatic or query-time index is O(NlogN) (where N is the
    number of entries in the table) and the cost of doing a full table scan is only
    O(N), an automatic index will only be created if SQLite expects that the lookup
    will be run more than logN times during the course of the SQL statement. Consider
    an example:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有索引可用来帮助查询的评估时，SQLite可能会创建一个仅在单个SQL语句的持续时间内存在的自动索引。自动索引有时也称为“查询时间索引”。由于构建自动或查询时间索引的成本是O(NlogN)（其中N是表中的条目数），而进行全表扫描的成本仅为O(N)，因此只有在SQLite预计在SQL语句执行过程中查找超过logN次时才会创建自动索引。考虑以下例子：
- en: '[PRE36]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the query above, if both t1 and t2 have approximately N rows, then without
    any indexes the query will require O(N*N) time. On the other hand, creating an
    index on table t2 requires O(NlogN) time and using that index to evaluate the
    query requires an additional O(NlogN) time. In the absence of [ANALYZE](lang_analyze.html)
    information, SQLite guesses that N is one million and hence it believes that constructing
    the automatic index will be the cheaper approach.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的查询中，如果t1和t2都大约有N行，那么在没有任何索引的情况下，查询将需要O(N*N)的时间。另一方面，在表t2上创建一个索引需要O(NlogN)的时间，并且使用该索引来评估查询需要额外的O(NlogN)时间。在缺乏[ANALYZE](lang_analyze.html)信息的情况下，SQLite猜测N为一百万，因此认为构建自动索引将是更便宜的方法。
- en: 'An automatic query-time index might also be used for a subquery:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 一个自动查询时间索引也可以用于子查询：
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this example, the t2 table is used in a subquery to translate values of the
    t1.b column. If each table contains N rows, SQLite expects that the subquery will
    run N times, and hence it will believe it is faster to construct an automatic,
    transient index on t2 first and then use that index to satisfy the N instances
    of the subquery.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，t2表用于子查询以翻译t1.b列的值。如果每个表包含N行，SQLite预计子查询将运行N次，因此它认为首先在t2上构建一个自动的临时索引，然后使用该索引来满足子查询的N个实例会更快。
- en: The automatic indexing capability can be disabled at run-time using the [automatic_index
    pragma](pragma.html#pragma_automatic_index). Automatic indexing is turned on by
    default, but this can be changed so that automatic indexing is off by default
    using the [SQLITE_DEFAULT_AUTOMATIC_INDEX](compile.html#default_automatic_index)
    compile-time option. The ability to create automatic indexes can be completely
    disabled by compiling with the [SQLITE_OMIT_AUTOMATIC_INDEX](compile.html#omit_automatic_index)
    compile-time option.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在运行时使用[automatic_index pragma](pragma.html#pragma_automatic_index)禁用自动索引功能。自动索引默认情况下是打开的，但可以通过[SQLITE_DEFAULT_AUTOMATIC_INDEX](compile.html#default_automatic_index)编译时选项更改为默认关闭自动索引。可以通过使用[SQLITE_OMIT_AUTOMATIC_INDEX](compile.html#omit_automatic_index)编译时选项完全禁用创建自动索引的能力。
- en: In SQLite [version 3.8.0](releaselog/3_8_0.html) (2013-08-26) and later, an
    [SQLITE_WARNING_AUTOINDEX](rescode.html#warning_autoindex) message is sent to
    the [error log](errlog.html) every time a statement is prepared that uses an automatic
    index. Application developers can and should use these warnings to identify the
    need for new persistent indexes in the schema.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQLite [版本 3.8.0](releaselog/3_8_0.html)（2013-08-26）及更高版本中，每次准备使用自动索引的语句时，都会向[错误日志](errlog.html)发送一个[SQLITE_WARNING_AUTOINDEX](rescode.html#warning_autoindex)消息。应用程序开发人员可以和应该利用这些警告来识别在架构中需要新持久索引的情况。
- en: Do not confuse automatic indexes with the [internal indexes](fileformat2.html#intschema)
    (having names like "sqlite_autoindex_*table*_*N*") that are sometimes created
    to implement a [PRIMARY KEY constraint](lang_createtable.html#primkeyconst) or
    [UNIQUE constraint](lang_createtable.html#uniqueconst). The automatic indexes
    described here exist only for the duration of a single query, are never persisted
    to disk, and are only visible to a single database connection. Internal indexes
    are part of the implementation of PRIMARY KEY and UNIQUE constraints, are long-lasting
    and persisted to disk, and are visible to all database connections. The term "autoindex"
    appears in the names of [internal indexes](fileformat2.html#intschema) for legacy
    reasons and does not indicate that internal indexes and automatic indexes are
    related.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将自动索引与[内部索引](fileformat2.html#intschema)（其名称类似于“sqlite_autoindex_*table*_*N*”）混淆。有时会创建这些内部索引来实现[主键约束](lang_createtable.html#primkeyconst)或[唯一约束](lang_createtable.html#uniqueconst)。此处描述的自动索引仅存在于单个查询的持续时间内，从不持久化到磁盘，并且仅对单个数据库连接可见。内部索引是主键和唯一约束实现的一部分，具有长期持久性并持久化到磁盘，对所有数据库连接可见。术语“autoindex”出现在[内部索引](fileformat2.html#intschema)的名称中，出于传统原因，并不表示内部索引和自动索引有关联。
- en: 14.1\. Hash Joins
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.1\. 散列连接
- en: An automatic index is almost the same thing as a [hash join](https://en.wikipedia.org/wiki/Hash_join).
    The only difference is that a B-Tree is used instead of a hash table. If you are
    willing to say that the transient B-Tree constructed for an automatic index is
    really just a fancy hash table, then a query that uses an automatic index is just
    a hash join.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 自动索引几乎与[hash join](https://en.wikipedia.org/wiki/Hash_join)相同。唯一的区别是使用B-Tree而不是哈希表。如果你愿意说为自动索引构建的短暂B-Tree实际上只是一个花哨的哈希表，那么使用自动索引的查询就是一个哈希连接。
- en: SQLite constructs a transient index instead of a hash table in this instance
    because it already has a robust and high performance B-Tree implementation at
    hand, whereas a hash-table would need to be added. Adding a separate hash table
    implementation to handle this one case would increase the size of the library
    (which is designed for use on low-memory embedded devices) for minimal performance
    gain. SQLite might be enhanced with a hash-table implementation someday, but for
    now it seems better to continue using automatic indexes in cases where client/server
    database engines might use a hash join.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，SQLite 构建了一个临时索引，而不是哈希表，因为它已经具备了强大且高性能的 B-Tree 实现，而哈希表则需要额外添加。在低内存嵌入式设备上使用的库的大小会因为添加单独的哈希表实现而增加，而性能收益微乎其微。或许未来
    SQLite 可能会通过增加哈希表实现来进行增强，但目前继续在客户端/服务器数据库引擎可能使用哈希连接的情况下使用自动索引似乎更好。
- en: 15\. The WHERE-Clause Push-Down Optimization
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15\. WHERE 子句推送优化
- en: 'If a subquery cannot be [flattened](optoverview.html#flattening) into the outer
    query, it might still be possible to enhance performance by "pushing down" WHERE
    clause terms from the outer query into the subquery. Consider an example:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果子查询无法 [展平化](optoverview.html#flattening) 到外部查询中，仍然可能通过将 WHERE 子句从外部查询推送到子查询中来增强性能。考虑一个例子：
- en: '[PRE38]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The view v1 cannot be [flattened](optoverview.html#flattening) because it is
    DISTINCT. It must instead be run as a subquery with the results being stored in
    a transient table, then the join is performed between t2 and the transient table.
    The push-down optimization pushes down the "b BETWEEN 10 AND 20" term into the
    view. This makes the transient table smaller, and helps the subquery to run faster
    if there is an index on t1.b. The resulting evaluation is like this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 视图 v1 由于是 DISTINCT，无法进行 [展平化](optoverview.html#flattening)。必须将其作为子查询运行，并将结果存储在临时表中，然后在
    t2 和临时表之间执行连接。推送优化将 "b BETWEEN 10 AND 20" 条件推送到视图中。这样可以使临时表变小，如果 t1.b 上有索引，则有助于子查询运行更快。结果的评估如下：
- en: '[PRE39]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The WHERE-clause push-down optimization cannot always be used. For example,
    if the subquery contains a LIMIT, then pushing down any part of the WHERE clause
    from the outer query could change the result of the inner query. There are other
    restrictions, explained in a comment in the source code on the pushDownWhereTerms()
    routine that implements this optimization.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: WHERE 子句推送优化并非总是可用。例如，如果子查询包含 LIMIT，则从外部查询推送 WHERE 子句的任何部分可能会改变内部查询的结果。在实现这一优化的
    pushDownWhereTerms() 程序中，源代码中的注释解释了其他限制。
- en: Do not confuse this optimization with the optimization by a similar name in
    MySQL. The MySQL push-down optimization changes the order of evaluation of WHERE-clause
    constraints such that those that can be evaluated using only the index and without
    having to find the corresponding table row are evaluated first, thus avoiding
    an unnecessary table row lookup if the constraint fails. For disambiguation, SQLite
    calls this the "MySQL push-down optimization". SQLite does do the MySQL push-down
    optimization too, in addition to the WHERE-clause push-down optimization. But
    the focus of this section is the WHERE-clause push-down optimization.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将这种优化与MySQL中同名的优化混淆。MySQL的推入优化改变了WHERE子句约束条件的评估顺序，使得那些可以仅使用索引而不必查找相应表行的约束条件首先评估，从而在约束条件失败时避免不必要的表行查找。为了消除歧义，SQLite将其称为"MySQL推入优化"。SQLite确实也执行MySQL推入优化，除了WHERE子句推入优化之外。但本节的重点是WHERE子句推入优化。
- en: 16\. The OUTER JOIN Strength Reduction Optimization
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16\. 外连接强度降低优化
- en: An OUTER JOIN (either a LEFT JOIN, a RIGHT JOIN, or a FULL JOIN) can sometimes
    be simplified. A LEFT or RIGHT JOIN can be converted into an ordinary (INNER)
    JOIN, or a FULL JOIN might be converted into either a LEFT or a RIGHT JOIN. This
    can happen if there are terms in the WHERE clause that guarantee the same result
    after simplification. For example, if any column in the right-hand table of the
    LEFT JOIN must be non-NULL in order for the WHERE clause to be true, then the
    LEFT JOIN is demoted to an ordinary JOIN.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 外连接（LEFT JOIN、RIGHT JOIN或FULL JOIN）有时可以简化。LEFT JOIN或RIGHT JOIN可以转换为普通（INNER）JOIN，或者FULL
    JOIN可能转换为LEFT JOIN或RIGHT JOIN。这可以发生在WHERE子句中存在保证简化后得到相同结果的条件时。例如，如果LEFT JOIN右表中的任何列必须为非NULL才能使WHERE子句为真，则LEFT
    JOIN将被降级为普通JOIN。
- en: 'The theorem prover that determines whether a join can be simplified is imperfect.
    It sometimes returns a false negative. In other words, it sometimes fails to prove
    that reducing the strength of an OUTER JOIN is safe when in fact it is safe. For
    example, the prover does not know the [datetime() SQL function](lang_datefunc.html#dttm)
    will always return NULL if its first argument is NULL, and so it will not recognize
    that the LEFT JOIN in the following query could be strength-reduced:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 判断连接是否可以简化的定理证明器并不完美。有时会返回假负。换句话说，有时候它无法证明降低外连接强度是安全的，而实际上是安全的。例如，该证明器不知道如果其第一个参数为NULL，则[datetime()
    SQL函数](lang_datefunc.html#dttm)始终返回NULL，因此它不会意识到以下查询中的LEFT JOIN可以进行强度降低：
- en: '[PRE40]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It is possible that future enhancements to the prover might enable it to recognize
    that NULL inputs to certain built-in functions always result in a NULL answer.
    However, not all built-in functions have that property (for example [coalesce()](lang_corefunc.html#coalesce))
    and, of course, the prover will never be able to reason about [application-defined
    SQL functions](appfunc.html).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能未来对证明器的增强可能使其能够识别出对某些内建函数的NULL输入始终导致NULL答案。然而，并非所有内建函数都具有该属性（例如[coalesce()](lang_corefunc.html#coalesce)），当然，证明器永远无法推理出[应用程序定义的SQL函数](appfunc.html)。
- en: 17\. The Omit OUTER JOIN Optimization
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17\. 省略OUTER JOIN 优化
- en: 'Sometimes a LEFT or RIGHT JOIN can be completely omitted from a query without
    changing the result. This can happen if all of the following are true:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，可以完全省略查询中的LEFT JOIN或RIGHT JOIN而不改变结果。如果以下条件全部为真，则可能会发生这种情况：
- en: The query is not an aggregate
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询不是一个聚合查询。
- en: Either the query is DISTINCT or else the ON or USING clause on the OUTER JOIN
    constrains the join such that it matches only a single row
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要么查询是DISTINCT，要么OUTER JOIN的ON或USING子句约束联接，以便仅匹配单行。
- en: The right-hand table of the LEFT JOIN or the left-hand table of a RIGHT JOIN
    is not be used anywhere in the query outside of its own USING or ON clause.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在查询之外，LEFT JOIN的右表或RIGHT JOIN的左表不在其自己的USING或ON子句之外的任何地方使用。
- en: OUTER JOIN elimination often comes up when OUTER JOINs are used inside of views,
    and then the view is used in such as way that none of the columns on the right-hand
    table of the LEFT JOIN or on the left-hand table of a RIGHT JOIN are referenced.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图中使用OUTER JOIN时经常出现OUTER JOIN消除的情况，然后视图被用于这样的方式，即左连接的右表或右连接的左表上的列没有被引用。
- en: 'Here is a simple example of omitting a LEFT JOIN:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是省略LEFT JOIN的一个简单示例：
- en: '[PRE41]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The t2 table is completely unused in the query above, and so the query planner
    is able to implement the query as if it were written:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述查询中，表t2完全未使用，因此查询规划器能够实现查询，如同它是这样编写的：
- en: '[PRE42]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As of this writing, only LEFT JOINs are eliminated. This optimize has not yet
    been generalized to work with RIGHT JOINs as RIGHT JOIN is a relatively new addition
    to SQLite. That asymmetry will probably be corrected in a future release.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 截至本文撰写时，仅消除了LEFT JOIN。此优化尚未普遍应用于RIGHT JOIN，因为RIGHT JOIN是SQLite相对较新的添加。这种不对称性可能会在未来的版本中得到纠正。
- en: 18\. The Constant Propagation Optimization
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 18\. 常量传播优化
- en: When a WHERE clause contains two or more equality constraints connected by the
    AND operator such that all of the [affinities](datatype3.html#affinity) of the
    various constraints are the same, then SQLite might use the transitive property
    of equality to construct new "virtual" constraints that can be used to simplify
    expressions and/or improve performance. This is called the "constant-propagation
    optimization".
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当 WHERE 子句包含两个或多个由 AND 运算符连接的相等约束条件，且所有约束的亲和性均相同时，SQLite 可能利用等式的传递性构建新的 "虚拟"
    约束，用于简化表达式和/或提高性能。这称为 "常量传播优化"。
- en: 'For example, consider the following schema and query:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下架构和查询：
- en: '[PRE43]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: SQLite looks at the "a=b" and "b=5" constraints and deduces that if those two
    constraints are true, then it must also be the case that "a=5" is true. This means
    that the desired row can be looked up quickly using a value of 5 for the INTEGER
    PRIMARY KEY.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 分析 "a=b" 和 "b=5" 约束，并推断如果这两个约束成立，则必然也成立 "a=5"。这意味着可以使用整数主键值为 5 快速查找所需的行。
