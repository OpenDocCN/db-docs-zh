["```sql\n> CREATE TABLE t1(a INT, b VARCHAR(10));\n> INSERT INTO t1(a,b) VALUES('123',456);\n> \n> ```", "```sql\n> CREATE TABLE t1(a INT, b TEXT, c REAL);\n> CREATE VIEW v1(x,y,z) AS SELECT b, a+c, 42 FROM t1 WHERE b!=11;\n> \n> ```", "```sql\n> CREATE TABLE t1(\n>     t  TEXT,     -- text affinity by rule 2\n>     nu NUMERIC,  -- numeric affinity by rule 5\n>     i  INTEGER,  -- integer affinity by rule 1\n>     r  REAL,     -- real affinity by rule 4\n>     no BLOB      -- no affinity by rule 3\n> );\n> \n> -- Values stored as TEXT, INTEGER, INTEGER, REAL, TEXT.\n> INSERT INTO t1 VALUES('500.0', '500.0', '500.0', '500.0', '500.0');\n> SELECT typeof(t), typeof(nu), typeof(i), typeof(r), typeof(no) FROM t1;\n> text|integer|integer|real|text\n> \n> -- Values stored as TEXT, INTEGER, INTEGER, REAL, REAL.\n> DELETE FROM t1;\n> INSERT INTO t1 VALUES(500.0, 500.0, 500.0, 500.0, 500.0);\n> SELECT typeof(t), typeof(nu), typeof(i), typeof(r), typeof(no) FROM t1;\n> text|integer|integer|real|real\n> \n> -- Values stored as TEXT, INTEGER, INTEGER, REAL, INTEGER.\n> DELETE FROM t1;\n> INSERT INTO t1 VALUES(500, 500, 500, 500, 500);\n> SELECT typeof(t), typeof(nu), typeof(i), typeof(r), typeof(no) FROM t1;\n> text|integer|integer|real|integer\n> \n> -- BLOBs are always stored as BLOBs regardless of column affinity.\n> DELETE FROM t1;\n> INSERT INTO t1 VALUES(x'0500', x'0500', x'0500', x'0500', x'0500');\n> SELECT typeof(t), typeof(nu), typeof(i), typeof(r), typeof(no) FROM t1;\n> blob|blob|blob|blob|blob\n> \n> -- NULLs are also unaffected by affinity\n> DELETE FROM t1;\n> INSERT INTO t1 VALUES(NULL,NULL,NULL,NULL,NULL);\n> SELECT typeof(t), typeof(nu), typeof(i), typeof(r), typeof(no) FROM t1;\n> null|null|null|null|null\n> \n> ```", "```sql\n> CREATE TABLE t1(\n>     a TEXT,      -- text affinity\n>     b NUMERIC,   -- numeric affinity\n>     c BLOB,      -- no affinity\n>     d            -- no affinity\n> );\n> \n> -- Values will be stored as TEXT, INTEGER, TEXT, and INTEGER respectively\n> INSERT INTO t1 VALUES('500', '500', '500', 500);\n> SELECT typeof(a), typeof(b), typeof(c), typeof(d) FROM t1;\n> text|integer|text|integer\n> \n> -- Because column \"a\" has text affinity, numeric values on the\n> -- right-hand side of the comparisons are converted to text before\n> -- the comparison occurs.\n> SELECT a < 40,   a < 60,   a < 600 FROM t1;\n> 0|1|1\n> \n> -- Text affinity is applied to the right-hand operands but since\n> -- they are already TEXT this is a no-op; no conversions occur.\n> SELECT a < '40', a < '60', a < '600' FROM t1;\n> 0|1|1\n> \n> -- Column \"b\" has numeric affinity and so numeric affinity is applied\n> -- to the operands on the right.  Since the operands are already numeric,\n> -- the application of affinity is a no-op; no conversions occur.  All\n> -- values are compared numerically.\n> SELECT b < 40,   b < 60,   b < 600 FROM t1;\n> 0|0|1\n> \n> -- Numeric affinity is applied to operands on the right, converting them\n> -- from text to integers.  Then a numeric comparison occurs.\n> SELECT b < '40', b < '60', b < '600' FROM t1;\n> 0|0|1\n> \n> -- No affinity conversions occur.  Right-hand side values all have\n> -- storage class INTEGER which are always less than the TEXT values\n> -- on the left.\n> SELECT c < 40,   c < 60,   c < 600 FROM t1;\n> 0|0|0\n> \n> -- No affinity conversions occur.  Values are compared as TEXT.\n> SELECT c < '40', c < '60', c < '600' FROM t1;\n> 0|1|1\n> \n> -- No affinity conversions occur.  Right-hand side values all have\n> -- storage class INTEGER which compare numerically with the INTEGER\n> -- values on the left.\n> SELECT d < 40,   d < 60,   d < 600 FROM t1;\n> 0|0|1\n> \n> -- No affinity conversions occur.  INTEGER values on the left are\n> -- always less than TEXT values on the right.\n> SELECT d < '40', d < '60', d < '600' FROM t1;\n> 1|1|1\n> \n> ```", "```sql\n> CREATE TABLE t1(\n>     x INTEGER PRIMARY KEY,\n>     a,                 /* collating sequence BINARY */\n>     b COLLATE BINARY,  /* collating sequence BINARY */\n>     c COLLATE RTRIM,   /* collating sequence RTRIM  */\n>     d COLLATE NOCASE   /* collating sequence NOCASE */\n> );\n>                    /* x   a     b     c       d */\n> INSERT INTO t1 VALUES(1,'abc','abc', 'abc  ','abc');\n> INSERT INTO t1 VALUES(2,'abc','abc', 'abc',  'ABC');\n> INSERT INTO t1 VALUES(3,'abc','abc', 'abc ', 'Abc');\n> INSERT INTO t1 VALUES(4,'abc','abc ','ABC',  'abc');\n>  \n> /* Text comparison a=b is performed using the BINARY collating sequence. */\n> SELECT x FROM t1 WHERE a = b ORDER BY x;\n> --result 1 2 3\n> \n> /* Text comparison a=b is performed using the RTRIM collating sequence. */\n> SELECT x FROM t1 WHERE a = b COLLATE RTRIM ORDER BY x;\n> --result 1 2 3 4\n> \n> /* Text comparison d=a is performed using the NOCASE collating sequence. */\n> SELECT x FROM t1 WHERE d = a ORDER BY x;\n> --result 1 2 3 4\n> \n> /* Text comparison a=d is performed using the BINARY collating sequence. */\n> SELECT x FROM t1 WHERE a = d ORDER BY x;\n> --result 1 4\n> \n> /* Text comparison 'abc'=c is performed using the RTRIM collating sequence. */\n> SELECT x FROM t1 WHERE 'abc' = c ORDER BY x;\n> --result 1 2 3\n> \n> /* Text comparison c='abc' is performed using the RTRIM collating sequence. */\n> SELECT x FROM t1 WHERE c = 'abc' ORDER BY x;\n> --result 1 2 3\n> \n> /* Grouping is performed using the NOCASE collating sequence (Values\n> ** 'abc', 'ABC', and 'Abc' are placed in the same group). */\n> SELECT count(*) FROM t1 GROUP BY d ORDER BY 1;\n> --result 4\n> \n> /* Grouping is performed using the BINARY collating sequence.  'abc' and\n> ** 'ABC' and 'Abc' form different groups */\n> SELECT count(*) FROM t1 GROUP BY (d || '') ORDER BY 1;\n> --result 1 1 2\n> \n> /* Sorting or column c is performed using the RTRIM collating sequence. */\n> SELECT x FROM t1 ORDER BY c, x;\n> --result 4 1 2 3\n> \n> /* Sorting of (c||'') is performed using the BINARY collating sequence. */\n> SELECT x FROM t1 ORDER BY (c||''), x;\n> --result 4 2 3 1\n> \n> /* Sorting of column c is performed using the NOCASE collating sequence. */\n> SELECT x FROM t1 ORDER BY c COLLATE NOCASE, x;\n> --result 2 4 3 1\n> \n> ```"]