- en: 10.8.2 EXPLAIN Output Format
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.8.2 EXPLAIN输出格式
- en: 原文：[https://dev.mysql.com/doc/refman/8.0/en/explain-output.html](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://dev.mysql.com/doc/refman/8.0/en/explain-output.html](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html)
- en: The [`EXPLAIN`](explain.html "15.8.2 EXPLAIN Statement") statement provides
    information about how MySQL executes statements. [`EXPLAIN`](explain.html "15.8.2 EXPLAIN
    Statement") works with [`SELECT`](select.html "15.2.13 SELECT Statement"), [`DELETE`](delete.html
    "15.2.2 DELETE Statement"), [`INSERT`](insert.html "15.2.7 INSERT Statement"),
    [`REPLACE`](replace.html "15.2.12 REPLACE Statement"), and [`UPDATE`](update.html
    "15.2.17 UPDATE Statement") statements.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[`EXPLAIN`](explain.html "15.8.2 EXPLAIN Statement")语句提供有关MySQL如何执行语句的信息。[`EXPLAIN`](explain.html
    "15.8.2 EXPLAIN Statement")与[`SELECT`](select.html "15.2.13 SELECT Statement")，[`DELETE`](delete.html
    "15.2.2 DELETE Statement")，[`INSERT`](insert.html "15.2.7 INSERT Statement")，[`REPLACE`](replace.html
    "15.2.12 REPLACE Statement")和[`UPDATE`](update.html "15.2.17 UPDATE Statement")语句一起使用。'
- en: '[`EXPLAIN`](explain.html "15.8.2 EXPLAIN Statement") returns a row of information
    for each table used in the [`SELECT`](select.html "15.2.13 SELECT Statement")
    statement. It lists the tables in the output in the order that MySQL would read
    them while processing the statement. This means that MySQL reads a row from the
    first table, then finds a matching row in the second table, and then in the third
    table, and so on. When all tables are processed, MySQL outputs the selected columns
    and backtracks through the table list until a table is found for which there are
    more matching rows. The next row is read from this table and the process continues
    with the next table.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[`EXPLAIN`](explain.html "15.8.2 EXPLAIN Statement")为[`SELECT`](select.html
    "15.2.13 SELECT Statement")语句中使用的每个表返回一行信息。它按照MySQL在处理语句时读取它们的顺序在输出中列出表。这意味着MySQL从第一个表中读取一行，然后在第二个表中找到匹配的行，然后在第三个表中找到匹配的行，依此类推。当所有表都被处理时，MySQL输出所选列，并通过表列表回溯，直到找到一个表，其中有更多匹配的行。从这个表中读取下一行，然后继续下一个表的过程。'
- en: Note
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'MySQL Workbench has a Visual Explain capability that provides a visual representation
    of [`EXPLAIN`](explain.html "15.8.2 EXPLAIN Statement") output. See [Tutorial:
    Using Explain to Improve Query Performance](/doc/workbench/en/wb-tutorial-visual-explain-dbt3.html).'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 'MySQL Workbench具有Visual Explain功能，提供了[`EXPLAIN`](explain.html "15.8.2 EXPLAIN
    Statement")输出的可视化表示。请参阅[Tutorial: Using Explain to Improve Query Performance](/doc/workbench/en/wb-tutorial-visual-explain-dbt3.html)。'
- en: '[EXPLAIN Output Columns](explain-output.html#explain-output-columns "EXPLAIN
    Output Columns")'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[EXPLAIN输出列](explain-output.html#explain-output-columns "EXPLAIN Output Columns")'
- en: '[EXPLAIN Join Types](explain-output.html#explain-join-types "EXPLAIN Join Types")'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[EXPLAIN连接类型](explain-output.html#explain-join-types "EXPLAIN Join Types")'
- en: '[EXPLAIN Extra Information](explain-output.html#explain-extra-information "EXPLAIN
    Extra Information")'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[EXPLAIN额外信息](explain-output.html#explain-extra-information "EXPLAIN Extra
    Information")'
- en: '[EXPLAIN Output Interpretation](explain-output.html#explain-output-interpretation
    "EXPLAIN Output Interpretation")'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[EXPLAIN输出解释](explain-output.html#explain-output-interpretation "EXPLAIN Output
    Interpretation")'
- en: EXPLAIN Output Columns
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: EXPLAIN输出列
- en: This section describes the output columns produced by [`EXPLAIN`](explain.html
    "15.8.2 EXPLAIN Statement"). Later sections provide additional information about
    the [`type`](explain-output.html#explain-join-types "EXPLAIN Join Types") and
    [`Extra`](explain-output.html#explain-extra-information "EXPLAIN Extra Information")
    columns.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了[`EXPLAIN`](explain.html "15.8.2 EXPLAIN Statement")生成的输出列。后续章节提供有关[`type`](explain-output.html#explain-join-types
    "EXPLAIN Join Types")和[`Extra`](explain-output.html#explain-extra-information
    "EXPLAIN Extra Information")列的附加信息。
- en: Each output row from [`EXPLAIN`](explain.html "15.8.2 EXPLAIN Statement") provides
    information about one table. Each row contains the values summarized in [Table 10.1,
    “EXPLAIN Output Columns”](explain-output.html#explain-output-column-table "Table 10.1 EXPLAIN
    Output Columns"), and described in more detail following the table. Column names
    are shown in the table's first column; the second column provides the equivalent
    property name shown in the output when `FORMAT=JSON` is used.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每个[`EXPLAIN`](explain.html "15.8.2 EXPLAIN Statement")的输出行提供有关一个表的信息。每行包含[表10.1，“EXPLAIN输出列”](explain-output.html#explain-output-column-table
    "表10.1 EXPLAIN输出列")中总结的值，并在表后详细描述。表中显示列名在表的第一列；第二列提供了在使用`FORMAT=JSON`时输出中显示的等效属性名称。
- en: '**Table 10.1 EXPLAIN Output Columns**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**表10.1 EXPLAIN输出列**'
- en: '| Column | JSON Name | Meaning |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 列 | JSON名称 | 含义 |'
- en: '| [`id`](explain-output.html#explain_id) | `select_id` | The `SELECT` identifier
    |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| [`id`](explain-output.html#explain_id) | `select_id` | `SELECT`标识符 |'
- en: '| [`select_type`](explain-output.html#explain_select_type) | None | The `SELECT`
    type |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| [`select_type`](explain-output.html#explain_select_type) | None | `SELECT`
    类型 |'
- en: '| [`table`](explain-output.html#explain_table) | `table_name` | The table for
    the output row |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| [`table`](explain-output.html#explain_table) | `table_name` | 输出行的表 |'
- en: '| [`partitions`](explain-output.html#explain_partitions) | `partitions` | The
    matching partitions |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| [`partitions`](explain-output.html#explain_partitions) | `partitions` | 匹配的分区
    |'
- en: '| [`type`](explain-output.html#explain_type) | `access_type` | The join type
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| [`type`](explain-output.html#explain_type) | `access_type` | 连接类型 |'
- en: '| [`possible_keys`](explain-output.html#explain_possible_keys) | `possible_keys`
    | The possible indexes to choose |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| [`possible_keys`](explain-output.html#explain_possible_keys) | `possible_keys`
    | 可选择的索引 |'
- en: '| [`key`](explain-output.html#explain_key) | `key` | The index actually chosen
    |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| [`key`](explain-output.html#explain_key) | `key` | 实际选择的索引 |'
- en: '| [`key_len`](explain-output.html#explain_key_len) | `key_length` | The length
    of the chosen key |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| [`key_len`](explain-output.html#explain_key_len) | `key_length` | 所选键的长度
    |'
- en: '| [`ref`](explain-output.html#explain_ref) | `ref` | The columns compared to
    the index |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| [`ref`](explain-output.html#explain_ref) | `ref` | 与索引进行比较的列 |'
- en: '| [`rows`](explain-output.html#explain_rows) | `rows` | Estimate of rows to
    be examined |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| [`rows`](explain-output.html#explain_rows) | `rows` | 预计要检查的行数 |'
- en: '| [`filtered`](explain-output.html#explain_filtered) | `filtered` | Percentage
    of rows filtered by table condition |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| [`filtered`](explain-output.html#explain_filtered) | `filtered` | 表条件过滤的行的百分比
    |'
- en: '| [`Extra`](explain-output.html#explain_extra) | None | Additional information
    |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| [`Extra`](explain-output.html#explain_extra) | None | 附加信息 |'
- en: '| Column | JSON Name | Meaning |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 列 | JSON 名称 | 含义 |'
- en: Note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: JSON properties which are `NULL` are not displayed in JSON-formatted `EXPLAIN`
    output.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JSON 格式的 `EXPLAIN` 输出中，值为 `NULL` 的 JSON 属性不会显示。
- en: '`id` (JSON name: `select_id`)'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`（JSON 名称：`select_id`）'
- en: The [`SELECT`](select.html "15.2.13 SELECT Statement") identifier. This is the
    sequential number of the [`SELECT`](select.html "15.2.13 SELECT Statement") within
    the query. The value can be `NULL` if the row refers to the union result of other
    rows. In this case, the `table` column shows a value like `<union*`M`*,*`N`*>`
    to indicate that the row refers to the union of the rows with `id` values of *`M`*
    and *`N`*.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[`SELECT`](select.html "15.2.13 SELECT Statement")标识符。这是查询中[`SELECT`](select.html
    "15.2.13 SELECT Statement")的顺序号。如果行引用其他行的联合结果，则该值可以为`NULL`。在这种情况下，`table`列显示类似`<union*`M`*,*`N`*>`的值，表示该行引用具有`id`值为*`M`*和*`N`*的行的联合。'
- en: '`select_type` (JSON name: none)'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`select_type`（JSON 名称：无）'
- en: The type of [`SELECT`](select.html "15.2.13 SELECT Statement"), which can be
    any of those shown in the following table. A JSON-formatted `EXPLAIN` exposes
    the `SELECT` type as a property of a `query_block`, unless it is `SIMPLE` or `PRIMARY`.
    The JSON names (where applicable) are also shown in the table.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[`SELECT`](select.html "15.2.13 SELECT Statement")的类型，可以是以下表中显示的任何类型之一。JSON
    格式的 `EXPLAIN` 将 `SELECT` 类型公开为 `query_block` 的属性，除非它是 `SIMPLE` 或 `PRIMARY`。表中还显示了
    JSON 名称（如果适用）。'
- en: '| `select_type` Value | JSON Name | Meaning |'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `select_type` 值 | JSON 名称 | 含义 |'
- en: '| `SIMPLE` | None | Simple [`SELECT`](select.html "15.2.13 SELECT Statement")
    (not using [`UNION`](union.html "15.2.18 UNION Clause") or subqueries) |'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `SIMPLE` | None | 简单的[`SELECT`](select.html "15.2.13 SELECT Statement")（不使用[`UNION`](union.html
    "15.2.18 UNION Clause")或子查询） |'
- en: '| `PRIMARY` | None | Outermost [`SELECT`](select.html "15.2.13 SELECT Statement")
    |'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `PRIMARY` | None | 最外层的[`SELECT`](select.html "15.2.13 SELECT Statement")
    |'
- en: '| [`UNION`](union.html "15.2.18 UNION Clause") | None | Second or later [`SELECT`](select.html
    "15.2.13 SELECT Statement") statement in a [`UNION`](union.html "15.2.18 UNION
    Clause") |'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| [`UNION`](union.html "15.2.18 UNION Clause") | None | [`UNION`](union.html
    "15.2.18 UNION Clause")中的第二个或更后的[`SELECT`](select.html "15.2.13 SELECT Statement")语句
    |'
- en: '| `DEPENDENT UNION` | `dependent` (`true`) | Second or later [`SELECT`](select.html
    "15.2.13 SELECT Statement") statement in a [`UNION`](union.html "15.2.18 UNION
    Clause"), dependent on outer query |'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `DEPENDENT UNION` | `dependent` (`true`) | [`UNION`](union.html "15.2.18 UNION
    Clause")中的第二个或更后的[`SELECT`](select.html "15.2.13 SELECT Statement")语句，依赖于外部查询
    |'
- en: '| `UNION RESULT` | `union_result` | Result of a [`UNION`](union.html "15.2.18 UNION
    Clause"). |'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `UNION RESULT` | `union_result` | [`UNION`](union.html "15.2.18 UNION Clause")的结果。
    |'
- en: '| [`SUBQUERY`](optimizer-hints.html#optimizer-hints-subquery "Subquery Optimizer
    Hints") | None | First [`SELECT`](select.html "15.2.13 SELECT Statement") in subquery
    |'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| [`SUBQUERY`](optimizer-hints.html#optimizer-hints-subquery "Subquery Optimizer
    Hints") | None | 子查询中的第一个[`SELECT`](select.html "15.2.13 SELECT Statement") |'
- en: '| `DEPENDENT SUBQUERY` | `dependent` (`true`) | First [`SELECT`](select.html
    "15.2.13 SELECT Statement") in subquery, dependent on outer query |'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `DEPENDENT SUBQUERY` | `dependent`（`true`） | 子查询中的第一个[`SELECT`](select.html
    "15.2.13 SELECT语句")，依赖于外部查询 |'
- en: '| `DERIVED` | None | Derived table |'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `DERIVED` | 无 | 派生表 |'
- en: '| `DEPENDENT DERIVED` | `dependent` (`true`) | Derived table dependent on another
    table |'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `DEPENDENT DERIVED` | `dependent`（`true`） | 依赖于另一张表的派生表 |'
- en: '| `MATERIALIZED` | `materialized_from_subquery` | Materialized subquery |'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `MATERIALIZED` | `materialized_from_subquery` | 物化子查询 |'
- en: '| `UNCACHEABLE SUBQUERY` | `cacheable` (`false`) | A subquery for which the
    result cannot be cached and must be re-evaluated for each row of the outer query
    |'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `UNCACHEABLE SUBQUERY` | `cacheable`（`false`） | 不能缓存结果且必须对外部查询的每一行重新评估的子查询
    |'
- en: '| `UNCACHEABLE UNION` | `cacheable` (`false`) | The second or later select
    in a [`UNION`](union.html "15.2.18 UNION Clause") that belongs to an uncacheable
    subquery (see `UNCACHEABLE SUBQUERY`) |'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `UNCACHEABLE UNION` | `cacheable`（`false`） | [`UNION`](union.html "15.2.18 UNION子句")中的第二个或更后续的选择属于不可缓存子查询（参见`UNCACHEABLE
    SUBQUERY`）|'
- en: '| `select_type` Value | JSON Name | Meaning |'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `select_type`值 | JSON名称 | 含义 |'
- en: '`DEPENDENT` typically signifies the use of a correlated subquery. See [Section 15.2.15.7,
    “Correlated Subqueries”](correlated-subqueries.html "15.2.15.7 Correlated Subqueries").'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`DEPENDENT`通常表示使用相关子查询。参见[第15.2.15.7节，“相关子查询”](correlated-subqueries.html "15.2.15.7 相关子查询")。'
- en: '`DEPENDENT SUBQUERY` evaluation differs from `UNCACHEABLE SUBQUERY` evaluation.
    For `DEPENDENT SUBQUERY`, the subquery is re-evaluated only once for each set
    of different values of the variables from its outer context. For `UNCACHEABLE
    SUBQUERY`, the subquery is re-evaluated for each row of the outer context.'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`DEPENDENT SUBQUERY`评估与`UNCACHEABLE SUBQUERY`评估不同。对于`DEPENDENT SUBQUERY`，子查询仅针对其外部上下文的不同变量值集重新评估一次。对于`UNCACHEABLE
    SUBQUERY`，子查询对外部上下文的每一行重新评估。'
- en: When you specify `FORMAT=JSON` with `EXPLAIN`, the output has no single property
    directly equivalent to `select_type`; the `query_block` property corresponds to
    a given `SELECT`. Properties equivalent to most of the `SELECT` subquery types
    just shown are available (an example being `materialized_from_subquery` for `MATERIALIZED`),
    and are displayed when appropriate. There are no JSON equivalents for `SIMPLE`
    or `PRIMARY`.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你在`EXPLAIN`中指定`FORMAT=JSON`时，输出中没有与`select_type`直接等价的单个属性；`query_block`属性对应于给定的`SELECT`。大多数刚刚显示的`SELECT`子查询类型的等效属性是可用的（例如`materialized_from_subquery`对应于`MATERIALIZED`），并在适当时显示。对于`SIMPLE`或`PRIMARY`，没有JSON等价物。
- en: The `select_type` value for non-[`SELECT`](select.html "15.2.13 SELECT Statement")
    statements displays the statement type for affected tables. For example, `select_type`
    is `DELETE` for [`DELETE`](delete.html "15.2.2 DELETE Statement") statements.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 非[`SELECT`](select.html "15.2.13 SELECT语句")语句的`select_type`值显示受影响表的语句类型。例如，对于[`DELETE`](delete.html
    "15.2.2 DELETE语句")语句，`select_type`为`DELETE`。
- en: '`table` (JSON name: `table_name`)'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`table`（JSON名称：`table_name`）'
- en: 'The name of the table to which the row of output refers. This can also be one
    of the following values:'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出行所指的表的名称。这也可以是以下值之一：
- en: '`<union*`M`*,*`N`*>`: The row refers to the union of the rows with `id` values
    of *`M`* and *`N`*.'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<union*`M`*,*`N`*>`：该行指的是具有`id`值为*`M`*和*`N`*的行的并集。'
- en: '`<derived*`N`*>`: The row refers to the derived table result for the row with
    an `id` value of *`N`*. A derived table may result, for example, from a subquery
    in the `FROM` clause.'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<derived*`N`*>`：该行指的是具有`id`值为*`N`*的行的派生表结果。派生表可能是由`FROM`子句中的子查询导致的。'
- en: '`<subquery*`N`*>`: The row refers to the result of a materialized subquery
    for the row with an `id` value of *`N`*. See [Section 10.2.2.2, “Optimizing Subqueries
    with Materialization”](subquery-materialization.html "10.2.2.2 Optimizing Subqueries
    with Materialization").'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<subquery*`N`*>`：该行指的是具有`id`值为*`N`*的行的物化子查询的结果。参见[第10.2.2.2节，“使用物化进行子查询优化”](subquery-materialization.html
    "10.2.2.2 使用物化进行子查询优化")。'
- en: '`partitions` (JSON name: `partitions`)'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`partitions`（JSON名称：`partitions`）'
- en: The partitions from which records would be matched by the query. The value is
    `NULL` for nonpartitioned tables. See [Section 26.3.5, “Obtaining Information
    About Partitions”](partitioning-info.html "26.3.5 Obtaining Information About
    Partitions").
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查询将匹配的分区。对于非分区表，该值为`NULL`。参见[第26.3.5节，“获取有关分区的信息”](partitioning-info.html "26.3.5 获取有关分区的信息")。
- en: '`type` (JSON name: `access_type`)'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`（JSON名称：`access_type`）'
- en: The join type. For descriptions of the different types, see [`EXPLAIN` Join
    Types](explain-output.html#explain-join-types "EXPLAIN Join Types").
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 连接类型。有关不同类型的描述，请参见[`EXPLAIN` Join Types](explain-output.html#explain-join-types
    "EXPLAIN Join Types")。
- en: '`possible_keys` (JSON name: `possible_keys`)'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`possible_keys`（JSON名称：`possible_keys`）'
- en: The `possible_keys` column indicates the indexes from which MySQL can choose
    to find the rows in this table. Note that this column is totally independent of
    the order of the tables as displayed in the output from [`EXPLAIN`](explain.html
    "15.8.2 EXPLAIN Statement"). That means that some of the keys in `possible_keys`
    might not be usable in practice with the generated table order.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`possible_keys`列指示MySQL可以选择从中查找此表中的行的索引。请注意，此列与从[`EXPLAIN`](explain.html "15.8.2 EXPLAIN
    Statement")输出中显示的表的顺序无关。这意味着`possible_keys`中的一些键在实践中可能无法与生成的表顺序一起使用。'
- en: If this column is `NULL` (or undefined in JSON-formatted output), there are
    no relevant indexes. In this case, you may be able to improve the performance
    of your query by examining the `WHERE` clause to check whether it refers to some
    column or columns that would be suitable for indexing. If so, create an appropriate
    index and check the query with [`EXPLAIN`](explain.html "15.8.2 EXPLAIN Statement")
    again. See [Section 15.1.9, “ALTER TABLE Statement”](alter-table.html "15.1.9 ALTER
    TABLE Statement").
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果此列为`NULL`（或在JSON格式输出中未定义），则没有相关的索引。在这种情况下，您可以通过检查`WHERE`子句来查看是否引用了适合索引的某些列，从而改善查询的性能。如果是这样，请创建一个适当的索引，并再次使用[`EXPLAIN`](explain.html
    "15.8.2 EXPLAIN Statement")检查查询。参见[第15.1.9节，“ALTER TABLE Statement”](alter-table.html
    "15.1.9 ALTER TABLE Statement")。
- en: To see what indexes a table has, use `SHOW INDEX FROM *`tbl_name`*`.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要查看表具有哪些索引，请使用`SHOW INDEX FROM *`tbl_name`*`。
- en: '`key` (JSON name: `key`)'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`key`（JSON名称：`key`）'
- en: The `key` column indicates the key (index) that MySQL actually decided to use.
    If MySQL decides to use one of the `possible_keys` indexes to look up rows, that
    index is listed as the key value.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`key`列指示MySQL实际决定使用的键（索引）。如果MySQL决定使用`possible_keys`中的一个索引来查找行，那么该索引将列为键值。'
- en: It is possible that `key` may name an index that is not present in the `possible_keys`
    value. This can happen if none of the `possible_keys` indexes are suitable for
    looking up rows, but all the columns selected by the query are columns of some
    other index. That is, the named index covers the selected columns, so although
    it is not used to determine which rows to retrieve, an index scan is more efficient
    than a data row scan.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`key`可能指的是`possible_keys`值中不存在的索引。如果`possible_keys`中的索引都不适合查找行，但查询选择的所有列都是某个其他索引的列，就会发生这种情况。也就是说，命名的索引覆盖了选择的列，因此虽然它不用于确定要检索哪些行，但索引扫描比数据行扫描更有效率。'
- en: For `InnoDB`, a secondary index might cover the selected columns even if the
    query also selects the primary key because `InnoDB` stores the primary key value
    with each secondary index. If `key` is `NULL`, MySQL found no index to use for
    executing the query more efficiently.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于`InnoDB`，即使查询还选择了主键，次要索引也可能覆盖了选择的列，因为`InnoDB`将主键值与每个次要索引一起存储。如果`key`为`NULL`，则MySQL找不到用于更有效地执行查询的索引。
- en: To force MySQL to use or ignore an index listed in the `possible_keys` column,
    use `FORCE INDEX`, `USE INDEX`, or `IGNORE INDEX` in your query. See [Section 10.9.4,
    “Index Hints”](index-hints.html "10.9.4 Index Hints").
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要强制MySQL使用或忽略`possible_keys`列中列出的索引，请在查询中使用`FORCE INDEX`、`USE INDEX`或`IGNORE
    INDEX`。参见[第10.9.4节，“Index Hints”](index-hints.html "10.9.4 Index Hints")。
- en: For `MyISAM` tables, running [`ANALYZE TABLE`](analyze-table.html "15.7.3.1 ANALYZE
    TABLE Statement") helps the optimizer choose better indexes. For `MyISAM` tables,
    [**myisamchk --analyze**](myisamchk.html "6.6.4 myisamchk — MyISAM Table-Maintenance
    Utility") does the same. See [Section 15.7.3.1, “ANALYZE TABLE Statement”](analyze-table.html
    "15.7.3.1 ANALYZE TABLE Statement"), and [Section 9.6, “MyISAM Table Maintenance
    and Crash Recovery”](myisam-table-maintenance.html "9.6 MyISAM Table Maintenance
    and Crash Recovery").
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于`MyISAM`表，运行[`ANALYZE TABLE`](analyze-table.html "15.7.3.1 ANALYZE TABLE Statement")有助于优化器选择更好的索引。对于`MyISAM`表，[**myisamchk
    --analyze**](myisamchk.html "6.6.4 myisamchk — MyISAM Table-Maintenance Utility")也是一样的。参见[第15.7.3.1节，“ANALYZE
    TABLE Statement”](analyze-table.html "15.7.3.1 ANALYZE TABLE Statement")，以及[第9.6节，“MyISAM
    Table Maintenance and Crash Recovery”](myisam-table-maintenance.html "9.6 MyISAM
    Table Maintenance and Crash Recovery")。
- en: '`key_len` (JSON name: `key_length`)'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`key_len`（JSON名称：`key_length`）'
- en: The `key_len` column indicates the length of the key that MySQL decided to use.
    The value of `key_len` enables you to determine how many parts of a multiple-part
    key MySQL actually uses. If the `key` column says `NULL`, the `key_len` column
    also says `NULL`.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`key_len`列指示MySQL决定使用的键的长度。`key_len`的值使您能够确定MySQL实际使用多部分键的部分数。如果`key`列说`NULL`，则`key_len`列也说`NULL`。'
- en: Due to the key storage format, the key length is one greater for a column that
    can be `NULL` than for a `NOT NULL` column.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于键存储格式，对于可以为`NULL`的列，键长度比`NOT NULL`列多一个。
- en: '`ref` (JSON name: `ref`)'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ref`（JSON名称：`ref`）'
- en: The `ref` column shows which columns or constants are compared to the index
    named in the `key` column to select rows from the table.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ref`列显示与在`key`列中命名的索引进行比较以从表中选择行的哪些列或常量。'
- en: If the value is `func`, the value used is the result of some function. To see
    which function, use [`SHOW WARNINGS`](show-warnings.html "15.7.7.42 SHOW WARNINGS
    Statement") following [`EXPLAIN`](explain.html "15.8.2 EXPLAIN Statement") to
    see the extended [`EXPLAIN`](explain.html "15.8.2 EXPLAIN Statement") output.
    The function might actually be an operator such as an arithmetic operator.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果值为`func`，则使用的值是某个函数的结果。要查看哪个函数，请在[`EXPLAIN`](explain.html "15.8.2 EXPLAIN
    Statement")之后使用[`SHOW WARNINGS`](show-warnings.html "15.7.7.42 SHOW WARNINGS Statement")查看扩展的[`EXPLAIN`](explain.html
    "15.8.2 EXPLAIN Statement")输出。该函数实际上可能是算术运算符等运算符。
- en: '`rows` (JSON name: `rows`)'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rows`（JSON名称：`rows`）'
- en: The `rows` column indicates the number of rows MySQL believes it must examine
    to execute the query.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`rows`列指示MySQL认为必须检查的行数以执行查询。'
- en: For [`InnoDB`](innodb-storage-engine.html "Chapter 17 The InnoDB Storage Engine")
    tables, this number is an estimate, and may not always be exact.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于[`InnoDB`](innodb-storage-engine.html "Chapter 17 The InnoDB Storage Engine")表，此数字是一个估计值，可能并不总是准确的。
- en: '`filtered` (JSON name: `filtered`)'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filtered`（JSON名称：`filtered`）'
- en: The `filtered` column indicates an estimated percentage of table rows that are
    filtered by the table condition. The maximum value is 100, which means no filtering
    of rows occurred. Values decreasing from 100 indicate increasing amounts of filtering.
    `rows` shows the estimated number of rows examined and `rows` × `filtered` shows
    the number of rows that are joined with the following table. For example, if `rows`
    is 1000 and `filtered` is 50.00 (50%), the number of rows to be joined with the
    following table is 1000 × 50% = 500.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`filtered`列指示由表条件过滤的表行的估计百分比。最大值为100，表示未发生任何行过滤。从100递减的值表示过滤量增加。`rows`显示估计检查的行数，`rows`
    × `filtered`显示与下表连接的行数。例如，如果`rows`为1000，`filtered`为50.00（50％），则要与下表连接的行数为1000
    × 50％= 500。'
- en: '`Extra` (JSON name: none)'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Extra`（JSON名称：无）'
- en: This column contains additional information about how MySQL resolves the query.
    For descriptions of the different values, see [`EXPLAIN` Extra Information](explain-output.html#explain-extra-information
    "EXPLAIN Extra Information").
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此列包含有关MySQL如何解析查询的其他信息。有关不同值的描述，请参见[`EXPLAIN` Extra Information](explain-output.html#explain-extra-information
    "EXPLAIN Extra Information")。
- en: There is no single JSON property corresponding to the `Extra` column; however,
    values that can occur in this column are exposed as JSON properties, or as the
    text of the `message` property.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 没有与`Extra`列对应的单个JSON属性；但是，此列中可能出现的值会作为JSON属性或作为`message`属性的文本公开。
- en: EXPLAIN Join Types
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解释连接类型
- en: 'The `type` column of [`EXPLAIN`](explain.html "15.8.2 EXPLAIN Statement") output
    describes how tables are joined. In JSON-formatted output, these are found as
    values of the `access_type` property. The following list describes the join types,
    ordered from the best type to the worst:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[`EXPLAIN`](explain.html "15.8.2 EXPLAIN Statement")输出的`type`列描述了表是如何连接的。在JSON格式的输出中，这些被发现为`access_type`属性的值。以下列表描述了连接类型，从最佳类型到最差类型：'
- en: '[`system`](explain-output.html#jointype_system)'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`system`](explain-output.html#jointype_system)'
- en: The table has only one row (= system table). This is a special case of the [`const`](explain-output.html#jointype_const)
    join type.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表只有一行（=系统表）。这是[`const`](explain-output.html#jointype_const)连接类型的特殊情况。
- en: '[`const`](explain-output.html#jointype_const)'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`const`](explain-output.html#jointype_const)'
- en: The table has at most one matching row, which is read at the start of the query.
    Because there is only one row, values from the column in this row can be regarded
    as constants by the rest of the optimizer. [`const`](explain-output.html#jointype_const)
    tables are very fast because they are read only once.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该表最多只有一行匹配行，在查询开始时读取。因为只有一行，来自此行的列值可以被优化器的其余部分视为常量。[`const`](explain-output.html#jointype_const)表非常快，因为只读取一次。
- en: '[`const`](explain-output.html#jointype_const) is used when you compare all
    parts of a `PRIMARY KEY` or `UNIQUE` index to constant values. In the following
    queries, *`tbl_name`* can be used as a [`const`](explain-output.html#jointype_const)
    table:'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当您将`PRIMARY KEY`或`UNIQUE`索引的所有部分与常量值进行比较时，将使用[`const`](explain-output.html#jointype_const)。在以下查询中，*`tbl_name`*可以作为[`const`](explain-output.html#jointype_const)表使用：
- en: '[PRE0]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[`eq_ref`](explain-output.html#jointype_eq_ref)'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`eq_ref`](explain-output.html#jointype_eq_ref)'
- en: One row is read from this table for each combination of rows from the previous
    tables. Other than the [`system`](explain-output.html#jointype_system) and [`const`](explain-output.html#jointype_const)
    types, this is the best possible join type. It is used when all parts of an index
    are used by the join and the index is a `PRIMARY KEY` or `UNIQUE NOT NULL` index.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于前面表的每一行组合，从该表中读取一行。除了[`system`](explain-output.html#jointype_system)和[`const`](explain-output.html#jointype_const)类型之外，这是最佳的连接类型。当连接使用索引的所有部分并且索引是`PRIMARY
    KEY`或`UNIQUE NOT NULL`索引时使用。
- en: '[`eq_ref`](explain-output.html#jointype_eq_ref) can be used for indexed columns
    that are compared using the `=` operator. The comparison value can be a constant
    or an expression that uses columns from tables that are read before this table.
    In the following examples, MySQL can use an [`eq_ref`](explain-output.html#jointype_eq_ref)
    join to process *`ref_table`*:'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以用于使用`=`运算符比较的索引列。比较值可以是常量或使用在此表之前读取的表的列的表达式。在以下示例中，MySQL可以使用[`eq_ref`](explain-output.html#jointype_eq_ref)连接来处理*`ref_table`*：
- en: '[PRE1]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[`ref`](explain-output.html#jointype_ref)'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`ref`](explain-output.html#jointype_ref)'
- en: All rows with matching index values are read from this table for each combination
    of rows from the previous tables. [`ref`](explain-output.html#jointype_ref) is
    used if the join uses only a leftmost prefix of the key or if the key is not a
    `PRIMARY KEY` or `UNIQUE` index (in other words, if the join cannot select a single
    row based on the key value). If the key that is used matches only a few rows,
    this is a good join type.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于前面表的每一行组合，从该表中读取具有匹配索引值的所有行。如果连接仅使用键的最左前缀或键不是`PRIMARY KEY`或`UNIQUE`索引（换句话说，如果连接不能基于键值选择单行），则使用[`ref`](explain-output.html#jointype_ref)。如果使用的键仅匹配少数行，则这是一种很好的连接类型。
- en: '[`ref`](explain-output.html#jointype_ref) can be used for indexed columns that
    are compared using the `=` or `<=>` operator. In the following examples, MySQL
    can use a [`ref`](explain-output.html#jointype_ref) join to process *`ref_table`*:'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以用于使用`=`或`<=>`运算符比较的索引列。在以下示例中，MySQL可以使用[`ref`](explain-output.html#jointype_ref)连接来处理*`ref_table`*：
- en: '[PRE2]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[`fulltext`](explain-output.html#jointype_fulltext)'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`fulltext`](explain-output.html#jointype_fulltext)'
- en: The join is performed using a `FULLTEXT` index.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`FULLTEXT`索引执行连接。
- en: '[`ref_or_null`](explain-output.html#jointype_ref_or_null)'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`ref_or_null`](explain-output.html#jointype_ref_or_null)'
- en: 'This join type is like [`ref`](explain-output.html#jointype_ref), but with
    the addition that MySQL does an extra search for rows that contain `NULL` values.
    This join type optimization is used most often in resolving subqueries. In the
    following examples, MySQL can use a [`ref_or_null`](explain-output.html#jointype_ref_or_null)
    join to process *`ref_table`*:'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种连接类型类似于[`ref`](explain-output.html#jointype_ref)，但额外搜索包含`NULL`值的行。这种连接类型优化通常在解析子查询时最常使用。在以下示例中，MySQL可以使用[`ref_or_null`](explain-output.html#jointype_ref_or_null)连接来处理*`ref_table`*：
- en: '[PRE3]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: See [Section 10.2.1.15, “IS NULL Optimization”](is-null-optimization.html "10.2.1.15 IS
    NULL Optimization").
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请参阅[第10.2.1.15节，“IS NULL Optimization”](is-null-optimization.html "10.2.1.15 IS
    NULL Optimization")。
- en: '[`index_merge`](explain-output.html#jointype_index_merge)'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`index_merge`](explain-output.html#jointype_index_merge)'
- en: This join type indicates that the Index Merge optimization is used. In this
    case, the `key` column in the output row contains a list of indexes used, and
    `key_len` contains a list of the longest key parts for the indexes used. For more
    information, see [Section 10.2.1.3, “Index Merge Optimization”](index-merge-optimization.html
    "10.2.1.3 Index Merge Optimization").
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此连接类型指示使用了索引合并优化。在这种情况下，输出行中的`key`列包含使用的索引列表，`key_len`包含用于索引的最长键部分列表。有关更多信息，请参见[第10.2.1.3节，“索引合并优化”](index-merge-optimization.html
    "10.2.1.3 索引合并优化")。
- en: '[`unique_subquery`](explain-output.html#jointype_unique_subquery)'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`unique_subquery`](explain-output.html#jointype_unique_subquery)'
- en: 'This type replaces [`eq_ref`](explain-output.html#jointype_eq_ref) for some
    `IN` subqueries of the following form:'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于以下形式的一些`IN`子查询，此类型替换了[`eq_ref`](explain-output.html#jointype_eq_ref)：
- en: '[PRE4]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[`unique_subquery`](explain-output.html#jointype_unique_subquery) is just an
    index lookup function that replaces the subquery completely for better efficiency.'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[`unique_subquery`](explain-output.html#jointype_unique_subquery)只是一个索引查找函数，完全替换子查询以提高效率。'
- en: '[`index_subquery`](explain-output.html#jointype_index_subquery)'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`index_subquery`](explain-output.html#jointype_index_subquery)'
- en: 'This join type is similar to [`unique_subquery`](explain-output.html#jointype_unique_subquery).
    It replaces `IN` subqueries, but it works for nonunique indexes in subqueries
    of the following form:'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此连接类型类似于[`unique_subquery`](explain-output.html#jointype_unique_subquery)。它替换了`IN`子查询，但适用于以下形式的非唯一索引子查询：
- en: '[PRE5]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[`range`](explain-output.html#jointype_range)'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`range`](explain-output.html#jointype_range)'
- en: Only rows that are in a given range are retrieved, using an index to select
    the rows. The `key` column in the output row indicates which index is used. The
    `key_len` contains the longest key part that was used. The `ref` column is `NULL`
    for this type.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 仅检索给定范围内的行，使用索引选择行。输出行中的`key`列指示使用的索引。`key_len`包含使用的最长键部分。对于这种类型，`ref`列为`NULL`。
- en: '[`range`](explain-output.html#jointype_range) can be used when a key column
    is compared to a constant using any of the [`=`](comparison-operators.html#operator_equal),
    [`<>`](comparison-operators.html#operator_not-equal), [`>`](comparison-operators.html#operator_greater-than),
    [`>=`](comparison-operators.html#operator_greater-than-or-equal), [`<`](comparison-operators.html#operator_less-than),
    [`<=`](comparison-operators.html#operator_less-than-or-equal), [`IS NULL`](comparison-operators.html#operator_is-null),
    [`<=>`](comparison-operators.html#operator_equal-to), [`BETWEEN`](comparison-operators.html#operator_between),
    [`LIKE`](string-comparison-functions.html#operator_like), or [`IN()`](comparison-operators.html#operator_in)
    operators:'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当使用任何[`=`](comparison-operators.html#operator_equal)、[`<>`](comparison-operators.html#operator_not-equal)、[`>`](comparison-operators.html#operator_greater-than)、[`>=`](comparison-operators.html#operator_greater-than-or-equal)、[`<`](comparison-operators.html#operator_less-than)、[`<=`](comparison-operators.html#operator_less-than-or-equal)、[`IS
    NULL`](comparison-operators.html#operator_is-null)、[`<=>`](comparison-operators.html#operator_equal-to)、[`BETWEEN`](comparison-operators.html#operator_between)、[`LIKE`](string-comparison-functions.html#operator_like)或[`IN()`](comparison-operators.html#operator_in)运算符将键列与常量进行比较时，可以使用[`range`](explain-output.html#jointype_range)：
- en: '[PRE6]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[`index`](explain-output.html#jointype_index)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`index`](explain-output.html#jointype_index)'
- en: 'The `index` join type is the same as [`ALL`](explain-output.html#jointype_all),
    except that the index tree is scanned. This occurs two ways:'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`index`连接类型与[`ALL`](explain-output.html#jointype_all)相同，只是扫描索引树。有两种情况：'
- en: If the index is a covering index for the queries and can be used to satisfy
    all data required from the table, only the index tree is scanned. In this case,
    the `Extra` column says `Using index`. An index-only scan usually is faster than
    [`ALL`](explain-output.html#jointype_all) because the size of the index usually
    is smaller than the table data.
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果索引是查询的覆盖索引，并且可以用于满足表中所需的所有数据，那么只扫描索引树。在这种情况下，`Extra`列显示`Using index`。索引扫描通常比[`ALL`](explain-output.html#jointype_all)更快，因为索引的大小通常比表数据小。
- en: A full table scan is performed using reads from the index to look up data rows
    in index order. `Uses index` does not appear in the `Extra` column.
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行全表扫描，使用从索引读取的数据行按索引顺序查找数据行。`Extra`列中不会出现`Uses index`。
- en: MySQL can use this join type when the query uses only columns that are part
    of a single index.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当查询仅使用属于单个索引的列时，MySQL可以使用此连接类型。
- en: '[`ALL`](explain-output.html#jointype_all)'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`ALL`](explain-output.html#jointype_all)'
- en: A full table scan is done for each combination of rows from the previous tables.
    This is normally not good if the table is the first table not marked [`const`](explain-output.html#jointype_const),
    and usually *very* bad in all other cases. Normally, you can avoid [`ALL`](explain-output.html#jointype_all)
    by adding indexes that enable row retrieval from the table based on constant values
    or column values from earlier tables.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于前面表的每个行组合，都会进行完整表扫描。如果表不是第一个未标记为 [`const`](explain-output.html#jointype_const)
    的表，通常情况下这是不好的，而在其他情况下通常是*非常*糟糕的。通常，您可以通过添加索引来避免 [`ALL`](explain-output.html#jointype_all)，这些索引使得可以基于常量值或来自早期表的列值检索行。
- en: EXPLAIN Extra Information
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: EXPLAIN 额外信息
- en: The `Extra` column of [`EXPLAIN`](explain.html "15.8.2 EXPLAIN Statement") output
    contains additional information about how MySQL resolves the query. The following
    list explains the values that can appear in this column. Each item also indicates
    for JSON-formatted output which property displays the `Extra` value. For some
    of these, there is a specific property. The others display as the text of the
    `message` property.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[`EXPLAIN`](explain.html "15.8.2 EXPLAIN Statement") 输出的 `Extra` 列包含关于 MySQL
    如何解析查询的附加信息。以下列表解释了此列中可能出现的值。每个项目还指示了 JSON 格式输出中显示 `Extra` 值的属性。对于其中一些，有一个特定的属性。其他显示为
    `message` 属性的文本。'
- en: If you want to make your queries as fast as possible, look out for `Extra` column
    values of `Using filesort` and `Using temporary`, or, in JSON-formatted `EXPLAIN`
    output, for `using_filesort` and `using_temporary_table` properties equal to `true`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要使查询尽可能快速，请注意 `Extra` 列值为 `Using filesort` 和 `Using temporary`，或者在 JSON 格式的
    `EXPLAIN` 输出中，`using_filesort` 和 `using_temporary_table` 属性等于 `true`。
- en: '`Backward index scan` (JSON: `backward_index_scan`)'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Backward index scan` (JSON：`backward_index_scan`)'
- en: The optimizer is able to use a descending index on an `InnoDB` table. Shown
    together with `Using index`. For more information, see [Section 10.3.13, “Descending
    Indexes”](descending-indexes.html "10.3.13 Descending Indexes").
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 优化器能够在 `InnoDB` 表上使用降序索引。与 `Using index` 一起显示。有关更多信息，请参见 [Section 10.3.13, “Descending
    Indexes”](descending-indexes.html "10.3.13 Descending Indexes")。
- en: '`Child of ''*`table`*'' pushed join@1` (JSON: `message` text)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Child of ''*`table`*'' pushed join@1` (JSON：`message` 文本)'
- en: This table is referenced as the child of *`table`* in a join that can be pushed
    down to the NDB kernel. Applies only in NDB Cluster, when pushed-down joins are
    enabled. See the description of the [`ndb_join_pushdown`](mysql-cluster-options-variables.html#sysvar_ndb_join_pushdown)
    server system variable for more information and examples.
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此表被引用为 *`table`* 的子表，可以将其推送到 NDB 内核中进行连接。仅适用于 NDB Cluster，在启用推送连接时。有关更多信息和示例，请参见
    [`ndb_join_pushdown`](mysql-cluster-options-variables.html#sysvar_ndb_join_pushdown)
    服务器系统变量的描述。
- en: '`const row not found` (JSON property: `const_row_not_found`)'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const row not found` (JSON 属性：`const_row_not_found`)'
- en: For a query such as `SELECT ... FROM *`tbl_name`*`, the table was empty.
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于诸如 `SELECT ... FROM *`tbl_name`*` 的查询，表是空的。
- en: '`Deleting all rows` (JSON property: `message`)'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Deleting all rows` (JSON 属性：`message`)'
- en: For [`DELETE`](delete.html "15.2.2 DELETE Statement"), some storage engines
    (such as [`MyISAM`](myisam-storage-engine.html "18.2 The MyISAM Storage Engine"))
    support a handler method that removes all table rows in a simple and fast way.
    This `Extra` value is displayed if the engine uses this optimization.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于 [`DELETE`](delete.html "15.2.2 DELETE Statement")，一些存储引擎（例如 [`MyISAM`](myisam-storage-engine.html
    "18.2 The MyISAM Storage Engine")）支持一种移除所有表行的处理程序方法，以简单快速的方式执行。如果引擎使用此优化，则显示此
    `Extra` 值。
- en: '`Distinct` (JSON property: `distinct`)'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Distinct` (JSON 属性：`distinct`)'
- en: MySQL is looking for distinct values, so it stops searching for more rows for
    the current row combination after it has found the first matching row.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: MySQL 正在寻找不同的值，因此在找到第一个匹配行后，停止为当前行组合搜索更多行。
- en: '`FirstMatch(*`tbl_name`*)` (JSON property: `first_match`)'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FirstMatch(*`tbl_name`*)` (JSON 属性：`first_match`)'
- en: The semijoin FirstMatch join shortcutting strategy is used for *`tbl_name`*.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 半连接 FirstMatch 加入快捷策略用于 *`tbl_name`*。
- en: '`Full scan on NULL key` (JSON property: `message`)'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Full scan on NULL key` (JSON 属性：`message`)'
- en: This occurs for subquery optimization as a fallback strategy when the optimizer
    cannot use an index-lookup access method.
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当优化器无法使用索引查找访问方法时，对于子查询优化，这是一个后备策略。
- en: '`Impossible HAVING` (JSON property: `message`)'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Impossible HAVING` (JSON 属性：`message`)'
- en: The `HAVING` clause is always false and cannot select any rows.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`HAVING` 子句始终为假，无法选择任何行。'
- en: '`Impossible WHERE` (JSON property: `message`)'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Impossible WHERE` (JSON 属性：`message`)'
- en: The `WHERE` clause is always false and cannot select any rows.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`WHERE`子句始终为false，无法选择任何行。'
- en: '`Impossible WHERE noticed after reading const tables` (JSON property: `message`)'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`在读取const表后注意到不可能的WHERE`（JSON属性：`message`）。'
- en: MySQL has read all [`const`](explain-output.html#jointype_const) (and [`system`](explain-output.html#jointype_system))
    tables and notice that the `WHERE` clause is always false.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: MySQL已读取所有[`const`](explain-output.html#jointype_const)（和[`system`](explain-output.html#jointype_system)）表，并注意到`WHERE`子句始终为false。
- en: '`LooseScan(*`m`*..*`n`*)` (JSON property: `message`)'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LooseScan(*`m`*..*`n`*)`（JSON属性：`message`）。'
- en: The semijoin LooseScan strategy is used. *`m`* and *`n`* are key part numbers.
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用半连接LooseScan策略。*`m`*和*`n`*是关键部分号。
- en: '`No matching min/max row` (JSON property: `message`)'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`没有匹配的最小/最大行`（JSON属性：`message`）。'
- en: No row satisfies the condition for a query such as `SELECT MIN(...) FROM ...
    WHERE *`condition`*`.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 没有任何行满足查询条件，比如`SELECT MIN(...) FROM ... WHERE *`condition`*`。
- en: '`no matching row in const table` (JSON property: `message`)'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const`表中没有匹配的行（JSON属性：`message`）。'
- en: For a query with a join, there was an empty table or a table with no rows satisfying
    a unique index condition.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于具有连接的查询，存在一个空表或一个表不满足唯一索引条件的行。
- en: '`No matching rows after partition pruning` (JSON property: `message`)'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`分区修剪后没有匹配的行`（JSON属性：`message`）。'
- en: For [`DELETE`](delete.html "15.2.2 DELETE Statement") or [`UPDATE`](update.html
    "15.2.17 UPDATE Statement"), the optimizer found nothing to delete or update after
    partition pruning. It is similar in meaning to `Impossible WHERE` for [`SELECT`](select.html
    "15.2.13 SELECT Statement") statements.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于[`DELETE`](delete.html "15.2.2 DELETE Statement")或[`UPDATE`](update.html "15.2.17 UPDATE
    Statement")语句，在分区修剪后，优化器发现没有要删除或更新的内容。这在某种程度上类似于[`SELECT`](select.html "15.2.13 SELECT
    Statement")语句的`Impossible WHERE`。
- en: '`No tables used` (JSON property: `message`)'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`未使用任何表`（JSON属性：`message`）。'
- en: The query has no `FROM` clause, or has a `FROM DUAL` clause.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查询没有`FROM`子句，或者有一个`FROM DUAL`子句。
- en: For [`INSERT`](insert.html "15.2.7 INSERT Statement") or [`REPLACE`](replace.html
    "15.2.12 REPLACE Statement") statements, [`EXPLAIN`](explain.html "15.8.2 EXPLAIN
    Statement") displays this value when there is no [`SELECT`](select.html "15.2.13 SELECT
    Statement") part. For example, it appears for `EXPLAIN INSERT INTO t VALUES(10)`
    because that is equivalent to `EXPLAIN INSERT INTO t SELECT 10 FROM DUAL`.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于[`INSERT`](insert.html "15.2.7 INSERT Statement")或[`REPLACE`](replace.html
    "15.2.12 REPLACE Statement")语句，当没有[`SELECT`](select.html "15.2.13 SELECT Statement")部分时，[`EXPLAIN`](explain.html
    "15.8.2 EXPLAIN Statement")显示此值。例如，对于`EXPLAIN INSERT INTO t VALUES(10)`，因为这等效于`EXPLAIN
    INSERT INTO t SELECT 10 FROM DUAL`。
- en: '`Not exists` (JSON property: `message`)'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`不存在`（JSON属性：`message`）。'
- en: 'MySQL was able to do a `LEFT JOIN` optimization on the query and does not examine
    more rows in this table for the previous row combination after it finds one row
    that matches the `LEFT JOIN` criteria. Here is an example of the type of query
    that can be optimized this way:'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: MySQL能够在查询上进行`LEFT JOIN`优化，并在找到符合`LEFT JOIN`条件的一行后，不再检查此表中的其他行组合。以下是可以通过这种方式优化的查询类型示例：
- en: '[PRE7]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Assume that `t2.id` is defined as `NOT NULL`. In this case, MySQL scans `t1`
    and looks up the rows in `t2` using the values of `t1.id`. If MySQL finds a matching
    row in `t2`, it knows that `t2.id` can never be `NULL`, and does not scan through
    the rest of the rows in `t2` that have the same `id` value. In other words, for
    each row in `t1`, MySQL needs to do only a single lookup in `t2`, regardless of
    how many rows actually match in `t2`.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设`t2.id`被定义为`NOT NULL`。在这种情况下，MySQL扫描`t1`并使用`t1.id`的值查找`t2`中的行。如果MySQL在`t2`中找到匹配的行，它知道`t2.id`永远不会是`NULL`，并且不会扫描具有相同`id`值的`t2`中的其他行。换句话说，对于`t1`中的每一行，MySQL只需要在`t2`中进行一次查找，而不管实际上有多少行与`t2`中的`id`值匹配。
- en: In MySQL 8.0.17 and later, this can also indicate that a `WHERE` condition of
    the form `NOT IN (*`subquery`*)` or `NOT EXISTS (*`subquery`*)` has been transformed
    internally into an antijoin. This removes the subquery and brings its tables into
    the plan for the topmost query, providing improved cost planning. By merging semijoins
    and antijoins, the optimizer can reorder tables in the execution plan more freely,
    in some cases resulting in a faster plan.
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在MySQL 8.0.17及更高版本中，这也可能表示形如`NOT IN (*`subquery`*)`或`NOT EXISTS (*`subquery`*)`的`WHERE`条件已在内部转换为反连接。这会删除子查询，并将其表合并到顶层查询的计划中，提供了更好的成本规划。通过合并半连接和反连接，优化器可以更自由地重新排列执行计划中的表，在某些情况下可以得到更快的计划。
- en: You can see when an antijoin transformation is performed for a given query by
    checking the `Message` column from `SHOW WARNINGS` following execution of `EXPLAIN`,
    or in the output of `EXPLAIN FORMAT=TREE`.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过在执行`EXPLAIN`后检查`SHOW WARNINGS`中的`Message`列，或在`EXPLAIN FORMAT=TREE`的输出中，可以看到给定查询执行时进行的反连接转换。
- en: Note
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: An antijoin is the complement of a semijoin `*`table_a`* JOIN *`table_b`* ON
    *`condition`*`. The antijoin returns all rows from *`table_a`* for which there
    is *no* row in *`table_b`* which matches *`condition`*.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 反连接是半连接`*`table_a`* JOIN *`table_b`* ON *`condition`*`的补集。反连接返回*`table_a`*中所有没有与*`table_b`*匹配*`condition`*的行。
- en: '`Plan isn''t ready yet` (JSON property: none)'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`计划尚未准备好`（JSON 属性：无）'
- en: This value occurs with [`EXPLAIN FOR CONNECTION`](explain-for-connection.html
    "10.8.4 Obtaining Execution Plan Information for a Named Connection") when the
    optimizer has not finished creating the execution plan for the statement executing
    in the named connection. If execution plan output comprises multiple lines, any
    or all of them could have this `Extra` value, depending on the progress of the
    optimizer in determining the full execution plan.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当优化器尚未完成为在命名连接中执行的语句创建执行计划时，会出现[`EXPLAIN FOR CONNECTION`](explain-for-connection.html
    "10.8.4 为命名连接获取执行计划信息")中的这个值。如果执行计划输出包含多行，则根据优化器在确定完整执行计划的进度而定，任何一行或所有行都可能具有这个`Extra`值。
- en: '`Range checked for each record (index map: *`N`*)` (JSON property: `message`)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Range checked for each record (index map: *`N`*)`（JSON 属性：`message`）'
- en: MySQL found no good index to use, but found that some of indexes might be used
    after column values from preceding tables are known. For each row combination
    in the preceding tables, MySQL checks whether it is possible to use a [`range`](explain-output.html#jointype_range)
    or [`index_merge`](explain-output.html#jointype_index_merge) access method to
    retrieve rows. This is not very fast, but is faster than performing a join with
    no index at all. The applicability criteria are as described in [Section 10.2.1.2,
    “Range Optimization”](range-optimization.html "10.2.1.2 Range Optimization"),
    and [Section 10.2.1.3, “Index Merge Optimization”](index-merge-optimization.html
    "10.2.1.3 Index Merge Optimization"), with the exception that all column values
    for the preceding table are known and considered to be constants.
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: MySQL 没有找到合适的索引可用，但发现在了解前面表的列值后，可能会使用一些索引。对于前面表中的每一行组合，MySQL 检查是否可以使用[`range`](explain-output.html#jointype_range)或[`index_merge`](explain-output.html#jointype_index_merge)访问方法来检索行。这并不是非常快速，但比完全没有索引的连接要快。适用条件如[第
    10.2.1.2 节，“范围优化”](range-optimization.html "10.2.1.2 范围优化")和[第 10.2.1.3 节，“索引合并优化”](index-merge-optimization.html
    "10.2.1.3 索引合并优化")中所述，唯一的例外是前面表的所有列值都已知且被视为常量。
- en: Indexes are numbered beginning with 1, in the same order as shown by [`SHOW
    INDEX`](show-index.html "15.7.7.22 SHOW INDEX Statement") for the table. The index
    map value *`N`* is a bitmask value that indicates which indexes are candidates.
    For example, a value of `0x19` (binary 11001) means that indexes 1, 4, and 5 are
    considered.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 索引从 1 开始编号，与表的[`SHOW INDEX`](show-index.html "15.7.7.22 SHOW INDEX 语句")显示的顺序相同。索引映射值*`N`*是一个位掩码值，指示哪些索引是候选索引。例如，值`0x19`（二进制
    11001）表示索引 1、4 和 5 被考虑。
- en: '`Recursive` (JSON property: `recursive`)'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Recursive`（JSON 属性：`recursive`）'
- en: This indicates that the row applies to the recursive [`SELECT`](select.html
    "15.2.13 SELECT Statement") part of a recursive common table expression. See [Section 15.2.20,
    “WITH (Common Table Expressions)”](with.html "15.2.20 WITH (Common Table Expressions)").
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这表示该行适用于递归[`SELECT`](select.html "15.2.13 SELECT 语句")的部分，即递归公共表达式。参见[第 15.2.20
    节，“WITH（公共表达式）”](with.html "15.2.20 WITH（公共表达式）")。
- en: '`Rematerialize` (JSON property: `rematerialize`)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rematerialize`（JSON 属性：`rematerialize`）'
- en: '`Rematerialize (X,...)` is displayed in the `EXPLAIN` row for table `T`, where
    `X` is any lateral derived table whose rematerialization is triggered when a new
    row of `T` is read. For example:'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在表`T`的`EXPLAIN`行中显示`Rematerialize (X,...)`，其中`X`是任何侧向派生表，当读取`T`的新行时触发其重新生成。例如：
- en: '[PRE8]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The content of the derived table is rematerialized to bring it up to date each
    time a new row of `t` is processed by the top query.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 派生表的内容在每次顶部查询处理新行时重新生成，以使其保持最新状态。
- en: '`Scanned *`N`* databases` (JSON property: `message`)'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`扫描了*`N`*个数据库`（JSON 属性：`message`）'
- en: This indicates how many directory scans the server performs when processing
    a query for `INFORMATION_SCHEMA` tables, as described in [Section 10.2.3, “Optimizing
    INFORMATION_SCHEMA Queries”](information-schema-optimization.html "10.2.3 Optimizing
    INFORMATION_SCHEMA Queries"). The value of *`N`* can be 0, 1, or `all`.
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这指示服务器在处理`INFORMATION_SCHEMA`表查询时执行多少目录扫描，如[Section 10.2.3, “Optimizing INFORMATION_SCHEMA
    Queries”](information-schema-optimization.html "10.2.3 Optimizing INFORMATION_SCHEMA
    Queries")中所述。*`N`*的值可以是0、1或`all`。
- en: '`Select tables optimized away` (JSON property: `message`)'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Select tables optimized away`（JSON 属性：`message`）'
- en: The optimizer determined 1) that at most one row should be returned, and 2)
    that to produce this row, a deterministic set of rows must be read. When the rows
    to be read can be read during the optimization phase (for example, by reading
    index rows), there is no need to read any tables during query execution.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 优化器确定了以下两点：1）最多只返回一行，2）为了产生这一行，必须读取一组确定性的行。当要读取的行可以在优化阶段读取时（例如，通过读取索引行），在查询执行期间就不需要读取任何表。
- en: The first condition is fulfilled when the query is implicitly grouped (contains
    an aggregate function but no `GROUP BY` clause). The second condition is fulfilled
    when one row lookup is performed per index used. The number of indexes read determines
    the number of rows to read.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当查询隐式分组（包含聚合函数但没有`GROUP BY`子句）时，第一个条件得到满足。当每个使用的索引执行一次行查找时，第二个条件得到满足。读取的索引数决定了要读取的行数。
- en: 'Consider the following implicitly grouped query:'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 考虑以下隐式分组查询：
- en: '[PRE9]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Suppose that `MIN(c1)` can be retrieved by reading one index row and `MIN(c2)`
    can be retrieved by reading one row from a different index. That is, for each
    column `c1` and `c2`, there exists an index where the column is the first column
    of the index. In this case, one row is returned, produced by reading two deterministic
    rows.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设通过读取一个索引行可以检索到`MIN(c1)`，通过从不同索引读取一行可以检索到`MIN(c2)`。也就是说，对于每个列`c1`和`c2`，存在一个索引，其中该列是索引的第一列。在这种情况下，通过读取两个确定性行生成一行返回。
- en: 'This `Extra` value does not occur if the rows to read are not deterministic.
    Consider this query:'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果要读取的行不是确定性的，则不会出现此`Extra`值。考虑以下查询：
- en: '[PRE10]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Suppose that `(c1, c2)` is a covering index. Using this index, all rows with
    `c1 <= 10` must be scanned to find the minimum `c2` value. By contrast, consider
    this query:'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设`(c1, c2)`是一个覆盖索引。使用此索引，必须扫描所有`c1 <= 10`的行以找到最小的`c2`值。相比之下，考虑以下查询：
- en: '[PRE11]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this case, the first index row with `c1 = 10` contains the minimum `c2` value.
    Only one row must be read to produce the returned row.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，具有`c1 = 10`的第一个索引行包含最小的`c2`值。只需读取一行即可生成返回的行。
- en: For storage engines that maintain an exact row count per table (such as `MyISAM`,
    but not `InnoDB`), this `Extra` value can occur for `COUNT(*)` queries for which
    the `WHERE` clause is missing or always true and there is no `GROUP BY` clause.
    (This is an instance of an implicitly grouped query where the storage engine influences
    whether a deterministic number of rows can be read.)
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于维护每个表的确切行数的存储引擎（例如`MyISAM`，但不包括`InnoDB`），对于缺少或始终为真的`WHERE`子句且没有`GROUP BY`子句的`COUNT(*)`查询，此`Extra`值可能出现。（这是存储引擎影响是否可以读取确定数量的行的隐式分组查询的一个实例。）
- en: '`Skip_open_table`, `Open_frm_only`, `Open_full_table` (JSON property: `message`)'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Skip_open_table`，`Open_frm_only`，`Open_full_table`（JSON 属性：`message`）'
- en: These values indicate file-opening optimizations that apply to queries for `INFORMATION_SCHEMA`
    tables.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些值指示适用于`INFORMATION_SCHEMA`表查询的文件打开优化。
- en: '`Skip_open_table`: Table files do not need to be opened. The information is
    already available from the data dictionary.'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Skip_open_table`：不需要打开表文件。信息已经从数据字典中获取。'
- en: '`Open_frm_only`: Only the data dictionary need be read for table information.'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Open_frm_only`：只需读取数据字典以获取表信息。'
- en: '`Open_full_table`: Unoptimized information lookup. Table information must be
    read from the data dictionary and by reading table files.'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Open_full_table`：未优化的信息查找。必须从数据字典中读取表信息，并通过读取表文件。'
- en: '`Start temporary`, `End temporary` (JSON property: `message`)'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Start temporary`，`End temporary`（JSON 属性：`message`）'
- en: This indicates temporary table use for the semijoin Duplicate Weedout strategy.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这表明临时表用于半连接去重策略。
- en: '`unique row not found` (JSON property: `message`)'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unique row not found`（JSON 属性：`message`）'
- en: For a query such as `SELECT ... FROM *`tbl_name`*`, no rows satisfy the condition
    for a `UNIQUE` index or `PRIMARY KEY` on the table.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于诸如`SELECT ... FROM *tbl_name*`的查询，没有行满足表上的`UNIQUE`索引或`PRIMARY KEY`的条件。
- en: '`Using filesort` (JSON property: `using_filesort`)'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Using filesort`（JSON 属性：`using_filesort`）'
- en: MySQL must do an extra pass to find out how to retrieve the rows in sorted order.
    The sort is done by going through all rows according to the join type and storing
    the sort key and pointer to the row for all rows that match the `WHERE` clause.
    The keys then are sorted and the rows are retrieved in sorted order. See [Section 10.2.1.16,
    “ORDER BY Optimization”](order-by-optimization.html "10.2.1.16 ORDER BY Optimization").
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: MySQL 必须进行额外的传递来找出如何按排序顺序检索行。排序是通过根据连接类型遍历所有行并为匹配`WHERE`子句的所有行存储排序键和指向行的指针来完成的。然后对键进行排序，并按排序顺序检索行。请参阅[第
    10.2.1.16 节，“ORDER BY 优化”](order-by-optimization.html "10.2.1.16 ORDER BY Optimization")。
- en: '`Using index` (JSON property: `using_index`)'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Using index`（JSON 属性：`using_index`）'
- en: The column information is retrieved from the table using only information in
    the index tree without having to do an additional seek to read the actual row.
    This strategy can be used when the query uses only columns that are part of a
    single index.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 仅使用索引树中的信息从表中检索列信息，而无需进行额外的查找以读取实际行。当查询仅使用单个索引的列时，可以使用此策略。
- en: For `InnoDB` tables that have a user-defined clustered index, that index can
    be used even when `Using index` is absent from the `Extra` column. This is the
    case if `type` is [`index`](explain-output.html#jointype_index) and `key` is `PRIMARY`.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于具有用户定义的聚簇索引的`InnoDB`表，即使`Extra`列中缺少`Using index`，该索引也可以使用。如果`type`是[`index`](explain-output.html#jointype_index)，并且`key`是`PRIMARY`，则是这种情况。
- en: Information about any covering indexes used is shown for `EXPLAIN FORMAT=TRADITIONAL`
    and `EXPLAIN FORMAT=JSON`. Beginning with MySQL 8.0.27, it is also shown for `EXPLAIN
    FORMAT=TREE`.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有关使用的任何覆盖索引的信息显示在`EXPLAIN FORMAT=TRADITIONAL`和`EXPLAIN FORMAT=JSON`中。从 MySQL
    8.0.27 开始，也会显示在`EXPLAIN FORMAT=TREE`中。
- en: '`Using index condition` (JSON property: `using_index_condition`)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Using index condition`（JSON 属性：`using_index_condition`）'
- en: Tables are read by accessing index tuples and testing them first to determine
    whether to read full table rows. In this way, index information is used to defer
    (“push down”) reading full table rows unless it is necessary. See [Section 10.2.1.6,
    “Index Condition Pushdown Optimization”](index-condition-pushdown-optimization.html
    "10.2.1.6 Index Condition Pushdown Optimization").
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过访问索引元组并首先测试它们来读取表。通过这种方式，索引信息用于推迟（“推下去”）读取完整的表行，除非有必要。请参阅[第 10.2.1.6 节，“索引条件推迟优化”](index-condition-pushdown-optimization.html
    "10.2.1.6 Index Condition Pushdown Optimization")。
- en: '`Using index for group-by` (JSON property: `using_index_for_group_by`)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Using index for group-by`（JSON 属性：`using_index_for_group_by`）'
- en: Similar to the `Using index` table access method, `Using index for group-by`
    indicates that MySQL found an index that can be used to retrieve all columns of
    a `GROUP BY` or `DISTINCT` query without any extra disk access to the actual table.
    Additionally, the index is used in the most efficient way so that for each group,
    only a few index entries are read. For details, see [Section 10.2.1.17, “GROUP
    BY Optimization”](group-by-optimization.html "10.2.1.17 GROUP BY Optimization").
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类似于`Using index`表访问方法，`Using index for group-by`表示 MySQL 找到了一个可以用于检索`GROUP BY`或`DISTINCT`查询的所有列的索引，而无需额外访问实际表的磁盘。此外，索引以最有效的方式使用，以便对于每个组，只读取了少量索引条目。有关详细信息，请参阅[第
    10.2.1.17 节，“GROUP BY 优化”](group-by-optimization.html "10.2.1.17 GROUP BY Optimization")。
- en: '`Using index for skip scan` (JSON property: `using_index_for_skip_scan`)'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Using index for skip scan`（JSON 属性：`using_index_for_skip_scan`)'
- en: Indicates that the Skip Scan access method is used. See [Skip Scan Range Access
    Method](range-optimization.html#range-access-skip-scan "Skip Scan Range Access
    Method").
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表示使用了 Skip Scan 访问方法。请参阅[Skip Scan 范围访问方法](range-optimization.html#range-access-skip-scan
    "Skip Scan Range Access Method")。
- en: '`Using join buffer (Block Nested Loop)`, `Using join buffer (Batched Key Access)`,
    `Using join buffer (hash join)` (JSON property: `using_join_buffer`)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Using join buffer (Block Nested Loop)`，`Using join buffer (Batched Key Access)`，`Using
    join buffer (hash join)`（JSON 属性：`using_join_buffer`）'
- en: Tables from earlier joins are read in portions into the join buffer, and then
    their rows are used from the buffer to perform the join with the current table.
    `(Block Nested Loop)` indicates use of the Block Nested-Loop algorithm, `(Batched
    Key Access)` indicates use of the Batched Key Access algorithm, and `(hash join)`
    indicates use of a hash join. That is, the keys from the table on the preceding
    line of the [`EXPLAIN`](explain.html "15.8.2 EXPLAIN Statement") output are buffered,
    and the matching rows are fetched in batches from the table represented by the
    line in which `Using join buffer` appears.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 早期连接的表被分段读入连接缓冲区，然后它们的行从缓冲区中使用来与当前表进行连接。`(Block Nested Loop)`表示使用块嵌套循环算法，`(Batched
    Key Access)`表示使用批量键访问算法，`(hash join)`表示使用哈希连接。也就是说，前一行[`EXPLAIN`](explain.html
    "15.8.2 EXPLAIN Statement")输出中的表的键被缓冲，匹配的行从出现`Using join buffer`的行所代表的表中批量获取。
- en: In JSON-formatted output, the value of `using_join_buffer` is always one of
    `Block Nested Loop`, `Batched Key Access`, or `hash join`.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 JSON 格式输出中，`using_join_buffer`的值始终是`Block Nested Loop`、`Batched Key Access`或`hash
    join`之一。
- en: Hash joins are available beginning with MySQL 8.0.18; the Block Nested-Loop
    algorithm is not used in MySQL 8.0.20 or later MySQL releases. For more information
    about these optimizations, see [Section 10.2.1.4, “Hash Join Optimization”](hash-joins.html
    "10.2.1.4 Hash Join Optimization"), and [Block Nested-Loop Join Algorithm](nested-loop-joins.html#block-nested-loop-join-algorithm
    "Block Nested-Loop Join Algorithm").
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: MySQL 8.0.18 开始提供哈希连接；MySQL 8.0.20 或更高版本的 MySQL 不使用块嵌套循环算法。有关这些优化的更多信息，请参见[第
    10.2.1.4 节，“哈希连接优化”](hash-joins.html "10.2.1.4 Hash Join Optimization")和[块嵌套循环连接算法](nested-loop-joins.html#block-nested-loop-join-algorithm
    "Block Nested-Loop Join Algorithm")。
- en: See [Batched Key Access Joins](bnl-bka-optimization.html#bka-optimization "Batched
    Key Access Joins"), for information about the Batched Key Access algorithm.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有关批量键访问算法的信息，请参见[批量键访问连接](bnl-bka-optimization.html#bka-optimization "Batched
    Key Access Joins")。
- en: '`Using MRR` (JSON property: `message`)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Using MRR`（JSON 属性：`message`）'
- en: Tables are read using the Multi-Range Read optimization strategy. See [Section 10.2.1.11,
    “Multi-Range Read Optimization”](mrr-optimization.html "10.2.1.11 Multi-Range
    Read Optimization").
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表使用多范围读取优化策略进行读取。请参见[第 10.2.1.11 节，“多范围读取优化”](mrr-optimization.html "10.2.1.11 Multi-Range
    Read Optimization")。
- en: '`Using sort_union(...)`, `Using union(...)`, `Using intersect(...)` (JSON property:
    `message`)'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Using sort_union(...)`，`Using union(...)`，`Using intersect(...)`（JSON 属性：`message`）'
- en: These indicate the particular algorithm showing how index scans are merged for
    the [`index_merge`](explain-output.html#jointype_index_merge) join type. See [Section 10.2.1.3,
    “Index Merge Optimization”](index-merge-optimization.html "10.2.1.3 Index Merge
    Optimization").
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些指示了特定算法，显示了如何为[`index_merge`](explain-output.html#jointype_index_merge)连接类型合并索引扫描。请参见[第
    10.2.1.3 节，“索引合并优化”](index-merge-optimization.html "10.2.1.3 Index Merge Optimization")。
- en: '`Using temporary` (JSON property: `using_temporary_table`)'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Using temporary`（JSON 属性：`using_temporary_table`）'
- en: To resolve the query, MySQL needs to create a temporary table to hold the result.
    This typically happens if the query contains `GROUP BY` and `ORDER BY` clauses
    that list columns differently.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要解决查询，MySQL 需要创建一个临时表来保存结果。如果查询包含不同列的`GROUP BY`和`ORDER BY`子句，通常会发生这种情况。
- en: '`Using where` (JSON property: `attached_condition`)'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Using where`（JSON 属性：`attached_condition`）'
- en: A `WHERE` clause is used to restrict which rows to match against the next table
    or send to the client. Unless you specifically intend to fetch or examine all
    rows from the table, you may have something wrong in your query if the `Extra`
    value is not `Using where` and the table join type is [`ALL`](explain-output.html#jointype_all)
    or [`index`](explain-output.html#jointype_index).
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`WHERE`子句用于限制要与下一个表匹配或发送到客户端的行。除非您明确打算从表中获取或检查所有行，否则如果`Extra`值不是`Using where`且表连接类型为[`ALL`](explain-output.html#jointype_all)或[`index`](explain-output.html#jointype_index)，则查询可能存在问题。'
- en: '`Using where` has no direct counterpart in JSON-formatted output; the `attached_condition`
    property contains any `WHERE` condition used.'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Using where`在 JSON 格式输出中没有直接对应项；`attached_condition`属性包含使用的任何`WHERE`条件。'
- en: '`Using where with pushed condition` (JSON property: `message`)'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Using where with pushed condition`（JSON 属性：`message`）'
- en: This item applies to [`NDB`](mysql-cluster.html "Chapter 25 MySQL NDB Cluster
    8.0") tables *only*. It means that NDB Cluster is using the Condition Pushdown
    optimization to improve the efficiency of a direct comparison between a nonindexed
    column and a constant. In such cases, the condition is “pushed down” to the cluster's
    data nodes and is evaluated on all data nodes simultaneously. This eliminates
    the need to send nonmatching rows over the network, and can speed up such queries
    by a factor of 5 to 10 times over cases where Condition Pushdown could be but
    is not used. For more information, see [Section 10.2.1.5, “Engine Condition Pushdown
    Optimization”](engine-condition-pushdown-optimization.html "10.2.1.5 Engine Condition
    Pushdown Optimization").
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此项仅适用于[`NDB`](mysql-cluster.html "Chapter 25 MySQL NDB Cluster 8.0")表。这意味着NDB
    Cluster正在使用条件下推优化来提高非索引列和常量之间直接比较的效率。在这种情况下，条件被“推送”到集群的数据节点，并同时在所有数据节点上进行评估。这消除了在网络上传送不匹配的行的需要，并且可以将这类查询的速度提高5到10倍，相对于可能但未使用条件下推的情况。有关更多信息，请参见[Section 10.2.1.5,
    “Engine Condition Pushdown Optimization”](engine-condition-pushdown-optimization.html
    "10.2.1.5 Engine Condition Pushdown Optimization")。
- en: '`Zero limit` (JSON property: `message`)'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Zero limit`（JSON属性：`message`）'
- en: The query had a `LIMIT 0` clause and cannot select any rows.
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查询有一个`LIMIT 0`子句，无法选择任何行。
- en: EXPLAIN Output Interpretation
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解释输出解释
- en: You can get a good indication of how good a join is by taking the product of
    the values in the `rows` column of the [`EXPLAIN`](explain.html "15.8.2 EXPLAIN
    Statement") output. This should tell you roughly how many rows MySQL must examine
    to execute the query. If you restrict queries with the [`max_join_size`](server-system-variables.html#sysvar_max_join_size)
    system variable, this row product also is used to determine which multiple-table
    [`SELECT`](select.html "15.2.13 SELECT Statement") statements to execute and which
    to abort. See [Section 7.1.1, “Configuring the Server”](server-configuration.html
    "7.1.1 Configuring the Server").
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将[`EXPLAIN`](explain.html "15.8.2 EXPLAIN Statement")输出中`rows`列中的值相乘，您可以很好地了解连接的好坏。这应该大致告诉您MySQL必须检查多少行才能执行查询。如果使用[`max_join_size`](server-system-variables.html#sysvar_max_join_size)系统变量限制查询，这个行乘积也用于确定要执行哪些多表[`SELECT`](select.html
    "15.2.13 SELECT Statement")语句以及要中止哪些。请参见[Section 7.1.1, “Configuring the Server”](server-configuration.html
    "7.1.1 Configuring the Server")。
- en: The following example shows how a multiple-table join can be optimized progressively
    based on the information provided by [`EXPLAIN`](explain.html "15.8.2 EXPLAIN
    Statement").
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何根据[`EXPLAIN`](explain.html "15.8.2 EXPLAIN Statement")提供的信息逐步优化多表连接。
- en: 'Suppose that you have the [`SELECT`](select.html "15.2.13 SELECT Statement")
    statement shown here and that you plan to examine it using [`EXPLAIN`](explain.html
    "15.8.2 EXPLAIN Statement"):'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有以下所示的[`SELECT`](select.html "15.2.13 SELECT Statement")语句，并计划使用[`EXPLAIN`](explain.html
    "15.8.2 EXPLAIN Statement")来检查它：
- en: '[PRE12]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For this example, make the following assumptions:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此示例，请做出以下假设：
- en: The columns being compared have been declared as follows.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要比较的列已声明如下。
- en: '| Table | Column | Data Type |'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 表 | 列 | 数据类型 |'
- en: '| `tt` | `ActualPC` | `CHAR(10)` |'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `tt` | `ActualPC` | `CHAR(10)` |'
- en: '| `tt` | `AssignedPC` | `CHAR(10)` |'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `tt` | `AssignedPC` | `CHAR(10)` |'
- en: '| `tt` | `ClientID` | `CHAR(10)` |'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `tt` | `ClientID` | `CHAR(10)` |'
- en: '| `et` | `EMPLOYID` | `CHAR(15)` |'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `et` | `EMPLOYID` | `CHAR(15)` |'
- en: '| `do` | `CUSTNMBR` | `CHAR(15)` |'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `do` | `CUSTNMBR` | `CHAR(15)` |'
- en: The tables have the following indexes.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表具有以下索引。
- en: '| Table | Index |'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 表 | 索引 |'
- en: '| `tt` | `ActualPC` |'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `tt` | `ActualPC` |'
- en: '| `tt` | `AssignedPC` |'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `tt` | `AssignedPC` |'
- en: '| `tt` | `ClientID` |'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `tt` | `ClientID` |'
- en: '| `et` | `EMPLOYID` (primary key) |'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `et` | `EMPLOYID`（主键） |'
- en: '| `do` | `CUSTNMBR` (primary key) |'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `do` | `CUSTNMBR`（主键） |'
- en: The `tt.ActualPC` values are not evenly distributed.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tt.ActualPC`的值分布不均匀。'
- en: 'Initially, before any optimizations have been performed, the [`EXPLAIN`](explain.html
    "15.8.2 EXPLAIN Statement") statement produces the following information:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，在执行任何优化之前，[`EXPLAIN`](explain.html "15.8.2 EXPLAIN Statement")语句产生以下信息：
- en: '[PRE13]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Because `type` is [`ALL`](explain-output.html#jointype_all) for each table,
    this output indicates that MySQL is generating a Cartesian product of all the
    tables; that is, every combination of rows. This takes quite a long time, because
    the product of the number of rows in each table must be examined. For the case
    at hand, this product is 74 × 2135 × 74 × 3872 = 45,268,558,720 rows. If the tables
    were bigger, you can only imagine how long it would take.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个表的 `type` 都是 [`ALL`](explain-output.html#jointype_all)，这个输出表明 MySQL 正在生成所有表的笛卡尔积；也就是说，每一行的组合都要被检查。这需要很长时间，因为必须检查每个表中行数的乘积。对于这个案例，这个乘积是
    74 × 2135 × 74 × 3872 = 45,268,558,720 行。如果表更大，你可以想象需要多长时间。
- en: One problem here is that MySQL can use indexes on columns more efficiently if
    they are declared as the same type and size. In this context, [`VARCHAR`](char.html
    "13.3.2 The CHAR and VARCHAR Types") and [`CHAR`](char.html "13.3.2 The CHAR and
    VARCHAR Types") are considered the same if they are declared as the same size.
    `tt.ActualPC` is declared as `CHAR(10)` and `et.EMPLOYID` is `CHAR(15)`, so there
    is a length mismatch.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个问题是，如果声明为相同类型和大小，MySQL可以更有效地使用列上的索引。在这种情况下，如果声明为相同大小，[`VARCHAR`](char.html
    "13.3.2 The CHAR and VARCHAR Types") 和 [`CHAR`](char.html "13.3.2 The CHAR and
    VARCHAR Types") 被视为相同。`tt.ActualPC` 声明为 `CHAR(10)`，`et.EMPLOYID` 声明为 `CHAR(15)`，因此存在长度不匹配。
- en: 'To fix this disparity between column lengths, use [`ALTER TABLE`](alter-table.html
    "15.1.9 ALTER TABLE Statement") to lengthen `ActualPC` from 10 characters to 15
    characters:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决列长度不匹配的差异，使用 [`ALTER TABLE`](alter-table.html "15.1.9 ALTER TABLE Statement")
    将 `ActualPC` 从 10 个字符扩展到 15 个字符：
- en: '[PRE14]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now `tt.ActualPC` and `et.EMPLOYID` are both `VARCHAR(15)`. Executing the [`EXPLAIN`](explain.html
    "15.8.2 EXPLAIN Statement") statement again produces this result:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `tt.ActualPC` 和 `et.EMPLOYID` 都是 `VARCHAR(15)`。再次执行 [`EXPLAIN`](explain.html
    "15.8.2 EXPLAIN Statement") 语句会产生这个结果：
- en: '[PRE15]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is not perfect, but is much better: The product of the `rows` values is
    less by a factor of 74\. This version executes in a couple of seconds.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是完美的，但要好得多：`rows` 值的乘积减少了 74 倍。这个版本在几秒钟内执行。
- en: 'A second alteration can be made to eliminate the column length mismatches for
    the `tt.AssignedPC = et_1.EMPLOYID` and `tt.ClientID = do.CUSTNMBR` comparisons:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 可以进行第二次修改以消除 `tt.AssignedPC = et_1.EMPLOYID` 和 `tt.ClientID = do.CUSTNMBR` 比较的列长度不匹配：
- en: '[PRE16]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After that modification, [`EXPLAIN`](explain.html "15.8.2 EXPLAIN Statement")
    produces the output shown here:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这种修改，[`EXPLAIN`](explain.html "15.8.2 EXPLAIN Statement") 产生了如下所示的输出：
- en: '[PRE17]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'At this point, the query is optimized almost as well as possible. The remaining
    problem is that, by default, MySQL assumes that values in the `tt.ActualPC` column
    are evenly distributed, and that is not the case for the `tt` table. Fortunately,
    it is easy to tell MySQL to analyze the key distribution:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一步，查询已经被优化得几乎尽可能好了。剩下的问题是，默认情况下，MySQL 假设 `tt.ActualPC` 列中的值是均匀分布的，而对于 `tt`
    表来说并非如此。幸运的是，可以轻松地告诉 MySQL 分析键的分布情况：
- en: '[PRE18]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With the additional index information, the join is perfect and [`EXPLAIN`](explain.html
    "15.8.2 EXPLAIN Statement") produces this result:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在额外的索引信息下，连接是完美的，[`EXPLAIN`](explain.html "15.8.2 EXPLAIN Statement") 产生了这个结果：
- en: '[PRE19]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `rows` column in the output from [`EXPLAIN`](explain.html "15.8.2 EXPLAIN
    Statement") is an educated guess from the MySQL join optimizer. Check whether
    the numbers are even close to the truth by comparing the `rows` product with the
    actual number of rows that the query returns. If the numbers are quite different,
    you might get better performance by using `STRAIGHT_JOIN` in your [`SELECT`](select.html
    "15.2.13 SELECT Statement") statement and trying to list the tables in a different
    order in the `FROM` clause. (However, `STRAIGHT_JOIN` may prevent indexes from
    being used because it disables semijoin transformations. See [Section 10.2.2.1,
    “Optimizing IN and EXISTS Subquery Predicates with Semijoin Transformations”](semijoins.html
    "10.2.2.1 Optimizing IN and EXISTS Subquery Predicates with Semijoin Transformations").)
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '[`EXPLAIN`](explain.html "15.8.2 EXPLAIN Statement") 输出中的 `rows` 列是 MySQL 连接优化器的一个估计。通过比较
    `rows` 的乘积与查询返回的实际行数，检查这些数字是否接近真实情况。如果数字相差很大，你可能会通过在 [`SELECT`](select.html "15.2.13 SELECT
    Statement") 语句中使用 `STRAIGHT_JOIN` 并尝试以不同顺序列出表来获得更好的性能。（但是，`STRAIGHT_JOIN` 可能会阻止索引的使用，因为它禁用了半连接转换。参见
    [Section 10.2.2.1, “Optimizing IN and EXISTS Subquery Predicates with Semijoin
    Transformations”](semijoins.html "10.2.2.1 Optimizing IN and EXISTS Subquery Predicates
    with Semijoin Transformations").）'
- en: It is possible in some cases to execute statements that modify data when [`EXPLAIN
    SELECT`](explain.html "15.8.2 EXPLAIN Statement") is used with a subquery; for
    more information, see [Section 15.2.15.8, “Derived Tables”](derived-tables.html
    "15.2.15.8 Derived Tables").
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，当使用子查询时，可以执行修改数据的语句；有关更多信息，请参见[第 15.2.15.8 节，“派生表”](derived-tables.html
    "15.2.15.8 派生表")时使用[`EXPLAIN SELECT`](explain.html "15.8.2 EXPLAIN 语句")。
