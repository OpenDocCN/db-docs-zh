- en: 1\. Introduction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1\. 介绍
- en: 原文：[https://sqlite.com/vtab.html#tabfunc2](https://sqlite.com/vtab.html#tabfunc2)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://sqlite.com/vtab.html#tabfunc2](https://sqlite.com/vtab.html#tabfunc2)
- en: A virtual table is an object that is registered with an open SQLite [database
    connection](c3ref/sqlite3.html). From the perspective of an SQL statement, the
    virtual table object looks like any other table or view. But behind the scenes,
    queries and updates on a virtual table invoke callback methods of the virtual
    table object instead of reading and writing on the database file.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟表是注册到打开的SQLite[数据库连接](c3ref/sqlite3.html)中的对象。从SQL语句的角度来看，虚拟表对象看起来像任何其他表或视图。但在幕后，对虚拟表的查询和更新调用虚拟表对象的回调方法，而不是直接读取和写入数据库文件。
- en: 'The virtual table mechanism allows an application to publish interfaces that
    are accessible from SQL statements as if they were tables. SQL statements can
    do almost anything to a virtual table that they can do to a real table, with the
    following exceptions:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟表机制允许应用程序发布可从SQL语句访问的接口，就像它们是表一样。SQL语句对虚拟表几乎可以像对真实表一样做任何事情，但有以下例外：
- en: One cannot create a trigger on a virtual table.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法在虚拟表上创建触发器。
- en: One cannot create additional indices on a virtual table. (Virtual tables can
    have indices but that must be built into the virtual table implementation. Indices
    cannot be added separately using [CREATE INDEX](lang_createindex.html) statements.)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法在虚拟表上创建额外的索引。（虚拟表可以有索引，但必须构建到虚拟表实现中。不能使用[CREATE INDEX](lang_createindex.html)语句单独添加索引。）
- en: One cannot run [ALTER TABLE ... ADD COLUMN](lang_altertable.html) commands against
    a virtual table.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法对虚拟表运行[ALTER TABLE ... ADD COLUMN](lang_altertable.html)命令。
- en: Individual virtual table implementations might impose additional constraints.
    For example, some virtual implementations might provide read-only tables. Or some
    virtual table implementations might allow [INSERT](lang_insert.html) or [DELETE](lang_delete.html)
    but not [UPDATE](lang_update.html). Or some virtual table implementations might
    limit the kinds of UPDATEs that can be made.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 单独的虚拟表实现可能会施加额外的约束。例如，某些虚拟实现可能提供只读表。或者某些虚拟表实现可能允许[INSERT](lang_insert.html)或[DELETE](lang_delete.html)，但不允许[UPDATE](lang_update.html)。或者某些虚拟表实现可能限制可以进行的UPDATE类型。
- en: A virtual table might represent an in-memory data structures. Or it might represent
    a view of data on disk that is not in the SQLite format. Or the application might
    compute the content of the virtual table on demand.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟表可以表示内存中的数据结构。或者它可以表示磁盘上不是SQLite格式的数据的视图。或者应用程序可以按需计算虚拟表的内容。
- en: 'Here are some existing and postulated uses for virtual tables:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些现有的和推测的虚拟表用途：
- en: A [full-text search](fts3.html) interface
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[全文搜索](fts3.html)接口'
- en: Spatial indices using [R-Trees](rtree.html)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用[R-Tree](rtree.html)进行空间索引
- en: Introspect the disk content of an SQLite database file (the [dbstat virtual
    table](dbstat.html))
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查SQLite数据库文件的磁盘内容（[dbstat虚拟表](dbstat.html)）
- en: Read and/or write the content of a comma-separated value (CSV) file
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取和/或写入逗号分隔值（CSV）文件的内容
- en: Access the filesystem of the host computer as if it were a database table
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问主机计算机的文件系统，就像它是数据库表一样
- en: Enabling SQL manipulation of data in statistics packages like R
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用对像R这样的统计包中的数据进行SQL操作
- en: See the [list of virtual tables](vtablist.html) page for a longer list of actual
    virtual table implementations.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看[virtual tables列表](vtablist.html)页面，获取更长的实际虚拟表实现列表。
- en: 1.1\. Usage
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1\. 使用方法
- en: A virtual table is created using a [CREATE VIRTUAL TABLE](lang_createvtab.html)
    statement.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[CREATE VIRTUAL TABLE](lang_createvtab.html)语句创建虚拟表。
- en: '**[create-virtual-table-stmt:](syntax/create-virtual-table-stmt.html)**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**[create-virtual-table-stmt:](syntax/create-virtual-table-stmt.html)**'
- en: <svg class="pikchr" viewBox="0 0 624.096 259.848"><text x="74" y="17" text-anchor="middle"
    fill="rgb(0,0,0)" dominant-baseline="central">CREATE</text> <text x="183" y="17"
    text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">VIRTUAL</text>
    <text x="286" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">TABLE</text>
    <text x="372" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">IF</text>
    <text x="435" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">NOT</text>
    <text x="521" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">EXISTS</text>
    <text x="95" y="92" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">schema-name</text>
    <text x="197" y="92" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)"
    dominant-baseline="central">.</text> <text x="300" y="92" text-anchor="middle"
    fill="rgb(0,0,0)" dominant-baseline="central">table-name</text> <text x="67" y="204"
    text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">USING</text>
    <text x="187" y="204" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">module-name</text>
    <text x="300" y="204" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)"
    dominant-baseline="central">(</text> <text x="432" y="204" text-anchor="middle"
    fill="rgb(0,0,0)" dominant-baseline="central">module-argument</text> <text x="563"
    y="204" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)" dominant-baseline="central">)</text>
    <text x="432" y="242" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)"
    dominant-baseline="central">,</text></svg>
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="pikchr" viewBox="0 0 624.096 259.848"><text x="74" y="17" text-anchor="middle"
    fill="rgb(0,0,0)" dominant-baseline="central">CREATE</text> <text x="183" y="17"
    text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">VIRTUAL</text>
    <text x="286" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">TABLE</text>
    <text x="372" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">IF</text>
    <text x="435" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">NOT</text>
    <text x="521" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">EXISTS</text>
    <text x="95" y="92" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">schema-name</text>
    <text x="197" y="92" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)"
    dominant-baseline="central">.</text> <text x="300" y="92" text-anchor="middle"
    fill="rgb(0,0,0)" dominant-baseline="central">table-name</text> <text x="67" y="204"
    text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">USING</text>
    <text x="187" y="204" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">module-name</text>
    <text x="300" y="204" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)"
    dominant-baseline="central">(</text> <text x="432" y="204" text-anchor="middle"
    fill="rgb(0,0,0)" dominant-baseline="central">module-argument</text> <text x="563"
    y="204" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)" dominant-baseline="central">)</text>
    <text x="432" y="242" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)"
    dominant-baseline="central">,</text></svg>
- en: The CREATE VIRTUAL TABLE statement creates a new table called table-name derived
    from the class module-name. The module-name is the name that is registered for
    the virtual table by the [sqlite3_create_module()](c3ref/create_module.html) interface.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: CREATE VIRTUAL TABLE语句创建一个名为table-name的新表，该表派生自类模块名称。module-name是由[sqlite3_create_module()](c3ref/create_module.html)接口注册为虚拟表的名称。
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'One can also provide comma-separated arguments to the module following the
    module name:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块名称后面，还可以提供逗号分隔的参数。
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The format of the arguments to the module is very general. Each module-argument
    may contain keywords, string literals, identifiers, numbers, and punctuation.
    Each module-argument is passed as written (as text) into the [constructor method](vtab.html#xcreate)
    of the virtual table implementation when the virtual table is created and that
    constructor is responsible for parsing and interpreting the arguments. The argument
    syntax is sufficiently general that a virtual table implementation can, if it
    wants to, interpret its arguments as [column definitions](lang_createtable.html#tablecoldef)
    in an ordinary [CREATE TABLE](lang_createtable.html) statement. The implementation
    could also impose some other interpretation on the arguments.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 模块参数的格式非常通用。每个模块参数可能包含关键字、字符串字面量、标识符、数字和标点符号。每个模块参数在创建虚拟表时作为文本传递给虚拟表实现的[构造方法](vtab.html#xcreate)，构造方法负责解析和解释参数。参数语法足够通用，以至于虚拟表实现可以将其参数解释为普通[CREATE
    TABLE](lang_createtable.html)语句中的[列定义](lang_createtable.html#tablecoldef)。实现也可以对参数施加其他解释。
- en: Once a virtual table has been created, it can be used like any other table with
    the exceptions noted above and imposed by specific virtual table implementations.
    A virtual table is destroyed using the ordinary [DROP TABLE](lang_droptable.html)
    syntax.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了虚拟表，它可以像任何其他表一样使用，但特定虚拟表实现可能会施加一些上述未提到的异常。使用普通[DROP TABLE](lang_droptable.html)语法销毁虚拟表。
- en: 1.1.1\. Temporary virtual tables
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.1\. 临时虚拟表
- en: There is no "CREATE TEMP VIRTUAL TABLE" statement. To create a temporary virtual
    table, add the "temp" schema before the virtual table name.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 没有"CREATE TEMP VIRTUAL TABLE"语句。要创建临时虚拟表，请在虚拟表名称前加上"temp"模式。
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 1.1.2\. Eponymous virtual tables
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.2\. 同名虚拟表
- en: Some virtual tables exist automatically in the "main" schema of every database
    connection in which their module is registered, even without a [CREATE VIRTUAL
    TABLE](lang_createvtab.html) statement. Such virtual tables are called "eponymous
    virtual tables". To use an eponymous virtual table, simply use the module name
    as if it were a table. Eponymous virtual tables exist in the "main" schema only,
    so they will not work if prefixed with a different schema name.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一些虚拟表自动存在于每个数据库连接的"main"模式中，即使没有[CREATE VIRTUAL TABLE](lang_createvtab.html)语句也是如此。这些虚拟表称为"同名虚拟表"。要使用同名虚拟表，只需将模块名称用作表名即可。同名虚拟表仅存在于"main"模式中，因此如果使用不同模式名称作为前缀，则无法正常工作。
- en: An example of an eponymous virtual table is the [dbstat virtual table](dbstat.html).
    To use the dbstat virtual table as an eponymous virtual table, simply query against
    the "dbstat" module name, as if it were an ordinary table. (Note that SQLite must
    be compiled with the [SQLITE_ENABLE_DBSTAT_VTAB](compile.html#enable_dbstat_vtab)
    option to include the dbstat virtual table in the build.)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个同名虚拟表的例子是[dbstat虚拟表](dbstat.html)。要将dbstat虚拟表作为同名虚拟表使用，只需针对"dbstat"模块名称查询，就像查询普通表一样。（请注意，SQLite必须使用[SQLITE_ENABLE_DBSTAT_VTAB](compile.html#enable_dbstat_vtab)选项编译，才能在构建中包括dbstat虚拟表。）
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A virtual table is eponymous if its [xCreate](vtab.html#xcreate) method is the
    exact same function as the [xConnect](vtab.html#xconnect) method, or if the [xCreate](vtab.html#xcreate)
    method is NULL. The [xCreate](vtab.html#xcreate) method is called when a virtual
    table is first created using the [CREATE VIRTUAL TABLE](lang_createvtab.html)
    statement. The [xConnect](vtab.html#xconnect) method is invoked whenever a database
    connection attaches to or reparses a schema. When these two methods are the same,
    that indicates that the virtual table has no persistent state that needs to be
    created and destroyed.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其[xCreate](vtab.html#xcreate)方法与[xConnect](vtab.html#xconnect)方法完全相同，或者[xCreate](vtab.html#xcreate)方法为NULL，则虚拟表称为同名虚拟表。在使用[CREATE
    VIRTUAL TABLE](lang_createvtab.html)语句首次创建虚拟表时，会调用[xCreate](vtab.html#xcreate)方法。每当数据库连接附加到或重新解析模式时，都会调用[xConnect](vtab.html#xconnect)方法。当这两个方法相同时，表明虚拟表没有需要创建和销毁的持久状态。
- en: 1.1.3\. Eponymous-only virtual tables
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.3\. 仅同名虚拟表
- en: If the [xCreate](vtab.html#xcreate) method is NULL, then [CREATE VIRTUAL TABLE](lang_createvtab.html)
    statements are prohibited for that virtual table, and the virtual table is an
    "eponymous-only virtual table". Eponymous-only virtual tables are useful as [table-valued
    functions](vtab.html#tabfunc2).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果[xCreate](vtab.html#xcreate)方法为NULL，则禁止对该虚拟表执行[CREATE VIRTUAL TABLE](lang_createvtab.html)语句，并且该虚拟表为"仅同名虚拟表"。仅同名虚拟表可用作[表值函数](vtab.html#tabfunc2)。
- en: Note that prior to [version 3.9.0](releaselog/3_9_0.html) (2015-10-14), SQLite
    did not check the xCreate method for NULL before invoking it. So if an eponymous-only
    virtual table is registered with SQLite [version 3.8.11.1](releaselog/3_8_11_1.html)
    (2015-07-29) or earlier and a [CREATE VIRTUAL TABLE](lang_createvtab.html) command
    is attempted against that virtual table module, a jump to a NULL pointer will
    occur, resulting in a crash.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在[版本3.9.0](releaselog/3_9_0.html)（2015-10-14）之前，SQLite在调用xCreate方法之前未检查其是否为NULL。因此，如果在SQLite
    [版本3.8.11.1](releaselog/3_8_11_1.html)（2015-07-29）或更早版本中注册了仅同名虚拟表，并尝试对该虚拟表模块执行[CREATE
    VIRTUAL TABLE](lang_createvtab.html)命令，则会发生跳转到NULL指针的情况，导致崩溃。
- en: 1.2\. Implementation
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2\. 实现
- en: 'Several new C-level objects are used by the virtual table implementation:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟表实现使用了几个新的C级对象：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The [sqlite3_module](c3ref/module.html) structure defines a module object used
    to implement a virtual table. Think of a module as a class from which one can
    construct multiple virtual tables having similar properties. For example, one
    might have a module that provides read-only access to comma-separated-value (CSV)
    files on disk. That one module can then be used to create several virtual tables
    where each virtual table refers to a different CSV file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[sqlite3_module](c3ref/module.html) 结构定义了一个用于实现虚拟表的模块对象。将模块视为可以构建具有类似属性的多个虚拟表的类。例如，可以有一个模块提供对磁盘上逗号分隔值（CSV）文件的只读访问。然后可以使用该模块创建若干虚拟表，其中每个虚拟表都引用不同的
    CSV 文件。'
- en: The module structure contains methods that are invoked by SQLite to perform
    various actions on the virtual table such as creating new instances of a virtual
    table or destroying old ones, reading and writing data, searching for and deleting,
    updating, or inserting rows. The module structure is explained in more detail
    below.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 模块结构包含通过 SQLite 调用的方法，执行虚拟表上的各种操作，如创建虚拟表的新实例或销毁旧实例，读写数据，搜索和删除、更新或插入行。模块结构将在下文中详细解释。
- en: 'Each virtual table instance is represented by an [sqlite3_vtab](c3ref/vtab.html)
    structure. The sqlite3_vtab structure looks like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每个虚拟表实例由 [sqlite3_vtab](c3ref/vtab.html) 结构表示。sqlite3_vtab 结构的样子如下：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Virtual table implementations will normally subclass this structure to add additional
    private and implementation-specific fields. The nRef field is used internally
    by the SQLite core and should not be altered by the virtual table implementation.
    The virtual table implementation may pass error message text to the core by putting
    an error message string in zErrMsg. Space to hold this error message string must
    be obtained from an SQLite memory allocation function such as [sqlite3_mprintf()](c3ref/mprintf.html)
    or [sqlite3_malloc()](c3ref/free.html). Prior to assigning a new value to zErrMsg,
    the virtual table implementation must free any preexisting content of zErrMsg
    using [sqlite3_free()](c3ref/free.html). Failure to do this will result in a memory
    leak. The SQLite core will free and zero the content of zErrMsg when it delivers
    the error message text to the client application or when it destroys the virtual
    table. The virtual table implementation only needs to worry about freeing the
    zErrMsg content when it overwrites the content with a new, different error message.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟表实现通常会对此结构进行子类化，以添加额外的私有和特定实现的字段。nRef 字段在 SQLite 核心内部使用，不应由虚拟表实现更改。虚拟表实现可以通过在
    zErrMsg 中放置错误消息字符串来将错误消息文本传递给核心。必须从 SQLite 内存分配函数（如 [sqlite3_mprintf()](c3ref/mprintf.html)
    或 [sqlite3_malloc()](c3ref/free.html)）获取空间来保存此错误消息字符串。在对 zErrMsg 赋予新值之前，虚拟表实现必须使用
    [sqlite3_free()](c3ref/free.html) 释放 zErrMsg 的任何现有内容。未能执行此操作将导致内存泄漏。当核心向客户应用程序传递错误消息文本或销毁虚拟表时，核心将释放并清零
    zErrMsg 的内容。虚拟表实现只需要在使用新的、不同的错误消息覆盖内容时担心释放 zErrMsg 的内容。
- en: 'The [sqlite3_vtab_cursor](c3ref/vtab_cursor.html) structure represents a pointer
    to a specific row of a virtual table. This is what an sqlite3_vtab_cursor looks
    like:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[sqlite3_vtab_cursor](c3ref/vtab_cursor.html) 结构表示指向虚拟表特定行的指针。这就是 sqlite3_vtab_cursor
    的样子：'
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once again, practical implementations will likely subclass this structure to
    add additional private fields.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 再一次，实际的实现很可能会对此结构进行子类化，以添加额外的私有字段。
- en: The [sqlite3_index_info](c3ref/index_info.html) structure is used to pass information
    into and out of the xBestIndex method of the module that implements a virtual
    table.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[sqlite3_index_info](c3ref/index_info.html) 结构用于在实现虚拟表的模块的 xBestIndex 方法中传递信息。'
- en: 'Before a [CREATE VIRTUAL TABLE](lang_createvtab.html) statement can be run,
    the module specified in that statement must be registered with the database connection.
    This is accomplished using either of the [sqlite3_create_module()](c3ref/create_module.html)
    or [sqlite3_create_module_v2()](c3ref/create_module.html) interfaces:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 [CREATE VIRTUAL TABLE](lang_createvtab.html) 语句之前，必须使用该语句中指定的模块将其注册到数据库连接。可以使用
    [sqlite3_create_module()](c3ref/create_module.html) 或 [sqlite3_create_module_v2()](c3ref/create_module.html)
    接口来实现这一点：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The [sqlite3_create_module()](c3ref/create_module.html) and [sqlite3_create_module_v2()](c3ref/create_module.html)
    routines associates a module name with an [sqlite3_module](c3ref/module.html)
    structure and a separate client data that is specific to each module. The only
    difference between the two create_module methods is that the _v2 method includes
    an extra parameter that specifies a destructor for client data pointer. The module
    structure is what defines the behavior of a virtual table. The module structure
    looks like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[sqlite3_create_module()](c3ref/create_module.html) 和 [sqlite3_create_module_v2()](c3ref/create_module.html)
    程序将模块名与 [sqlite3_module](c3ref/module.html) 结构及专用于每个模块的客户端数据关联起来。 两种 create_module
    方法之间唯一的区别在于 _v2 方法包含了一个额外的参数，用于指定客户端数据指针的析构函数。 模块结构定义了虚拟表的行为。 模块结构如下所示：'
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The module structure defines all of the methods for each virtual table object.
    The module structure also contains the iVersion field which defines the particular
    edition of the module table structure. Currently, iVersion is always 4 or less,
    but in future releases of SQLite the module structure definition might be extended
    with additional methods and in that case the maximum iVersion value will be increased.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 模块结构定义了每个虚拟表对象的所有方法。 模块结构还包含了 iVersion 字段，用于定义模块表结构的特定版本。 目前，iVersion 总是 4 或更低，但在
    SQLite 的未来版本中，模块结构定义可能会扩展到包括额外的方法，在这种情况下，最大的 iVersion 值将会增加。
- en: The rest of the module structure consists of methods used to implement various
    features of the virtual table. Details on what each of these methods do are provided
    in the sequel.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 模块结构的其余部分包括用于实现虚拟表各种特性的方法。 关于每个方法的详细信息将在后续部分提供。
- en: 1.3\. Virtual Tables And Shared Cache
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3\. 虚拟表与共享缓存
- en: Prior to SQLite [version 3.6.17](releaselog/3_6_17.html) (2009-08-10), the virtual
    table mechanism assumes that each [database connection](c3ref/sqlite3.html) kept
    its own copy of the database schema. Hence, the virtual table mechanism could
    not be used in a database that has [shared cache mode](sharedcache.html) enabled.
    The [sqlite3_create_module()](c3ref/create_module.html) interface would return
    an error if [shared cache mode](sharedcache.html) is enabled. That restriction
    was relaxed beginning with SQLite [version 3.6.17](releaselog/3_6_17.html).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLite [版本 3.6.17](releaselog/3_6_17.html)（2009-08-10）之前，虚拟表机制假设每个 [数据库连接](c3ref/sqlite3.html)
    都保存其自己的数据库架构副本。 因此，启用 [共享缓存模式](sharedcache.html) 的数据库中不能使用虚拟表机制。 如果启用了 [共享缓存模式](sharedcache.html)，[sqlite3_create_module()](c3ref/create_module.html)
    接口将返回错误。 从 SQLite [版本 3.6.17](releaselog/3_6_17.html) 开始，该限制得到了放宽。
- en: 1.4\. Creating New Virtual Table Implementations
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4\. 创建新的虚拟表实现
- en: 'Follow these steps to create your own virtual table:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建您自己的虚拟表：
- en: Write all necessary methods.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写所有必要的方法。
- en: Create an instance of the [sqlite3_module](c3ref/module.html) structure containing
    pointers to all the methods from step 1.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含指向步骤 1 所有方法的 [sqlite3_module](c3ref/module.html) 结构的实例。
- en: Register your [sqlite3_module](c3ref/module.html) structure using one of the
    [sqlite3_create_module()](c3ref/create_module.html) or [sqlite3_create_module_v2()](c3ref/create_module.html)
    interfaces.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用其中一个接口 [sqlite3_create_module()](c3ref/create_module.html) 或 [sqlite3_create_module_v2()](c3ref/create_module.html)
    注册您的 [sqlite3_module](c3ref/module.html) 结构。
- en: Run a [CREATE VIRTUAL TABLE](lang_createvtab.html) command that specifies the
    new module in the USING clause.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行一个指定了新模块的 [CREATE VIRTUAL TABLE](lang_createvtab.html) 命令，使用 USING 子句。
- en: 'The only really hard part is step 1\. You might want to start with an existing
    virtual table implementation and modify it to suit your needs. The [SQLite source
    tree](https://sqlite.org/src/dir?ci=trunk&type=tree) contains many virtual table
    implementations that are suitable for copying, including:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一真正困难的部分是步骤 1。您可能希望从现有的虚拟表实现开始，并修改以满足您的需求。 [SQLite 源代码树](https://sqlite.org/src/dir?ci=trunk&type=tree)
    包含许多适合复制的虚拟表实现，包括：
- en: '**[templatevtab.c](https://sqlite.org/src/file/ext/misc/templatevtab.c)** →
    A virtual table created specifically to serve as a template for other custom virtual
    tables.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[templatevtab.c](https://sqlite.org/src/file/ext/misc/templatevtab.c)** →
    一个专门用于作为其他自定义虚拟表模板的虚拟表。'
- en: '**[series.c](https://sqlite.org/src/file/ext/misc/series.c)** → Implementation
    of the generate_series() table-valued function.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[series.c](https://sqlite.org/src/file/ext/misc/series.c)** → 生成 generate_series()
    表值函数的实现。'
- en: '**[json.c](https://sqlite.org/src/file/src/json.c)** → Contains the sources
    for the [json_each()](json1.html#jeach) and [json_tree()](json1.html#jtree) table-valued
    functions.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[json.c](https://sqlite.org/src/file/src/json.c)** → 包含 [json_each()](json1.html#jeach)
    和 [json_tree()](json1.html#jtree) 表值函数的源代码。'
- en: '**[csv.c](https://sqlite.org/src/file/ext/misc/csv.c)** → A virtual table that
    reads CSV files.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[csv.c](https://sqlite.org/src/file/ext/misc/csv.c)** → 一个读取 CSV 文件的虚拟表。'
- en: There are [many other virtual table implementations](vtablist.html) in the SQLite
    source tree that can be used as examples. Locate these other virtual table implementations
    by searching for "sqlite3_create_module".
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 源代码树中有[许多其他虚拟表实现](vtablist.html)，可以作为示例使用。通过搜索 "sqlite3_create_module"
    可以找到这些其他虚拟表实现。
- en: You might also want to implement your new virtual table as a [loadable extension](loadext.html).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还希望将您的新虚拟表实现为[可加载扩展](loadext.html)。
- en: 2\. Virtual Table Methods
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2\. 虚拟表方法
- en: 2.1\. The xCreate Method
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1\. xCreate 方法
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The xCreate method is called to create a new instance of a virtual table in
    response to a [CREATE VIRTUAL TABLE](lang_createvtab.html) statement. If the xCreate
    method is the same pointer as the [xConnect](vtab.html#xconnect) method, then
    the virtual table is an [eponymous virtual table](vtab.html#epovtab). If the xCreate
    method is omitted (if it is a NULL pointer) then the virtual table is an [eponymous-only
    virtual table](vtab.html#epoonlyvtab).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当 xCreate 方法与 [xConnect](vtab.html#xconnect) 方法的指针相同时，将调用 xCreate 方法来响应 [CREATE
    VIRTUAL TABLE](lang_createvtab.html) 语句以创建虚拟表的新实例。 如果省略 xCreate 方法（如果它是一个 NULL
    指针），那么虚拟表将是一个[仅名义虚拟表](vtab.html#epoonlyvtab)。
- en: The db parameter is a pointer to the SQLite [database connection](c3ref/sqlite3.html)
    that is executing the [CREATE VIRTUAL TABLE](lang_createvtab.html) statement.
    The pAux argument is the copy of the client data pointer that was the fourth argument
    to the [sqlite3_create_module()](c3ref/create_module.html) or [sqlite3_create_module_v2()](c3ref/create_module.html)
    call that registered the [virtual table module](c3ref/module.html). The argv parameter
    is an array of argc pointers to null terminated strings. The first string, argv[0],
    is the name of the module being invoked. The module name is the name provided
    as the second argument to [sqlite3_create_module()](c3ref/create_module.html)
    and as the argument to the USING clause of the [CREATE VIRTUAL TABLE](lang_createvtab.html)
    statement that is running. The second, argv[1], is the name of the database in
    which the new virtual table is being created. The database name is "main" for
    the primary database, or "temp" for TEMP database, or the name given at the end
    of the [ATTACH](lang_attach.html) statement for attached databases. The third
    element of the array, argv[2], is the name of the new virtual table, as specified
    following the TABLE keyword in the [CREATE VIRTUAL TABLE](lang_createvtab.html)
    statement. If present, the fourth and subsequent strings in the argv[] array report
    the arguments to the module name in the [CREATE VIRTUAL TABLE](lang_createvtab.html)
    statement.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: db 参数是执行 [CREATE VIRTUAL TABLE](lang_createvtab.html) 语句的 SQLite [数据库连接](c3ref/sqlite3.html)
    的指针。 pAux 参数是注册 [虚拟表模块](c3ref/module.html) 的 [sqlite3_create_module()](c3ref/create_module.html)
    或 [sqlite3_create_module_v2()](c3ref/create_module.html) 调用的第四个参数的客户端数据指针副本。 argv
    参数是指向空终止字符串的 argc 指针数组。 第一个字符串，argv[0]，是调用的模块名称。 模块名称是作为 [sqlite3_create_module()](c3ref/create_module.html)
    的第二个参数提供的名称，并作为 [CREATE VIRTUAL TABLE](lang_createvtab.html) 语句中 USING 子句的参数运行。
    数组的第二个元素，argv[1]，是正在创建新虚拟表的数据库的名称。 主数据库的名称为 "main"，TEMP 数据库为 "temp"，或者是 [ATTACH](lang_attach.html)
    语句末尾指定的附加数据库的名称。 数组的第三个元素，argv[2]，是在 [CREATE VIRTUAL TABLE](lang_createvtab.html)
    语句中 TABLE 关键字后指定的新虚拟表的名称。 如果存在，argv[] 数组中的第四个及后续字符串报告了 [CREATE VIRTUAL TABLE](lang_createvtab.html)
    语句中模块名称的参数。
- en: The job of this method is to construct the new virtual table object (an [sqlite3_vtab](c3ref/vtab.html)
    object) and return a pointer to it in *ppVTab.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的任务是构造新的虚拟表对象（一个 [sqlite3_vtab](c3ref/vtab.html) 对象），并将指向它的指针返回给 *ppVTab。
- en: 'As part of the task of creating a new [sqlite3_vtab](c3ref/vtab.html) structure,
    this method must invoke [sqlite3_declare_vtab()](c3ref/declare_vtab.html) to tell
    the SQLite core about the columns and datatypes in the virtual table. The [sqlite3_declare_vtab()](c3ref/declare_vtab.html)
    API has the following prototype:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 作为创建新的 [sqlite3_vtab](c3ref/vtab.html) 结构的一部分，此方法必须调用 [sqlite3_declare_vtab()](c3ref/declare_vtab.html)
    来告知 SQLite 核心有关虚拟表中列和数据类型的信息。 [sqlite3_declare_vtab()](c3ref/declare_vtab.html)
    API 的原型如下：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first argument to [sqlite3_declare_vtab()](c3ref/declare_vtab.html) must
    be the same [database connection](c3ref/sqlite3.html) pointer as the first parameter
    to this method. The second argument to [sqlite3_declare_vtab()](c3ref/declare_vtab.html)
    must a zero-terminated UTF-8 string that contains a well-formed [CREATE TABLE](lang_createtable.html)
    statement that defines the columns in the virtual table and their data types.
    The name of the table in this CREATE TABLE statement is ignored, as are all constraints.
    Only the column names and datatypes matter. The CREATE TABLE statement string
    need not to be held in persistent memory. The string can be deallocated and/or
    reused as soon as the [sqlite3_declare_vtab()](c3ref/declare_vtab.html) routine
    returns.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[sqlite3_declare_vtab()](c3ref/declare_vtab.html) 的第一个参数必须与此方法的第一个参数相同，即 [数据库连接](c3ref/sqlite3.html)
    指针。[sqlite3_declare_vtab()](c3ref/declare_vtab.html) 的第二个参数必须是一个以零结尾的 UTF-8 字符串，其中包含一个格式良好的
    [CREATE TABLE](lang_createtable.html) 语句，定义虚拟表中的列及其数据类型。此 CREATE TABLE 语句中的表名和所有约束均会被忽略，只有列名和数据类型有关。CREATE
    TABLE 语句字符串不必保存在持久性内存中，该字符串可以在 [sqlite3_declare_vtab()](c3ref/declare_vtab.html)
    函数返回后释放或重新使用。'
- en: 'The xConnect method can also optionally request special features for the virtual
    table by making one or more calls to the [sqlite3_vtab_config()](c3ref/vtab_config.html)
    interface:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: xConnect 方法还可以选择通过对 [sqlite3_vtab_config()](c3ref/vtab_config.html) 接口进行一次或多次调用来请求虚拟表的特殊功能：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Calls to sqlite3_vtab_config() are optional. But for maximum security, it is
    recommended that virtual table implementations invoke "[sqlite3_vtab_config](c3ref/vtab_config.html)(db,
    [SQLITE_VTAB_DIRECTONLY](c3ref/c_vtab_constraint_support.html#sqlitevtabdirectonly))"
    if the virtual table will not be used from inside of triggers or views.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对 sqlite3_vtab_config() 的调用是可选的。但是为了最大安全性，建议虚拟表实现在虚拟表不会从触发器或视图内部使用时调用 "[sqlite3_vtab_config](c3ref/vtab_config.html)(db,
    [SQLITE_VTAB_DIRECTONLY](c3ref/c_vtab_constraint_support.html#sqlitevtabdirectonly))"。
- en: The xCreate method need not initialize the pModule, nRef, and zErrMsg fields
    of the [sqlite3_vtab](c3ref/vtab.html) object. The SQLite core will take care
    of that chore.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: xCreate 方法不需要初始化 [sqlite3_vtab](c3ref/vtab.html) 对象的 pModule、nRef 和 zErrMsg
    字段。SQLite 核心将处理这些琐事。
- en: The xCreate should return [SQLITE_OK](rescode.html#ok) if it is successful in
    creating the new virtual table, or [SQLITE_ERROR](rescode.html#error) if it is
    not successful. If not successful, the [sqlite3_vtab](c3ref/vtab.html) structure
    must not be allocated. An error message may optionally be returned in *pzErr if
    unsuccessful. Space to hold the error message string must be allocated using an
    SQLite memory allocation function like [sqlite3_malloc()](c3ref/free.html) or
    [sqlite3_mprintf()](c3ref/mprintf.html) as the SQLite core will attempt to free
    the space using [sqlite3_free()](c3ref/free.html) after the error has been reported
    up to the application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 xCreate 方法成功创建新的虚拟表，则应返回 [SQLITE_OK](rescode.html#ok)，如果失败则返回 [SQLITE_ERROR](rescode.html#error)。如果失败，不应分配
    [sqlite3_vtab](c3ref/vtab.html) 结构。如果失败，可选择在 *pzErr 中返回错误消息。必须使用 SQLite 内存分配函数（如
    [sqlite3_malloc()](c3ref/free.html) 或 [sqlite3_mprintf()](c3ref/mprintf.html)）分配用于保存错误消息字符串的空间，因为
    SQLite 核心在向应用程序报告错误后会尝试使用 [sqlite3_free()](c3ref/free.html) 释放这些空间。
- en: If the xCreate method is omitted (left as a NULL pointer) then the virtual table
    is an [eponymous-only virtual table](vtab.html#epoonlyvtab). New instances of
    the virtual table cannot be created using [CREATE VIRTUAL TABLE](lang_createvtab.html)
    and the virtual table can only be used via its module name. Note that SQLite versions
    prior to 3.9.0 (2015-10-14) do not understand eponymous-only virtual tables and
    will segfault if an attempt is made to [CREATE VIRTUAL TABLE](lang_createvtab.html)
    on an eponymous-only virtual table because the xCreate method was not checked
    for null.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略 xCreate 方法（保留为 NULL 指针），则该虚拟表是一个 [仅拟名虚拟表](vtab.html#epoonlyvtab)。无法使用 [CREATE
    VIRTUAL TABLE](lang_createvtab.html) 创建虚拟表的新实例，且只能通过其模块名称使用该虚拟表。请注意，SQLite 版本
    3.9.0（2015-10-14）之前的版本不理解仅拟名虚拟表，如果尝试在仅拟名虚拟表上使用 [CREATE VIRTUAL TABLE](lang_createvtab.html)
    会导致段错误，因为未检查 xCreate 方法是否为 null。
- en: If the xCreate method is the exact same pointer as the [xConnect](vtab.html#xconnect)
    method, that indicates that the virtual table does not need to initialize backing
    store. Such a virtual table can be used as an [eponymous virtual table](vtab.html#epovtab)
    or as a named virtual table using [CREATE VIRTUAL TABLE](lang_createvtab.html)
    or both.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果xCreate方法与[xConnect](vtab.html#xconnect)方法的确切指针相同，则表示该虚拟表不需要初始化支持存储。这样的虚拟表可以用作[同名虚拟表](vtab.html#epovtab)，或者使用[CREATE
    VIRTUAL TABLE](lang_createvtab.html)创建具名虚拟表，或者两者都可以。
- en: 2.1.1\. Hidden columns in virtual tables
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1\. 虚拟表中的隐藏列
- en: 'If a column datatype contains the special keyword "HIDDEN" (in any combination
    of upper and lower case letters) then that keyword it is omitted from the column
    datatype name and the column is marked as a hidden column internally. A hidden
    column differs from a normal column in three respects:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列数据类型包含特殊关键字“HIDDEN”（以任何大小写字母的任意组合），则该关键字将从列数据类型名称中省略，并在内部标记为隐藏列。隐藏列与普通列在三个方面不同：
- en: Hidden columns are not listed in the dataset returned by "[PRAGMA table_info](pragma.html#pragma_table_info)",
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[PRAGMA table_info](pragma.html#pragma_table_info) 返回的数据集中未列出隐藏列。'
- en: Hidden columns are not included in the expansion of a "*" expression in the
    result set of a [SELECT](lang_select.html), and
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[SELECT](lang_select.html)的结果集中，隐藏列不包括在"*"表达式的展开中，
- en: Hidden columns are not included in the implicit column-list used by an [INSERT](lang_insert.html)
    statement that lacks an explicit column-list.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在缺乏显式列列表的[INSERT](lang_insert.html)语句中，隐藏列不包括在隐含的列列表中。
- en: 'For example, if the following SQL is passed to [sqlite3_declare_vtab()](c3ref/declare_vtab.html):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果将以下SQL传递给[sqlite3_declare_vtab()](c3ref/declare_vtab.html)：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Then the virtual table would be created with two hidden columns, and with datatypes
    of "VARCHAR(12)" and "INTEGER".
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后虚拟表将创建两个隐藏列，数据类型为"VARCHAR(12)"和"INTEGER"。
- en: An example use of hidden columns can be seen in the [FTS3](fts3.html) virtual
    table implementation, where every FTS virtual table contains an [FTS hidden column](fts3.html#hiddencol)
    that is used to pass information from the virtual table into [FTS auxiliary functions](fts3.html#snippet)
    and to the [FTS MATCH](fts3.html#full_text_index_queries) operator.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏列的一个示例用法可以在[FTS3](fts3.html)虚拟表实现中看到，其中每个FTS虚拟表包含一个[FTS隐藏列](fts3.html#hiddencol)，用于将信息从虚拟表传递到[FTS辅助函数](fts3.html#snippet)和[FTS
    MATCH](fts3.html#full_text_index_queries)运算符。
- en: 2.1.2\. Table-valued functions
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.2\. 表值函数
- en: A [virtual table](vtab.html) that contains [hidden columns](vtab.html#hiddencol)
    can be used like a table-valued function in the FROM clause of a [SELECT](lang_select.html)
    statement. The arguments to the table-valued function become constraints on the
    HIDDEN columns of the virtual table.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包含[隐藏列](vtab.html#hiddencol)的[virtual table](vtab.html)可以在[SELECT](lang_select.html)语句的FROM子句中像表值函数一样使用。表值函数的参数成为虚拟表的隐藏列的约束条件。
- en: 'For example, the "generate_series" extension (located in the [ext/misc/series.c](https://www.sqlite.org/src/artifact?ci=trunk&filename=ext/misc/series.c)
    file in the [source tree](https://www.sqlite.org/src/tree?ci=trunk)) implements
    an [eponymous virtual table](vtab.html#epovtab) with the following schema:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，“generate_series”扩展（位于[ext/misc/series.c](https://www.sqlite.org/src/artifact?ci=trunk&filename=ext/misc/series.c)文件中的[源代码树](https://www.sqlite.org/src/tree?ci=trunk)）实现了一个同名虚拟表，其模式如下：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The [sqlite3_module.xBestIndex](vtab.html#xbestindex) method in the implementation
    of this table checks for equality constraints against the HIDDEN columns, and
    uses those as input parameters to determine the range of integer "value" outputs
    to generate. Reasonable defaults are used for any unconstrained columns. For example,
    to list all integers between 5 and 50:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表的实现中的[sqlite3_module.xBestIndex](vtab.html#xbestindex)方法检查与隐藏列的相等约束，并将其用作确定生成的整数“值”输出范围的输入参数。对于任何无约束的列，使用合理的默认值。例如，要列出5到50之间的所有整数：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The previous query is equivalent to the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询等同于以下内容：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Arguments on the virtual table name are matched to [hidden columns](vtab.html#hiddencol)
    in order. The number of arguments can be less than the number of hidden columns,
    in which case the latter hidden columns are unconstrained. However, an error results
    if there are more arguments than there are hidden columns in the virtual table.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟表名称上的参数与[隐藏列](vtab.html#hiddencol)按顺序匹配。参数数量可以少于隐藏列的数量，此时后面的隐藏列不受限制。但如果虚拟表中的参数比隐藏列更多，将会导致错误。
- en: 2.1.3\. WITHOUT ROWID Virtual Tables
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.3\. WITHOUT ROWID虚拟表
- en: Beginning with SQLite [version 3.14.0](releaselog/3_14.html) (2016-08-08), the
    CREATE TABLE statement that is passed into [sqlite3_declare_vtab()](c3ref/declare_vtab.html)
    may contain a [WITHOUT ROWID](withoutrowid.html) clause. This is useful for cases
    where the virtual table rows cannot easily be mapped into unique integers. A CREATE
    TABLE statement that includes WITHOUT ROWID must define one or more columns as
    the PRIMARY KEY. Every column of the PRIMARY KEY must individually be NOT NULL
    and all columns for each row must be collectively unique.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 从SQLite [版本3.14.0](releaselog/3_14.html)（2016-08-08）开始，传递给[sqlite3_declare_vtab()](c3ref/declare_vtab.html)的CREATE
    TABLE语句可以包含[WITHOUT ROWID](withoutrowid.html)子句。这对于虚拟表行不易映射为唯一整数的情况非常有用。包含WITHOUT
    ROWID的CREATE TABLE语句必须定义一个或多个列作为主键。主键的每一列都必须单独为NOT NULL，并且每行的所有列必须集体唯一。
- en: Note that SQLite does not enforce the PRIMARY KEY for a WITHOUT ROWID virtual
    table. Enforcement is the responsibility of the underlying virtual table implementation.
    But SQLite does assume that the PRIMARY KEY constraint is valid - that the identified
    columns really are UNIQUE and NOT NULL - and it uses that assumption to optimize
    queries against the virtual table.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，SQLite不会强制执行WITHOUT ROWID虚拟表的主键约束。执行是底层虚拟表实现的责任。但SQLite确实假设主键约束是有效的 - 即被标识的列确实是唯一的且非空
    - 并且利用此假设来优化针对虚拟表的查询。
- en: The rowid column is not accessible on a WITHOUT ROWID virtual table (of course).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在WITHOUT ROWID虚拟表上无法访问rowid列。
- en: The [xUpdate](vtab.html#xupdate) method was originally designed around having
    a [ROWID](lang_createtable.html#rowid) as a single value. The [xUpdate](vtab.html#xupdate)
    method has been expanded to accommodate an arbitrary PRIMARY KEY in place of the
    ROWID, but the PRIMARY KEY must still be only one column. For this reason, SQLite
    will reject any WITHOUT ROWID virtual table that has more than one PRIMARY KEY
    column and a non-NULL xUpdate method.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[xUpdate](vtab.html#xupdate)方法最初设计时围绕单个值作为[ROWID](lang_createtable.html#rowid)展开。后来，[xUpdate](vtab.html#xupdate)方法已经扩展，以适应任意的主键替代ROWID，但主键仍然必须只有一个列。因此，SQLite将拒绝任何具有多个主键列和非空xUpdate方法的WITHOUT
    ROWID虚拟表。'
- en: 2.2\. The xConnect Method
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2\. xConnect方法
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The xConnect method is very similar to [xCreate](vtab.html#xcreate). It has
    the same parameters and constructs a new [sqlite3_vtab](c3ref/vtab.html) structure
    just like xCreate. And it must also call [sqlite3_declare_vtab()](c3ref/declare_vtab.html)
    like xCreate. It should also make all of the same [sqlite3_vtab_config()](c3ref/vtab_config.html)
    calls as xCreate.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: xConnect方法与[xCreate](vtab.html#xcreate)非常相似。它具有相同的参数，并像xCreate一样构造一个新的[sqlite3_vtab](c3ref/vtab.html)结构。它也必须像xCreate一样调用[sqlite3_declare_vtab()](c3ref/declare_vtab.html)。还应该进行与xCreate相同的所有[sqlite3_vtab_config()](c3ref/vtab_config.html)调用。
- en: The difference is that xConnect is called to establish a new connection to an
    existing virtual table whereas xCreate is called to create a new virtual table
    from scratch.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 区别在于xConnect用于建立与现有虚拟表的新连接，而xCreate用于从头创建新虚拟表。
- en: The xCreate and xConnect methods are only different when the virtual table has
    some kind of backing store that must be initialized the first time the virtual
    table is created. The xCreate method creates and initializes the backing store.
    The xConnect method just connects to an existing backing store. When xCreate and
    xConnect are the same, the table is an [eponymous virtual table](vtab.html#epovtab).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当虚拟表具有某种必须在创建时初始化的后备存储时，xCreate和xConnect方法才有所不同。xCreate方法创建并初始化后备存储。xConnect方法仅连接到现有的后备存储。当xCreate和xConnect相同时，表是一个[同名虚拟表](vtab.html#epovtab)。
- en: As an example, consider a virtual table implementation that provides read-only
    access to existing comma-separated-value (CSV) files on disk. There is no backing
    store that needs to be created or initialized for such a virtual table (since
    the CSV files already exist on disk) so the xCreate and xConnect methods will
    be identical for that module.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个虚拟表实现，它提供对磁盘上现有逗号分隔值（CSV）文件的只读访问。对于这样的虚拟表，不需要创建或初始化后端存储（因为CSV文件已经存在于磁盘上），因此该模块的
    xCreate 和 xConnect 方法将是相同的。
- en: Another example is a virtual table that implements a full-text index. The xCreate
    method must create and initialize data structures to hold the dictionary and posting
    lists for that index. The xConnect method, on the other hand, only has to locate
    and use an existing dictionary and posting lists that were created by a prior
    xCreate call.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是实现全文索引的虚拟表。xCreate 方法必须创建和初始化用于保存该索引的字典和 posting 列表的数据结构。另一方面，xConnect
    方法只需定位并使用之前 xCreate 调用创建的现有字典和 posting 列表。
- en: The xConnect method must return [SQLITE_OK](rescode.html#ok) if it is successful
    in creating the new virtual table, or [SQLITE_ERROR](rescode.html#error) if it
    is not successful. If not successful, the [sqlite3_vtab](c3ref/vtab.html) structure
    must not be allocated. An error message may optionally be returned in *pzErr if
    unsuccessful. Space to hold the error message string must be allocated using an
    SQLite memory allocation function like [sqlite3_malloc()](c3ref/free.html) or
    [sqlite3_mprintf()](c3ref/mprintf.html) as the SQLite core will attempt to free
    the space using [sqlite3_free()](c3ref/free.html) after the error has been reported
    up to the application.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 xConnect 方法成功创建新的虚拟表，必须返回 [SQLITE_OK](rescode.html#ok)，如果不成功，则返回 [SQLITE_ERROR](rescode.html#error)。如果不成功，不得分配
    [sqlite3_vtab](c3ref/vtab.html) 结构。如果不成功，错误消息可以选择性地在 *pzErr 中返回。必须使用类似于 [sqlite3_malloc()](c3ref/free.html)
    或 [sqlite3_mprintf()](c3ref/mprintf.html) 的 SQLite 内存分配函数分配错误消息字符串的空间，因为 SQLite
    核心在报告错误后将尝试使用 [sqlite3_free()](c3ref/free.html) 释放该空间。
- en: The xConnect method is required for every virtual table implementation, though
    the [xCreate](vtab.html#xcreate) and xConnect pointers of the [sqlite3_module](c3ref/module.html)
    object may point to the same function if the virtual table does not need to initialize
    backing store.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟表实现中，每个虚拟表都需要 xConnect 方法，尽管 [xCreate](vtab.html#xcreate) 和 [sqlite3_module](c3ref/module.html)
    对象的 xConnect 指针可能指向同一个函数，如果虚拟表不需要初始化后端存储。
- en: 2.3\. The xBestIndex Method
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3\. xBestIndex 方法
- en: 'SQLite uses the xBestIndex method of a virtual table module to determine the
    best way to access the virtual table. The xBestIndex method has a prototype like
    this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 使用虚拟表模块的 xBestIndex 方法来确定访问虚拟表的最佳方式。xBestIndex 方法的原型如下：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The SQLite core communicates with the xBestIndex method by filling in certain
    fields of the [sqlite3_index_info](c3ref/index_info.html) structure and passing
    a pointer to that structure into xBestIndex as the second parameter. The xBestIndex
    method fills out other fields of this structure which forms the reply. The [sqlite3_index_info](c3ref/index_info.html)
    structure looks like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 核心通过填充 [sqlite3_index_info](c3ref/index_info.html) 结构的某些字段，并将指向该结构的指针作为第二个参数传递给
    xBestIndex 方法，与 xBestIndex 方法进行通信。xBestIndex 方法填充该结构的其他字段，形成回复。[sqlite3_index_info](c3ref/index_info.html)
    结构如下：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note the warnings on the "estimatedRows", "idxFlags", and colUsed fields. These
    fields were added with SQLite versions 3.8.2, 3.9.0, and 3.10.0, respectively.
    Any extension that reads or writes these fields must first check that the version
    of the SQLite library in use is greater than or equal to appropriate version -
    perhaps comparing the value returned from [sqlite3_libversion_number()](c3ref/libversion.html)
    against constants 3008002, 3009000, and/or 3010000\. The result of attempting
    to access these fields in an sqlite3_index_info structure created by an older
    version of SQLite are undefined.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 "estimatedRows"、"idxFlags" 和 colUsed 字段上的警告。这些字段分别是在 SQLite 版本 3.8.2、3.9.0
    和 3.10.0 中添加的。任何读取或写入这些字段的扩展必须首先检查正在使用的 SQLite 库版本是否大于或等于相应的版本，例如可以将 [sqlite3_libversion_number()](c3ref/libversion.html)
    返回的值与常量 3008002、3009000 和/或 3010000 进行比较。尝试访问由旧版 SQLite 创建的 sqlite3_index_info
    结构中的这些字段的结果是未定义的。
- en: 'In addition, there are some defined constants:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些定义的常量：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Use the [sqlite3_vtab_collation()](c3ref/vtab_collation.html) interface to
    find the name of the [collating sequence](datatype3.html#collation) that should
    be used when evaluating the i-th constraint:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[sqlite3_vtab_collation()](c3ref/vtab_collation.html)接口查找在评估第i个约束时应使用的[排序序列](datatype3.html#collation)的名称：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The SQLite core calls the xBestIndex method when it is compiling a query that
    involves a virtual table. In other words, SQLite calls this method when it is
    running [sqlite3_prepare()](c3ref/prepare.html) or the equivalent. By calling
    this method, the SQLite core is saying to the virtual table that it needs to access
    some subset of the rows in the virtual table and it wants to know the most efficient
    way to do that access. The xBestIndex method replies with information that the
    SQLite core can then use to conduct an efficient search of the virtual table.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当SQLite核心编译涉及虚拟表的查询时，会调用xBestIndex方法。换句话说，当SQLite运行[sqlite3_prepare()](c3ref/prepare.html)或其等效方法时，会调用此方法。通过调用此方法，SQLite核心向虚拟表表示需要访问虚拟表中某些行的子集，并希望了解执行该访问的最有效方法。xBestIndex方法将回复SQLite核心可以用来进行虚拟表高效搜索的信息。
- en: While compiling a single SQL query, the SQLite core might call xBestIndex multiple
    times with different settings in [sqlite3_index_info](c3ref/index_info.html).
    The SQLite core will then select the combination that appears to give the best
    performance.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译单个SQL查询时，SQLite核心可能会多次调用xBestIndex，并在[sqlite3_index_info](c3ref/index_info.html)中使用不同的设置。然后SQLite核心将选择似乎提供最佳性能的组合。
- en: Before calling this method, the SQLite core initializes an instance of the [sqlite3_index_info](c3ref/index_info.html)
    structure with information about the query that it is currently trying to process.
    This information derives mainly from the WHERE clause and ORDER BY or GROUP BY
    clauses of the query, but also from any ON or USING clauses if the query is a
    join. The information that the SQLite core provides to the xBestIndex method is
    held in the part of the structure that is marked as "Inputs". The "Outputs" section
    is initialized to zero.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用此方法之前，SQLite 核心会用关于当前正在处理的查询的信息初始化一个[sqlite3_index_info](c3ref/index_info.html)结构的实例。这些信息主要来自查询的WHERE子句和ORDER
    BY或GROUP BY子句，但如果查询是一个连接，则还会来自任何ON或USING子句。SQLite 核心提供给xBestIndex方法的信息保存在标记为“Inputs”的结构的一部分中。“Outputs”部分初始化为零。
- en: The information in the [sqlite3_index_info](c3ref/index_info.html) structure
    is ephemeral and may be overwritten or deallocated as soon as the xBestIndex method
    returns. If the xBestIndex method needs to remember any part of the [sqlite3_index_info](c3ref/index_info.html)
    structure, it should make a copy. Care must be take to store the copy in a place
    where it will be deallocated, such as in the idxStr field with needToFreeIdxStr
    set to 1.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[sqlite3_index_info](c3ref/index_info.html)结构中的信息是短暂的，并且可能在xBestIndex方法返回后被覆盖或释放。如果xBestIndex方法需要记住[sqlite3_index_info](c3ref/index_info.html)结构的任何部分，它应该制作一份副本。必须小心地将副本存储在可能会被释放的位置，例如在needToFreeIdxStr设置为1的idxStr字段中。'
- en: Note that xBestIndex will always be called before [xFilter](vtab.html#xfilter),
    since the idxNum and idxStr outputs from xBestIndex are required inputs to xFilter.
    However, there is no guarantee that xFilter will be called following a successful
    xBestIndex.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在调用[xFilter](vtab.html#xfilter)之前始终会调用xBestIndex，因为从xBestIndex中获取的idxNum和idxStr输出是xFilter的必需输入。但是，并不保证在成功的xBestIndex之后一定会调用xFilter。
- en: The xBestIndex method is required for every virtual table implementation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 每个虚拟表实现都需要xBestIndex方法。
- en: 2.3.1\. Inputs
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1\. 输入
- en: The main thing that the SQLite core is trying to communicate to the virtual
    table is the constraints that are available to limit the number of rows that need
    to be searched. The aConstraint[] array contains one entry for each constraint.
    There will be exactly nConstraint entries in that array.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite核心试图向虚拟表传达的主要信息是可用于限制需要搜索的行数的约束条件。aConstraint[]数组包含每个约束的条目。该数组中将恰好有nConstraint个条目。
- en: Each constraint will usually correspond to a term in the WHERE clause or in
    a USING or ON clause that is of the form
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 每个约束通常对应于WHERE子句中的一个项或形如USING或ON子句中的一个项
- en: column OP EXPR
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列 OP 表达式
- en: 'Where "column" is a column in the virtual table, OP is an operator like "="
    or "<", and EXPR is an arbitrary expression. So, for example, if the WHERE clause
    contained a term like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在“column”是虚拟表中的列，“OP”是像“=”或“<”这样的运算符，而“EXPR”是任意表达式。因此，例如，如果WHERE子句包含如下项：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then one of the constraints would be on the "a" column with operator "=" and
    an expression of "5". Constraints need not have a literal representation of the
    WHERE clause. The query optimizer might make transformations to the WHERE clause
    in order to extract as many constraints as it can. So, for example, if the WHERE
    clause contained something like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个约束可能是在 "a" 列上，操作符为 "="，表达式为 "5"。约束不需要在 WHERE 子句中具有文字表示。查询优化器可能会对 WHERE 子句进行转换，以提取尽可能多的约束。例如，如果
    WHERE 子句包含类似以下内容：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The query optimizer might translate this into three separate constraints:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 查询优化器可能会将此转换为三个单独的约束：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: For each such constraint, the aConstraint[].iColumn field indicates which column
    appears on the left-hand side of the constraint. The first column of the virtual
    table is column 0\. The rowid of the virtual table is column -1\. The aConstraint[].op
    field indicates which operator is used. The SQLITE_INDEX_CONSTRAINT_* constants
    map integer constants into operator values. Columns occur in the order they were
    defined by the call to [sqlite3_declare_vtab()](c3ref/declare_vtab.html) in the
    [xCreate](vtab.html#xcreate) or [xConnect](vtab.html#xconnect) method. Hidden
    columns are counted when determining the column index.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个这样的约束，aConstraint[].iColumn 字段指示约束左侧的列。虚拟表的第一列是列 0。虚拟表的 rowid 是列 -1。aConstraint[].op
    字段指示使用的操作符。SQLITE_INDEX_CONSTRAINT_* 常量将整数常量映射到操作符值。列按照在 [sqlite3_declare_vtab()](c3ref/declare_vtab.html)
    中调用时定义的顺序出现。在确定列索引时，隐藏列也会被计数。
- en: 'If the [xFindFunction()](vtab.html#xfindfunction) method for the virtual table
    is defined, and if xFindFunction() sometimes returns [SQLITE_INDEX_CONSTRAINT_FUNCTION](c3ref/c_index_constraint_eq.html)
    or larger, then the constraints might also be of the form:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果虚拟表的 [xFindFunction()](vtab.html#xfindfunction) 方法已定义，并且 xFindFunction() 有时返回
    [SQLITE_INDEX_CONSTRAINT_FUNCTION](c3ref/c_index_constraint_eq.html) 或更大的值，则约束也可能是以下形式之一：
- en: FUNCTION( column, EXPR)
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: FUNCTION(column, EXPR)
- en: In this case the aConstraint[].op value is the same as the value returned by
    [xFindFunction()](vtab.html#xfindfunction) for FUNCTION.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，aConstraint[].op 的值与 [xFindFunction()](vtab.html#xfindfunction) 返回的 FUNCTION
    的值相同。
- en: The aConstraint[] array contains information about all constraints that apply
    to the virtual table. But some of the constraints might not be usable because
    of the way tables are ordered in a join. The xBestIndex method must therefore
    only consider constraints that have an aConstraint[].usable flag which is true.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 数组 aConstraint[] 包含有关适用于虚拟表的所有约束的信息。但是由于表在连接中的排序方式，某些约束可能无法使用。因此，xBestIndex
    方法只需考虑具有 aConstraint[].usable 标志为 true 的约束。
- en: In addition to WHERE clause constraints, the SQLite core also tells the xBestIndex
    method about the ORDER BY clause. (In an aggregate query, the SQLite core might
    put in GROUP BY clause information in place of the ORDER BY clause information,
    but this fact should not make any difference to the xBestIndex method.) If all
    terms of the ORDER BY clause are columns in the virtual table, then nOrderBy will
    be the number of terms in the ORDER BY clause and the aOrderBy[] array will identify
    the column for each term in the order by clause and whether or not that column
    is ASC or DESC.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 WHERE 子句约束外，SQLite 核心还告知 xBestIndex 方法关于 ORDER BY 子句的信息。（在聚合查询中，SQLite 核心可能会用
    GROUP BY 子句信息替代 ORDER BY 子句信息，但这个事实不应该对 xBestIndex 方法造成任何影响。）如果 ORDER BY 子句的所有项都是虚拟表中的列，则
    nOrderBy 将是 ORDER BY 子句中项的数量，aOrderBy[] 数组将标识每个 ORDER BY 子句项的列，以及该列是 ASC 还是 DESC。
- en: In SQLite [version 3.10.0](releaselog/3_10_0.html) (2016-01-06) and later, the
    colUsed field is available to indicate which fields of the virtual table are actually
    used by the statement being prepared. If the lowest bit of colUsed is set, that
    means that the first column is used. The second lowest bit corresponds to the
    second column. And so forth. If the most significant bit of colUsed is set, that
    means that one or more columns other than the first 63 columns are used. If column
    usage information is needed by the [xFilter](vtab.html#xfilter) method, then the
    required bits must be encoded into either the output idxNum field or idxStr content.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLite [version 3.10.0](releaselog/3_10_0.html)（2016-01-06）及更高版本中，colUsed
    字段可用于指示被准备的语句实际使用的虚拟表的哪些字段。如果 colUsed 的最低位设置了，这意味着使用了第一列。第二低位对应第二列，依此类推。如果 colUsed
    的最高位设置了，这意味着除了前63列之外还使用了一列或多列。如果[xFilter](vtab.html#xfilter)方法需要列使用信息，则必须将所需的位编码到输出的
    idxNum 字段或 idxStr 内容中。
- en: 2.3.1.1\. LIKE, GLOB, REGEXP, and MATCH functions
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.1.1\. LIKE、GLOB、REGEXP 和 MATCH 函数
- en: 'For the LIKE, GLOB, REGEXP, and MATCH operators, the aConstraint[].iColumn
    value is the virtual table column that is the left operand of the operator. However,
    if these operators are expressed as function calls instead of operators, then
    the aConstraint[].iColumn value references the virtual table column that is the
    second argument to that function:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 LIKE、GLOB、REGEXP 和 MATCH 操作符，aConstraint[].iColumn 值是虚拟表列，即操作符的左操作数。但是，如果这些操作符表示为函数调用而不是操作符，则
    aConstraint[].iColumn 值引用的是作为该函数第二个参数的虚拟表列：
- en: LIKE(*EXPR*, *column*)
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: LIKE(*EXPR*, *column*)
- en: GLOB(*EXPR*, *column*)
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: GLOB(*EXPR*, *column*)
- en: REGEXP(*EXPR*, *column*)
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: REGEXP(*EXPR*, *column*)
- en: MATCH(*EXPR*, *column*)
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: MATCH(*EXPR*, *column*)
- en: 'Hence, as far as the xBestIndex() method is concerned, the following two forms
    are equivalent:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，就xBestIndex()方法而言，以下两种形式是等效的：
- en: '*column* LIKE *EXPR*'
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*column* LIKE *EXPR*'
- en: LIKE(*EXPR*,*column*)
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: LIKE(*EXPR*,*column*)
- en: This special behavior of looking at the second argument of a function only occurs
    for the LIKE, GLOB, REGEXP, and MATCH functions. For all other functions, the
    aConstraint[].iColumn value references the first argument of the function.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 LIKE、GLOB、REGEXP 和 MATCH 函数，仅在查看函数的第二个参数时才会出现这种特殊行为。对于所有其他函数，aConstraint[].iColumn
    值引用的是函数的第一个参数。
- en: This special feature of LIKE, GLOB, REGEXP, and MATCH does not apply to the
    [xFindFunction()](vtab.html#xfindfunction) method, however. The [xFindFunction()](vtab.html#xfindfunction)
    method always keys off of the left operand of an LIKE, GLOB, REGEXP, or MATCH
    operator but off of the first argument to function-call equivalents of those operators.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，LIKE、GLOB、REGEXP 和 MATCH 的这种特殊功能不适用于[xFindFunction()](vtab.html#xfindfunction)方法。[xFindFunction()](vtab.html#xfindfunction)方法始终基于
    LIKE、GLOB、REGEXP 或 MATCH 操作符的左操作数，而不是这些操作符的函数调用等效的第一个参数。
- en: 2.3.1.2\. LIMIT and OFFSET
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.1.2\. LIMIT 和 OFFSET
- en: When aConstraint[].op is one of SQLITE_INDEX_CONSTRAINT_LIMIT or SQLITE_INDEX_CONSTRAINT_OFFSET,
    that indicates that there is a LIMIT or OFFSET clause on the SQL query statement
    that is using the virtual table. The LIMIT and OFFSET operators have no left operand,
    and so when aConstraint[].op is one of SQLITE_INDEX_CONSTRAINT_LIMIT or SQLITE_INDEX_CONSTRAINT_OFFSET
    then the aConstraint[].iColumn value is meaningless and should not be used.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当 aConstraint[].op 是 SQLITE_INDEX_CONSTRAINT_LIMIT 或 SQLITE_INDEX_CONSTRAINT_OFFSET
    之一时，表示在使用虚拟表的 SQL 查询语句中存在 LIMIT 或 OFFSET 子句。LIMIT 和 OFFSET 操作符没有左操作数，因此当 aConstraint[].op
    是 SQLITE_INDEX_CONSTRAINT_LIMIT 或 SQLITE_INDEX_CONSTRAINT_OFFSET 之一时，aConstraint[].iColumn
    值是无意义的，不应使用。
- en: 2.3.1.3\. Right-hand side values of constraints
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.1.3\. 约束的右手边值
- en: The [sqlite3_vtab_rhs_value()](c3ref/vtab_rhs_value.html) interface can be used
    to try to access the right-hand operand of a constraint. However, the value of
    a right-hand operator might not be known at the time that the xBestIndex method
    is run, so the sqlite3_vtab_rhs_value() call might not be successful. Usually
    the right operand of a constraint is only available to xBestIndex if it is coded
    as a literal value in the input SQL. If the right operand is coded as an expression
    or a [host parameter](c3ref/bind_blob.html), it probably will not be accessible
    to xBestIndex. Some operators, such as [SQLITE_INDEX_CONSTRAINT_ISNULL](c3ref/c_index_constraint_eq.html)
    and [SQLITE_INDEX_CONSTRAINT_ISNOTNULL](c3ref/c_index_constraint_eq.html) have
    no right-hand operand. The sqlite3_vtab_rhs_value() interface always returns [SQLITE_NOTFOUND](rescode.html#notfound)
    for such operators.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[sqlite3_vtab_rhs_value()](c3ref/vtab_rhs_value.html) 接口可用于尝试访问约束的右操作数。但是，在运行
    xBestIndex 方法时可能并不知道右操作数的值，因此 sqlite3_vtab_rhs_value() 调用可能不成功。通常情况下，约束的右操作数仅在输入
    SQL 中编码为文字值时才可用于 xBestIndex。如果右操作数被编码为表达式或 [主机参数](c3ref/bind_blob.html)，则 xBestIndex
    可能无法访问。某些操作符，如 [SQLITE_INDEX_CONSTRAINT_ISNULL](c3ref/c_index_constraint_eq.html)
    和 [SQLITE_INDEX_CONSTRAINT_ISNOTNULL](c3ref/c_index_constraint_eq.html)，没有右操作数。sqlite3_vtab_rhs_value()
    接口对于这类操作符总是返回 [SQLITE_NOTFOUND](rescode.html#notfound)。'
- en: 2.3.2\. Outputs
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2\. 输出
- en: Given all of the information above, the job of the xBestIndex method it to figure
    out the best way to search the virtual table.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上述所有信息，xBestIndex 方法的工作是找出搜索虚拟表的最佳方法。
- en: The xBestIndex method conveys an indexing strategy to the [xFilter](vtab.html#xfilter)
    method through the idxNum and idxStr fields. The idxNum value and idxStr string
    content are arbitrary as far as the SQLite core is concerned and can have any
    meaning as long as xBestIndex and xFilter agree on what that meaning is. The SQLite
    core just copies the information from xBestIndex through to the [xFilter](vtab.html#xfilter)
    method, assuming only that the char sequence referenced via idxStr is NUL terminated.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: xBestIndex 方法通过 idxNum 和 idxStr 字段向 [xFilter](vtab.html#xfilter) 方法传递索引策略。就
    SQLite 核心而言，idxNum 值和 idxStr 字符串内容是任意的，并且只要 xBestIndex 和 xFilter 在它们的含义上达成一致，可以有任何含义。SQLite
    核心只是简单地将信息从 xBestIndex 复制到 [xFilter](vtab.html#xfilter) 方法，假定 idxStr 引用的字符序列是以
    NUL 结尾的。
- en: The idxStr value may be a string obtained from an SQLite memory allocation function
    such as [sqlite3_mprintf()](c3ref/mprintf.html). If this is the case, then the
    needToFreeIdxStr flag must be set to true so that the SQLite core will know to
    call [sqlite3_free()](c3ref/free.html) on that string when it has finished with
    it, and thus avoid a memory leak. The idxStr value may also be a static constant
    string, in which case the needToFreeIdxStr boolean should remain false.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: idxStr 值可以是从 SQLite 内存分配函数（如 [sqlite3_mprintf()](c3ref/mprintf.html)）获得的字符串。如果是这种情况，则
    needToFreeIdxStr 标志必须设置为 true，以便 SQLite 核心在使用完后调用 [sqlite3_free()](c3ref/free.html)
    释放该字符串，避免内存泄漏。idxStr 值也可以是静态常量字符串，在这种情况下，needToFreeIdxStr 布尔值应保持 false。
- en: The estimatedCost field should be set to the estimated number of disk access
    operations required to execute this query against the virtual table. The SQLite
    core will often call xBestIndex multiple times with different constraints, obtain
    multiple cost estimates, then choose the query plan that gives the lowest estimate.
    The SQLite core initializes estimatedCost to a very large value prior to invoking
    xBestIndex, so if xBestIndex determines that the current combination of parameters
    is undesirable, it can leave the estimatedCost field unchanged to discourage its
    use.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: estimatedCost 字段应设置为执行该查询所需的估计磁盘访问操作数。SQLite 核心通常会多次调用 xBestIndex，使用不同的约束获取多个成本估算，然后选择给出最低估算的查询计划。SQLite
    核心在调用 xBestIndex 之前将 estimatedCost 初始化为一个非常大的值，因此如果 xBestIndex 确定当前参数组合不理想，它可以保持
    estimatedCost 字段不变，以阻止其使用。
- en: If the current version of SQLite is 3.8.2 or greater, the estimatedRows field
    may be set to an estimate of the number of rows returned by the proposed query
    plan. If this value is not explicitly set, the default estimate of 25 rows is
    used.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前的 SQLite 版本为 3.8.2 或更高，则 estimatedRows 字段可以设置为建议查询计划返回的行数的估算值。如果未显式设置此值，则使用默认的
    25 行估算。
- en: If the current version of SQLite is 3.9.0 or greater, the idxFlags field may
    be set to SQLITE_INDEX_SCAN_UNIQUE to indicate that the virtual table will return
    only zero or one rows given the input constraints. Additional bits of the idxFlags
    field might be understood in later versions of SQLite.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前SQLite版本为3.9.0或更高，则idxFlags字段可以设置为SQLITE_INDEX_SCAN_UNIQUE，表示虚拟表在给定输入约束条件时将仅返回零行或一行。在后续SQLite版本中，可能会理解idxFlags字段的附加位。
- en: The aConstraintUsage[] array contains one element for each of the nConstraint
    constraints in the inputs section of the [sqlite3_index_info](c3ref/index_info.html)
    structure. The aConstraintUsage[] array is used by xBestIndex to tell the core
    how it is using the constraints.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: aConstraintUsage[]数组包含[sqlite3_index_info](c3ref/index_info.html)结构中输入部分nConstraint个约束条件的每一个元素。aConstraintUsage[]数组被xBestIndex用来告诉核心它如何使用这些约束条件。
- en: The xBestIndex method may set aConstraintUsage[].argvIndex entries to values
    greater than zero. Exactly one entry should be set to 1, another to 2, another
    to 3, and so forth up to as many or as few as the xBestIndex method wants. The
    EXPR of the corresponding constraints will then be passed in as the argv[] parameters
    to xFilter.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: xBestIndex方法可以将aConstraintUsage[].argvIndex条目设置为大于零的值。应该将一个条目设置为1，另一个设置为2，再另一个设置为3，依此类推，直到xBestIndex方法想要的数量为止。相应约束条件的EXPR将作为argv[]参数传递给xFilter。
- en: For example, if the aConstraint[3].argvIndex is set to 1, then when xFilter
    is called, the argv[0] passed to xFilter will have the EXPR value of the aConstraint[3]
    constraint.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果aConstraint[3].argvIndex设置为1，则在调用xFilter时，传递给xFilter的argv[0]将具有aConstraint[3]约束的EXPR值。
- en: 2.3.2.1\. Omit constraint checking in bytecode
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.2.1\. 在字节码中省略约束检查
- en: 'By default, the SQLite generates [bytecode](opcode.html) that will double checks
    all constraints on each row of the virtual table to verify that they are satisfied.
    If the virtual table can guarantee that a constraint will always be satisfied,
    it can try to suppress that double-check by setting aConstraintUsage[].omit. However,
    with some exceptions, this is only a hint and there is no guarantee that the redundant
    check of the constraint will be suppressed. Key points:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，SQLite生成的[字节码](opcode.html)会对虚拟表的每一行进行双重检查，以验证它们是否满足所有约束条件。如果虚拟表能够保证某个约束条件始终得到满足，它可以尝试通过设置aConstraintUsage[].omit来抑制这种双重检查。然而，除了一些例外情况外，这只是一个提示，并不能保证会抑制约束条件的多余检查。重点如下：
- en: The omit flag is only honored if the argvIndex value for the constraint is greater
    than 0 and less than or equal to 16\. Constraint checking is never suppressed
    for constraints that do not pass their right operand into the xFilter method.
    The current implementation is only able to suppress redundant constraint checking
    for the first 16 values passed to xFilter, though that limitation might be increased
    in future releases.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有当约束条件的argvIndex值大于0且小于或等于16时，omit标志才会被尊重。对于未将右操作数传递到xFilter方法的约束条件，永远不会抑制约束检查。当前实现只能抑制传递给xFilter的前16个值的冗余约束检查，尽管这个限制可能会在未来的版本中增加。
- en: The omit flag is always honored for [SQLITE_INDEX_CONSTRAINT_OFFSET](c3ref/c_index_constraint_eq.html)
    constraints as long as argvIndex is greater than 0\. Setting the omit flag on
    an SQLITE_INDEX_CONSTRAINT_OFFSET constraint indicates to SQLite that the virtual
    table will itself suppress the first N rows of output, where N is the right operand
    of the OFFSET operator. If the virtual table implementation sets omit on an SQLITE_INDEX_CONSTRAINT_OFFSET
    constraint but then fails to suppress the first N rows of output, an incorrect
    answer will result from the overall query.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只要argvIndex大于0，就始终尊重[SQLITE_INDEX_CONSTRAINT_OFFSET](c3ref/c_index_constraint_eq.html)约束的omit标志。在SQLITE_INDEX_CONSTRAINT_OFFSET约束上设置omit标志表示SQLite将自行抑制输出的前N行，其中N是OFFSET运算符的右操作数。如果虚拟表实现在SQLITE_INDEX_CONSTRAINT_OFFSET约束上设置omit，但未能抑制输出的前N行，则整体查询将产生不正确的结果。
- en: 2.3.2.2\. ORDER BY and orderByConsumed
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.2.2\. ORDER BY和orderByConsumed
- en: If the virtual table will output rows in the order specified by the ORDER BY
    clause, then the orderByConsumed flag may be set to true. If the output is not
    automatically in the correct order then orderByConsumed must be left in its default
    false setting. This will indicate to the SQLite core that it will need to do a
    separate sorting pass over the data after it comes out of the virtual table. Setting
    orderByConsumed is an optimization. A query will always get the correct answer
    if orderByConsumed is left at its default value (0). Unnecessary sort operations
    might be avoided resulting in a faster query if orderByConsumed is set, but setting
    orderByConsumed incorrectly can result in an incorrect answer. It is suggested
    that new virtual table implementations leave the orderByConsumed value unset initially,
    and then after everything else is known to be working correctly, go back and attempt
    to optimize by setting orderByConsumed where appropriate.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果虚拟表将按 ORDER BY 子句指定的顺序输出行，则可以将 orderByConsumed 标志设置为 true。如果输出不自动按正确顺序，则必须将
    orderByConsumed 保留在其默认 false 设置中。这将告知 SQLite 核心在虚拟表输出后需要对数据进行单独的排序处理。设置 orderByConsumed
    是一种优化。如果将 orderByConsumed 设置为其默认值（0），则查询将始终获得正确答案。如果设置 orderByConsumed 不正确，则可能导致错误答案。建议新的虚拟表实现在最初未设置
    orderByConsumed 的值，然后在确认一切正常工作后，根据需要返回并尝试优化设置 orderByConsumed。
- en: Sometimes the orderByConsumed flag can be safely set even if the outputs from
    the virtual table are not strictly in the order specified by nOrderBy and aOrderBy.
    If the [sqlite3_vtab_distinct()](c3ref/vtab_distinct.html) interface returns 1
    or 2, that indicates that the ordering can be relaxed. See the documentation on
    [sqlite3_vtab_distinct()](c3ref/vtab_distinct.html) for further information.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 有时即使虚拟表的输出与 nOrderBy 和 aOrderBy 指定的顺序不完全相符，也可以安全地设置 orderByConsumed 标志。如果 [sqlite3_vtab_distinct()](c3ref/vtab_distinct.html)
    接口返回 1 或 2，则表示可以放宽排序。有关详细信息，请参阅关于 [sqlite3_vtab_distinct()](c3ref/vtab_distinct.html)
    的文档。
- en: 2.3.3\. Return Value
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.3\. 返回值
- en: 'The xBestIndex method should return SQLITE_OK on success. If any kind of fatal
    error occurs, an appropriate error code (ex: [SQLITE_NOMEM](rescode.html#nomem))
    should be returned instead.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: xBestIndex 方法应在成功时返回 SQLITE_OK。如果发生任何致命错误，则应返回适当的错误代码（例如：[SQLITE_NOMEM](rescode.html#nomem)）。
- en: If xBestIndex returns [SQLITE_CONSTRAINT](rescode.html#constraint), that does
    not indicate an error. Rather, SQLITE_CONSTRAINT indicates that the particular
    combination of input parameters specified is insufficient for the virtual table
    to do its job. This is logically the same as setting the estimatedCost to infinity.
    If every call to xBestIndex for a particular query plan returns SQLITE_CONSTRAINT,
    that means there is no way for the virtual table to be safely used, and the [sqlite3_prepare()](c3ref/prepare.html)
    call will fail with a "no query solution" error.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 xBestIndex 返回 [SQLITE_CONSTRAINT](rescode.html#constraint)，这并不表示错误。相反，SQLITE_CONSTRAINT
    表示指定的输入参数组合对虚拟表执行其工作是不足的。从逻辑上讲，这与将 estimatedCost 设置为无穷大是相同的。如果针对特定查询计划的每次 xBestIndex
    调用都返回 SQLITE_CONSTRAINT，则表示无法安全使用虚拟表，并且 [sqlite3_prepare()](c3ref/prepare.html)
    调用将因“无查询解决方案”错误而失败。
- en: 2.3.4\. Enforcing Required Parameters On Table-Valued Functions
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.4\. 强制对表值函数进行必需参数的执行
- en: 'The SQLITE_CONSTRAINT return from xBestIndex is useful for [table-valued functions](vtab.html#tabfunc2)
    that have required parameters. If the aConstraint[].usable field is false for
    one of the required parameter, then the xBestIndex method should return SQLITE_CONSTRAINT.
    If a required field does not appear in the aConstraint[] array at all, that means
    that the corresponding parameter is omitted from the input SQL. In that case,
    xBestIndex should set an error message in pVTab->zErrMsg and return SQLITE_ERROR.
    To summarize:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: xBestIndex 返回的 SQLITE_CONSTRAINT 对于具有必需参数的 [表值函数](vtab.html#tabfunc2) 非常有用。如果一个必需参数的
    aConstraint[].usable 字段为 false，则 xBestIndex 方法应返回 SQLITE_CONSTRAINT。如果某个必需字段在
    aConstraint[] 数组中根本不存在，则意味着输入 SQL 中省略了相应的参数。在这种情况下，xBestIndex 应在 pVTab->zErrMsg
    中设置错误消息并返回 SQLITE_ERROR。总结一下：
- en: The aConstraint[].usable value for a required parameter is false → return SQLITE_CONSTRAINT.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于必需的参数，aConstraint[].usable 值为 false → 返回 SQLITE_CONSTRAINT。
- en: A required parameter does not appears anywhere in the aConstraint[] array →
    Set an error message in pVTab->zErrMsg and return SQLITE_ERROR
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果必需的参数在 aConstraint[] 数组中根本没有出现 → 在 pVTab->zErrMsg 中设置错误消息并返回 SQLITE_ERROR。
- en: 'The following example will better illustrate the use of SQLITE_CONSTRAINT as
    a return value from xBestIndex:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例将更好地说明从xBestIndex返回SQLITE_CONSTRAINT作为返回值的用法：
- en: '[PRE24]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Assuming that the first hidden column of "tablevaluedfunc" is "param1", the
    query above is semantically equivalent to this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 假设"tablevaluedfunc"的第一个隐藏列是"param1"，则上面的查询在语义上等同于这个查询：
- en: '[PRE25]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The query planner must decide between many possible implementations of this
    query, but two plans in particular are of note:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 查询规划器必须在此查询的多种可能实现之间做出选择，但特别注意的是有两个计划：
- en: Scan all rows of realtab and for each row, find rows in tablevaluedfunc where
    param1 is equal to realtab.x
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扫描realtab的所有行，并对每一行，在tablevaluedfunc中找到param1等于realtab.x
- en: Scan all rows of tablevalued func and for each row find rows in realtab where
    x is equal to tablevaluedfunc.param1.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扫描tablevaluedfunc的所有行，并对每一行在realtab中找到x等于tablevaluedfunc.param1的行。
- en: The xBestIndex method will be invoked once for each of the potential plans above.
    For plan 1, the aConstraint[].usable flag for the SQLITE_CONSTRAINT_EQ constraint
    on the param1 column will be true because the right-hand side value for the "param1
    = ?" constraint will be known, since it is determined by the outer realtab loop.
    But for plan 2, the aConstraint[].usable flag for "param1 = ?" will be false because
    the right-hand side value is determined by an inner loop and is thus an unknown
    quantity. Because param1 is a required input to the table-valued functions, the
    xBestIndex method should return SQLITE_CONSTRAINT when presented with plan 2,
    indicating that a required input is missing. This forces the query planner to
    select plan 1.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: xBestIndex方法将为上述每个潜在的计划调用一次。对于计划1，对param1列的SQLITE_CONSTRAINT_EQ约束条件的aConstraint[].usable标志将为true，因为"param1
    = ?"约束条件的右侧值将是已知的，因为它由外部realtab循环确定。但对于计划2，"param1 = ?"的aConstraint[].usable标志将为false，因为右侧值是由内部循环确定的，因此是一个未知量。因为param1是表值函数的必需输入，所以xBestIndex方法在提供计划2时应返回SQLITE_CONSTRAINT，表示缺少必需的输入。这迫使查询规划器选择计划1。
- en: 2.4\. The xDisconnect Method
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4\. xDisconnect方法
- en: '[PRE26]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This method releases a connection to a virtual table. Only the [sqlite3_vtab](c3ref/vtab.html)
    object is destroyed. The virtual table is not destroyed and any backing store
    associated with the virtual table persists. This method undoes the work of [xConnect](vtab.html#xconnect).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法释放了对虚拟表的连接。只有[sqlite3_vtab](c3ref/vtab.html)对象被销毁。虚拟表不会被销毁，与虚拟表关联的任何后备存储仍然存在。这种方法撤销了[xConnect](vtab.html#xconnect)的工作。
- en: This method is a destructor for a connection to the virtual table. Contrast
    this method with [xDestroy](vtab.html#sqlite3_module.xDestroy). The xDestroy is
    a destructor for the entire virtual table.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法是对虚拟表连接的析构函数。与[xDestroy](vtab.html#sqlite3_module.xDestroy)方法相比，这种方法有所不同。xDestroy是整个虚拟表的析构函数。
- en: The xDisconnect method is required for every virtual table implementation, though
    it is acceptable for the xDisconnect and [xDestroy](vtab.html#sqlite3_module.xDestroy)
    methods to be the same function if that makes sense for the particular virtual
    table.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 每个虚拟表实现都需要xDisconnect方法，尽管xDisconnect和[xDestroy](vtab.html#sqlite3_module.xDestroy)方法可以是同一个函数，如果对特定的虚拟表有意义的话。
- en: 2.5\. The xDestroy Method
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5\. xDestroy方法
- en: '[PRE27]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This method releases a connection to a virtual table, just like the [xDisconnect](vtab.html#xdisconnect)
    method, and it also destroys the underlying table implementation. This method
    undoes the work of [xCreate](vtab.html#xcreate).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法释放了对虚拟表的连接，就像[xDisconnect](vtab.html#xdisconnect)方法一样，并销毁了底层表的实现。这种方法撤销了[xCreate](vtab.html#xcreate)的工作。
- en: The [xDisconnect](vtab.html#xdisconnect) method is called whenever a database
    connection that uses a virtual table is closed. The xDestroy method is only called
    when a [DROP TABLE](lang_droptable.html) statement is executed against the virtual
    table.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用虚拟表的数据库连接关闭时，会调用[xDisconnect](vtab.html#xdisconnect)方法。只有在执行[DROP TABLE](lang_droptable.html)语句来删除虚拟表时才会调用xDestroy方法。
- en: The xDestroy method is required for every virtual table implementation, though
    it is acceptable for the [xDisconnect](vtab.html#xdisconnect) and xDestroy methods
    to be the same function if that makes sense for the particular virtual table.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 每个虚拟表实现都需要xDestroy方法，尽管[xDisconnect](vtab.html#xdisconnect)和xDestroy方法可以是同一个函数，如果对特定的虚拟表有意义的话。
- en: 2.6\. The xOpen Method
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.6\. xOpen方法
- en: '[PRE28]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The xOpen method creates a new cursor used for accessing (read and/or writing)
    a virtual table. A successful invocation of this method will allocate the memory
    for the [sqlite3_vtab_cursor](c3ref/vtab_cursor.html) (or a subclass), initialize
    the new object, and make *ppCursor point to the new object. The successful call
    then returns [SQLITE_OK](rescode.html#ok).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 xOpen 创建一个用于访问（读和/或写）虚拟表的新游标。此方法的成功调用将为 [sqlite3_vtab_cursor](c3ref/vtab_cursor.html)（或其子类）分配内存，初始化新对象，并使
    *ppCursor 指向新对象。成功的调用然后返回 [SQLITE_OK](rescode.html#ok)。
- en: For every successful call to this method, the SQLite core will later invoke
    the [xClose](vtab.html#xclose) method to destroy the allocated cursor.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此方法的每次成功调用，SQLite 核心随后将调用 [xClose](vtab.html#xclose) 方法来销毁分配的游标。
- en: The xOpen method need not initialize the pVtab field of the [sqlite3_vtab_cursor](c3ref/vtab_cursor.html)
    structure. The SQLite core will take care of that chore automatically.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 xOpen 不需要初始化 [sqlite3_vtab_cursor](c3ref/vtab_cursor.html) 结构体的 pVtab 字段。SQLite
    核心会自动处理这一任务。
- en: A virtual table implementation must be able to support an arbitrary number of
    simultaneously open cursors.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟表实现必须能够支持任意数量的同时打开的游标。
- en: When initially opened, the cursor is in an undefined state. The SQLite core
    will invoke the [xFilter](vtab.html#xfilter) method on the cursor prior to any
    attempt to position or read from the cursor.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 初始打开时，游标处于未定义状态。SQLite 核心将在尝试定位或读取游标之前立即调用游标上的 [xFilter](vtab.html#xfilter)
    方法。
- en: The xOpen method is required for every virtual table implementation.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 xOpen 是每个虚拟表实现所必需的。
- en: 2.7\. The xClose Method
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.7\. 方法 xClose
- en: '[PRE29]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The xClose method closes a cursor previously opened by [xOpen](vtab.html#xopen).
    The SQLite core will always call xClose once for each cursor opened using xOpen.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 xClose 关闭先前由 [xOpen](vtab.html#xopen) 打开的游标。SQLite 核心将始终对使用 xOpen 打开的每个游标调用一次
    xClose。
- en: This method must release all resources allocated by the corresponding xOpen
    call. The routine will not be called again even if it returns an error. The SQLite
    core will not use the [sqlite3_vtab_cursor](c3ref/vtab_cursor.html) again after
    it has been closed.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法必须释放由相应 xOpen 调用分配的所有资源。即使返回错误，也不会再次调用该例程。SQLite 核心在关闭后不会再次使用 [sqlite3_vtab_cursor](c3ref/vtab_cursor.html)。
- en: The xClose method is required for every virtual table implementation.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 xClose 是每个虚拟表实现所必需的。
- en: 2.8\. The xEof Method
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.8\. 方法 xEof
- en: '[PRE30]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The xEof method must return false (zero) if the specified cursor currently points
    to a valid row of data, or true (non-zero) otherwise. This method is called by
    the SQL engine immediately after each [xFilter](vtab.html#xfilter) and [xNext](vtab.html#xnext)
    invocation.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 xEof 必须在指定的游标当前指向有效数据行时返回 false（零），否则返回 true（非零）。此方法在每次 [xFilter](vtab.html#xfilter)
    和 [xNext](vtab.html#xnext) 调用后由 SQL 引擎立即调用。
- en: The xEof method is required for every virtual table implementation.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 xEof 是每个虚拟表实现所必需的。
- en: 2.9\. The xFilter Method
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.9\. 方法 xFilter
- en: '[PRE31]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This method begins a search of a virtual table. The first argument is a cursor
    opened by [xOpen](vtab.html#xopen). The next two arguments define a particular
    search index previously chosen by [xBestIndex](vtab.html#xbestindex). The specific
    meanings of idxNum and idxStr are unimportant as long as xFilter and xBestIndex
    agree on what that meaning is.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法开始对虚拟表的搜索。第一个参数是由 [xOpen](vtab.html#xopen) 打开的游标。接下来的两个参数定义了先前由 [xBestIndex](vtab.html#xbestindex)
    选择的特定搜索索引。idxNum 和 idxStr 的具体含义不重要，只要 xFilter 和 xBestIndex 对此含义达成一致即可。
- en: The xBestIndex function may have requested the values of certain expressions
    using the aConstraintUsage[].argvIndex values of the [sqlite3_index_info](c3ref/index_info.html)
    structure. Those values are passed to xFilter using the argc and argv parameters.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 xBestIndex 可能已经使用 [sqlite3_index_info](c3ref/index_info.html) 结构体的 aConstraintUsage[].argvIndex
    值请求了某些表达式的值。这些值通过 argc 和 argv 参数传递给 xFilter。
- en: If the virtual table contains one or more rows that match the search criteria,
    then the cursor must be left point at the first row. Subsequent calls to [xEof](vtab.html#xeof)
    must return false (zero). If there are no rows match, then the cursor must be
    left in a state that will cause the [xEof](vtab.html#xeof) to return true (non-zero).
    The SQLite engine will use the [xColumn](vtab.html#xcolumn) and [xRowid](vtab.html#xrowid)
    methods to access that row content. The [xNext](vtab.html#xnext) method will be
    used to advance to the next row.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果虚拟表包含一个或多个符合搜索条件的行，则游标必须指向第一行。后续对 [xEof](vtab.html#xeof) 的调用必须返回 false（零）。如果没有匹配的行，则游标必须处于使得
    [xEof](vtab.html#xeof) 返回 true（非零）的状态。SQLite 引擎将使用 [xColumn](vtab.html#xcolumn)
    和 [xRowid](vtab.html#xrowid) 方法访问该行内容。[xNext](vtab.html#xnext) 方法用于前进到下一行。
- en: This method must return [SQLITE_OK](rescode.html#ok) if successful, or an sqlite
    [error code](rescode.html) if an error occurs.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，此方法必须返回 [SQLITE_OK](rescode.html#ok)，如果发生错误，则返回 sqlite [error code](rescode.html)。
- en: The xFilter method is required for every virtual table implementation.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: xFilter 方法是每个虚拟表实现所必需的。
- en: 2.10\. The xNext Method
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.10\. xNext 方法
- en: '[PRE32]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The xNext method advances a [virtual table cursor](c3ref/vtab_cursor.html) to
    the next row of a result set initiated by [xFilter](vtab.html#xfilter). If the
    cursor is already pointing at the last row when this routine is called, then the
    cursor no longer points to valid data and a subsequent call to the [xEof](vtab.html#xeof)
    method must return true (non-zero). If the cursor is successfully advanced to
    another row of content, then subsequent calls to [xEof](vtab.html#xeof) must return
    false (zero).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: xNext 方法将 [虚拟表游标](c3ref/vtab_cursor.html) 前进到由 [xFilter](vtab.html#xfilter)
    初始化的结果集的下一行。如果在调用此例程时游标已经指向最后一行，则游标不再指向有效数据，后续对 [xEof](vtab.html#xeof) 方法的调用必须返回
    true（非零）。如果成功将游标前进到另一行内容，则后续对 [xEof](vtab.html#xeof) 的调用必须返回 false（零）。
- en: This method must return [SQLITE_OK](rescode.html#ok) if successful, or an sqlite
    [error code](rescode.html) if an error occurs.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，此方法必须返回 [SQLITE_OK](rescode.html#ok)，如果发生错误，则返回 sqlite [error code](rescode.html)。
- en: The xNext method is required for every virtual table implementation.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: xNext 方法是每个虚拟表实现所必需的。
- en: 2.11\. The xColumn Method
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.11\. xColumn 方法
- en: '[PRE33]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The SQLite core invokes this method in order to find the value for the N-th
    column of the current row. N is zero-based so the first column is numbered 0\.
    The xColumn method may return its result back to SQLite using one of the following
    interface:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 核心调用此方法以查找当前行第 N 列的值。N 是从零开始的，因此第一列编号为 0。xColumn 方法可以使用以下接口将其结果返回给 SQLite：
- en: '[sqlite3_result_blob()](c3ref/result_blob.html)'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[sqlite3_result_blob()](c3ref/result_blob.html)'
- en: '[sqlite3_result_double()](c3ref/result_blob.html)'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[sqlite3_result_double()](c3ref/result_blob.html)'
- en: '[sqlite3_result_int()](c3ref/result_blob.html)'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[sqlite3_result_int()](c3ref/result_blob.html)'
- en: '[sqlite3_result_int64()](c3ref/result_blob.html)'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[sqlite3_result_int64()](c3ref/result_blob.html)'
- en: '[sqlite3_result_null()](c3ref/result_blob.html)'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[sqlite3_result_null()](c3ref/result_blob.html)'
- en: '[sqlite3_result_text()](c3ref/result_blob.html)'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[sqlite3_result_text()](c3ref/result_blob.html)'
- en: '[sqlite3_result_text16()](c3ref/result_blob.html)'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[sqlite3_result_text16()](c3ref/result_blob.html)'
- en: '[sqlite3_result_text16le()](c3ref/result_blob.html)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[sqlite3_result_text16le()](c3ref/result_blob.html)'
- en: '[sqlite3_result_text16be()](c3ref/result_blob.html)'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[sqlite3_result_text16be()](c3ref/result_blob.html)'
- en: '[sqlite3_result_zeroblob()](c3ref/result_blob.html)'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[sqlite3_result_zeroblob()](c3ref/result_blob.html)'
- en: If the xColumn method implementation calls none of the functions above, then
    the value of the column defaults to an SQL NULL.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 xColumn 方法实现未调用上述任何函数，则列的值默认为 SQL NULL。
- en: To raise an error, the xColumn method should use one of the result_text() methods
    to set the error message text, then return an appropriate [error code](rescode.html).
    The xColumn method must return [SQLITE_OK](rescode.html#ok) on success.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要引发错误，xColumn 方法应使用 result_text() 方法之一设置错误消息文本，然后返回适当的 [error code](rescode.html)。xColumn
    方法在成功时必须返回 [SQLITE_OK](rescode.html#ok)。
- en: The xColumn method is required for every virtual table implementation.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: xColumn 方法是每个虚拟表实现所必需的。
- en: 2.12\. The xRowid Method
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.12\. xRowid 方法
- en: '[PRE34]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: A successful invocation of this method will cause *pRowid to be filled with
    the [rowid](lang_createtable.html#rowid) of row that the [virtual table cursor](c3ref/vtab_cursor.html)
    pCur is currently pointing at. This method returns [SQLITE_OK](rescode.html#ok)
    on success. It returns an appropriate [error code](rescode.html) on failure.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 成功调用此方法将导致*pRowid被填充为虚拟表游标`pCur`当前指向的行的[rowid](lang_createtable.html#rowid)。此方法在成功时返回[SQLITE_OK](rescode.html#ok)，在失败时返回适当的[错误代码](rescode.html)。
- en: The xRowid method is required for every virtual table implementation.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 每个虚拟表实现都需要`xRowid`方法。
- en: 2.13\. The xUpdate Method
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.13\. `xUpdate`方法
- en: '[PRE35]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: All changes to a virtual table are made using the xUpdate method. This one method
    can be used to insert, delete, or update.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 所有对虚拟表的更改都使用`xUpdate`方法进行。这个方法可以用来插入、删除或更新。
- en: The argc parameter specifies the number of entries in the argv array. The value
    of argc will be 1 for a pure delete operation or N+2 for an insert or replace
    or update where N is the number of columns in the table. In the previous sentence,
    N includes any hidden columns.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: argc参数指定argv数组中的条目数。对于纯删除操作，argc的值为1，对于插入或替换或更新操作，argc的值为N+2，其中N是表中的列数。在前一句中，N包括任何隐藏列。
- en: Every argv entry will have a non-NULL value in C but may contain the SQL value
    NULL. In other words, it is always true that `argv[i]!=0` for **i** between 0
    and `argc-1`. However, it might be the case that `sqlite3_value_type(argv[i])==SQLITE_NULL`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 每个argv条目在C中都将具有非NULL值，但可能包含SQL值NULL。换句话说，对于所有`i`在0到`argc-1`之间，`argv[i]!=0`总是成立。但是，可能会出现`sqlite3_value_type(argv[i])==SQLITE_NULL`的情况。
- en: The argv[0] parameter is the [rowid](lang_createtable.html#rowid) of a row in
    the virtual table to be deleted. If argv[0] is an SQL NULL, then no deletion occurs.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`argv[0]`参数是要删除的虚拟表中行的[rowid](lang_createtable.html#rowid)。如果`argv[0]`是SQL
    NULL，则不会进行删除操作。'
- en: The argv[1] parameter is the rowid of a new row to be inserted into the virtual
    table. If argv[1] is an SQL NULL, then the implementation must choose a rowid
    for the newly inserted row. Subsequent argv[] entries contain values of the columns
    of the virtual table, in the order that the columns were declared. The number
    of columns will match the table declaration that the [xConnect](vtab.html#xconnect)
    or [xCreate](vtab.html#xcreate) method made using the [sqlite3_declare_vtab()](c3ref/declare_vtab.html)
    call. All hidden columns are included.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`argv[1]`参数是要插入到虚拟表中的新行的rowid。如果`argv[1]`是SQL NULL，则实现必须为新插入的行选择一个rowid。随后的argv[]条目包含虚拟表列的值，按照声明这些列的顺序进行排列。列数将与使用[sqlite3_declare_vtab()](c3ref/declare_vtab.html)调用的表声明匹配。所有隐藏列都包括在内。'
- en: When doing an insert without a rowid (argc>1, argv[1] is an SQL NULL), on a
    virtual table that uses ROWID (but not on a [WITHOUT ROWID virtual table](vtab.html#worid)),
    the implementation must set *pRowid to the rowid of the newly inserted row; this
    will become the value returned by the [sqlite3_last_insert_rowid()](c3ref/last_insert_rowid.html)
    function. Setting this value in all the other cases is a harmless no-op; the SQLite
    engine ignores the *pRowid return value if argc==1 or argv[1] is not an SQL NULL.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有rowid插入（argc>1，argv[1]是SQL NULL）的情况下，在使用ROWID的虚拟表上（但不是在[WITHOUT ROWID虚拟表](vtab.html#worid)上），实现必须将*pRowid设置为新插入行的rowid；这将成为[sqlite3_last_insert_rowid()](c3ref/last_insert_rowid.html)函数返回的值。在所有其他情况下设置此值都是无害的操作；如果argc==1或argv[1]不是SQL
    NULL，则SQLite引擎会忽略*pRowid返回值。
- en: Each call to xUpdate will fall into one of cases shown below. Not that references
    to **argv[i]** mean the SQL value held within the argv[i] object, not the argv[i]
    object itself.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用xUpdate都将落入下面显示的一种情况。请注意，对**argv[i]**的引用意味着argv[i]对象内包含的SQL值，而不是argv[i]对象本身。
- en: '**argc = 1'
  id: totrans-267
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**`argc = 1`'
- en: argv[0] ≠ NULL**
  id: totrans-268
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`argv[0] ≠ NULL**`'
- en: ''
  id: totrans-269
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'DELETE: The single row with rowid or PRIMARY KEY equal to argv[0] is deleted.
    No insert occurs.'
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: DELETE：删除具有与argv[0]相等的rowid或主键的单行。不进行插入。
- en: ''
  id: totrans-271
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**argc > 1'
  id: totrans-272
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**`argc > 1`'
- en: argv[0] = NULL**
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`argv[0] = NULL**`'
- en: ''
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'INSERT: A new row is inserted with column values taken from argv[2] and following.
    In a rowid virtual table, if argv[1] is an SQL NULL, then a new unique rowid is
    generated automatically. The argv[1] will be NULL for a [WITHOUT ROWID virtual
    table](vtab.html#worid), in which case the implementation should take the PRIMARY
    KEY value from the appropriate column in argv[2] and following.'
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 插入：使用从 argv[2] 和之后获取的列值插入新行。在 rowid 虚拟表中，如果 argv[1] 是 SQL NULL，则会自动生成新的唯一 rowid。对于[无
    rowid 虚拟表](vtab.html#worid)，argv[1] 将为 NULL，在这种情况下，实现应从 argv[2] 和之后的适当列中获取主键值。
- en: ''
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**argc > 1'
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**argc > 1'
- en: argv[0] ≠ NULL
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`argv[0] ≠ NULL'
- en: argv[0] = argv[1]**
  id: totrans-279
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`argv[0] = argv[1]**'
- en: ''
  id: totrans-280
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'UPDATE: The row with rowid or PRIMARY KEY argv[0] is updated with new values
    in argv[2] and following parameters.'
  id: totrans-281
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 更新：使用 argv[0] 中的 rowid 或主键更新为 argv[2] 和之后的新值参数。
- en: ''
  id: totrans-282
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**argc > 1'
  id: totrans-283
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**argc > 1'
- en: argv[0] ≠ NULL
  id: totrans-284
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`argv[0] ≠ NULL'
- en: argv[0] ≠ argv[1]**
  id: totrans-285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`argv[0] ≠ argv[1]**'
- en: ''
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'UPDATE with rowid or PRIMARY KEY change: The row with rowid or PRIMARY KEY
    argv[0] is updated with the rowid or PRIMARY KEY in argv[1] and new values in
    argv[2] and following parameters. This will occur when an SQL statement updates
    a rowid, as in the statement:'
  id: totrans-287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 更新带有 rowid 或主键更改：使用 argv[0] 中的 rowid 或主键更新为 argv[1] 中的 rowid 或主键以及 argv[2] 和之后的新值参数。这将发生在
    SQL 语句更新行id 的情况下，如下所示：
- en: ''
  id: totrans-288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[UPDATE](lang_update.html) table SET rowid=rowid+1 WHERE ...;'
  id: totrans-289
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[更新](lang_update.html) 表 SET rowid=rowid+1 WHERE ...;'
- en: The xUpdate method must return [SQLITE_OK](rescode.html#ok) if and only if it
    is successful. If a failure occurs, the xUpdate must return an appropriate [error
    code](rescode.html). On a failure, the pVTab->zErrMsg element may optionally be
    replaced with error message text stored in memory allocated from SQLite using
    functions such as [sqlite3_mprintf()](c3ref/mprintf.html) or [sqlite3_malloc()](c3ref/free.html).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 xUpdate 方法成功，则必须返回 [SQLITE_OK](rescode.html#ok)。如果发生故障，则 xUpdate 必须返回适当的
    [错误代码](rescode.html)。在失败时，可以选择将 pVTab->zErrMsg 元素替换为使用类似 [sqlite3_mprintf()](c3ref/mprintf.html)
    或 [sqlite3_malloc()](c3ref/free.html) 从 SQLite 分配的内存中存储的错误消息文本。
- en: If the xUpdate method violates some constraint of the virtual table (including,
    but not limited to, attempting to store a value of the wrong datatype, attempting
    to store a value that is too large or too small, or attempting to change a read-only
    value) then the xUpdate must fail with an appropriate [error code](rescode.html).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 xUpdate 方法违反虚拟表的某些约束（包括但不限于尝试存储错误数据类型的值、尝试存储过大或过小的值、或尝试更改只读值），则 xUpdate 必须使用适当的
    [错误代码](rescode.html) 失败。
- en: If the xUpdate method is performing an UPDATE, then [sqlite3_value_nochange(X)](c3ref/value_blob.html)
    can be used to discover which columns of the virtual table were actually modified
    by the UPDATE statement. The [sqlite3_value_nochange(X)](c3ref/value_blob.html)
    interface returns true for columns that do not change. On every UPDATE, SQLite
    will first invoke [xColumn](vtab.html#xcolumn) separately for each unchanging
    column in the table to obtain the value for that column. The [xColumn](vtab.html#xcolumn)
    method can check to see if the column is unchanged at the SQL level by invoking
    [sqlite3_vtab_nochange()](c3ref/vtab_nochange.html). If [xColumn](vtab.html#xcolumn)
    sees that the column is not being modified, it should return without setting a
    result using one of the [sqlite3_result_xxxxx()](c3ref/result_blob.html) interfaces.
    Only in that case [sqlite3_value_nochange()](c3ref/value_blob.html) will be true
    within the xUpdate method. If [xColumn](vtab.html#xcolumn) does invoke one or
    more [sqlite3_result_xxxxx()](c3ref/result_blob.html) interfaces, then SQLite
    understands that as a change in the value of the column and the [sqlite3_value_nochange()](c3ref/value_blob.html)
    call for that column within xUpdate will return false.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 xUpdate 方法正在执行更新操作，则可以使用 [sqlite3_value_nochange(X)](c3ref/value_blob.html)
    来发现虚拟表中哪些列实际上被更新语句修改了。 [sqlite3_value_nochange(X)](c3ref/value_blob.html) 接口对于不变的列返回
    true。在每次更新时，SQLite 首先为表中每个未更改的列分别调用 [xColumn](vtab.html#xcolumn) 以获取该列的值。 [xColumn](vtab.html#xcolumn)
    方法可以通过调用 [sqlite3_vtab_nochange()](c3ref/vtab_nochange.html) 来检查SQL级别上是否未更改该列。如果
    [xColumn](vtab.html#xcolumn) 发现列未被修改，则应返回而不使用 [sqlite3_result_xxxxx()](c3ref/result_blob.html)
    接口设置结果。只有在这种情况下，xUpdate 方法内部的 [sqlite3_value_nochange()](c3ref/value_blob.html)
    才会返回 true。如果 [xColumn](vtab.html#xcolumn) 调用了一个或多个 [sqlite3_result_xxxxx()](c3ref/result_blob.html)
    接口，则SQLite会理解为列值的更改，而 xUpdate 方法内部对该列的 [sqlite3_value_nochange()](c3ref/value_blob.html)
    调用将返回 false。
- en: There might be one or more [sqlite3_vtab_cursor](c3ref/vtab_cursor.html) objects
    open and in use on the virtual table instance and perhaps even on the row of the
    virtual table when the xUpdate method is invoked. The implementation of xUpdate
    must be prepared for attempts to delete or modify rows of the table out from other
    existing cursors. If the virtual table cannot accommodate such changes, the xUpdate
    method must return an [error code](rescode.html).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟表实例上和在虚拟表的行上可能会有一个或多个[sqlite3_vtab_cursor](c3ref/vtab_cursor.html)对象处于打开和使用状态，当调用xUpdate方法时。在实现xUpdate方法时，必须准备好处理来自其他现有游标的删除或修改表行的尝试。如果虚拟表无法适应这些更改，则xUpdate方法必须返回一个[错误代码](rescode.html)。
- en: The xUpdate method is optional. If the xUpdate pointer in the [sqlite3_module](c3ref/module.html)
    for a virtual table is a NULL pointer, then the virtual table is read-only.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: xUpdate方法是可选的。如果虚拟表在[sqlite3_module](c3ref/module.html)中的xUpdate指针是空指针，则该虚拟表是只读的。
- en: 2.14\. The xFindFunction Method
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.14\. xFindFunction 方法
- en: '[PRE36]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This method is called during [sqlite3_prepare()](c3ref/prepare.html) to give
    the virtual table implementation an opportunity to overload functions. This method
    may be set to NULL in which case no overloading occurs.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法在[sqlite3_prepare()](c3ref/prepare.html)期间调用，以使虚拟表实现有机会重载函数。如果此方法被设置为NULL，则不会进行重载。
- en: 'When a function uses a column from a virtual table as its first argument, this
    method is called to see if the virtual table would like to overload the function.
    The first three parameters are inputs: the virtual table, the number of arguments
    to the function, and the name of the function. If no overloading is desired, this
    method returns 0\. To overload the function, this method writes the new function
    implementation into *pxFunc and writes user data into *ppArg and returns either
    1 or a number between [SQLITE_INDEX_CONSTRAINT_FUNCTION](c3ref/c_index_constraint_eq.html)
    and 255.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数将虚拟表的列作为其第一个参数时，将调用此方法以查看虚拟表是否希望重载该函数。前三个参数是输入：虚拟表、函数的参数数目和函数的名称。如果不希望进行重载，则此方法返回0。要重载函数，此方法将新函数实现写入*pxFunc，并将用户数据写入*ppArg，并返回1或介于[SQLITE_INDEX_CONSTRAINT_FUNCTION](c3ref/c_index_constraint_eq.html)和255之间的数字。
- en: Historically, the return value from xFindFunction() was either zero or one.
    Zero means that the function is not overloaded and one means that it is overload.
    The ability to return values of [SQLITE_INDEX_CONSTRAINT_FUNCTION](c3ref/c_index_constraint_eq.html)
    or greater was added in version 3.25.0 (2018-09-15). If xFindFunction returns
    [SQLITE_INDEX_CONSTRAINT_FUNCTION](c3ref/c_index_constraint_eq.html) or greater,
    than means that the function takes two arguments and the function can be used
    as a boolean in the WHERE clause of a query and that the virtual table is able
    to exploit that function to speed up the query result. When xFindFunction returns
    [SQLITE_INDEX_CONSTRAINT_FUNCTION](c3ref/c_index_constraint_eq.html) or larger,
    the value returned becomes the [sqlite3_index_info](c3ref/index_info.html).aConstraint.op
    value for one of the constraints passed into [xBestIndex()](vtab.html#xbestindex).
    The first argument to the function is the column identified by aConstraint[].iColumn
    field of the constraint and the second argument to the function is the value that
    will be passed into [xFilter()](vtab.html#xfilter) (if the aConstraintUsage[].argvIndex
    value is set) or the value returned from [sqlite3_vtab_rhs_value()](c3ref/vtab_rhs_value.html).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，xFindFunction()的返回值只能是零或一。零表示函数未重载，一表示已重载。从版本3.25.0（2018-09-15）开始，可以返回[SQLITE_INDEX_CONSTRAINT_FUNCTION](c3ref/c_index_constraint_eq.html)或更大的值。如果xFindFunction返回[SQLITE_INDEX_CONSTRAINT_FUNCTION](c3ref/c_index_constraint_eq.html)或更大的值，则表示该函数接受两个参数，并且该函数可以在查询的WHERE子句中用作布尔值，并且虚拟表能够利用该函数加速查询结果。当xFindFunction返回[SQLITE_INDEX_CONSTRAINT_FUNCTION](c3ref/c_index_constraint_eq.html)或更大的值时，返回的值将成为传递给[xBestIndex()](vtab.html#xbestindex)中的一个约束的[sqlite3_index_info](c3ref/index_info.html).aConstraint.op值。函数的第一个参数是由约束的aConstraint[].iColumn字段标识的列，第二个参数是将传递给[xFilter()](vtab.html#xfilter)（如果设置了aConstraintUsage[].argvIndex值）或从[sqlite3_vtab_rhs_value()](c3ref/vtab_rhs_value.html)返回的值。
- en: 'The [Geopoly module](geopoly.html) is an example of a virtual table that makes
    use of [SQLITE_INDEX_CONSTRAINT_FUNCTION](c3ref/c_index_constraint_eq.html) to
    improve performance. The xFindFunction() method for Geopoly returns SQLITE_INDEX_CONSTRAINT_FUNCTION
    for the [geopoly_overlap()](geopoly.html#goverlap) SQL function and it returns
    SQLITE_INDEX_CONSTRAINT_FUNCTION+1 for the [geopoly_within()](geopoly.html#gwithin)
    SQL function. This permits search optimizations for queries such as:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '[Geopoly 模块](geopoly.html) 是利用 [SQLITE_INDEX_CONSTRAINT_FUNCTION](c3ref/c_index_constraint_eq.html)
    来提升性能的虚拟表的一个示例。Geopoly 的 xFindFunction() 方法返回 SQLITE_INDEX_CONSTRAINT_FUNCTION
    以用于 [geopoly_overlap()](geopoly.html#goverlap) SQL 函数，并且返回 SQLITE_INDEX_CONSTRAINT_FUNCTION+1
    以用于 [geopoly_within()](geopoly.html#gwithin) SQL 函数。这允许对查询进行优化，例如：'
- en: '[PRE37]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that infix functions ([LIKE](lang_expr.html#like), [GLOB](lang_expr.html#glob),
    [REGEXP](lang_expr.html#regexp), and [MATCH](lang_expr.html#match)) reverse the
    order of their arguments. So "like(A,B)" would normally work the same as "B like
    A". However, xFindFunction() always looks a the left-most argument, not the first
    logical argument. Hence, for the form "B like A", SQLite looks at the left operand
    "B" and if that operand is a virtual table column it invokes the xFindFunction()
    method on that virtual table. But if the form "like(A,B)" is used instead, then
    SQLite checks the A term to see if it is column of a virtual table and if so it
    invokes the xFindFunction() method for the virtual table of column A.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 注意中缀函数（[LIKE](lang_expr.html#like)、[GLOB](lang_expr.html#glob)、[REGEXP](lang_expr.html#regexp)
    和 [MATCH](lang_expr.html#match)）反转其参数的顺序。因此，“like(A,B)”通常与“B like A”相同。但是，xFindFunction()
    总是查看最左边的参数，而不是第一个逻辑参数。因此，对于形式“B like A”，SQLite 查看左操作数“B”，如果该操作数是虚拟表列，则在该虚拟表上调用
    xFindFunction() 方法。但如果使用形式“like(A,B)”，则 SQLite 检查 A 项是否为虚拟表列，如果是，则为列 A 的虚拟表调用
    xFindFunction() 方法。
- en: The function pointer returned by this routine must be valid for the lifetime
    of the [sqlite3_vtab](c3ref/vtab.html) object given in the first parameter.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 此例程返回的函数指针必须对于给定的 [sqlite3_vtab](c3ref/vtab.html) 对象的生命周期有效。
- en: 2.15\. The xBegin Method
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.15\. xBegin 方法
- en: '[PRE38]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This method begins a transaction on a virtual table. This is method is optional.
    The xBegin pointer of [sqlite3_module](c3ref/module.html) may be NULL.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法在虚拟表上开始一个事务。这个方法是可选的。[sqlite3_module](c3ref/module.html) 的 xBegin 指针可能为
    NULL。
- en: This method is always followed by one call to either the [xCommit](vtab.html#xcommit)
    or [xRollback](vtab.html#xrollback) method. Virtual table transactions do not
    nest, so the xBegin method will not be invoked more than once on a single virtual
    table without an intervening call to either [xCommit](vtab.html#xcommit) or [xRollback](vtab.html#xrollback).
    Multiple calls to other methods can and likely will occur in between the xBegin
    and the corresponding [xCommit](vtab.html#xcommit) or [xRollback](vtab.html#xrollback).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法总是在调用 [xCommit](vtab.html#xcommit) 或 [xRollback](vtab.html#xrollback) 方法之一后跟随。虚拟表事务不嵌套，因此在单个虚拟表上不会连续调用
    xBegin 方法而没有调用 [xCommit](vtab.html#xcommit) 或 [xRollback](vtab.html#xrollback)。在
    xBegin 和对应的 [xCommit](vtab.html#xcommit) 或 [xRollback](vtab.html#xrollback) 之间可能会多次调用其他方法。
- en: 2.16\. The xSync Method
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.16\. xSync 方法
- en: '[PRE39]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This method signals the start of a two-phase commit on a virtual table. This
    is method is optional. The xSync pointer of [sqlite3_module](c3ref/module.html)
    may be NULL.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法在虚拟表上发出两阶段提交的开始信号。这个方法是可选的。[sqlite3_module](c3ref/module.html) 的 xSync 指针可能为
    NULL。
- en: This method is only invoked after call to the [xBegin](vtab.html#xBegin) method
    and prior to an [xCommit](vtab.html#xcommit) or [xRollback](vtab.html#xrollback).
    In order to implement two-phase commit, the xSync method on all virtual tables
    is invoked prior to invoking the [xCommit](vtab.html#xcommit) method on any virtual
    table. If any of the xSync methods fail, the entire transaction is rolled back.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法仅在调用 [xBegin](vtab.html#xBegin) 方法后且在 [xCommit](vtab.html#xcommit) 或 [xRollback](vtab.html#xrollback)
    之前调用。为了实现两阶段提交，将在任何虚拟表上的 xCommit 方法调用之前调用所有虚拟表的 xSync 方法。如果任何 xSync 方法失败，则整个事务将回滚。
- en: 2.17\. The xCommit Method
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.17\. xCommit 方法
- en: '[PRE40]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This method causes a virtual table transaction to commit. This is method is
    optional. The xCommit pointer of [sqlite3_module](c3ref/module.html) may be NULL.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法导致虚拟表事务提交。这个方法是可选的。[sqlite3_module](c3ref/module.html) 的 xCommit 指针可能为 NULL。
- en: A call to this method always follows a prior call to [xBegin](vtab.html#xBegin)
    and [xSync](vtab.html#xsync).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方法调用之前总是先调用 [xBegin](vtab.html#xBegin) 和 [xSync](vtab.html#xsync)。
- en: 2.18\. The xRollback Method
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.18\. xRollback 方法
- en: '[PRE41]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This method causes a virtual table transaction to rollback. This is method is
    optional. The xRollback pointer of [sqlite3_module](c3ref/module.html) may be
    NULL.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法导致虚拟表事务回滚。此方法是可选的。[sqlite3_module](c3ref/module.html) 的 xRollback 指针可能为 NULL。
- en: A call to this method always follows a prior call to [xBegin](vtab.html#xBegin).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 对此方法的调用始终紧随对[xBegin](vtab.html#xBegin)的先前调用。
- en: 2.19\. The xRename Method
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.19\. xRename 方法
- en: '[PRE42]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This method provides notification that the virtual table implementation that
    the virtual table will be given a new name. If this method returns [SQLITE_OK](rescode.html#ok)
    then SQLite renames the table. If this method returns an [error code](rescode.html)
    then the renaming is prevented.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法提供了一个通知，告知虚拟表实现将给虚拟表一个新名称。如果此方法返回 [SQLITE_OK](rescode.html#ok)，那么 SQLite
    将重命名表。如果此方法返回错误代码，则会阻止重命名操作。
- en: The xRename method is optional. If omitted, then the virtual table may not be
    renamed using the ALTER TABLE RENAME command.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: xRename 方法是可选的。如果省略，则不能使用 ALTER TABLE RENAME 命令重命名虚拟表。
- en: The [PRAGMA legacy_alter_table](pragma.html#pragma_legacy_alter_table) setting
    is enabled prior to invoking this method, and the value for legacy_alter_table
    is restored after this method finishes. This is necessary for the correct operation
    of virtual tables that make use of [shadow tables](vtab.html#xshadowname) where
    the shadow tables must be renamed to match the new virtual table name. If the
    legacy_alter_format is off, then the xConnect method will be invoked for the virtual
    table every time the xRename method tries to change the name of the shadow table.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用此方法之前，会先启用[PRAGMA legacy_alter_table](pragma.html#pragma_legacy_alter_table)设置，并在此方法结束后恢复
    legacy_alter_table 的值。这对于使用[shadow tables](vtab.html#xshadowname)的虚拟表的正确操作是必需的，其中
    shadow tables 必须重命名以匹配新的虚拟表名称。如果 legacy_alter_format 为关闭状态，则每次 xRename 方法尝试更改
    shadow table 的名称时都将为虚拟表调用 xConnect 方法。
- en: 2.20\. The xSavepoint, xRelease, and xRollbackTo Methods
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.20\. xSavepoint、xRelease 和 xRollbackTo 方法
- en: '[PRE43]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: These methods provide the virtual table implementation an opportunity to implement
    nested transactions. They are always optional and will only be called in SQLite
    [version 3.7.7](releaselog/3_7_7.html) (2011-06-23) and later.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法为虚拟表实现提供了实现嵌套事务的机会。它们始终是可选的，并且仅在 SQLite [版本 3.7.7](releaselog/3_7_7.html)（2011-06-23）及更高版本中才会被调用。
- en: When xSavepoint(X,N) is invoked, that is a signal to the virtual table X that
    it should save its current state as savepoint N. A subsequent call to xRollbackTo(X,R)
    means that the state of the virtual table should return to what it was when xSavepoint(X,R)
    was last called. The call to xRollbackTo(X,R) will invalidate all savepoints with
    N>R; none of the invalided savepoints will be rolled back or released without
    first being reinitialized by a call to xSavepoint(). A call to xRelease(X,M) invalidates
    all savepoints where N>=M.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 xSavepoint(X,N) 时，这是对虚拟表 X 的信号，它应将当前状态保存为 savepoint N。随后调用 xRollbackTo(X,R)
    意味着虚拟表的状态应返回到上次调用 xSavepoint(X,R) 时的状态。调用 xRollbackTo(X,R) 将使所有 N>R 的 savepoint
    失效；在未通过调用 xSavepoint() 重新初始化之前，这些失效的 savepoint 都不会被回滚或释放。调用 xRelease(X,M) 会使所有
    N>=M 的 savepoint 失效。
- en: None of the xSavepoint(), xRelease(), or xRollbackTo() methods will ever be
    called except in between calls to xBegin() and either xCommit() or xRollback().
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在 xBegin() 和 xCommit() 或 xRollback() 之间的调用之外，将永远不会调用 xSavepoint()、xRelease()
    或 xRollbackTo() 方法。
- en: 2.21\. The xShadowName Method
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.21\. xShadowName 方法
- en: 'Some virtual table implementations (ex: [FTS3](fts3.html), [FTS5](fts5.html),
    and [RTREE](rtree.html)) make use of real (non-virtual) database tables to store
    content. For example, when content is inserted into the FTS3 virtual table, the
    data is ultimately stored in real tables named "%_content", "%_segdir", "%_segments",
    "%_stat", and "%_docsize" where "%" is the name of the original virtual table.
    This auxiliary real tables that store content for a virtual table are called "shadow
    tables". See ([1](fts3.html#*shadowtab)), ([2](fts5.html#fts5shadowtables)), and
    ([3](rtree.html#xshadow)) for additional information.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 一些虚拟表实现（例如：[FTS3](fts3.html)、[FTS5](fts5.html) 和 [RTREE](rtree.html)）利用真实（非虚拟）数据库表来存储内容。例如，当内容插入
    FTS3 虚拟表时，数据最终存储在名为 "%_content"、"%_segdir"、"%_segments"、"%_stat" 和 "%_docsize"
    的真实表中，其中 "%" 是原始虚拟表的名称。用于存储虚拟表内容的这些辅助真实表称为 "shadow tables"。详细信息请参见 ([1](fts3.html#*shadowtab))、([2](fts5.html#fts5shadowtables))
    和 ([3](rtree.html#xshadow))。
- en: The xShadowName method exists to allow SQLite to determine whether a certain
    real table is in fact a shadow table for a virtual table.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: xShadowName方法存在，允许SQLite确定某个实际表是否确实是虚拟表的影子表。
- en: 'SQLite understands a real table to be a shadow table if all of the following
    are true:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果SQLite满足以下所有条件，则认为一个实际表是一个影子表：
- en: The name of the table contains one or more "_" characters.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表名包含一个或多个"_"字符。
- en: The part of the name prior to the last "_" exactly matches the name of a virtual
    table that was created using [CREATE VIRTUAL TABLE](lang_createvtab.html). (Shadow
    tables are not recognized for [eponymous virtual tables](vtab.html#epovtab) and
    [table-valued functions](vtab.html#tabfunc2).)
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称中最后一个"_"字符之前的部分与使用[CREATE VIRTUAL TABLE](lang_createvtab.html)创建的虚拟表的名称完全匹配。（影子表不适用于[同名虚拟表](vtab.html#epovtab)和[表值函数](vtab.html#tabfunc2)。）
- en: The virtual table contains an xShadowName method.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟表包含一个xShadowName方法。
- en: The xShadowName method returns true when its input is the part of the table
    name past the last "_" character.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当xShadowName方法的输入是表名中最后一个"_"字符后面的部分时，xShadowName方法返回true。
- en: If SQLite recognizes a table as a shadow table, and if the [SQLITE_DBCONFIG_DEFENSIVE](c3ref/c_dbconfig_defensive.html#sqlitedbconfigdefensive)
    flag is set, then the shadow table is read-only for ordinary SQL statements. The
    shadow table can still be written, but only by SQL that is invoked from within
    one of the methods of some virtual table implementation.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果SQLite识别一个表为影子表，并且设置了[SQLITE_DBCONFIG_DEFENSIVE](c3ref/c_dbconfig_defensive.html#sqlitedbconfigdefensive)标志，那么对于普通SQL语句来说，影子表是只读的。影子表仍然可以被写入，但只能通过某个虚拟表实现的方法内部调用的SQL来写入。
- en: The whole point of the xShadowName method is to protect the content of shadow
    tables from being corrupted by hostile SQL. Every virtual table implementation
    that uses shadow tables should be able to detect and cope with corrupted shadow
    table content. However, bugs in particular virtual table implementation might
    allow a deliberately corrupted shadow table to cause a crash or other malfunction.
    The xShadowName mechanism seeks to avoid zero-day exploits by preventing ordinary
    SQL statements from deliberately corrupting shadow tables.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: xShadowName方法的整个目的是保护影子表内容免受恶意SQL的破坏。每个使用影子表的虚拟表实现都应该能够检测和处理被损坏的影子表内容。但是，特定虚拟表实现中的错误可能允许故意损坏的影子表导致崩溃或其他故障。xShadowName机制旨在通过防止普通SQL语句故意损坏影子表来避免零日攻击。
- en: Shadow tables are read/write by default. Shadow tables only become read-only
    when the [SQLITE_DBCONFIG_DEFENSIVE](c3ref/c_dbconfig_defensive.html#sqlitedbconfigdefensive)
    flag is set using [sqlite3_db_config()](c3ref/db_config.html). Shadow tables need
    to be read/write by default in order to maintain backwards compatibility. For
    example, the SQL text generated by the [.dump](cli.html#dump) command of the [CLI](cli.html)
    writes directly into shadow tables.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 影子表默认是可读写的。只有在使用[sqlite3_db_config()](c3ref/db_config.html)设置了[SQLITE_DBCONFIG_DEFENSIVE](c3ref/c_dbconfig_defensive.html#sqlitedbconfigdefensive)标志之后，影子表才会变成只读。影子表默认需要是可读写的，以保持向后兼容性。例如，[CLI](cli.html)的[.dump](cli.html#dump)命令生成的SQL文本直接写入影子表中。
- en: 2.22\. The xIntegrity Method
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.22\. xIntegrity方法
- en: If the iVersion for an sqlite3_module is 4 or more and the xIntegrity method
    is not NULL, then the [PRAGMA integrity_check](pragma.html#pragma_integrity_check)
    and [PRAGMA quick_check](pragma.html#pragma_quick_check) commands will invoke
    xIntegrity as part of its processing. If the xIntegrity method writes an error
    message string into the fifth parameter, then PRAGMA integrity_check will report
    that error as part of its output. So, in other words, the xIntegrity method allows
    the [PRAGMA integrity_check](pragma.html#pragma_integrity_check) command to verify
    the integrity of content stored in a virtual table.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个sqlite3_module的iVersion为4或更高，并且xIntegrity方法不为NULL，则[PRAGMA integrity_check](pragma.html#pragma_integrity_check)和[PRAGMA
    quick_check](pragma.html#pragma_quick_check)命令将在处理过程中调用xIntegrity。如果xIntegrity方法将错误消息字符串写入第五个参数，则PRAGMA
    integrity_check将将该错误作为其输出的一部分报告。因此，换句话说，xIntegrity方法允许[PRAGMA integrity_check](pragma.html#pragma_integrity_check)命令验证存储在虚拟表中的内容的完整性。
- en: 'The xIntegrity method is called with five parameters:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: xIntegrity方法被调用时有五个参数：
- en: '**pVTab** → A pointer to the [sqlite3_vtab](c3ref/vtab.html) object that is
    the virtual table being checked.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pVTab** → 指向正在检查的[sqlite3_vtab](c3ref/vtab.html)对象的指针。'
- en: '**zSchema** → The name of the schema ("main", "temp", etc.) in which the virtual
    table is defined.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**zSchema** → 虚拟表定义所在的模式（"main"、"temp"等）的名称。'
- en: '**zTabName** → The name of the virtual table.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**zTabName** → 虚拟表的名称。'
- en: '**mFlags** → A flag to indicate whether this is an "integrity_check" or a "quick_check".
    Currently, this parameter will always be either 0 or 1, though future versions
    of SQLite might use other bits of the integer to indicate additional processing
    options.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**mFlags** → 一个标志，指示这是一个"integrity_check"还是"quick_check"。当前，该参数总是0或1，但未来的SQLite版本可能会使用整数的其他位来指示额外的处理选项。'
- en: '**pzErr** → This parameter points to a "char*" that is initialized to NULL.
    The xIntegrity() implementation should make *pzErr point to an error string obtained
    from sqlite3_malloc() or equivalent if it finds any problems.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pzErr** → 此参数指向一个初始化为NULL的"char*"。如果xIntegrity()实现发现任何问题，应该从sqlite3_malloc()或等效方法获取错误字符串，并让*pzErr指向该字符串。'
- en: The xIntegrity method should normally return SQLITE_OK - even if it finds problems
    in the content of the virtual table. Any other error code means that the xIntegrity
    method itself encountered problems while trying to evaluate the virtual table
    content. So, for example, if the inverted index for [FTS5](fts5.html) is found
    to be internally inconsistent, then the xIntegrity method should write an appropriate
    error message into the pzErr parameter and return SQLITE_OK. But if the xIntegrity
    method is unable to complete its evaluation of the virtual table content due to
    running out of memory, then it should return SQLITE_NOMEM.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: xIntegrity方法通常应返回SQLITE_OK，即使在虚拟表内容中发现问题。任何其他错误代码意味着xIntegrity方法本身在评估虚拟表内容时遇到问题。例如，如果发现[FTS5](fts5.html)的反向索引内部不一致，则xIntegrity方法应将适当的错误消息写入pzErr参数并返回SQLITE_OK。但如果xIntegrity方法由于内存耗尽而无法完成对虚拟表内容的评估，则应返回SQLITE_NOMEM。
- en: If an error message is generated, space to hold the error message string should
    be obtained from [sqlite3_malloc64()](c3ref/free.html) or the equivalent. Ownership
    of the error message string will pass to the SQLite core when xIntegrity returns.
    The core will make sure that [sqlite3_free()](c3ref/free.html) is invoked to reclaim
    the memory which it has finished with the error message. The PRAGMA integrity_check
    command that invokes the xIntegrity method does not change the returned error
    message. The xIntegrity method itself should include the name of the virtual table
    as part of the message. The zSchema and zName parameters are provided to make
    that easier.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 如果生成了错误消息，则应从[sqlite3_malloc64()](c3ref/free.html)或等效方法获取空间以保存错误消息字符串。当xIntegrity返回时，错误消息字符串的所有权将传递给SQLite核心。核心会确保在使用完错误消息后调用[sqlite3_free()](c3ref/free.html)来回收内存。调用xIntegrity方法的PRAGMA
    integrity_check命令不会更改返回的错误消息。xIntegrity方法本身应包含虚拟表名称作为消息的一部分。zSchema和zName参数提供了便利。
- en: The mFlags parameter is currently a boolean value (either 0 or 1) that indicates
    if the xIntegrity method was called due to [PRAGMA integrity_check](pragma.html#pragma_integrity_check)
    (mFlags==0) or due to [PRAGMA quick_check](pragma.html#pragma_quick_check) (mFlags==1).
    Generally speaking, the xIntegrity method should do whatever validity checking
    it can accomplish in linear time regardless, but only do checking that requires
    superlinear time if `(mFlags&1)==0`. Future versions of SQLite might use higher-order
    bits of the mFlags parameter to indicate additional processing options.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: mFlags参数目前是一个布尔值（0或1），指示xIntegrity方法是由于[PRAGMA integrity_check](pragma.html#pragma_integrity_check)（mFlags==0）还是由于[PRAGMA
    quick_check](pragma.html#pragma_quick_check)（mFlags==1）而调用。一般来说，xIntegrity方法应该以线性时间完成所有可能的有效性检查，但仅在`(mFlags&1)==0`时才执行需要超线性时间的检查。未来的SQLite版本可能会使用mFlags参数的高阶位来指示额外的处理选项。
- en: Support for the xIntegrity method was added in SQLite version 3.44.0 (2023-11-01).
    In that same release, the xIntegrity method was added to many built-in virtual
    tables, such as [FTS3](fts3.html), [FTS5](fts5.html), and [RTREE](rtree.html)
    so that the content of those tables will henceforth be automatically checked for
    consistency when [PRAGMA integrity_check](pragma.html#pragma_integrity_check)
    is run.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 支持xIntegrity方法是在SQLite版本3.44.0（2023-11-01）中添加的。在同一个发布版本中，xIntegrity方法还被添加到许多内置虚拟表中，例如[FTS3](fts3.html)，[FTS5](fts5.html)和[RTREE](rtree.html)，因此当运行[PRAGMA
    integrity_check](pragma.html#pragma_integrity_check)时，这些表的内容将自动进行一致性检查。
