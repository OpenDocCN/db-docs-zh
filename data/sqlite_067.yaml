- en: 1\. The RBU Extension
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1\. RBU 扩展
- en: 原文：[https://sqlite.com/rbu.html](https://sqlite.com/rbu.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://sqlite.com/rbu.html](https://sqlite.com/rbu.html)
- en: 'The RBU extension is an add-on for SQLite designed for use with large SQLite
    database files on low-power devices at the edge of a network. RBU may be used
    for two separate tasks:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: RBU 扩展是专为在网络边缘的低功耗设备上使用的大型 SQLite 数据库文件而设计的附加模块。RBU 可以用于两个独立的任务：
- en: '**RBU Update operations**. An [RBU Update](rbu.html#rbu_updates) is a bulk
    update of a database file that may include many insert, update and delete operations
    on one or more tables.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RBU 更新操作**。[RBU 更新](rbu.html#rbu_updates) 是对数据库文件的批量更新，可以包括一个或多个表上的许多插入、更新和删除操作。'
- en: '**RBU Vacuum operations**. An [RBU Vacuum](rbu.html#rbu_vacuum) optimizes and
    rebuilds an entire database file, with results similar to SQLite''s native VACUUM
    command.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RBU 真空操作**。[RBU 真空](rbu.html#rbu_vacuum) 优化并重建整个数据库文件，其效果类似于 SQLite 的原生 VACUUM
    命令。'
- en: The acronym RBU stands for "Resumable Bulk Update".
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: RBU 的缩写代表 "Resumable Bulk Update"。
- en: 'Both of the RBU functions may be accomplished using SQLite''s built-in SQL
    commands - RBU update via a series of [INSERT](lang_insert.html), [DELETE](lang_delete.html)
    and [UPDATE](lang_update.html) commands within a single transaction, and RBU vacuum
    by a single [VACUUM](lang_vacuum.html) command. The RBU module provides the following
    advantages over these simpler approaches:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 内置的 SQL 命令可以完成这两个 RBU 功能 - RBU 更新通过在单个事务中执行一系列 [INSERT](lang_insert.html)、[DELETE](lang_delete.html)
    和 [UPDATE](lang_update.html) 命令，而 RBU 真空则通过单个 [VACUUM](lang_vacuum.html) 命令。RBU
    模块相比这些更简单的方法提供了以下优势：
- en: '**RBU may be more efficient**'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**RBU 可能更高效**'
- en: The most efficient way to apply changes to a B-Tree (the data structure that
    SQLite uses to store each table and index on disk) is to make the changes in key
    order. But if an SQL table has one or more indexes, the key order for each index
    may be different from the main table and the other auxiliary indexes. As a result,
    when executing a series of [INSERT](lang_insert.html), [UPDATE](lang_update.html)
    and [DELETE](lang_delete.html) statements it is not generally possible to order
    the operations so that all b-trees are updated in key order. The RBU update process
    works around this by applying all changes to the main table in one pass, then
    applying changes to each index in separate passes, ensuring each B-Tree is updated
    optimally. For a large database file (one that does not fit in the OS disk cache)
    this procedure can result in two orders of magnitude faster updates.
  id: totrans-8
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: SQLite 使用的数据结构 B 树（用于在磁盘上存储每个表和索引）最有效的修改方法是按键顺序进行修改。但是，如果 SQL 表具有一个或多个索引，那么每个索引的键顺序可能与主表和其他辅助索引不同。因此，在执行一系列
    [INSERT](lang_insert.html)、[UPDATE](lang_update.html) 和 [DELETE](lang_delete.html)
    语句时，通常无法按键顺序对所有 B 树进行更新。RBU 更新过程通过在一个通道中对主表应用所有修改，然后在单独的通道中对每个索引应用修改，确保每个 B 树都得到了最优更新。对于大型数据库文件（即不适合于操作系统磁盘缓存的文件），这一过程可以使更新速度提高两个数量级。
- en: An RBU Vacuum operation requires less temporary disk space and writes less data
    to disk than an SQLite VACUUM. An SQLite VACUUM requires roughly twice the size
    of the final database file in temporary disk space to run. The total amount of
    data written is around three times the size of the final database file. By contrast,
    an RBU Vacuum requires roughly the size of the final database file in temporary
    disk space and writes a total of twice that to disk.
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: RBU 真空操作所需的临时磁盘空间较少，写入磁盘的数据也较少，相较于 SQLite 的 VACUUM 操作。SQLite 的 VACUUM 操作需要大约是最终数据库文件大小的两倍的临时磁盘空间来运行，并且总写入数据量大约是最终数据库文件大小的三倍。相比之下，RBU
    真空操作需要大约是最终数据库文件大小的临时磁盘空间，并且总写入数据量是两倍于此。
- en: On the other hand, an RBU Vacuum uses more CPU than a regular SQLite VACUUM
    - in one test as much as five times as much. For this reason, an RBU Vacuum is
    often significantly slower than an SQLite VACUUM under the same conditions.
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一方面，RBU 真空操作比常规 SQLite VACUUM 使用更多 CPU - 在某个测试中多达五倍。因此，在相同条件下，RBU 真空操作通常比 SQLite
    VACUUM 操作慢得多。
- en: '**RBU runs in the background**'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**RBU 在后台运行**'
- en: An ongoing RBU operation (either an update or a vacuum) does not interfere with
    read access to the database file.
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正在进行的 RBU 操作（更新或真空操作）不会干扰对数据库文件的读访问。
- en: '**RBU runs incrementally**'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**RBU 以增量方式运行**'
- en: RBU operations may be suspended and then later resumed, perhaps with intervening
    power outages and/or system resets. For an RBU update, the original database content
    remains visible to all database readers until the entire update has been applied
    - even if the update is suspended and then later resumed.
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: RBU 操作可以暂停，然后稍后恢复，期间可能发生断电和/或系统重启。对于 RBU 更新，原始数据库内容对所有数据库读取者可见，直到整个更新被应用完成 -
    即使更新被暂停然后稍后恢复。
- en: The RBU extension is not enabled by default. To enable it, compile the [amalgamation](amalgamation.html)
    with the [SQLITE_ENABLE_RBU](compile.html#enable_rbu) compile-time option.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: RBU 扩展默认未启用。要启用它，请使用编译时选项 [SQLITE_ENABLE_RBU](compile.html#enable_rbu) 编译 [amalgamation](amalgamation.html)。
- en: 2\. RBU Updates
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2\. RBU 更新
- en: 2.1\. RBU Update Limitations
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1\. RBU 更新限制
- en: 'The following limitations apply to RBU updates:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下限制适用于 RBU 更新：
- en: The changes must consist of [INSERT](lang_insert.html), [UPDATE](lang_update.html),
    and [DELETE](lang_delete.html) operations only. CREATE and DROP operations are
    not supported.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改必须仅包括 [INSERT](lang_insert.html)、[UPDATE](lang_update.html) 和 [DELETE](lang_delete.html)
    操作。不支持 CREATE 和 DROP 操作。
- en: '[INSERT](lang_insert.html) statements may not use default values.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[INSERT](lang_insert.html) 语句不得使用默认值。'
- en: '[UPDATE](lang_update.html) and [DELETE](lang_delete.html) statements must identify
    the target rows by rowid or by non-NULL PRIMARY KEY values.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[UPDATE](lang_update.html) 和 [DELETE](lang_delete.html) 语句必须通过 rowid 或非 NULL
    主键值来识别目标行。'
- en: '[UPDATE](lang_update.html) statements may not modify PRIMARY KEY or rowid values.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[UPDATE](lang_update.html) 语句不得修改 PRIMARY KEY 或 rowid 值。'
- en: RBU updates cannot be applied to any tables that contain a column named "rbu_control".
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RBU 更新不能应用于包含名为"rbu_control"的列的任何表。
- en: The RBU update will not fire any triggers.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RBU 更新不会触发任何触发器。
- en: The RBU update will not detect or prevent foreign key or CHECK constraint violations.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RBU 更新不会检测或阻止外键或 CHECK 约束的违反。
- en: All RBU updates use the "OR ROLLBACK" constraint handling mechanism.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有 RBU 更新使用“OR ROLLBACK”约束处理机制。
- en: The target database may not be in [WAL mode](wal.html).
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标数据库可能不处于[WAL 模式](wal.html)。
- en: ~~The target database may not contain [indexes on expressions](expridx.html).~~
    Indexes on expressions are supported beginning with SQLite 3.30.0 (2019-10-04).
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ~~目标数据库上可能没有[表达式索引](expridx.html)。~~ 表达式索引从 SQLite 3.30.0 版本（2019-10-04）开始支持。
- en: No other writes may occur on the target database while the RBU update is being
    applied. A read-lock is held on the target database to prevent this.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用 RBU 更新时，目标数据库上不得进行其他写操作。为防止此类操作，目标数据库上会持有读锁。
- en: 2.2\. Preparing an RBU Update File
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2\. 准备 RBU 更新文件
- en: All changes to be applied by RBU are stored in a separate SQLite database called
    the "RBU database". The database that is to be modified is called the "target
    database".
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 RBU 要应用的更改都存储在一个名为“RBU 数据库”的单独 SQLite 数据库中。要修改的数据库称为“目标数据库”。
- en: For each table in the target database that will be modified by the update, a
    corresponding table is created within the RBU database. The RBU database table
    schema is not the same as that of the target database, but is derived from it
    as [described below](rbu.html#database_tables).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 每个目标数据库中将通过更新修改的表都会在 RBU 数据库中创建一个对应的表。RBU 数据库表的架构与目标数据库不同，但来源于目标数据库，具体描述请参见[下文](rbu.html#database_tables)。
- en: The RBU database table contains a single row for each target database row inserted,
    updated or deleted by the update. Populating the RBU database tables is described
    in [the following section](rbu.html#database_contents).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: RBU 数据库表包含每个被更新的目标数据库行的单行记录。填充 RBU 数据库表的详细过程请参阅[下一节](rbu.html#database_contents)。
- en: 2.2.1\. The RBU Database Schema
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1\. RBU 数据库架构
- en: For each table in the target database, the RBU database should contain a table
    named "data<*integer*>_<*target-table-name*>" where <*target-table-name*> is the
    name of the table in the target database and <*integer*> is any sequence of zero
    or more numeric characters (0-9). Tables within the RBU database are processed
    in order by name (from smallest to largest according to the BINARY collation sequence),
    so the order in which target tables are updated is influenced by the selection
    of the <*integer*> portion of the data_% table name. While this can be useful
    when using RBU to update [certain types of virtual tables](rbu.html#fts4_tables),
    there is normally no reason to use anything other than an empty string in place
    of <*integer*>.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于目标数据库中的每个表，RBU 数据库应包含一个名为"data<*integer*>_<*target-table-name*>"的表，其中<*target-table-name*>是目标数据库中表的名称，<*integer*>是任意长度的数字字符序列（0-9）。RBU
    数据库中的表按名称顺序处理（按照二进制排序顺序从小到大），因此更新目标表的顺序受到数据_% 表名称中<*integer*>部分选择的影响。在使用 RBU 更新
    [某些类型的虚拟表](rbu.html#fts4_tables) 时，这可能是有用的，但通常没有理由使用任何东西来代替<*integer*>部分除了空字符串。
- en: 'The data_% table must have all the same columns as the target table, plus one
    additional column named "rbu_control". The data_% table should have no PRIMARY
    KEY or UNIQUE constraints, but each column should have the same type as the corresponding
    column in the target database. The rbu_control column should have no type at all.
    For example, if the target database contains:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 数据_% 表必须具有与目标表相同的所有列，另外还需要一个名为"rbu_control"的额外列。数据_% 表不应具有主键或唯一约束，但是每列的类型应与目标数据库中相应列的类型相同。rbu_control
    列不应具有任何类型。例如，如果目标数据库包含：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then the RBU database should contain:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 RBU 数据库应包含：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The order of the columns in the data_% table does not matter.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 数据_% 表中列的顺序无关紧要。
- en: 'If the target database table is a virtual table or a table that has no PRIMARY
    KEY declaration, the data_% table must also contain a column named "rbu_rowid".
    The rbu_rowid column is mapped to the tables [ROWID](lang_createtable.html#rowid).
    For example, if the target database contains either of the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标数据库表是虚拟表或没有主键声明的表，则数据_% 表还必须包含一个名为"rbu_rowid"的列。rbu_rowid 列被映射到表的 [ROWID](lang_createtable.html#rowid)。例如，如果目标数据库包含以下内容之一：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'then the RBU database should contain:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 RBU 数据库应包含：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Virtual tables for which the "rowid" column does not function like a primary
    key value cannot be updated using RBU.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 无法使用 RBU 更新“rowid”列不像主键值那样运行的虚拟表。
- en: 'All non-hidden columns (i.e. all columns matched by "SELECT *") of the target
    table must be present in the input table. For virtual tables, hidden columns are
    optional - they are updated by RBU if present in the input table, or not otherwise.
    For example, to write to an fts4 table with a hidden languageid column such as:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 目标表的所有非隐藏列（即由 "SELECT *" 匹配的所有列）必须存在于输入表中。对于虚拟表，隐藏列是可选的 - 如果在输入表中存在，则由 RBU 更新，否则不会更新。例如，要向具有隐藏的
    languageid 列的 fts4 表写入：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Either of the following input table schemas may be used:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下任一输入表模式：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 2.2.2\. RBU Database Contents
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.2\. RBU 数据库内容
- en: For each row to INSERT into the target database as part of the RBU update, the
    corresponding data_% table should contain a single record with the "rbu_control"
    column set to contain integer value 0\. The other columns should be set to the
    values that make up the new record to insert.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 每行在 RBU 更新的一部分插入目标数据库时，对应的 data_% 表应包含一条 "rbu_control" 列设置为整数值 0 的记录。其他列应设置为组成要插入的新记录的值。
- en: The "rbu_control" column may also be set to integer value 2 for an INSERT. In
    this case, the new row silently replaces any existing row that has the same primary
    key values. This is equivalent to a DELETE followed by an INSERT with the same
    primary key values. It is not the same as an SQL REPLACE command, as in that case
    the new row may replace any conflicting rows (i.e. those that conflict due to
    UNIQUE constraints or indexes), not just those with conflicting primary keys.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '"rbu_control" 列的整数值也可以设为 2 用于插入操作。在这种情况下，新行会悄悄地替换任何具有相同主键值的现有行。这相当于先删除再插入具有相同主键值的行。这不同于
    SQL 的 REPLACE 命令，在那种情况下，新行可能会替换任何冲突行（例如由于唯一约束或索引而产生的冲突行），而不仅仅是具有冲突主键的行。'
- en: If the target database table has an INTEGER PRIMARY KEY, it is not possible
    to insert a NULL value into the IPK column. Attempting to do so results in an
    SQLITE_MISMATCH error.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标数据库表具有 INTEGER PRIMARY KEY，则不可能向 IPK 列插入 NULL 值。试图这样做会导致 SQLITE_MISMATCH
    错误。
- en: For each row to DELETE from the target database as part of the RBU update, the
    corresponding data_% table should contain a single record with the "rbu_control"
    column set to contain integer value 1\. The real primary key values of the row
    to delete should be stored in the corresponding columns of the data_% table. The
    values stored in the other columns are not used.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 每行在 RBU 更新中从目标数据库中删除时，对应的 data_% 表应包含一条 "rbu_control" 列设置为整数值 1 的记录。要删除的行的实际主键值应存储在
    data_% 表的相应列中。其他列中存储的值不会被使用。
- en: 'For each row to UPDATE from the target database as part of the RBU update,
    the corresponding data_% table should contain a single record with the "rbu_control"
    column set to contain a value of type text. The real primary key values identifying
    the row to update should be stored in the corresponding columns of the data_%
    table row, as should the new values of all columns being update. The text value
    in the "rbu_control" column must contain the same number of characters as there
    are columns in the target database table, and must consist entirely of ''x'' and
    ''.'' characters (or in some special cases ''d'' - see below). For each column
    that is being updated, the corresponding character is set to ''x''. For those
    that remain as they are, the corresponding character of the rbu_control value
    should be set to ''.''. For example, given the tables above, the update statement:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于目标数据库中每行要作为 RBU 更新的一部分进行 UPDATE，相应的 data_% 表应包含一个 rbu_control 列设置为包含文本类型值。用于更新的真实主键值应存储在
    data_% 表行的相应列中，所有更新的列的新值也应存储在其中。rbu_control 列中的文本值必须与目标数据库表中的列数相同，并且必须完全由 'x'
    和 '.' 字符组成（或在某些特殊情况下为 'd' - 见下文）。对于要更新的每一列，相应的字符设置为 'x'。对于保持原样的列，rbu_control 值的相应字符应设置为
    '.'。例如，给定上述表格，更新语句为：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'is represented by the data_t1 row created by:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由 data_t1 行创建的数据 t1 列表示。
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If RBU is used to update a large BLOB value within a target database, it may
    be more efficient to store a patch or delta that can be used to modify the existing
    BLOB instead of an entirely new value within the RBU database. RBU allows deltas
    to be specified in two ways:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 RBU 来更新目标数据库中的大型 BLOB 值，则将存储一个补丁或增量，以修改现有的 BLOB 而不是在 RBU 数据库中存储全新的值可能更有效。RBU
    允许以两种方式指定增量：
- en: In the "fossil delta" format - the format used for blob deltas by the [Fossil
    source-code management system](http://fossil-scm.org), or
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 "石油增量" 格式中 - 这是 [Fossil 源代码管理系统](http://fossil-scm.org) 使用的 BLOB 增量格式，或者
- en: In a custom format defined by the RBU application.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 RBU 应用程序定义的自定义格式中。
- en: The fossil delta format may only be used to update BLOB values. Instead of storing
    the new BLOB within the data_% table, the fossil delta is stored instead. And
    instead of specifying an 'x' as part of the rbu_control string for the column
    to be updated, an 'f' character is stored. When processing an 'f' update, RBU
    loads the original BLOB data from disk, applies the fossil delta to it and stores
    the results back into the database file. The RBU databases generated by [sqldiff
    --rbu](rbu.html#sqldiff) make use of fossil deltas wherever doing so would save
    space in the RBU database.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 石油增量格式仅用于更新 BLOB 值。在 data_% 表中，不存储新的 BLOB，而是存储石油增量。而不是在 rbu_control 字符串的列作为更新的一部分中指定
    'x'，而是存储一个 'f' 字符。处理 'f' 更新时，RBU 从磁盘加载原始 BLOB 数据，将石油增量应用于其上，并将结果存储回数据库文件中。由 [sqldiff
    --rbu](rbu.html#sqldiff) 生成的 RBU 数据库在 RBU 数据库中保存空间时使用石油增量。
- en: To use a custom delta format, the RBU application must register a user-defined
    SQL function named "rbu_delta" before beginning to process the update. rbu_delta()
    will be invoked with two arguments - the original value stored in the target table
    column and the delta value provided as part of the RBU update. It should return
    the result of applying the delta to the original value. To use the custom delta
    function, the character of the rbu_control value corresponding to the target column
    to update must be set to 'd' instead of 'x'. Then, instead of updating the target
    table with the value stored in the corresponding data_% column, RBU invokes the
    user-defined SQL function "rbu_delta()" and the store in the target table column.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用自定义增量格式，RBU 应用程序必须在开始处理更新之前注册名为 "rbu_delta" 的用户定义 SQL 函数。rbu_delta() 将被调用两个参数
    - 存储在目标表列中的原始值和作为 RBU 更新的一部分提供的增量值。它应返回将增量应用到原始值后的结果。要使用自定义增量函数，更新目标列时 rbu_control
    值对应的字符必须设置为 'd' 而不是 'x'。然后，RBU 不是使用存储在对应数据_% 列中的值来更新目标表，而是调用用户定义的 SQL 函数 "rbu_delta()"
    并将结果存储在目标表列中。
- en: 'For example, this row:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，此行：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'causes RBU to update the target database table in a way similar to:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 导致 RBU 以类似方式更新目标数据库表：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If the target database table is a virtual table or a table with no PRIMARY
    KEY, the rbu_control value should not include a character corresponding to the
    rbu_rowid value. For example, this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标数据库表是虚拟表或者没有主键的表，则 rbu_control 值不应包含与 rbu_rowid 值对应的字符。例如，这样：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'causes a result similar to:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 导致类似如下结果：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The data_% tables themselves should have no PRIMARY KEY declarations. However,
    RBU is more efficient if reading the rows in from each data_% table in "rowid"
    order is roughly the same as reading them sorted by the PRIMARY KEY of the corresponding
    target database table. In other words, rows should be sorted using the destination
    table PRIMARY KEY fields before they are inserted into the data_% tables.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 数据_% 表本身不应有主键声明。然而，如果从每个数据_% 表中按 "rowid" 排序的行顺序与按对应目标数据库表的主键排序它们的顺序大致相同，那么 RBU
    就更有效率。换句话说，在插入到数据_% 表之前，应该使用目标表主键字段对行进行排序。
- en: 2.2.3\. Using RBU with FTS3/4 Tables
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.3\. 使用 RBU 与 FTS3/4 表
- en: 'Usually, an [FTS3 or FTS4](fts3.html) table is an example of a virtual table
    with a rowid that works like a PRIMARY KEY. So, for the following FTS4 tables:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，[FTS3 或 FTS4](https://fts3.html) 表是具有类似主键功能的虚拟表的示例。因此，对于以下 FTS4 表：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The data_% tables may be created as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 数据_% 表可以按以下方式创建：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: And populated as if the target table were an ordinary SQLite table with no explicit
    PRIMARY KEY columns.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 并填充，就好像目标表是普通的 SQLite 表且没有显式的主键列。
- en: '[Contentless FTS4 tables](fts3.html#_contentless_fts4_tables_) are handled
    similarly, except that any attempt to update or delete rows will cause an error
    when applying the update.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[无内容的 FTS4 表](https://fts3.html#_contentless_fts4_tables_) 处理方式类似，除非尝试更新或删除行会在应用更新时导致错误。'
- en: '[External content FTS4 tables](fts3.html#_external_content_fts4_tables_) may
    also be updated using RBU. In this case the user is required to configure the
    RBU database so that the same set of UPDATE, DELETE and INSERT operations are
    applied to the FTS4 index as to the underlying content table. As for all updates
    of external content FTS4 tables, the user is also required to ensure that any
    UPDATE or DELETE operations are applied to the FTS4 index before they are applied
    to the underlying content table (refer to FTS4 documentation for a detailed explanation).
    In RBU, this is done by ensuring that the name of the data_% table used to write
    to the FTS4 table sorts before the name of the data_% table used to update the
    underlying content table using the [BINARY](datatype3.html#collation) collation
    sequence. In order to avoid duplicating data within the RBU database, an SQL view
    may be used in place of one of the data_% tables. For example, for the target
    database schema:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[外部内容 FTS4 表](fts3.html#_external_content_fts4_tables_) 也可以使用 RBU 进行更新。在这种情况下，用户需要配置
    RBU 数据库，以便将相同的 UPDATE、DELETE 和 INSERT 操作应用到 FTS4 索引和底层内容表。对于所有外部内容 FTS4 表的更新，用户还需要确保任何
    UPDATE 或 DELETE 操作先应用到 FTS4 索引，然后再应用到底层内容表（详细说明请参阅 FTS4 文档）。在 RBU 中，通过确保用于向 FTS4
    表写入的 data_% 表的名称按照 [BINARY](datatype3.html#collation) 校对序列排序在用于更新底层内容表的 data_%
    表的名称之前来完成这一操作。为了避免在 RBU 数据库中重复数据，可以使用 SQL 视图代替其中一个 data_% 表。例如，对于目标数据库模式：'
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following RBU database schema may be used:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下 RBU 数据库模式：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The data_ccc table may then be populated as normal with the updates intended
    for target database table ccc. The same updates will be read by RBU from the data0_ccc_fts
    view and applied to FTS table ccc_fts. Because "data0_ccc_fts" is smaller than
    "data_ccc", the FTS table will be updated first, as required.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 数据表 data_ccc 可以像往常一样填充，以进行对目标数据库表 ccc 的更新。RBU 将从 data0_ccc_fts 视图读取相同的更新，并将其应用于
    FTS 表 ccc_fts。因为 "data0_ccc_fts" 比 "data_ccc" 小，所以按照要求先更新 FTS 表。
- en: 'Cases in which the underlying content table has an explicit INTEGER PRIMARY
    KEY column are slightly more difficult, as the text values stored in the rbu_control
    column are slightly different for the FTS index and its underlying content table.
    For the underlying content table, a character must be included in any rbu_control
    text values for the explicit IPK, but for the FTS table itself, which has an implicit
    rowid, it should not. This is inconvenient, but can be solved using a more complicated
    view, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于底层内容表具有显式 INTEGER PRIMARY KEY 列的情况稍微复杂，因为存储在 rbu_control 列中的文本值对于 FTS 索引及其底层内容表略有不同。对于底层内容表，rbu_control
    文本值中必须包含字符以表示显式 IPK，但对于具有隐式 rowid 的 FTS 表本身，则不应该包含。尽管这很不便，但可以通过更复杂的视图来解决，如下所示：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The substr() function in the SQL view above returns the text of the rbu_control
    argument with the first character (the one corresponding to column "i", which
    is not required by the FTS table) removed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述的SQL视图中，substr()函数返回rbu_control参数的文本，去除第一个字符（对应于不需要在FTS表中的列“i”）。
- en: 2.2.4\. Automatically Generating RBU Updates with sqldiff
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.4\. 使用sqldiff自动生成RBU更新
- en: 'As of SQLite [version 3.9.0](releaselog/3_9_0.html) (2015-10-14), the [sqldiff](sqldiff.html)
    utility is able to generate RBU databases representing the difference between
    two databases with identical schemas. For example, the following command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 自SQLite [版本 3.9.0](releaselog/3_9_0.html)（2015-10-14）起，sqldiff实用工具能够生成代表两个具有相同模式的数据库之间差异的RBU数据库。例如，以下命令：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Outputs an SQL script to create an RBU database which, if used to update database
    t1.db, patches it so that its contents are identical to that of database t2.db.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 输出一个SQL脚本，用于创建一个RBU数据库，如果用于更新数据库t1.db，则修补它以使其内容与数据库t2.db完全相同。
- en: By default, sqldiff attempts to process all non-virtual tables within the two
    databases provided to it. If any table appears in one database but not the other,
    or if any table has a slightly different schema in one database it is an error.
    The "--table" option may be useful if this causes a problem
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，sqldiff尝试处理两个提供给它的数据库中的所有非虚拟表。如果任何表在一个数据库中出现而在另一个数据库中不存在，或者如果任何表在一个数据库中的模式稍有不同，将会报错。如果这造成问题，“--table”选项可能会有帮助。
- en: 'Virtual tables are ignored by default by sqldiff. However, it is possible to
    explicitly create an RBU data_% table for a virtual table that features a rowid
    that functions like a primary key using a command such as:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，sqldiff会忽略虚拟表。但是，可以通过类似以下命令显式创建一个虚拟表的RBU数据_%表，其中包含类似主键功能的rowid：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Unfortunately, even though virtual tables are ignored by default, any [underlying
    database tables](fts3.html#*shadowtab) that they create in order to store data
    within the database are not, and [sqldiff](sqldiff.html) will include add these
    to any RBU database. For this reason, users attempting to use sqldiff to create
    RBU updates to apply to target databases with one or more virtual tables will
    likely have to run sqldiff using the --table option separately for each table
    to update in the target database.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，尽管默认情况下忽略虚拟表，但是它们创建的任何底层数据库表以在数据库中存储数据的方式并不被忽略，并且sqldiff会将这些表添加到任何RBU数据库中。因此，试图使用sqldiff创建RBU更新以应用到具有一个或多个虚拟表的目标数据库的用户可能需要单独使用--table选项运行sqldiff来更新每个要更新的目标数据库中的表。
- en: 2.3\. RBU Update C/C++ Programming
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3\. RBU更新C/C++编程
- en: 'The RBU extension interface allows an application to apply an RBU update stored
    in an RBU database to an existing target database. The procedure is as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: RBU扩展接口允许应用将存储在RBU数据库中的RBU更新应用到现有的目标数据库。具体步骤如下：
- en: Open an RBU handle using the sqlite3rbu_open(T,A,S) function.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用sqlite3rbu_open(T,A,S)函数打开一个RBU句柄。
- en: The T argument is the name of the target database file. The A argument is the
    name of the RBU database file. The S argument is the name of a "state database"
    used to store state information needed to resume the update after an interruption.
    The S argument can be NULL in which case the state information is stored in the
    RBU database in various tables whose names all begin with "rbu_".
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: T参数是目标数据库文件的名称。A参数是RBU数据库文件的名称。S参数是用于存储在中断后恢复更新所需的状态信息的“状态数据库”的名称。如果S参数为NULL，则状态信息存储在RBU数据库中，其表名均以“rbu_”开头。
- en: The sqlite3rbu_open(T,A,S) function returns a pointer to an "sqlite3rbu" object,
    which is then passed into the subsequent interfaces.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sqlite3rbu_open(T,A,S)函数返回一个指向“sqlite3rbu”对象的指针，然后将其传递给后续接口。
- en: Register any required virtual table modules with the database handle returned
    by sqlite3rbu_db(X) (where argument X is the sqlite3rbu pointer returned from
    sqlite3rbu_open()). Also, if required, register the rbu_delta() SQL function using
    [sqlite3_create_function_v2()](c3ref/create_function.html).
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用由sqlite3rbu_open()返回的数据库句柄来注册任何所需的虚拟表模块（其中参数X是从sqlite3rbu_open()返回的sqlite3rbu指针）。此外，如有必要，使用[sqlite3_create_function_v2()](c3ref/create_function.html)注册rbu_delta()
    SQL函数。
- en: Invoke the sqlite3rbu_step(X) function one or more times on the sqlite3rbu object
    pointer X. Each call to sqlite3rbu_step() performs a single b-tree operation,
    so thousands of calls may be required to apply a complete update. The sqlite3rbu_step()
    interface will return SQLITE_DONE when the update has been completely applied.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在sqlite3rbu对象指针X上调用sqlite3rbu_step(X)函数一次或多次。每次调用sqlite3rbu_step()执行单个B树操作，因此可能需要数千次调用才能应用完整的更新。当更新完全应用时，sqlite3rbu_step()接口将返回SQLITE_DONE。
- en: Call sqlite3rbu_close(X) to destroy the sqlite3rbu object pointer. If sqlite3rbu_step(X)
    has been called enough times to completely apply the update to the target database,
    then the RBU database is marked as fully applied. Otherwise, the state of the
    RBU update application is saved in the state database (or in the RBU database
    if the name of the state database file in sqlite3rbu_open() is NULL) for later
    resumption of the update.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用sqlite3rbu_close(X)以销毁sqlite3rbu对象指针。如果已调用sqlite3rbu_step(X)足够次数以完全应用更新到目标数据库，则将RBU数据库标记为完全应用。否则，RBU更新应用的状态将保存在状态数据库中（或者如果在sqlite3rbu_open()中指定的状态数据库文件名称为NULL，则保存在RBU数据库中），以便稍后恢复更新。
- en: If an update is only partially applied to the target database by the time sqlite3rbu_close()
    is called, state information is saved within the state database if it exists,
    or otherwise in the RBU database. This allows subsequent processes to automatically
    resume the RBU update from where it left off. If state information is stored in
    the RBU database, it can be removed by dropping all tables whose names begin with
    "rbu_".
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在调用 sqlite3rbu_close() 时目标数据库仅部分应用了更新，则状态信息将保存在状态数据库（如果存在）或者 RBU 数据库中。这允许后续的进程从中断的位置自动恢复
    RBU 更新。如果状态信息存储在 RBU 数据库中，可以通过删除所有表名以 "rbu_" 开头的表来移除它。
- en: For more details, refer to the comments in [header file sqlite3rbu.h](http://sqlite.org/src/doc/trunk/ext/rbu/sqlite3rbu.h).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多详细信息，请参阅 [头文件 sqlite3rbu.h](http://sqlite.org/src/doc/trunk/ext/rbu/sqlite3rbu.h)
    中的注释。
- en: 3\. RBU Vacuum
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3\. RBU 清理
- en: 3.1\. RBU Vacuum Limitations
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1\. RBU 清理限制
- en: 'When compared with SQLite''s built-in VACUUM command, RBU Vacuum has the following
    limitations:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与 SQLite 内置的 VACUUM 命令相比，RBU 清理存在以下限制：
- en: It may not be used on a database that contains [indexes on expressions](expridx.html).
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不能用于包含 [表达式索引](expridx.html) 的数据库。
- en: The database being vacuumed may not be in [WAL mode](wal.html).
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被清理的数据库可能不处于 [WAL 模式](wal.html)。
- en: 3.2\. RBU Vacuum C/C++ Programming
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2\. RBU 清理 C/C++ 编程
- en: This section provides an overview of and example code demonstrating the integration
    of RBU Vacuum into an application program. For full details, refer to the comments
    in [header file sqlite3rbu.h](http://sqlite.org/src/doc/trunk/ext/rbu/sqlite3rbu.h).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了 RBU 清理集成到应用程序中的概述和示例代码。有关详细信息，请参阅 [头文件 sqlite3rbu.h](http://sqlite.org/src/doc/trunk/ext/rbu/sqlite3rbu.h)
    中的注释。
- en: 'RBU Vacuum applications all implement some variation of the following procedure:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的 RBU 清理应用程序都实现了以下过程的某种变体：
- en: An RBU handle is created by calling sqlite3rbu_vacuum(T, S).
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用 sqlite3rbu_vacuum(T, S) 创建 RBU 句柄。
- en: Argument T is the name of the database file to vacuum. Argument S is the name
    of a database in which the RBU module will save its state if the vacuum operation
    is suspended.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参数 T 是要清理的数据库文件的名称。参数 S 是如果暂停清理操作，RBU 模块将保存其状态的数据库的名称。
- en: If state database S does not exist when sqlite3rbu_vacuum() is invoked, it is
    automatically created and populated with the single table used to store the state
    of an RBU vacuum - "rbu_state". If an ongoing RBU vacuum is suspended, this table
    is populated with state data. The next time sqlite3rbu_vacuum() is called with
    the same S parameter, it detects this data and attempts to resume the suspended
    vacuum operation. When an RBU vacuum operation is completed or encounters an error,
    RBU automatically deletes the contents of the rbu_state table. In this case, the
    next call to sqlite3rbu_vacuum() starts an entirely new vacuum operation from
    scratch.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当调用sqlite3rbu_vacuum()时，如果状态数据库S不存在，则会自动创建并填充，用于存储RBU真空状态的单个表 - "rbu_state"。如果正在进行的RBU真空被暂停，则此表会填充状态数据。下次使用相同的S参数调用sqlite3rbu_vacuum()时，它会检测到这些数据，并尝试恢复暂停的真空操作。当RBU真空操作完成或遇到错误时，RBU会自动删除rbu_state表的内容。在这种情况下，下一次调用sqlite3rbu_vacuum()将从头开始进行全新的真空操作。
- en: It is a good idea to establish a convention for determining the RBU vacuum state
    database name based on the target database name. The example code below uses "<target>-vacuum",
    where <target> is the name of the database being vacuumed.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 建议根据目标数据库名称设定RBU真空状态数据库名称的约定。以下示例代码使用"<target>-vacuum"，其中<target>是正在进行真空操作的数据库名称。
- en: Any custom collation sequences used by indexes within the database being vacuumed
    are registered with both of the database handles returned by the sqlite3rbu_db()
    function.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于真空操作的数据库中使用的任何自定义排序序列都会在由sqlite3rbu_db()函数返回的两个数据库句柄中注册。
- en: Function sqlite3rbu_step() is called on the RBU handle until either the RBU
    vacuum is finished, an error occurs or the application wishes to suspend the RBU
    vacuum.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在RBU句柄上调用sqlite3rbu_step()函数，直到RBU真空完成、出现错误或应用程序希望暂停为止。
- en: Each call to sqlite3rbu_step() does a small amount of work towards completing
    the vacuum operation. Depending on the size of the database, a single vacuum may
    require thousands of calls to sqlite3rbu_step(). sqlite3rbu_step() returns SQLITE_DONE
    if the vacuum operation has finished, SQLITE_OK if the vacuum operation has not
    finished but no error has occurred, and an SQLite error code if an error is encountered.
    If an error does occur, all subsequent calls to sqlite3rbu_step() immediately
    return the same error code.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每次调用sqlite3rbu_step()都会完成一部分真空操作的工作。根据数据库的大小，单次真空操作可能需要数千次sqlite3rbu_step()调用。如果真空操作完成，sqlite3rbu_step()返回SQLITE_DONE；如果真空操作尚未完成但没有错误发生，则返回SQLITE_OK；如果遇到错误，则返回SQLite错误代码。如果发生错误，所有后续对sqlite3rbu_step()的调用都会立即返回相同的错误代码。
- en: Finally, sqlite3rbu_close() is called to close the RBU handle. If the application
    stopped calling sqlite3rbu_step() before either the vacuum finished or an error
    occurred, the state of the vacuum is saved in the state database so that it may
    be resumed later on.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，调用sqlite3rbu_close()关闭RBU句柄。如果应用在真空操作完成之前停止调用sqlite3rbu_step()，则真空的状态会保存在状态数据库中，以便稍后恢复。
- en: Like sqlite3rbu_step(), if the vacuum operation has finished, sqlite3rbu_close()
    returns SQLITE_DONE. If the vacuum has not finished but no error has occurred,
    SQLITE_OK is returned. Or, if an error has occurred, an SQLite error code is returned.
    If an error occurred as part of a prior call to sqlite3rbu_step(), sqlite3rbu_close()
    returns the same error code.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与sqlite3rbu_step()类似，如果真空操作已完成，sqlite3rbu_close()返回SQLITE_DONE。如果真空尚未完成但未发生错误，则返回SQLITE_OK。或者，如果发生错误，则返回SQLite错误代码。如果错误发生在先前的sqlite3rbu_step()调用中，sqlite3rbu_close()将返回相同的错误代码。
- en: The following example code illustrates the techniques described above.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码演示了上述描述的技术。
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
