- en: PRAGMA Statements
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PRAGMA 语句
- en: 原文：[https://sqlite.com/pragma.html](https://sqlite.com/pragma.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://sqlite.com/pragma.html](https://sqlite.com/pragma.html)
- en: 'The PRAGMA statement is an SQL extension specific to SQLite and used to modify
    the operation of the SQLite library or to query the SQLite library for internal
    (non-table) data. The PRAGMA statement is issued using the same interface as other
    SQLite commands (e.g. [SELECT](lang_select.html), [INSERT](lang_insert.html))
    but is different in the following important respects:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA 语句是 SQLite 特有的 SQL 扩展，用于修改 SQLite 库的操作或查询 SQLite 库的内部（非表格）数据。PRAGMA 语句使用与其他
    SQLite 命令相同的接口发出（例如 [SELECT](lang_select.html)、[INSERT](lang_insert.html)），但在以下重要方面有所不同：
- en: The pragma command is specific to SQLite and is not compatible with any other
    SQL database engine.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PRAGMA 命令专用于 SQLite，与其他任何 SQL 数据库引擎都不兼容。
- en: Specific pragma statements may be removed and others added in future releases
    of SQLite. There is no guarantee of backwards compatibility.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未来的 SQLite 版本可能会删除特定的 PRAGMA 语句并添加其他的 PRAGMA 语句。不保证向后兼容性。
- en: No error messages are generated if an unknown pragma is issued. Unknown pragmas
    are simply ignored. This means if there is a typo in a pragma statement the library
    does not inform the user of the fact.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果发出未知的 PRAGMA，不会生成错误消息。未知的 PRAGMA 会被简单地忽略。这意味着如果 PRAGMA 语句中有拼写错误，库不会通知用户这个事实。
- en: Some pragmas take effect during the SQL compilation stage, not the execution
    stage. This means if using the C-language [sqlite3_prepare()](c3ref/prepare.html),
    [sqlite3_step()](c3ref/step.html), [sqlite3_finalize()](c3ref/finalize.html) API
    (or similar in a wrapper interface), the pragma may run during the [sqlite3_prepare()](c3ref/prepare.html)
    call, not during the [sqlite3_step()](c3ref/step.html) call as normal SQL statements
    do. Or the pragma might run during sqlite3_step() just like normal SQL statements.
    Whether or not the pragma runs during sqlite3_prepare() or sqlite3_step() depends
    on the pragma and on the specific release of SQLite.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些 PRAGMA 在 SQL 编译阶段生效，而不是执行阶段。这意味着如果使用 C 语言的 [sqlite3_prepare()](c3ref/prepare.html)、[sqlite3_step()](c3ref/step.html)、[sqlite3_finalize()](c3ref/finalize.html)
    API（或者类似的封装接口），PRAGMA 可能会在 [sqlite3_prepare()](c3ref/prepare.html) 调用期间运行，而不是在通常的
    SQL 语句 [sqlite3_step()](c3ref/step.html) 调用期间运行。或者 PRAGMA 可能会像正常的 SQL 语句一样在 sqlite3_step()
    期间运行。PRAGMA 是否在 sqlite3_prepare() 还是 sqlite3_step() 期间运行取决于具体的 PRAGMA 和 SQLite
    的具体版本。
- en: The [EXPLAIN](lang_explain.html) and [EXPLAIN QUERY PLAN](eqp.html) prefixes
    to SQL statements only affect the behavior of the statement during [sqlite3_step()](c3ref/step.html).
    That means that PRAGMA statements that take effect during [sqlite3_prepare()](c3ref/prepare.html)
    will behave the same way regardless of whether or not they are prefaced by "EXPLAIN".
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[EXPLAIN](lang_explain.html) 和 [EXPLAIN QUERY PLAN](eqp.html) 前缀仅影响在 [sqlite3_step()](c3ref/step.html)
    执行期间 SQL 语句的行为。这意味着在 [sqlite3_prepare()](c3ref/prepare.html) 阶段生效的 PRAGMA 语句无论是否以
    "EXPLAIN" 开头，行为都是一样的。'
- en: The C-language API for SQLite provides the [SQLITE_FCNTL_PRAGMA](c3ref/c_fcntl_begin_atomic_write.html#sqlitefcntlpragma)
    [file control](c3ref/file_control.html) which gives [VFS](vfs.html) implementations
    the opportunity to add new PRAGMA statements or to override the meaning of built-in
    PRAGMA statements.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 的 C 语言 API 提供了[SQLITE_FCNTL_PRAGMA](c3ref/c_fcntl_begin_atomic_write.html#sqlitefcntlpragma)
    [文件控制](c3ref/file_control.html)，这使得 [VFS](vfs.html) 实现有机会添加新的 PRAGMA 语句或覆盖内置 PRAGMA
    语句的含义。
- en: '* * *'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: PRAGMA command syntax
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PRAGMA 命令语法
- en: '**[pragma-stmt:](syntax/pragma-stmt.html)**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**[pragma-stmt:](syntax/pragma-stmt.html)**'
- en: <svg class="pikchr" viewBox="0 0 824.352 99.576"><text x="75" y="17" text-anchor="middle"
    fill="rgb(0,0,0)" dominant-baseline="central">PRAGMA</text> <text x="218" y="17"
    text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">schema-name</text>
    <text x="320" y="17" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)"
    dominant-baseline="central">.</text> <text x="435" y="17" text-anchor="middle"
    fill="rgb(0,0,0)" dominant-baseline="central">pragma-name</text> <text x="555"
    y="82" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)" dominant-baseline="central">(</text>
    <text x="656" y="82" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">pragma-value</text>
    <text x="758" y="82" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)"
    dominant-baseline="central">)</text> <text x="555" y="44" text-anchor="middle"
    font-weight="bold" fill="rgb(0,0,0)" dominant-baseline="central">=</text> <text
    x="656" y="44" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">pragma-value</text></svg>
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="pikchr" viewBox="0 0 824.352 99.576"><text x="75" y="17" text-anchor="middle"
    fill="rgb(0,0,0)" dominant-baseline="central">PRAGMA</text> <text x="218" y="17"
    text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">模式名称</text>
    <text x="320" y="17" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)"
    dominant-baseline="central">.</text> <text x="435" y="17" text-anchor="middle"
    fill="rgb(0,0,0)" dominant-baseline="central">指示符名称</text> <text x="555" y="82"
    text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)" dominant-baseline="central">(</text>
    <text x="656" y="82" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">指示符值</text>
    <text x="758" y="82" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)"
    dominant-baseline="central">)</text> <text x="555" y="44" text-anchor="middle"
    font-weight="bold" fill="rgb(0,0,0)" dominant-baseline="central">=</text> <text
    x="656" y="44" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">指示符值</text></svg>
- en: '**[pragma-value:](syntax/pragma-value.html)**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**[指示符值：](syntax/pragma-value.html)**'
- en: <svg class="pikchr" viewBox="0 0 264.499 110.16"><text x="132" y="17" text-anchor="middle"
    fill="rgb(0,0,0)" dominant-baseline="central">signed-number</text> <text x="92"
    y="55" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">name</text>
    <text x="125" y="92" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">signed-literal</text></svg>
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="pikchr" viewBox="0 0 264.499 110.16"><text x="132" y="17" text-anchor="middle"
    fill="rgb(0,0,0)" dominant-baseline="central">带符号数</text> <text x="92" y="55"
    text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">名称</text> <text
    x="125" y="92" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">带符号文字</text></svg>
- en: '**[signed-number:](syntax/signed-number.html)**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**[带符号数：](syntax/signed-number.html)**'
- en: <svg class="pikchr" viewBox="0 0 292.013 99.576"><text x="66" y="44" text-anchor="middle"
    font-weight="bold" fill="rgb(0,0,0)" dominant-baseline="central">+</text> <text
    x="191" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">numeric-literal</text>
    <text x="66" y="82" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)"
    dominant-baseline="central">-</text></svg>
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="pikchr" viewBox="0 0 292.013 99.576"><text x="66" y="44" text-anchor="middle"
    font-weight="bold" fill="rgb(0,0,0)" dominant-baseline="central">+</text> <text
    x="191" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">数值文字</text>
    <text x="66" y="82" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)"
    dominant-baseline="central">-</text></svg>
- en: 'A pragma can take either zero or one argument. The argument is may be either
    in parentheses or it may be separated from the pragma name by an equal sign. The
    two syntaxes yield identical results. In many pragmas, the argument is a boolean.
    The boolean can be one of:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 指示符可以接受零个或一个参数。参数可以用括号括起来，也可以用等号与指示符名称分隔开来。这两种语法产生相同的结果。在许多指示符中，参数是布尔值。布尔值可以是以下之一：
- en: '**1 yes true on'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 yes true on'
- en: 0 no false off**
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 0 no false off**
- en: 'Keyword arguments can optionally appear in quotes. (Example: `''yes'' [FALSE]`.)
    Some pragmas takes a string literal as their argument. When pragma takes a keyword
    argument, it will usually also take a numeric equivalent as well. For example,
    "0" and "no" mean the same thing, as does "1" and "yes". When querying the value
    of a setting, many pragmas return the number rather than the keyword.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数可选择性地出现在引号中。（例如：`'yes' [FALSE]`。）一些指示符将字符串文字作为其参数。当指示符采用关键字参数时，通常也会采用相应的数值等价物。例如，“0”和“no”意思相同，同样，“1”和“yes”也一样。在查询设置的值时，许多指示符返回数字而不是关键字。
- en: A pragma may have an optional schema-name before the pragma name. The schema-name
    is the name of an [ATTACH](lang_attach.html)-ed database or "main" or "temp" for
    the main and the TEMP databases. If the optional schema name is omitted, "main"
    is assumed. In some pragmas, the schema name is meaningless and is simply ignored.
    In the documentation below, pragmas for which the schema name is meaningful are
    shown with a "*schema.*" prefix.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA 可能在 PRAGMA 名称之前具有可选的模式名称。模式名称是 [附加](lang_attach.html) 的数据库的名称或 "main"
    或 "temp" 用于主数据库和 TEMP 数据库。如果省略了可选的模式名称，则假定为 "main"。在某些 PRAGMA 中，模式名称无意义且仅仅被忽略。在下面的文档中，显示对模式名称有意义的
    PRAGMA 使用 "*schema.*" 前缀。
- en: '* * *'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: PRAGMA functions
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PRAGMA 函数
- en: PRAGMAs that return results and that have no side-effects can be accessed from
    ordinary [SELECT](lang_select.html) statements as [table-valued functions](vtab.html#tabfunc2).
    For each participating PRAGMA, the corresponding table-valued function has the
    same name as the PRAGMA with a 7-character "pragma_" prefix. The PRAGMA argument
    and schema, if any, are passed as arguments to the table-valued function, with
    the schema as an optional, last argument.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA 返回结果且没有副作用的 PRAGMA 可以像 [SELECT](lang_select.html) 语句一样从普通的 [表值函数](vtab.html#tabfunc2)
    中访问。对于每个参与的 PRAGMA，相应的表值函数具有相同的名称，前缀为 7 个字符的 "pragma_"。PRAGMA 参数和模式（如果有）作为参数传递给表值函数，模式作为可选的最后一个参数。
- en: 'For example, information about the columns in an index can be read using the
    [index_info pragma](pragma.html#pragma_index_info) as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以使用 [index_info pragma](pragma.html#pragma_index_info) 读取索引中列的信息如下：
- en: '[PRE0]'
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or, the same content can be read using:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以使用相同的内容读取：
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The advantage of the table-valued function format is that the query can return
    just a subset of the PRAGMA columns, can include a WHERE clause, can use aggregate
    functions, and the table-valued function can be just one of several data sources
    in a join. For example, to get a list of all indexed columns in a schema, one
    could query:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 表值函数格式的优点在于查询可以返回 PRAGMA 列的子集，可以包括 WHERE 子句，可以使用聚合函数，并且表值函数可以作为联接中的多个数据源之一。例如，要获取模式中所有索引列的列表，可以查询：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Additional notes:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 附加说明：
- en: Table-valued functions exist only for built-in PRAGMAs, not for PRAGMAs defined
    using the [SQLITE_FCNTL_PRAGMA](c3ref/c_fcntl_begin_atomic_write.html#sqlitefcntlpragma)
    file control.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表值函数仅适用于内置 PRAGMA，不适用于使用 [SQLITE_FCNTL_PRAGMA](c3ref/c_fcntl_begin_atomic_write.html#sqlitefcntlpragma)
    文件控制定义的 PRAGMA。
- en: Table-valued functions exist only for PRAGMAs that return results and that have
    no side-effects.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表值函数仅适用于返回结果且没有副作用的 PRAGMA。
- en: This feature could be used to implement [information schema](https://en.wikipedia.org/wiki/Information_schema)
    by first creating a separate schema using
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此功能可用于通过首先创建一个使用 [information schema](https://en.wikipedia.org/wiki/Information_schema)
    实现的单独模式来实现。
- en: '[PRE3]'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Then creating [VIEWs](lang_createview.html) in that schema that implement the
    official information schema tables using table-valued PRAGMA functions.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后在该模式中创建 [视图](lang_createview.html)，使用表值 PRAGMA 函数实现官方信息模式表。
- en: The table-valued functions for PRAGMA feature was added in SQLite version 3.16.0
    (2017-01-02). Prior versions of SQLite cannot use this feature.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PRAGMA 功能的表值函数特性在 SQLite 版本 3.16.0 (2017-01-02) 中添加。SQLite 的早期版本无法使用此功能。
- en: '* * *'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: List Of PRAGMAs
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PRAGMA 列表
- en: '[analysis_limit](pragma.html#pragma_analysis_limit)'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[分析限制](pragma.html#pragma_analysis_limit)'
- en: '[application_id](pragma.html#pragma_application_id)'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[应用程序 ID](pragma.html#pragma_application_id)'
- en: '[auto_vacuum](pragma.html#pragma_auto_vacuum)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[自动清理](pragma.html#pragma_auto_vacuum)'
- en: '[automatic_index](pragma.html#pragma_automatic_index)'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[自动索引](pragma.html#pragma_automatic_index)'
- en: '[busy_timeout](pragma.html#pragma_busy_timeout)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[忙碌超时](pragma.html#pragma_busy_timeout)'
- en: '[cache_size](pragma.html#pragma_cache_size)'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[缓存大小](pragma.html#pragma_cache_size)'
- en: '[cache_spill](pragma.html#pragma_cache_spill)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[缓存溢出](pragma.html#pragma_cache_spill)'
- en: '[~~case_sensitive_like¹~~](pragma.html#pragma_case_sensitive_like)'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[~~区分大小写的 like¹~~](pragma.html#pragma_case_sensitive_like)'
- en: '[cell_size_check](pragma.html#pragma_cell_size_check)'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[单元大小检查](pragma.html#pragma_cell_size_check)'
- en: '[checkpoint_fullfsync](pragma.html#pragma_checkpoint_fullfsync)'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[全同步检查点](pragma.html#pragma_checkpoint_fullfsync)'
- en: '[collation_list](pragma.html#pragma_collation_list)'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[排序列表](pragma.html#pragma_collation_list)'
- en: '[compile_options](pragma.html#pragma_compile_options)'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[编译选项](pragma.html#pragma_compile_options)'
- en: '[~~count_changes¹~~](pragma.html#pragma_count_changes)'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[~~更改计数¹~~](pragma.html#pragma_count_changes)'
- en: '[~~data_store_directory¹~~](pragma.html#pragma_data_store_directory)'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[~~数据存储目录¹~~](pragma.html#pragma_data_store_directory)'
- en: '[data_version](pragma.html#pragma_data_version)'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数据版本](pragma.html#pragma_data_version)'
- en: '[database_list](pragma.html#pragma_database_list)'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数据库列表](pragma.html#pragma_database_list)'
- en: '[~~default_cache_size¹~~](pragma.html#pragma_default_cache_size)'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[~~默认缓存大小¹~~](pragma.html#pragma_default_cache_size)'
- en: '[defer_foreign_keys](pragma.html#pragma_defer_foreign_keys)'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[延迟外键检查](pragma.html#pragma_defer_foreign_keys)'
- en: '[~~empty_result_callbacks¹~~](pragma.html#pragma_empty_result_callbacks)'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[~~空结果回调¹~~](pragma.html#pragma_empty_result_callbacks)'
- en: '[encoding](pragma.html#pragma_encoding)'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[编码方式](pragma.html#pragma_encoding)'
- en: '[foreign_key_check](pragma.html#pragma_foreign_key_check)'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[外键检查](pragma.html#pragma_foreign_key_check)'
- en: '[foreign_key_list](pragma.html#pragma_foreign_key_list)'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[外键列表](pragma.html#pragma_foreign_key_list)'
- en: '[foreign_keys](pragma.html#pragma_foreign_keys)'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[外键](pragma.html#pragma_foreign_keys)'
- en: '[freelist_count](pragma.html#pragma_freelist_count)'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[空闲列表数](pragma.html#pragma_freelist_count)'
- en: '[~~full_column_names¹~~](pragma.html#pragma_full_column_names)'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[~~全列名¹~~](pragma.html#pragma_full_column_names)'
- en: '[fullfsync](pragma.html#pragma_fullfsync)'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[完全同步](pragma.html#pragma_fullfsync)'
- en: '[function_list](pragma.html#pragma_function_list)'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[函数列表](pragma.html#pragma_function_list)'
- en: '[hard_heap_limit](pragma.html#pragma_hard_heap_limit)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[硬堆限制](pragma.html#pragma_hard_heap_limit)'
- en: '[ignore_check_constraints](pragma.html#pragma_ignore_check_constraints)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[忽略检查约束](pragma.html#pragma_ignore_check_constraints)'
- en: '[incremental_vacuum](pragma.html#pragma_incremental_vacuum)'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[增量清理](pragma.html#pragma_incremental_vacuum)'
- en: '[index_info](pragma.html#pragma_index_info)'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[索引信息](pragma.html#pragma_index_info)'
- en: '[index_list](pragma.html#pragma_index_list)'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[索引列表](pragma.html#pragma_index_list)'
- en: '[index_xinfo](pragma.html#pragma_index_xinfo)'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[索引扩展信息](pragma.html#pragma_index_xinfo)'
- en: '[integrity_check](pragma.html#pragma_integrity_check)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[完整性检查](pragma.html#pragma_integrity_check)'
- en: '[journal_mode](pragma.html#pragma_journal_mode)'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[日志模式](pragma.html#pragma_journal_mode)'
- en: '[journal_size_limit](pragma.html#pragma_journal_size_limit)'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[日志大小限制](pragma.html#pragma_journal_size_limit)'
- en: '[legacy_alter_table](pragma.html#pragma_legacy_alter_table)'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[传统表修改](pragma.html#pragma_legacy_alter_table)'
- en: '[legacy_file_format](pragma.html#pragma_legacy_file_format)'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[传统文件格式](pragma.html#pragma_legacy_file_format)'
- en: '[locking_mode](pragma.html#pragma_locking_mode)'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[锁定模式](pragma.html#pragma_locking_mode)'
- en: '[max_page_count](pragma.html#pragma_max_page_count)'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[最大页数](pragma.html#pragma_max_page_count)'
- en: '[mmap_size](pragma.html#pragma_mmap_size)'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[内存映射大小](pragma.html#pragma_mmap_size)'
- en: '[module_list](pragma.html#pragma_module_list)'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[模块列表](pragma.html#pragma_module_list)'
- en: '[optimize](pragma.html#pragma_optimize)'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[优化](pragma.html#pragma_optimize)'
- en: '[page_count](pragma.html#pragma_page_count)'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[页数](pragma.html#pragma_page_count)'
- en: '[page_size](pragma.html#pragma_page_size)'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[页大小](pragma.html#pragma_page_size)'
- en: '[parser_trace²](pragma.html#pragma_parser_trace)'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[解析器追踪²](pragma.html#pragma_parser_trace)'
- en: '[pragma_list](pragma.html#pragma_pragma_list)'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[PRAGMA列表](pragma.html#pragma_pragma_list)'
- en: '[query_only](pragma.html#pragma_query_only)'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[仅查询](pragma.html#pragma_query_only)'
- en: '[quick_check](pragma.html#pragma_quick_check)'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[快速检查](pragma.html#pragma_quick_check)'
- en: '[read_uncommitted](pragma.html#pragma_read_uncommitted)'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[读未提交](pragma.html#pragma_read_uncommitted)'
- en: '[recursive_triggers](pragma.html#pragma_recursive_triggers)'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[递归触发器](pragma.html#pragma_recursive_triggers)'
- en: '[reverse_unordered_selects](pragma.html#pragma_reverse_unordered_selects)'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[反向无序选择](pragma.html#pragma_reverse_unordered_selects)'
- en: '[schema_version³](pragma.html#pragma_schema_version)'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[模式版本³](pragma.html#pragma_schema_version)'
- en: '[secure_delete](pragma.html#pragma_secure_delete)'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[安全删除](pragma.html#pragma_secure_delete)'
- en: '[~~short_column_names¹~~](pragma.html#pragma_short_column_names)'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[~~短列名¹~~](pragma.html#pragma_short_column_names)'
- en: '[shrink_memory](pragma.html#pragma_shrink_memory)'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[内存收缩](pragma.html#pragma_shrink_memory)'
- en: '[soft_heap_limit](pragma.html#pragma_soft_heap_limit)'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[软堆限制](pragma.html#pragma_soft_heap_limit)'
- en: '[stats³](pragma.html#pragma_stats)'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[统计³](pragma.html#pragma_stats)'
- en: '[synchronous](pragma.html#pragma_synchronous)'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[同步方式](pragma.html#pragma_synchronous)'
- en: '[table_info](pragma.html#pragma_table_info)'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[表信息](pragma.html#pragma_table_info)'
- en: '[table_list](pragma.html#pragma_table_list)'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[表列表](pragma.html#pragma_table_list)'
- en: '[table_xinfo](pragma.html#pragma_table_xinfo)'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[表扩展信息](pragma.html#pragma_table_xinfo)'
- en: '[temp_store](pragma.html#pragma_temp_store)'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[临时存储](pragma.html#pragma_temp_store)'
- en: '[~~temp_store_directory¹~~](pragma.html#pragma_temp_store_directory)'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[~~临时存储目录¹~~](pragma.html#pragma_temp_store_directory)'
- en: '[threads](pragma.html#pragma_threads)'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[线程](pragma.html#pragma_threads)'
- en: '[trusted_schema](pragma.html#pragma_trusted_schema)'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[可信模式](pragma.html#pragma_trusted_schema)'
- en: '[user_version](pragma.html#pragma_user_version)'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[用户版本](pragma.html#pragma_user_version)'
- en: '[vdbe_addoptrace²](pragma.html#pragma_vdbe_addoptrace)'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[VDBE操作追踪²](pragma.html#pragma_vdbe_addoptrace)'
- en: '[vdbe_debug²](pragma.html#pragma_vdbe_debug)'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[VDBE调试²](pragma.html#pragma_vdbe_debug)'
- en: '[vdbe_listing²](pragma.html#pragma_vdbe_listing)'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[VDBE列表²](pragma.html#pragma_vdbe_listing)'
- en: '[vdbe_trace²](pragma.html#pragma_vdbe_trace)'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[VDBE追踪²](pragma.html#pragma_vdbe_trace)'
- en: '[wal_autocheckpoint](pragma.html#pragma_wal_autocheckpoint)'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[WAL自动检查点](pragma.html#pragma_wal_autocheckpoint)'
- en: '[wal_checkpoint](pragma.html#pragma_wal_checkpoint)'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[wal_checkpoint](pragma.html#pragma_wal_checkpoint)'
- en: '[writable_schema³](pragma.html#pragma_writable_schema)'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[writable_schema³](pragma.html#pragma_writable_schema)'
- en: 'Notes:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：
- en: Pragmas whose names are ~~struck through~~ are deprecated. Do not use them.
    They exist for historical compatibility.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被 ~~划掉~~ 的 pragma 已经被弃用。不要使用它们。它们仅存在于历史兼容性。
- en: These pragmas are only available in builds using non-standard compile-time options.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些 pragma 仅在使用非标准编译时选项的构建中可用。
- en: These pragmas are used for testing SQLite and are not recommended for use in
    application programs.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些 pragma 用于测试 SQLite，不建议在应用程序中使用。
- en: <h _id="pragma_analysis_limit" style="display:none">PRAGMA analysis_limit</h>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_analysis_limit" style="display:none">PRAGMA analysis_limit</h>
- en: '* * *'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA analysis_limit;'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA analysis_limit;'
- en: PRAGMA analysis_limit =** *N***;**
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA analysis_limit =** *N***;**
- en: Query or change a limit on the [approximate ANALYZE](lang_analyze.html#approx)
    setting. This is the approximate number of rows examined in each index by the
    [ANALYZE](lang_analyze.html) command. If the argument *N* is omitted, then the
    analysis limit is unchanged. If the limit is zero, then the analysis limit is
    disabled and the ANALYZE command will examine all rows of each index. If N is
    greater than zero, then the analysis limit is set to N and subsequent ANALYZE
    commands will stop analyzing each index after it has examined approximately N
    rows. If N is a negative number or something other than an integer value, then
    the pragma behaves as if the N argument was omitted. In all cases, the value returned
    is the new analysis limit used for subsequent ANALYZE commands.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 查询或更改 [approximate ANALYZE](lang_analyze.html#approx) 设置的限制。这是 ANALYZE 命令在每个索引中大约检查的行数。如果省略参数
    *N*，则分析限制保持不变。如果限制为零，则分析限制被禁用，ANALYZE 命令将检查每个索引的所有行。如果 N 大于零，则将分析限制设置为 N，并且后续的
    ANALYZE 命令将在检查大约 N 行后停止分析每个索引。如果 N 是负数或者不是整数值，则 pragma 的行为就像省略了 N 参数一样。在所有情况下，返回的值是用于后续
    ANALYZE 命令的新分析限制。
- en: This pragma can be used to help the ANALYZE command run faster on large databases.
    The results of analysis are not as good when only part of each index is examined,
    but the results are usually good enough. Setting N to 100 or 1000 allows the ANALYZE
    command to run quickly, even on enormous database files.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 pragma 可以帮助 ANALYZE 命令在大型数据库上运行得更快。当仅检查每个索引的一部分时，分析的结果可能不太好，但通常是足够好的。将 N
    设置为 100 或 1000 可以让 ANALYZE 命令在庞大的数据库文件上快速完成。
- en: This pragma was added in SQLite version 3.32.0 (2020-05-22). The current implementation
    only uses the lower 31 bits of the N value - higher order bits are silently ignored.
    Future versions of SQLite might begin using higher order bits.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 pragma 是在 SQLite 版本 3.32.0（2020-05-22）中添加的。当前的实现仅使用 N 值的低 31 位 - 高位比特会被忽略。未来的
    SQLite 版本可能会开始使用高位比特。
- en: Beginning with SQLite version 3.46.0 (2024-05-23), the recommended way of running
    [ANALYZE](lang_analyze.html) is with the [PRAGMA optimize](pragma.html#pragma_optimize)
    command. The [PRAGMA optimize](pragma.html#pragma_optimize) will automatically
    set a reasonable, temporary analysis limit that ensures that the [PRAGMA optimize](pragma.html#pragma_optimize)
    command will finish quickly even on enormous databases. Applications that use
    the [PRAGMA optimize](pragma.html#pragma_optimize) instead of running [ANALYZE](lang_analyze.html)
    directly do not need to set an analysis limit. <h _id="pragma_application_id"
    style="display:none">PRAGMA application_id</h>
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 从 SQLite 版本 3.46.0（2024-05-23）开始，推荐使用 [ANALYZE](lang_analyze.html) 时配合使用 [PRAGMA
    optimize](pragma.html#pragma_optimize) 命令。[PRAGMA optimize](pragma.html#pragma_optimize)
    将自动设置一个合理的临时分析限制，确保 [PRAGMA optimize](pragma.html#pragma_optimize) 命令即使在大型数据库上也能快速完成。使用
    [PRAGMA optimize](pragma.html#pragma_optimize) 而不是直接运行 [ANALYZE](lang_analyze.html)
    的应用程序不需要设置分析限制。<h _id="pragma_application_id" style="display:none">PRAGMA application_id</h>
- en: '* * *'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA** *schema.***application_id;'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA** *schema.***application_id;'
- en: PRAGMA** *schema.***application_id =** *integer* **;**
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA** *schema.***application_id =** *integer* **;**
- en: The application_id PRAGMA is used to query or set the 32-bit signed big-endian
    "Application ID" integer located at offset 68 into the [database header](fileformat2.html#database_header).
    Applications that use SQLite as their [application file-format](appfileformat.html)
    should set the Application ID integer to a unique integer so that utilities such
    as [file(1)](http://www.darwinsys.com/file/) can determine the specific file type
    rather than just reporting "SQLite3 Database". A list of assigned application
    IDs can be seen by consulting the [magic.txt](https://www.sqlite.org/src/artifact?ci=trunk&filename=magic.txt)
    file in the SQLite source repository.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序标识PRAGMA用于查询或设置位于[数据库头](fileformat2.html#database_header)偏移68的32位有符号大端“应用程序ID”整数。将SQLite用作其[应用程序文件格式](appfileformat.html)的应用程序应设置应用程序ID整数为唯一整数，以便像[file(1)](http://www.darwinsys.com/file/)这样的实用程序可以确定具体的文件类型，而不仅仅报告“SQLite3
    Database”。可以通过查阅SQLite源代码库中的[magic.txt](https://www.sqlite.org/src/artifact?ci=trunk&filename=magic.txt)文件来查看分配的应用程序ID列表。
- en: See also the [user_version pragma](pragma.html#pragma_user_version). <h _id="pragma_auto_vacuum"
    style="display:none">PRAGMA auto_vacuum</h>
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅[user_version pragma](pragma.html#pragma_user_version)。 <h _id="pragma_auto_vacuum"
    style="display:none">PRAGMA auto_vacuum</h>
- en: '* * *'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA** *schema.***auto_vacuum;'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA** *schema.***auto_vacuum;'
- en: PRAGMA** *schema.***auto_vacuum =** *0 | NONE | 1 | FULL | 2 | INCREMENTAL***;**
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA ** *schema.***auto_vacuum =** *0 | NONE | 1 | FULL | 2 | INCREMENTAL***;**
- en: Query or set the auto-vacuum status in the database.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 查询或设置数据库中的自动清理状态。
- en: The default setting for auto-vacuum is 0 or "none", unless the [SQLITE_DEFAULT_AUTOVACUUM](compile.html#default_autovacuum)
    compile-time option is used. The "none" setting means that auto-vacuum is disabled.
    When auto-vacuum is disabled and data is deleted data from a database, the database
    file remains the same size. Unused database file pages are added to a "[freelist](fileformat2.html#freelist)"
    and reused for subsequent inserts. So no database file space is lost. However,
    the database file does not shrink. In this mode the [VACUUM](lang_vacuum.html)
    command can be used to rebuild the entire database file and thus reclaim unused
    disk space.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 自动清理的默认设置为0或“none”，除非使用[SQLITE_DEFAULT_AUTOVACUUM](compile.html#default_autovacuum)编译时选项。设置为“none”表示自动清理已禁用。当禁用自动清理并从数据库中删除数据时，数据库文件的大小保持不变。未使用的数据库文件页面将添加到“[freelist](fileformat2.html#freelist)”中，并在后续插入时重用。因此，没有数据库文件空间会丢失。但是，数据库文件不会收缩。在这种模式下，可以使用[VACUUM](lang_vacuum.html)命令重建整个数据库文件，从而回收未使用的磁盘空间。
- en: When the auto-vacuum mode is 1 or "full", the freelist pages are moved to the
    end of the database file and the database file is truncated to remove the freelist
    pages at every transaction commit. Note, however, that auto-vacuum only truncates
    the freelist pages from the file. Auto-vacuum does not defragment the database
    nor repack individual database pages the way that the [VACUUM](lang_vacuum.html)
    command does. In fact, because it moves pages around within the file, auto-vacuum
    can actually make fragmentation worse.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当自动清理模式为1或“full”时，空闲列表页面将移动到数据库文件的末尾，并且在每次事务提交时将数据库文件截断以删除空闲列表页面。但请注意，自动清理仅会从文件中截断空闲列表页面。自动清理不会对数据库进行碎片整理或重新打包单个数据库页面，就像[VACUUM](lang_vacuum.html)命令所做的那样。实际上，由于在文件中移动页面，自动清理可能会加剧碎片化问题。
- en: Auto-vacuuming is only possible if the database stores some additional information
    that allows each database page to be traced backwards to its referrer. Therefore,
    auto-vacuuming must be turned on before any tables are created. It is not possible
    to enable or disable auto-vacuum after a table has been created.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 自动清理仅在数据库存储了额外信息以便追踪每个数据库页面到其引用者时才可能实现。因此，在创建任何表之前必须打开自动清理。在创建表后无法启用或禁用自动清理。
- en: When the value of auto-vacuum is 2 or "incremental" then the additional information
    needed to do auto-vacuuming is stored in the database file but auto-vacuuming
    does not occur automatically at each commit as it does with auto_vacuum=full.
    In incremental mode, the separate [incremental_vacuum](pragma.html#pragma_incremental_vacuum)
    pragma must be invoked to cause the auto-vacuum to occur.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当自动清理的值为2或“incremental”时，存储在数据库文件中的额外信息用于执行自动清理，但不会像auto_vacuum=full那样在每次提交时自动执行清理。在增量模式下，必须调用单独的[incremental_vacuum](pragma.html#pragma_incremental_vacuum)
    PRAGMA来触发自动清理。
- en: The database connection can be changed between full and incremental autovacuum
    mode at any time. However, changing from "none" to "full" or "incremental" can
    only occur when the database is new (no tables have yet been created) or by running
    the [VACUUM](lang_vacuum.html) command. To change auto-vacuum modes, first use
    the auto_vacuum pragma to set the new desired mode, then invoke the [VACUUM](lang_vacuum.html)
    command to reorganize the entire database file. To change from "full" or "incremental"
    back to "none" always requires running [VACUUM](lang_vacuum.html) even on an empty
    database.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库连接可以随时在完全和增量自动清理模式之间更改。但是，从"none"更改为"full"或"incremental"只能在数据库是新的情况下（尚未创建任何表）或通过运行[VACUUM](lang_vacuum.html)命令时才能发生。要更改自动清理模式，请首先使用auto_vacuum
    PRAGMA设置新的所需模式，然后调用[VACUUM](lang_vacuum.html)命令重新组织整个数据库文件。即使在空数据库上，从"full"或"incremental"更改回"none"始终需要运行[VACUUM](lang_vacuum.html)。
- en: When the auto_vacuum pragma is invoked with no arguments, it returns the current
    auto_vacuum mode.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当未提供参数调用auto_vacuum PRAGMA时，它返回当前的auto_vacuum模式。
- en: <h _id="pragma_automatic_index" style="display:none">PRAGMA automatic_index</h>
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_automatic_index" style="display:none">PRAGMA automatic_index</h>
- en: '* * *'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA automatic_index;'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA automatic_index;**'
- en: PRAGMA automatic_index =** *boolean***;**
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA automatic_index =** *boolean***;**'
- en: Query, set, or clear the [automatic indexing](optoverview.html#autoindex) capability.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 查询、设置或清除[自动索引](optoverview.html#autoindex)功能。
- en: '[Automatic indexing](optoverview.html#autoindex) is enabled by default as of
    [version 3.7.17](releaselog/3_7_17.html) (2013-05-20), but this might change in
    future releases of SQLite. <h _id="pragma_busy_timeout" style="display:none">PRAGMA
    busy_timeout</h>'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[自动索引](optoverview.html#autoindex)从[版本3.7.17](releaselog/3_7_17.html)（2013-05-20）开始默认启用，但在SQLite的未来版本中可能会更改。
    <h _id="pragma_busy_timeout" style="display:none">PRAGMA busy_timeout</h>'
- en: '* * *'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA busy_timeout;'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA busy_timeout;**'
- en: PRAGMA busy_timeout =** *milliseconds***;**
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA busy_timeout =** *milliseconds***;**
- en: Query or change the setting of the [busy timeout](c3ref/busy_timeout.html).
    This pragma is an alternative to the [sqlite3_busy_timeout()](c3ref/busy_timeout.html)
    C-language interface which is made available as a pragma for use with language
    bindings that do not provide direct access to [sqlite3_busy_timeout()](c3ref/busy_timeout.html).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 查询或更改[繁忙超时](c3ref/busy_timeout.html)的设置。此PRAGMA是[sqlite3_busy_timeout()](c3ref/busy_timeout.html)
    C语言接口的替代，用于不提供直接访问[sqlite3_busy_timeout()](c3ref/busy_timeout.html)的语言绑定。
- en: Each database connection can only have a single [busy handler](c3ref/busy_handler.html).
    This PRAGMA sets the busy handler for the process, possibly overwriting any previously
    set busy handler. <h _id="pragma_cache_size" style="display:none">PRAGMA cache_size</h>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数据库连接只能拥有一个[繁忙处理程序](c3ref/busy_handler.html)。此PRAGMA为进程设置繁忙处理程序，可能会覆盖之前设置的任何繁忙处理程序。
    <h _id="pragma_cache_size" style="display:none">PRAGMA cache_size</h>
- en: '* * *'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA** *schema.***cache_size;'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA** *schema.***cache_size;'
- en: PRAGMA** *schema.***cache_size =** *pages***;
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA **schema.**cache_size =** *pages***;
- en: PRAGMA** *schema.***cache_size = -***kibibytes***;**
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA **schema.**cache_size = -**kibibytes**;**
- en: Query or change the suggested maximum number of database disk pages that SQLite
    will hold in memory at once per open database file. Whether or not this suggestion
    is honored is at the discretion of the [Application Defined Page Cache](c3ref/pcache_methods2.html).
    The default page cache that is built into SQLite honors the request, however alternative
    application-defined page cache implementations may choose to interpret the suggested
    cache size in different ways or to ignore it all together. The default suggested
    cache size is -2000, which means the cache size is limited to 2048000 bytes of
    memory. The default suggested cache size can be altered using the [SQLITE_DEFAULT_CACHE_SIZE](compile.html#default_cache_size)
    compile-time options. The TEMP database has a default suggested cache size of
    0 pages.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 查询或更改SQLite每个打开数据库文件时将在内存中持有的建议最大数据库磁盘页面数。是否遵循此建议取决于[应用定义的页面缓存](c3ref/pcache_methods2.html)。内置于SQLite中的默认页面缓存遵循请求，但是替代的应用定义页面缓存实现可能选择以不同方式解释建议的缓存大小，或者完全忽略它。默认建议的缓存大小为-2000，这意味着缓存大小限制为2048000字节的内存。可以使用[SQLITE_DEFAULT_CACHE_SIZE](compile.html#default_cache_size)编译时选项更改默认建议的缓存大小。TEMP数据库的默认建议缓存大小为0页。
- en: If the argument N is positive then the suggested cache size is set to N. If
    the argument N is negative, then the number of cache pages is adjusted to be a
    number of pages that would use approximately abs(N*1024) bytes of memory based
    on the current page size. SQLite remembers the number of pages in the page cache,
    not the amount of memory used. So if you set the cache size using a negative number
    and subsequently change the page size (using the [PRAGMA page_size](pragma.html#pragma_page_size)
    command) then the maximum amount of cache memory will go up or down in proportion
    to the change in page size.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数 N 是正数，则建议的缓存大小设置为 N。如果参数 N 是负数，则根据当前页面大小调整缓存页的数量，以使用大约 abs(N*1024) 字节的内存。SQLite
    记住页面缓存的页数，而不是使用的内存量。因此，如果使用负数设置缓存大小，然后随后更改页面大小（使用[PRAGMA page_size](pragma.html#pragma_page_size)命令），则缓存内存的最大量会按比例增加或减少。
- en: '*Backwards compatibility note:* The behavior of cache_size with a negative
    N was different prior to [version 3.7.10](releaselog/3_7_10.html) (2012-01-16).
    In earlier versions, the number of pages in the cache was set to the absolute
    value of N.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*向后兼容性说明:* 在[版本 3.7.10](releaselog/3_7_10.html)（2012-01-16）之前，使用负 N 的 `cache_size`
    的行为有所不同。在早期版本中，缓存中的页面数量设置为 N 的绝对值。'
- en: When you change the cache size using the cache_size pragma, the change only
    endures for the current session. The cache size reverts to the default value when
    the database is closed and reopened.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `cache_size` pragma 更改缓存大小时，此更改仅在当前会话中有效。当关闭并重新打开数据库时，缓存大小将恢复为默认值。
- en: The default page cache implemention does not allocate the full amount of cache
    memory all at once. Cache memory is allocated in smaller chunks on an as-needed
    basis. The page_cache setting is a (suggested) upper bound on the amount of memory
    that the cache can use, not the amount of memory it will use all of the time.
    This is the behavior of the default page cache implementation, but an [application
    defined page cache](c3ref/pcache_methods2.html) is free to behave differently
    if it wants. <h _id="pragma_cache_spill" style="display:none">PRAGMA cache_spill</h>
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 默认页面缓存实现不会一次性分配全部缓存内存的完整量。缓存内存会按需以较小的块分配。`page_cache` 设置是缓存可以使用的内存量的（建议的）上限，而不是它将一直使用的内存量。这是默认页面缓存实现的行为，但如果应用程序定义了页面缓存，它可以自由地采用不同的行为。<h
    _id="pragma_cache_spill" style="display:none">PRAGMA cache_spill</h>
- en: '* * *'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA cache_spill;'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA cache_spill;**'
- en: PRAGMA cache_spill=***boolean***;
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA cache_spill=***boolean***;
- en: PRAGMA** *schema.***cache_spill=*N*;**
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA** *schema.***cache_spill=*N*;**
- en: The cache_spill pragma enables or disables the ability of the pager to spill
    dirty cache pages to the database file in the middle of a transaction. Cache_spill
    is enabled by default and most applications should leave it that way as cache
    spilling is usually advantageous. However, a cache spill has the side-effect of
    acquiring an [EXCLUSIVE lock](lockingv3.html#excl_lock) on the database file.
    Hence, some applications that have large long-running transactions may want to
    disable cache spilling in order to prevent the application from acquiring an exclusive
    lock on the database until the moment that the transaction [COMMIT](lang_transaction.html)s.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`cache_spill` 命令允许或禁用分页器在事务进行中将脏缓存页溢出到数据库文件的能力。默认情况下启用 `cache_spill`，大多数应用程序应该保持这种设置，因为缓存溢出通常是有利的。然而，缓存溢出会导致数据库文件获取[排他锁](lockingv3.html#excl_lock)的副作用。因此，一些具有大型长时间运行事务的应用程序可能希望禁用缓存溢出，以防止应用程序在事务[提交](lang_transaction.html)之前获取对数据库的排他锁。'
- en: The "PRAGMA cache_spill=*N*" form of this pragma sets a minimum cache size threshold
    required for spilling to occur. The number of pages in cache must exceed both
    the cache_spill threshold and the maximum cache size set by the [PRAGMA cache_size](pragma.html#pragma_cache_size)
    statement in order for spilling to occur.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '"PRAGMA cache_spill=*N*" 形式的此 pragma 设置了溢出发生所需的最小缓存大小阈值。在进行溢出之前，缓存中的页面数量必须超过
    `cache_spill` 阈值和由[PRAGMA cache_size](pragma.html#pragma_cache_size)语句设置的最大缓存大小。'
- en: The "PRAGMA cache_spill=*boolean*" form of this pragma applies across all databases
    attached to the database connection. But the "PRAGMA cache_spill=*N*" form of
    this statement only applies to the "main" schema or whatever other schema is specified
    as part of the statement. <h _id="pragma_case_sensitive_like" style="display:none">PRAGMA
    case_sensitive_like</h>
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '"PRAGMA cache_spill=*boolean*" 形式的这个 pragma 适用于连接到数据库连接的所有数据库。但这个语句的 "PRAGMA
    cache_spill=*N*" 形式只适用于 "main" 模式或者语句中指定的其他模式。'
- en: '* * *'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA case_sensitive_like =** *boolean***;**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA case_sensitive_like =** *boolean***;**'
- en: The default behavior of the [LIKE](lang_expr.html#like) operator is to ignore
    case for ASCII characters. Hence, by default **'a' LIKE 'A'** is true. The case_sensitive_like
    pragma installs a new application-defined LIKE function that is either case sensitive
    or insensitive depending on the value of the case_sensitive_like pragma. When
    case_sensitive_like is disabled, the default LIKE behavior is expressed. When
    case_sensitive_like is enabled, case becomes significant. So, for example, **'a'
    LIKE 'A'** is false but **'a' LIKE 'a'** is still true.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[LIKE](lang_expr.html#like) 操作符的默认行为是对 ASCII 字符不区分大小写。因此，默认情况下 **''a'' LIKE
    ''A''** 是 true。case_sensitive_like pragma 安装一个新的应用程序定义的 LIKE 函数，该函数是否区分大小写取决于
    case_sensitive_like pragma 的值。禁用 case_sensitive_like 时，表达默认的 LIKE 行为。启用 case_sensitive_like
    时，大小写变得重要。所以，例如，**''a'' LIKE ''A''** 是 false，但 **''a'' LIKE ''a''** 仍然是 true。'
- en: This pragma uses [sqlite3_create_function()](c3ref/create_function.html) to
    overload the LIKE and GLOB functions, which may override previous implementations
    of LIKE and GLOB registered by the application. This pragma only changes the behavior
    of the SQL [LIKE](lang_expr.html#like) operator. It does not change the behavior
    of the [sqlite3_strlike()](c3ref/strlike.html) C-language interface, which is
    always case insensitive.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 pragma 使用 [sqlite3_create_function()](c3ref/create_function.html) 来重载 LIKE
    和 GLOB 函数，这可能会覆盖应用程序注册的之前版本的 LIKE 和 GLOB。这个 pragma 只改变 SQL [LIKE](lang_expr.html#like)
    操作符的行为。它不会改变 [sqlite3_strlike()](c3ref/strlike.html) C 语言接口的行为，后者总是不区分大小写的。
- en: '**WARNING:** If a database uses the LIKE operator anywhere in the schema, such
    as in a [CHECK constraint](lang_createtable.html#ckconst) or in an [expression
    index](expridx.html) or in the WHERE clause of a [partial index](partialindex.html),
    then changing the definition of the LIKE operator using this PRAGMA can cause
    the database to appear to be corrupt. [PRAGMA integrity_check](pragma.html#pragma_integrity_check)
    will report errors. The database is not really corrupt in that changing the behavior
    of LIKE back to the way it was when the schema was defined and the database was
    populated will clear the problem. If the use of LIKE occurs only in indexes, then
    the problem can be cleared by running [REINDEX](lang_reindex.html). Nevertheless,
    the use of the case_sensitive_like pragma is discouraged.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告：**如果数据库中的模式任何地方使用了 LIKE 操作符，比如在 [CHECK 约束](lang_createtable.html#ckconst)
    中、在 [expression index](expridx.html) 中或者在 [partial index](partialindex.html) 的
    WHERE 子句中，那么使用这个 PRAGMA 改变 LIKE 操作符的定义可能导致数据库看起来是损坏的。[PRAGMA integrity_check](pragma.html#pragma_integrity_check)
    会报告错误。实际上数据库并不是真的损坏，因为将 LIKE 的行为改回到模式定义和数据库填充时的样子会清除问题。如果 LIKE 只出现在索引中，那么可以通过运行
    [REINDEX](lang_reindex.html) 来清除问题。尽管如此，使用 case_sensitive_like pragma 是不建议的。'
- en: '**This pragma is deprecated** and exists for backwards compatibility only.
    New applications should avoid using this pragma. Older applications should discontinue
    use of this pragma at the earliest opportunity. This pragma may be omitted from
    the build when SQLite is compiled using [SQLITE_OMIT_DEPRECATED](compile.html#omit_deprecated).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**这个 pragma 已被弃用**，只是为了向后兼容而存在。新应用程序应避免使用这个 pragma。旧应用程序应尽早停止使用这个 pragma。当
    SQLite 使用 [SQLITE_OMIT_DEPRECATED](compile.html#omit_deprecated) 编译时，可以省略这个 pragma。'
- en: <h _id="pragma_cell_size_check" style="display:none">PRAGMA cell_size_check</h>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_cell_size_check" style="display:none">PRAGMA cell_size_check
- en: '* * *'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA cell_size_check'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA cell_size_check**'
- en: PRAGMA cell_size_check =** *boolean***;**
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA cell_size_check =** *boolean***;**
- en: The cell_size_check pragma enables or disables additional sanity checking on
    database b-tree pages as they are initially read from disk. With cell size checking
    enabled, database corruption is detected earlier and is less likely to "spread".
    However, there is a small performance hit for doing the extra checks and so cell
    size checking is turned off by default. <h _id="pragma_checkpoint_fullfsync" style="display:none">PRAGMA
    checkpoint_fullfsync</h>
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: cell_size_check pragma在最初从磁盘读取数据库B树页面时启用或禁用额外的健全性检查。启用单元大小检查时，数据库损坏会更早地被检测到，且不太可能“蔓延”。但是，进行额外检查会带来一定的性能损耗，因此默认情况下关闭单元大小检查。
    <h _id="pragma_checkpoint_fullfsync" style="display:none">PRAGMA checkpoint_fullfsync</h>
- en: '* * *'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA checkpoint_fullfsync'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA checkpoint_fullfsync'
- en: PRAGMA checkpoint_fullfsync =** *boolean***;**
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA checkpoint_fullfsync =** *boolean***;**
- en: Query or change the fullfsync flag for [checkpoint](wal.html#ckpt) operations.
    If this flag is set, then the F_FULLFSYNC syncing method is used during checkpoint
    operations on systems that support F_FULLFSYNC. The default value of the checkpoint_fullfsync
    flag is off. Only Mac OS-X supports F_FULLFSYNC.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 查询或更改[检查点](wal.html#ckpt)操作的全fsync标志。如果设置了此标志，则在支持F_FULLFSYNC的系统上，在检查点操作期间使用F_FULLFSYNC同步方法。检查点_fullfsync标志的默认值为关闭。只有Mac
    OS-X支持F_FULLFSYNC。
- en: If the [fullfsync](pragma.html#pragma_fullfsync) flag is set, then the F_FULLFSYNC
    syncing method is used for all sync operations and the checkpoint_fullfsync setting
    is irrelevant.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了[fullfsync](pragma.html#pragma_fullfsync)标志，则所有同步操作都使用F_FULLFSYNC同步方法，并且checkpoint_fullfsync设置是无关紧要的。
- en: <h _id="pragma_collation_list" style="display:none">PRAGMA collation_list</h>
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_collation_list" style="display:none">PRAGMA collation_list</h>
- en: '* * *'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA collation_list;**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA collation_list;**'
- en: Return a list of the collating sequences defined for the current database connection.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 返回当前数据库连接定义的排序序列列表。
- en: <h _id="pragma_compile_options" style="display:none">PRAGMA compile_options</h>
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_compile_options" style="display:none">PRAGMA compile_options</h>
- en: '* * *'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA compile_options;**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA compile_options;**'
- en: This pragma returns the names of [compile-time options](compile.html) used when
    building SQLite, one option per row. The "SQLITE_" prefix is omitted from the
    returned option names. See also the [sqlite3_compileoption_get()](c3ref/compileoption_get.html)
    C/C++ interface and the [sqlite_compileoption_get()](lang_corefunc.html#sqlite_compileoption_get)
    SQL functions.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此pragma在构建SQLite时返回[编译时选项](compile.html)的名称，每行一个选项。返回的选项名称省略了"SQLITE_"前缀。还可以参考[C/C++接口sqlite3_compileoption_get()](c3ref/compileoption_get.html)和SQL函数[sqlite_compileoption_get()](lang_corefunc.html#sqlite_compileoption_get)。
- en: <h _id="pragma_count_changes" style="display:none">PRAGMA count_changes</h>
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_count_changes" style="display:none">PRAGMA count_changes</h>
- en: '* * *'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA count_changes;'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA count_changes;'
- en: PRAGMA count_changes =** boolean**;**
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA count_changes =** boolean**;**
- en: Query or change the count-changes flag. Normally, when the count-changes flag
    is not set, [INSERT](lang_insert.html), [UPDATE](lang_update.html) and [DELETE](lang_delete.html)
    statements return no data. When count-changes is set, each of these commands returns
    a single row of data consisting of one integer value - the number of rows inserted,
    modified or deleted by the command. The returned change count does not include
    any insertions, modifications or deletions performed by triggers, any changes
    made automatically by [foreign key actions](foreignkeys.html#fk_actions), or updates
    caused by an [upsert](lang_upsert.html).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 查询或更改计数更改标志。通常情况下，当未设置计数更改标志时，[INSERT](lang_insert.html)，[UPDATE](lang_update.html)和[DELETE](lang_delete.html)语句不返回数据。当设置了计数更改时，每个命令返回一个包含一个整数值的单行数据
    - 命令插入，修改或删除的行数。返回的更改计数不包括触发器执行的任何插入，修改或删除，任何由[外键操作](foreignkeys.html#fk_actions)自动进行的更改，或由[upsert](lang_upsert.html)引起的更新。
- en: Another way to get the row change counts is to use the [sqlite3_changes()](c3ref/changes.html)
    or [sqlite3_total_changes()](c3ref/total_changes.html) interfaces. There is a
    subtle different, though. When an INSERT, UPDATE, or DELETE is run against a view
    using an [INSTEAD OF trigger](lang_createtrigger.html#instead_of_trigger), the
    count_changes pragma reports the number of rows in the view that fired the trigger,
    whereas [sqlite3_changes()](c3ref/changes.html) and [sqlite3_total_changes()](c3ref/total_changes.html)
    do not.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种获取行更改计数的方法是使用[sqlite3_changes()](c3ref/changes.html)或[sqlite3_total_changes()](c3ref/total_changes.html)接口。不过有一个细微的区别。当针对使用[INSTEAD
    OF trigger](lang_createtrigger.html#instead_of_trigger)的视图运行INSERT、UPDATE或DELETE时，count_changes
    pragma 报告触发触发器的视图中的行数，而[sqlite3_changes()](c3ref/changes.html)和[sqlite3_total_changes()](c3ref/total_changes.html)不会。
- en: '**This pragma is deprecated** and exists for backwards compatibility only.
    New applications should avoid using this pragma. Older applications should discontinue
    use of this pragma at the earliest opportunity. This pragma may be omitted from
    the build when SQLite is compiled using [SQLITE_OMIT_DEPRECATED](compile.html#omit_deprecated).'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**此 pragma 已弃用**，仅用于向后兼容。新应用程序应避免使用此 pragma。较旧的应用程序应尽早停止使用此 pragma。当使用[SQLITE_OMIT_DEPRECATED](compile.html#omit_deprecated)
    编译 SQLite 时，此 pragma 可被省略。'
- en: <h _id="pragma_data_store_directory" style="display:none">PRAGMA data_store_directory</h>
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_data_store_directory" style="display:none">PRAGMA 数据存储目录</h>
- en: '* * *'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA data_store_directory;'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA 数据存储目录;'
- en: PRAGMA data_store_directory = '***directory-name***';**
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`PR   PRAGMA 数据存储目录 = ''***directory-name***'';**'
- en: Query or change the value of the [sqlite3_data_directory](c3ref/data_directory.html)
    global variable, which windows operating-system interface backends use to determine
    where to store database files specified using a relative pathname.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 查询或更改[sqlite3_data_directory](c3ref/data_directory.html)全局变量的值，Windows 操作系统接口后端用于确定使用相对路径名指定的数据库文件存储位置。
- en: Changing the data_store_directory setting is not threadsafe. Never change the
    data_store_directory setting if another thread within the application is running
    any SQLite interface at the same time. Doing so results in undefined behavior.
    Changing the data_store_directory setting writes to the [sqlite3_data_directory](c3ref/data_directory.html)
    global variable and that global variable is not protected by a mutex.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 更改 data_store_directory 设置不是线程安全的。如果应用程序中的另一个线程同时运行任何 SQLite 接口，请勿更改 data_store_directory
    设置。这样做会导致未定义的行为。更改 data_store_directory 设置会写入[sqlite3_data_directory](c3ref/data_directory.html)全局变量，而该全局变量没有受到互斥锁的保护。
- en: This facility is provided for WinRT which does not have an OS mechanism for
    reading or changing the current working directory. The use of this pragma in any
    other context is discouraged and may be disallowed in future releases.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能是为 WinRT 提供的，WinRT 没有用于读取或更改当前工作目录的 OS 机制。在任何其他情况下使用此 pragma 是不鼓励的，并且可能在将来的版本中被禁止。
- en: '**This pragma is deprecated** and exists for backwards compatibility only.
    New applications should avoid using this pragma. Older applications should discontinue
    use of this pragma at the earliest opportunity. This pragma may be omitted from
    the build when SQLite is compiled using [SQLITE_OMIT_DEPRECATED](compile.html#omit_deprecated).'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**此 pragma 已弃用**，仅用于向后兼容。新应用程序应避免使用此 pragma。较旧的应用程序应尽早停止使用此 pragma。当使用[SQLITE_OMIT_DEPRECATED](compile.html#omit_deprecated)
    编译 SQLite 时，此 pragma 可被省略。'
- en: <h _id="pragma_data_version" style="display:none">PRAGMA data_version</h>
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_data_version" style="display:none">PRAGMA 数据版本</h>
- en: '* * *'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA** *schema.***data_version;**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA** *schema.***data_version;**'
- en: The "PRAGMA data_version" command provides an indication that the database file
    has been modified. Interactive programs that hold database content in memory or
    that display database content on-screen can use the PRAGMA data_version command
    to determine if they need to flush and reload their memory or update the screen
    display.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '"PRAGMA 数据版本"命令提供了数据库文件已修改的指示。将数据库内容保存在内存中的交互式程序或在屏幕上显示数据库内容的程序可以使用 PRAGMA
    数据版本命令来确定它们是否需要刷新并重新加载其内存或更新屏幕显示。'
- en: The integer values returned by two invocations of "PRAGMA data_version" from
    the same connection will be different if changes were committed to the database
    by any other connection in the interim. The "PRAGMA data_version" value is unchanged
    for commits made on the same database connection. The behavior of "PRAGMA data_version"
    is the same for all database connections, including database connections in separate
    processes and [shared cache](sharedcache.html) database connections.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 两次调用相同连接的 "PRAGMA data_version" 返回的整数值如果在期间其他连接提交了数据库更改，则不同。对于在同一数据库连接上进行的提交，"PRAGMA
    data_version" 值保持不变。"PRAGMA data_version" 的行为对所有数据库连接都相同，包括独立进程中的数据库连接和 [共享缓存](sharedcache.html)
    数据库连接。
- en: The "PRAGMA data_version" value is a local property of each database connection
    and so values returned by two concurrent invocations of "PRAGMA data_version"
    on separate database connections are often different even though the underlying
    database is identical. It is only meaningful to compare the "PRAGMA data_version"
    values returned by the same database connection at two different points in time.
    <h _id="pragma_database_list" style="display:none">PRAGMA database_list</h>
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '"PRAGMA data_version" 的值是每个数据库连接的本地属性，因此在分开的数据库连接上同时调用两次 "PRAGMA data_version"
    返回的值通常是不同的，即使底层数据库相同。只有在不同时间点上由同一数据库连接返回的 "PRAGMA data_version" 值之间进行比较才有意义。<h
    _id="pragma_database_list" style="display:none">PRAGMA database_list</h>'
- en: '* * *'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA database_list;**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA database_list;**'
- en: This pragma works like a query to return one row for each database attached
    to the current database connection. The second column is "main" for the main database
    file, "temp" for the database file used to store TEMP objects, or the name of
    the ATTACHed database for other database files. The third column is the name of
    the database file itself, or an empty string if the database is not associated
    with a file.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 此 pragma 的工作方式类似于查询，返回当前数据库连接附加的每个数据库的一行。第二列是主数据库文件为"main"，用于存储 TEMP 对象的数据库文件为"temp"，或者是附加数据库的名称。第三列是数据库文件本身的名称，如果数据库没有关联文件则为空字符串。
- en: <h _id="pragma_default_cache_size" style="display:none">PRAGMA default_cache_size</h>
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_default_cache_size" style="display:none">PRAGMA default_cache_size</h>
- en: '* * *'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA** *schema.***default_cache_size;'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA** *schema.***default_cache_size;'
- en: PRAGMA** *schema.***default_cache_size =** *Number-of-pages***;**
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA** *schema.***default_cache_size =** *Number-of-pages***;**
- en: This pragma queries or sets the suggested maximum number of pages of disk cache
    that will be allocated per open database file. The difference between this pragma
    and [cache_size](pragma.html#pragma_cache_size) is that the value set here persists
    across database connections. The value of the default cache size is stored in
    the 4-byte big-endian integer located at offset 48 in the header of the database
    file.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 此 pragma 查询或设置建议的每个打开的数据库文件分配的磁盘缓存的最大页面数。此 pragma 与 [cache_size](pragma.html#pragma_cache_size)
    的区别在于此处设置的值跨数据库连接保持不变。默认缓存大小的值存储在数据库文件头部偏移量为 48 的 4 字节大端整数中。
- en: '**This pragma is deprecated** and exists for backwards compatibility only.
    New applications should avoid using this pragma. Older applications should discontinue
    use of this pragma at the earliest opportunity. This pragma may be omitted from
    the build when SQLite is compiled using [SQLITE_OMIT_DEPRECATED](compile.html#omit_deprecated).'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**此 pragma 已被弃用**，仅用于向后兼容。新应用程序应避免使用此 pragma。旧应用程序应尽早停止使用此 pragma。在使用 [SQLITE_OMIT_DEPRECATED](compile.html#omit_deprecated)
    编译 SQLite 时，可以从构建中省略此 pragma。'
- en: <h _id="pragma_defer_foreign_keys" style="display:none">PRAGMA defer_foreign_keys</h>
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_defer_foreign_keys" style="display:none">PRAGMA defer_foreign_keys</h>
- en: '* * *'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA defer_foreign_keys'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA defer_foreign_keys'
- en: PRAGMA defer_foreign_keys =** *boolean***;**
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA defer_foreign_keys =** *boolean***;**
- en: When the defer_foreign_keys [PRAGMA](pragma.html#syntax) is on, enforcement
    of all [foreign key constraints](foreignkeys.html) is delayed until the outermost
    transaction is committed. The defer_foreign_keys pragma defaults to OFF so that
    foreign key constraints are only deferred if they are created as "DEFERRABLE INITIALLY
    DEFERRED". The defer_foreign_keys pragma is automatically switched off at each
    COMMIT or ROLLBACK. Hence, the defer_foreign_keys pragma must be separately enabled
    for each transaction. This pragma is only meaningful if foreign key constraints
    are enabled, of course.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当defer_foreign_keys [PRAGMA](pragma.html#syntax)开启时，所有[外键约束](foreignkeys.html)的强制执行被延迟直到最外层事务提交。defer_foreign_keys
    pragma默认为OFF，因此仅在创建为“DEFERRABLE INITIALLY DEFERRED”的外键约束时才会延迟。每次提交或回滚时，defer_foreign_keys
    pragma都会自动关闭。因此，每个事务必须单独启用defer_foreign_keys pragma。当然，如果启用了外键约束，这个pragma才有意义。
- en: The [sqlite3_db_status](c3ref/db_status.html)(db,[SQLITE_DBSTATUS_DEFERRED_FKS](c3ref/c_dbstatus_options.html#sqlitedbstatusdeferredfks),...)
    C-language interface can be used during a transaction to determine if there are
    deferred and unresolved foreign key constraints.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[sqlite3_db_status](c3ref/db_status.html)(db,[SQLITE_DBSTATUS_DEFERRED_FKS](c3ref/c_dbstatus_options.html#sqlitedbstatusdeferredfks),...)
    C语言接口可用于在事务期间确定是否存在延迟和未解析的外键约束。'
- en: <h _id="pragma_empty_result_callbacks" style="display:none">PRAGMA empty_result_callbacks</h>
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_empty_result_callbacks" style="display:none">PRAGMA 空结果回调</h>
- en: '* * *'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA empty_result_callbacks;'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA 空结果回调;'
- en: PRAGMA empty_result_callbacks =** *boolean***;**
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA 空结果回调 =** *boolean***;**
- en: Query or change the empty-result-callbacks flag.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 查询或更改空结果回调标志。
- en: The empty-result-callbacks flag affects the [sqlite3_exec()](c3ref/exec.html)
    API only. Normally, when the empty-result-callbacks flag is cleared, the callback
    function supplied to the [sqlite3_exec()](c3ref/exec.html) is not invoked for
    commands that return zero rows of data. When empty-result-callbacks is set in
    this situation, the callback function is invoked exactly once, with the third
    parameter set to 0 (NULL). This is to enable programs that use the [sqlite3_exec()](c3ref/exec.html)
    API to retrieve column-names even when a query returns no data.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 空结果回调标志仅影响[sqlite3_exec()](c3ref/exec.html) API。通常情况下，当清除空结果回调标志时，提供给[sqlite3_exec()](c3ref/exec.html)的回调函数不会在返回零行数据的命令中调用。在这种情况下设置空结果回调时，回调函数将精确调用一次，第三个参数设置为0（NULL）。这是为了使使用[sqlite3_exec()](c3ref/exec.html)
    API的程序在查询不返回数据时也能检索到列名。
- en: '**This pragma is deprecated** and exists for backwards compatibility only.
    New applications should avoid using this pragma. Older applications should discontinue
    use of this pragma at the earliest opportunity. This pragma may be omitted from
    the build when SQLite is compiled using [SQLITE_OMIT_DEPRECATED](compile.html#omit_deprecated).'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**此pragma已被弃用**，仅用于向后兼容。新应用程序应避免使用此pragma。旧应用程序应尽快停止使用此pragma。在使用[SQLITE_OMIT_DEPRECATED](compile.html#omit_deprecated)编译SQLite时，可能会从构建中省略此pragma。'
- en: <h _id="pragma_encoding" style="display:none">PRAGMA encoding</h>
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_encoding" style="display:none">PRAGMA 编码</h>
- en: '* * *'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA encoding;'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA 编码;'
- en: PRAGMA encoding = 'UTF-8';
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA 编码 = 'UTF-8';
- en: PRAGMA encoding = 'UTF-16';
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA 编码 = 'UTF-16';
- en: PRAGMA encoding = 'UTF-16le';
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA 编码 = 'UTF-16le';
- en: PRAGMA encoding = 'UTF-16be';**
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA 编码 = 'UTF-16be';**
- en: In first form, if the main database has already been created, then this pragma
    returns the text encoding used by the main database, one of 'UTF-8', 'UTF-16le'
    (little-endian UTF-16 encoding) or 'UTF-16be' (big-endian UTF-16 encoding). If
    the main database has not already been created, then the value returned is the
    text encoding that will be used to create the main database, if it is created
    by this session.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种形式中，如果主数据库已经创建，则此pragma返回主数据库使用的文本编码之一：'UTF-8'、'UTF-16le'（小端UTF-16编码）或'UTF-16be'（大端UTF-16编码）。如果主数据库尚未创建，则返回的值是会话创建主数据库时将使用的文本编码。
- en: The second through fifth forms of this pragma set the encoding that the main
    database will be created with if it is created by this session. The string 'UTF-16'
    is interpreted as "UTF-16 encoding using native machine byte-ordering". It is
    not possible to change the text encoding of a database after it has been created
    and any attempt to do so will be silently ignored.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 第二至第五种形式的此pragma设置了如果此会话创建主数据库，则主数据库将使用的编码。字符串'UTF-16'被解释为“使用本地机器字节顺序的UTF-16编码”。创建数据库后无法更改文本编码，任何尝试这样做都将被静默忽略。
- en: If no encoding is first set with this pragma, then the encoding with which the
    main database will be created defaults to one determined by the [API used to open
    the connection](c3ref/open.html).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有首先使用此PRAGMA设置编码，则主数据库将使用由[用于打开连接的API](c3ref/open.html)确定的默认编码。
- en: Once an encoding has been set for a database, it cannot be changed.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦为数据库设置了编码，就无法更改。
- en: Databases created by the [ATTACH](lang_attach.html) command always use the same
    encoding as the main database. An attempt to [ATTACH](lang_attach.html) a database
    with a different text encoding from the "main" database will fail.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 由[ATTACH](lang_attach.html)命令创建的数据库始终使用与主数据库相同的编码。试图使用与“主”数据库不同的文本编码[ATTACH](lang_attach.html)数据库将失败。
- en: <h _id="pragma_foreign_key_check" style="display:none">PRAGMA foreign_key_check</h>
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_foreign_key_check" style="display:none">PRAGMA foreign_key_check</h>
- en: '* * *'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA** *schema.***foreign_key_check;'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA** *schema.*`foreign_key_check`;'
- en: PRAGMA** *schema.***foreign_key_check(***table-name***);**
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA** *schema.***foreign_key_check(***table-name***);**
- en: The foreign_key_check pragma checks the database, or the table called "*table-name*",
    for [foreign key constraints](foreignkeys.html) that are violated. The foreign_key_check
    pragma returns one row output for each foreign key violation. There are four columns
    in each result row. The first column is the name of the table that contains the
    REFERENCES clause. The second column is the [rowid](lang_createtable.html#rowid)
    of the row that contains the invalid REFERENCES clause, or NULL if the child table
    is a [WITHOUT ROWID](withoutrowid.html) table. The third column is the name of
    the table that is referred to. The fourth column is the index of the specific
    foreign key constraint that failed. The fourth column in the output of the foreign_key_check
    pragma is the same integer as the first column in the output of the [foreign_key_list
    pragma](pragma.html#pragma_foreign_key_list). When a "*table-name*" is specified,
    the only foreign key constraints checked are those created by REFERENCES clauses
    in the CREATE TABLE statement for *table-name*.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: foreign_key_check` PRAGMA`检查数据库或名为“*table-name*”的表，查找违反的[外键约束](foreignkeys.html)。每个外键违规都会返回一行输出。每个结果行有四列。第一列是包含REFERENCES子句的表的名称。第二列是包含无效REFERENCES子句的行的[rowid](lang_createtable.html#rowid)，如果子表是[WITHOUT
    ROWID](withoutrowid.html)表，则为NULL。第三列是被引用的表的名称。第四列是失败的特定外键约束的索引。foreign_key_check`
    PRAGMA输出的第四列与[foreign_key_list PRAGMA](pragma.html#pragma_foreign_key_list)输出的第一列相同。指定“*table-name*”时，只会检查由CREATE
    TABLE语句中REFERENCES子句创建的外键约束。
- en: <h _id="pragma_foreign_key_list" style="display:none">PRAGMA foreign_key_list</h>
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_foreign_key_list" style="display:none">PRAGMA foreign_key_list</h>
- en: '* * *'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA foreign_key_list(***table-name***);**'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA foreign_key_list(***table-name***);**'
- en: This pragma returns one row for each [foreign key constraint](foreignkeys.html)
    created by a REFERENCES clause in the CREATE TABLE statement of table "*table-name*".
    <h _id="pragma_foreign_keys" style="display:none">PRAGMA foreign_keys</h>
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 此PRAGMA为每个在CREATE TABLE语句中的REFERENCES子句创建的[外键约束](foreignkeys.html)返回一行。 <h _id="pragma_foreign_keys"
    style="display:none">PRAGMA foreign_keys</h>
- en: '* * *'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA foreign_keys;'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA foreign_keys;'
- en: PRAGMA foreign_keys =** *boolean***;**
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA foreign_keys =** *boolean***;**
- en: Query, set, or clear the enforcement of [foreign key constraints](foreignkeys.html).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 查询、设置或清除[外键约束](foreignkeys.html)的执行。
- en: This pragma is a no-op within a transaction; foreign key constraint enforcement
    may only be enabled or disabled when there is no pending [BEGIN](lang_transaction.html)
    or [SAVEPOINT](lang_savepoint.html).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 此PRAGMA在事务内无效；只有在没有待处理的[BEGIN](lang_transaction.html)或[SAVEPOINT](lang_savepoint.html)时才能启用或禁用外键约束执行。
- en: Changing the foreign_keys setting affects the execution of all statements prepared
    using the database connection, including those prepared before the setting was
    changed. Any existing statements prepared using the legacy [sqlite3_prepare()](c3ref/prepare.html)
    interface may fail with an [SQLITE_SCHEMA](rescode.html#schema) error after the
    foreign_keys setting is changed.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 更改foreign_keys设置会影响使用数据库连接准备的所有语句的执行，包括在更改设置之前准备的语句。在更改foreign_keys设置后，使用传统[sqlite3_prepare()](c3ref/prepare.html)接口准备的现有语句可能会因[SQLITE_SCHEMA](rescode.html#schema)错误而失败。
- en: As of SQLite [version 3.6.19](releaselog/3_6_19.html), the default setting for
    foreign key enforcement is OFF. However, that might change in a future release
    of SQLite. The default setting for foreign key enforcement can be specified at
    compile-time using the [SQLITE_DEFAULT_FOREIGN_KEYS](compile.html#default_foreign_keys)
    preprocessor macro. To minimize future problems, applications should set the foreign
    key enforcement flag as required by the application and not depend on the default
    setting. <h _id="pragma_freelist_count" style="display:none">PRAGMA freelist_count</h>
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 自 SQLite [version 3.6.19](releaselog/3_6_19.html) 起，默认情况下外键强制执行设置为关闭。但是，这可能会在将来的
    SQLite 发布版本中更改。可以在编译时使用 [SQLITE_DEFAULT_FOREIGN_KEYS](compile.html#default_foreign_keys)
    预处理宏指定外键强制执行的默认设置。为了尽量减少未来的问题，应用程序应根据应用程序的要求设置外键强制执行标志，而不依赖于默认设置。 <h _id="pragma_freelist_count"
    style="display:none">PRAGMA freelist_count</h>
- en: '* * *'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA** *schema.***freelist_count;**'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA** *schema.***freelist_count;**'
- en: Return the number of unused pages in the database file.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 返回数据库文件中未使用页面的数量。
- en: <h _id="pragma_full_column_names" style="display:none">PRAGMA full_column_names</h>
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_full_column_names" style="display:none">PRAGMA full_column_names</h>
- en: '* * *'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA full_column_names;'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA full_column_names;'
- en: PRAGMA full_column_names =** *boolean***;**
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA full_column_names =** *boolean***;**
- en: 'Query or change the full_column_names flag. This flag together with the [short_column_names](pragma.html#pragma_short_column_names)
    flag determine the way SQLite assigns names to result columns of [SELECT](lang_select.html)
    statements. Result columns are named by applying the following rules in order:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 查询或更改 full_column_names 标志。此标志与 [short_column_names](pragma.html#pragma_short_column_names)
    标志一起决定 SQLite 分配 [SELECT](lang_select.html) 语句结果列名称的方式。结果列名称按以下顺序应用规则命名：
- en: If there is an AS clause on the result, then the name of the column is the right-hand
    side of the AS clause.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果结果上有 AS 子句，则列的名称为 AS 子句的右侧。
- en: If the result is a general expression, not a just the name of a source table
    column, then the name of the result is a copy of the expression text.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果结果是一般表达式而不仅仅是源表列的名称，则结果的名称是表达式文本的副本。
- en: 'If the [short_column_names](pragma.html#pragma_short_column_names) pragma is
    ON, then the name of the result is the name of the source table column without
    the source table name prefix: COLUMN.'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 [short_column_names](pragma.html#pragma_short_column_names) pragma 打开，则结果的名称为源表列名，不包含源表名前缀：COLUMN。
- en: If both pragmas [short_column_names](pragma.html#pragma_short_column_names)
    and [full_column_names](pragma.html#pragma_full_column_names) are OFF then case
    (2) applies.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果同时关闭 [short_column_names](pragma.html#pragma_short_column_names) 和 [full_column_names](pragma.html#pragma_full_column_names)
    pragma，则适用情况（2）。
- en: 'The name of the result column is a combination of the source table and source
    column name: TABLE.COLUMN'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果列的名称是源表和源列名的组合：TABLE.COLUMN
- en: '**This pragma is deprecated** and exists for backwards compatibility only.
    New applications should avoid using this pragma. Older applications should discontinue
    use of this pragma at the earliest opportunity. This pragma may be omitted from
    the build when SQLite is compiled using [SQLITE_OMIT_DEPRECATED](compile.html#omit_deprecated).'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**此 pragma 已被弃用**，仅用于向后兼容。新应用程序应避免使用此 pragma。旧应用程序应尽快停止使用此 pragma。在使用 [SQLITE_OMIT_DEPRECATED](compile.html#omit_deprecated)
    编译 SQLite 时，可能会省略此 pragma。'
- en: <h _id="pragma_fullfsync" style="display:none">PRAGMA fullfsync</h>
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_fullfsync" style="display:none">PRAGMA fullfsync</h>
- en: '* * *'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA fullfsync'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA fullfsync'
- en: PRAGMA fullfsync =** *boolean***;**
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA fullfsync =** *boolean***;**
- en: Query or change the fullfsync flag. This flag determines whether or not the
    F_FULLFSYNC syncing method is used on systems that support it. The default value
    of the fullfsync flag is off. Only Mac OS X supports F_FULLFSYNC.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 查询或更改 fullfsync 标志。此标志确定系统是否支持 F_FULLFSYNC 同步方法的使用。fullfsync 标志的默认值为关闭。只有 Mac
    OS X 支持 F_FULLFSYNC。
- en: See also [checkpoint_fullfsync](pragma.html#pragma_checkpoint_fullfsync).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅 [checkpoint_fullfsync](pragma.html#pragma_checkpoint_fullfsync)。
- en: <h _id="pragma_function_list" style="display:none">PRAGMA function_list</h>
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_function_list" style="display:none">PRAGMA function_list</h>
- en: '* * *'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA function_list;**'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA function_list;**'
- en: This pragma returns a list of SQL functions known to the database connection.
    Each row of the result describes a single calling signature for a single SQL function.
    Some SQL functions will have multiple rows in the result set if they can (for
    example) be invoked with a varying number of arguments or can accept text in various
    encodings. <h _id="pragma_hard_heap_limit" style="display:none">PRAGMA hard_heap_limit</h>
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 此 PRAGMA 返回数据库连接已知的 SQL 函数列表。结果的每一行描述一个单独 SQL 函数的调用签名。某些 SQL 函数在结果集中可能会有多行，如果它们可以（例如）以不同数量的参数被调用，或者可以接受各种编码的文本。
    <h _id="pragma_hard_heap_limit" style="display:none">PRAGMA hard_heap_limit</h>
- en: '* * *'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA hard_heap_limit'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA hard_heap_limit'
- en: PRAGMA hard_heap_limit=***N*
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA hard_heap_limit=***N*
- en: This pragma invokes the [sqlite3_hard_heap_limit64()](c3ref/hard_heap_limit64.html)
    interface with the argument N, if N is specified and N is a positive integer that
    is less than the current hard heap limit. The hard_heap_limit pragma always returns
    the same integer that would be returned by the [sqlite3_hard_heap_limit64](c3ref/hard_heap_limit64.html)(-1)
    C-language function. That is to say, it always returns the value of the hard heap
    limit that is set after any changes imposed by this PRAGMA.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 此 PRAGMA 命令会调用 [sqlite3_hard_heap_limit64()](c3ref/hard_heap_limit64.html) 接口，并传递参数
    N，如果指定了 N 并且 N 是一个小于当前硬堆限制的正整数。hard_heap_limit PRAGMA 始终返回与 [sqlite3_hard_heap_limit64](c3ref/hard_heap_limit64.html)(-1)
    C 语言函数返回的相同整数。也就是说，它始终返回经过此 PRAGMA 强加的硬堆限制值之后的值。
- en: This pragma can only lower the heap limit, never raise it. The C-language interface
    [sqlite3_hard_heap_limit64()](c3ref/hard_heap_limit64.html) must be used to raise
    the heap limit.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 此 PRAGMA 命令只能降低堆限制，不能提高堆限制。必须使用 C 语言接口 [sqlite3_hard_heap_limit64()](c3ref/hard_heap_limit64.html)
    来提高堆限制。
- en: See also the [soft_heap_limit pragma](pragma.html#pragma_soft_heap_limit). <h
    _id="pragma_ignore_check_constraints" style="display:none">PRAGMA ignore_check_constraints</h>
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅 [soft_heap_limit PRAGMA](pragma.html#pragma_soft_heap_limit)。 <h _id="pragma_ignore_check_constraints"
    style="display:none">PRAGMA ignore_check_constraints</h>
- en: '* * *'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA ignore_check_constraints =** *boolean***;**'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA ignore_check_constraints =** *boolean***;**'
- en: This pragma enables or disables the enforcement of CHECK constraints. The default
    setting is off, meaning that CHECK constraints are enforced by default.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 PRAGMA 命令用于启用或禁用 CHECK 约束的执行。默认设置为 off，意味着 CHECK 约束默认情况下是启用的。
- en: <h _id="pragma_incremental_vacuum" style="display:none">PRAGMA incremental_vacuum</h>
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_incremental_vacuum" style="display:none">PRAGMA incremental_vacuum</h>
- en: '* * *'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA** *schema.***incremental_vacuum***(N)***;'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA** *schema.***incremental_vacuum***(N)***;'
- en: PRAGMA** *schema.***incremental_vacuum;**
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA** *schema.***incremental_vacuum;**'
- en: The incremental_vacuum pragma causes up to *N* pages to be removed from the
    [freelist](fileformat2.html#freelist). The database file is truncated by the same
    amount. The incremental_vacuum pragma has no effect if the database is not in
    [auto_vacuum=incremental](#pragma_auto_vacuum) mode or if there are no pages on
    the freelist. If there are fewer than *N* pages on the freelist, or if *N* is
    less than 1, or if the "(*N*)" argument is omitted, then the entire freelist is
    cleared.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: incremental_vacuum PRAGMA 命令会移除最多 *N* 页从 [freelist](fileformat2.html#freelist)
    中。数据库文件会相应地被截断相同数量的页。如果数据库不是在 [auto_vacuum=incremental](#pragma_auto_vacuum) 模式下，或者
    freelist 上没有页，incremental_vacuum PRAGMA 将不起作用。如果 freelist 上的页少于 *N* 页，或者 *N* 小于
    1，或者 "(*N*)" 参数被省略，则整个 freelist 将被清除。
- en: <h _id="pragma_index_info" style="display:none">PRAGMA index_info</h>
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_index_info" style="display:none">PRAGMA index_info</h>
- en: '* * *'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA** *schema.***index_info(***index-name***);**'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA** *schema.***index_info(***index-name***);**'
- en: This pragma returns one row for each key column in the named index. A key column
    is a column that is actually named in the [CREATE INDEX](lang_createindex.html)
    index statement or [UNIQUE constraint](lang_createtable.html#uniqueconst) or [PRIMARY
    KEY constraint](lang_createtable.html#primkeyconst) that created the index. Index
    entries also usually contain auxiliary columns that point back to the table row
    being indexed. The auxiliary index-columns are not shown by the index_info pragma,
    but they are listed by the [index_xinfo pragma](pragma.html#pragma_index_xinfo).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 此 PRAGMA 对每个指定索引中的每个关键列返回一行。关键列是实际在 [CREATE INDEX](lang_createindex.html) 索引语句或者创建索引的
    [UNIQUE 约束](lang_createtable.html#uniqueconst) 或 [PRIMARY KEY 约束](lang_createtable.html#primkeyconst)
    中命名的列。索引条目通常还包含指回正在索引的表行的辅助列。辅助索引列不会被 index_info PRAGMA 显示，但它们会被 [index_xinfo
    PRAGMA](pragma.html#pragma_index_xinfo) 列出。
- en: 'Output columns from the index_info pragma are as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: index_info PRAGMA 的输出列如下：
- en: The rank of the column within the index. (0 means left-most.)
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 索引列在索引中的排名。 （0表示最左边。）
- en: The rank of the column within the table being indexed. A value of -1 means [rowid](lang_createtable.html#rowid)
    and a value of -2 means that an [expression](expridx.html) is being used.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 索引列在被索引表中的排名。值为-1表示[rowid](lang_createtable.html#rowid)，值为-2表示使用表达式。
- en: The name of the column being indexed. This columns is NULL if the column is
    the [rowid](lang_createtable.html#rowid) or an [expression](expridx.html).
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正在索引的列的名称。如果列是[rowid](lang_createtable.html#rowid)或表达式，则此列为NULL。
- en: If there is no index named *index-name* but there is a [WITHOUT ROWID](withoutrowid.html)
    table with that name, then (as of SQLite [version 3.30.0](releaselog/3_30_0.html)
    on 2019-10-04) this pragma returns the PRIMARY KEY columns of the WITHOUT ROWID
    table as they are used in the records of the underlying b-tree, which is to say
    with duplicate columns removed. <h _id="pragma_index_list" style="display:none">PRAGMA
    index_list</h>
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有名为*index-name*的索引，但存在名为[WITHOUT ROWID](withoutrowid.html)的表，则（从SQLite [版本3.30.0](releaselog/3_30_0.html)起，于2019-10-04）此编译器返回WITHOUT
    ROWID表的主键列，因为它们在底层B树的记录中使用，即删除了重复列。<h _id="pragma_index_list" style="display:none">PRAGMA
    index_list</h>
- en: '* * *'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA** *schema.***index_list(***table-name***);**'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA** *schema.* ***index_list(***table-name***);**'
- en: This pragma returns one row for each index associated with the given table.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 此编译器返回与给定表关联的每个索引的一行。
- en: 'Output columns from the index_list pragma are as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 来自index_list编译器的输出列如下：
- en: A sequence number assigned to each index for internal tracking purposes.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为内部跟踪目的分配给每个索引的序列号。
- en: The name of the index.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 索引的名称。
- en: '"1" if the index is UNIQUE and "0" if not.'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果索引是唯一的，则为"1"，否则为"0"。
- en: '"c" if the index was created by a [CREATE INDEX](lang_createindex.html) statement,
    "u" if the index was created by a [UNIQUE constraint](lang_createtable.html#uniqueconst),
    or "pk" if the index was created by a [PRIMARY KEY constraint](lang_createtable.html#primkeyconst).'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果索引是通过[CREATE INDEX](lang_createindex.html)语句创建的，则为"c"，如果索引是通过[UNIQUE约束](lang_createtable.html#uniqueconst)创建的，则为"u"，如果索引是通过[PRIMARY
    KEY约束](lang_createtable.html#primkeyconst)创建的，则为"pk"。
- en: '"1" if the index is a [partial index](partialindex.html) and "0" if not.'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果索引是[部分索引](partialindex.html)，则为"1"，否则为"0"。
- en: <h _id="pragma_index_xinfo" style="display:none">PRAGMA index_xinfo</h>
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_index_xinfo" style="display:none">PRAGMA index_xinfo</h>
- en: '* * *'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA** *schema.***index_xinfo(***index-name***);**'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA** *schema.* ***index_xinfo(***index-name***);**'
- en: This pragma returns information about every column in an index. Unlike this
    [index_info pragma](pragma.html#pragma_index_info), this pragma returns information
    about every column in the index, not just the key columns. (A key column is a
    column that is actually named in the [CREATE INDEX](lang_createindex.html) index
    statement or [UNIQUE constraint](lang_createtable.html#uniqueconst) or [PRIMARY
    KEY constraint](lang_createtable.html#primkeyconst) that created the index. Auxiliary
    columns are additional columns needed to locate the table entry that corresponds
    to each index entry.)
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 此编译器返回索引中每一列的信息。与此[index_info编译器](pragma.html#pragma_index_info)不同，此编译器返回索引中每一列的信息，而不仅仅是关键列。（关键列是实际上在[CREATE
    INDEX](lang_createindex.html)索引语句或[UNIQUE约束](lang_createtable.html#uniqueconst)或[PRIMARY
    KEY约束](lang_createtable.html#primkeyconst)中命名的列，用于定位对应于每个索引条目的表条目的辅助列。）
- en: 'Output columns from the index_xinfo pragma are as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 来自index_xinfo编译器的输出列如下：
- en: The rank of the column within the index. (0 means left-most. Key columns come
    before auxiliary columns.)
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列在索引中的排名（0表示最左边。关键列在辅助列之前。）
- en: The rank of the column within the table being indexed, or -1 if the index-column
    is the [rowid](lang_createtable.html#rowid) of the table being indexed and -2
    if the [index is on an expression](expridx.html).
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 索引列在被索引表中的排名，如果索引列是被索引表的[rowid](lang_createtable.html#rowid)，则为-1，如果索引在表达式上，则为-2。
- en: The name of the column being indexed, or NULL if the index-column is the [rowid](lang_createtable.html#rowid)
    of the table being indexed or an [expression](expridx.html).
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正在索引的列的名称，如果索引列是被索引表的[rowid](lang_createtable.html#rowid)或表达式，则为NULL。
- en: 1 if the index-column is sorted in reverse (DESC) order by the index and 0 otherwise.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果索引列按索引以逆序（DESC）排序，则为1，否则为0。
- en: The name for the [collating sequence](datatype3.html#collation) used to compare
    values in the index-column.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于比较索引列中的值的排序序列的名称。
- en: 1 if the index-column is a key column and 0 if the index-column is an auxiliary
    column.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果索引列是键列，则返回1，如果索引列是辅助列，则返回0。
- en: If there is no index named *index-name* but there is a [WITHOUT ROWID](withoutrowid.html)
    table with that name, then (as of SQLite [version 3.30.0](releaselog/3_30_0.html)
    on 2019-10-04) this pragma returns the columns of the WITHOUT ROWID table as they
    are used in the records of the underlying b-tree, which is to say with de-duplicated
    PRIMARY KEY columns first followed by data columns. <h _id="pragma_integrity_check"
    style="display:none">PRAGMA integrity_check</h>
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不存在名为*索引名称*的索引但存在同名的[WITHOUT ROWID](withoutrowid.html)表，则（截至SQLite [version
    3.30.0](releaselog/3_30_0.html) 于2019-10-04）此pragma返回WITHOUT ROWID表的列，这些列按照在底层B树记录中使用的方式排列，即首先是去重的主键列，然后是数据列。<h
    _id="pragma_integrity_check" style="display:none">PRAGMA integrity_check</h>
- en: '* * *'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA** *schema.***integrity_check;'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA** *schema.***integrity_check;'
- en: PRAGMA** *schema.***integrity_check(***N***)
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA** *schema.***integrity_check(***N***)
- en: PRAGMA** *schema.***integrity_check(***TABLENAME***)**
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA** *schema.***integrity_check(***TABLENAME***)**
- en: 'This pragma does a low-level formatting and consistency check of the database.
    The integrity_check pragma look for:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 此pragma对数据库进行低级别的格式化和一致性检查。integrity_check pragma查找以下内容：
- en: Table or index entries that are out of sequence
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不按顺序的表或索引条目
- en: Misformatted records
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式错误的记录
- en: Missing pages
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺失的页码
- en: Missing or surplus index entries
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺失或多余的索引条目
- en: UNIQUE, CHECK, and NOT NULL constraint errors
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UNIQUE、CHECK和NOT NULL约束的错误
- en: Integrity of the freelist
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: freelist的一致性
- en: Sections of the database that are used more than once, or not at all
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库中被多次使用或根本未使用的部分
- en: If the integrity_check pragma finds problems, strings are returned (as multiple
    rows with a single column per row) which describe the problems. Pragma integrity_check
    will return at most *N* errors before the analysis quits, with N defaulting to
    100\. If pragma integrity_check finds no errors, a single row with the value 'ok'
    is returned.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果integrity_check pragma发现问题，则以描述问题的字符串形式返回结果（作为多行，每行一个列）。pragma integrity_check在分析退出之前最多返回*N*个错误，其中*N*默认为100。如果pragma
    integrity_check未发现错误，则返回单行字符串'ok'。
- en: The usual case is that the entire database file is checked. However, if the
    argument is *TABLENAME*, then checking is only performed for the the table named
    and its associated indexes. This is called a "partial integrity check". Because
    only a subset of the database is checked, errors such as unused sections of the
    file or duplication use of the same section of the file by two or more tables
    cannot be detected. The freelist is only verified on a partial integrity check
    if *TABLENAME* is [sqlite_schema](schematab.html) or one of its aliases. Support
    for partial integrity checks was added with version 3.33.0 (2020-08-14).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，会检查整个数据库文件。但是，如果参数是*TABLENAME*，则仅对名为*TABLENAME*及其相关索引执行检查。这称为“部分完整性检查”。由于仅检查数据库的子集，因此无法检测到未使用文件的部分或同一文件部分被两个或多个表重复使用的错误。仅当*TABLENAME*是[sqlite_schema](schematab.html)或其别名之一时，才会在部分完整性检查中验证freelist。支持部分完整性检查的功能是从版本3.33.0（2020-08-14）开始添加的。
- en: PRAGMA integrity_check does not find [FOREIGN KEY](foreignkeys.html) errors.
    Use the [PRAGMA foreign_key_check](pragma.html#pragma_foreign_key_check) command
    to find errors in FOREIGN KEY constraints.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA integrity_check无法找到[FOREIGN KEY](foreignkeys.html)错误。请使用[PRAGMA foreign_key_check](pragma.html#pragma_foreign_key_check)命令来查找外键约束的错误。
- en: See also the [PRAGMA quick_check](pragma.html#pragma_quick_check) command which
    does most of the checking of PRAGMA integrity_check but runs much faster.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅[PRAGMA quick_check](pragma.html#pragma_quick_check)命令，该命令执行大部分PRAGMA integrity_check的检查，但运行速度更快。
- en: <h _id="pragma_journal_mode" style="display:none">PRAGMA journal_mode</h>
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_journal_mode" style="display:none">PRAGMA journal_mode</h>
- en: '* * *'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA** *schema.***journal_mode;'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA** *schema.***journal_mode;'
- en: PRAGMA** *schema.***journal_mode = *DELETE | TRUNCATE | PERSIST | MEMORY | WAL
    | OFF***
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA** *schema.***journal_mode = *DELETE | TRUNCATE | PERSIST | MEMORY | WAL
    | OFF***
- en: This pragma queries or sets the journal mode for databases associated with the
    current [database connection](c3ref/sqlite3.html).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 此pragma查询或设置与当前[数据库连接](c3ref/sqlite3.html)关联的数据库的日志模式。
- en: The first form of this pragma queries the current journaling mode for *database*.
    When *database* is omitted, the "main" database is queried.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 查询当前数据库的日志模式时，第一种形式的此pragma查询*数据库*。当省略*数据库*时，默认查询“主”数据库。
- en: The second form changes the journaling mode for "*database*" or for all attached
    databases if "*database*" is omitted. The new journal mode is returned. If the
    journal mode could not be changed, the original journal mode is returned.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种形式改变了"*数据库*"或者如果省略"*数据库*"，则为所有附加数据库的日志模式。新的日志模式将被返回。如果无法更改日志模式，则将返回原始的日志模式。
- en: The DELETE journaling mode is the normal behavior. In the DELETE mode, the rollback
    journal is deleted at the conclusion of each transaction. Indeed, the delete operation
    is the action that causes the transaction to commit. (See the document titled
    [Atomic Commit In SQLite](atomiccommit.html) for additional detail.)
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: DELETE 日志模式是正常行为。在DELETE模式下，回滚日志在每次事务结束时被删除。事实上，删除操作是导致事务提交的动作。（请参阅名为[SQLite中的原子提交](atomiccommit.html)的文档以获取更多详细信息。）
- en: The TRUNCATE journaling mode commits transactions by truncating the rollback
    journal to zero-length instead of deleting it. On many systems, truncating a file
    is much faster than deleting the file since the containing directory does not
    need to be changed.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: TRUNCATE 日志模式通过将回滚日志截断为零长度而不是删除它来提交事务。在许多系统上，截断文件比删除文件要快得多，因为不需要更改包含目录。
- en: 'The PERSIST journaling mode prevents the rollback journal from being deleted
    at the end of each transaction. Instead, the header of the journal is overwritten
    with zeros. This will prevent other database connections from rolling the journal
    back. The PERSIST journaling mode is useful as an optimization on platforms where
    deleting or truncating a file is much more expensive than overwriting the first
    block of a file with zeros. See also: [PRAGMA journal_size_limit](pragma.html#pragma_journal_size_limit)
    and [SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT](compile.html#default_journal_size_limit).'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: PERSIST 日志模式会在每次事务结束时阻止回滚日志被删除。相反，日志的头部会被覆盖为零。这将防止其他数据库连接回滚日志。在删除或截断文件比用零覆盖文件的第一个块要昂贵得多的平台上，PERSIST
    日志模式是一种优化方式。参见：[PRAGMA journal_size_limit](pragma.html#pragma_journal_size_limit)
    和 [SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT](compile.html#default_journal_size_limit)。
- en: The MEMORY journaling mode stores the rollback journal in volatile RAM. This
    saves disk I/O but at the expense of database safety and integrity. If the application
    using SQLite crashes in the middle of a transaction when the MEMORY journaling
    mode is set, then the database file will very likely [go corrupt](howtocorrupt.html#cfgerr).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: MEMORY 日志模式将回滚日志存储在易失性RAM中。这节省了磁盘I/O，但以牺牲数据库的安全性和完整性为代价。如果在设置了MEMORY日志模式时，使用SQLite的应用程序在事务中间崩溃，则数据库文件很可能会[损坏](howtocorrupt.html#cfgerr)。
- en: The WAL journaling mode uses a [write-ahead log](wal.html) instead of a rollback
    journal to implement transactions. The WAL journaling mode is persistent; after
    being set it stays in effect across multiple database connections and after closing
    and reopening the database. A database in WAL journaling mode can only be accessed
    by SQLite [version 3.7.0](releaselog/3_7_0.html) (2010-07-21) or later.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: WAL 日志模式使用[预写式日志](wal.html)而不是回滚日志来实现事务。WAL日志模式是持久的；设置后它在多个数据库连接和在关闭和重新打开数据库后仍然有效。在WAL日志模式下的数据库只能被SQLite
    [版本 3.7.0](releaselog/3_7_0.html)（2010-07-21）或更高版本访问。
- en: The OFF journaling mode disables the rollback journal completely. No rollback
    journal is ever created and hence there is never a rollback journal to delete.
    The OFF journaling mode disables the atomic commit and rollback capabilities of
    SQLite. The [ROLLBACK](lang_transaction.html) command no longer works; it behaves
    in an undefined way. Applications must avoid using the [ROLLBACK](lang_transaction.html)
    command when the journal mode is OFF. If the application crashes in the middle
    of a transaction when the OFF journaling mode is set, then the database file will
    very likely [go corrupt](howtocorrupt.html#cfgerr). Without a journal, there is
    no way for a statement to unwind partially completed operations following a constraint
    error. This might also leave the database in a corrupted state. For example, if
    a duplicate entry causes a [CREATE UNIQUE INDEX](lang_createindex.html) statement
    to fail half-way through, it will leave behind a partially created, and hence
    corrupt, index. Because OFF journaling mode allows the database file to be corrupted
    using ordinary SQL, it is disabled when [SQLITE_DBCONFIG_DEFENSIVE](c3ref/c_dbconfig_defensive.html#sqlitedbconfigdefensive)
    is enabled.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: OFF日志模式完全禁用了回滚日志。不会创建任何回滚日志，因此也就没有回滚日志需要删除。OFF日志模式还禁用了SQLite的原子提交和回滚能力。[ROLLBACK](lang_transaction.html)命令不再起作用；其行为变得未定义。当日志模式为OFF时，应用程序必须避免使用[ROLLBACK](lang_transaction.html)命令。如果应用程序在设置OFF日志模式的情况下在事务中间崩溃，则数据库文件很可能会[损坏](howtocorrupt.html#cfgerr)。没有日志记录，语句无法在约束错误后部分取消完成的操作。这也可能导致数据库处于损坏状态。例如，如果重复条目导致[CREATE
    UNIQUE INDEX](lang_createindex.html)语句在中途失败，它将留下部分创建的、因此是损坏的索引。由于OFF日志模式允许使用普通SQL来损坏数据库文件，因此在启用[SQLITE_DBCONFIG_DEFENSIVE](c3ref/c_dbconfig_defensive.html#sqlitedbconfigdefensive)时会禁用它。
- en: Note that the journal_mode for an [in-memory database](inmemorydb.html) is either
    MEMORY or OFF and can not be changed to a different value. An attempt to change
    the journal_mode of an [in-memory database](inmemorydb.html) to any setting other
    than MEMORY or OFF is ignored. Note also that the journal_mode cannot be changed
    while a transaction is active.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，[内存数据库](inmemorydb.html)的`journal_mode`只能是MEMORY或者OFF，不能更改为其他值。尝试将[内存数据库](inmemorydb.html)的`journal_mode`设置为MEMORY或OFF以外的任何设置都会被忽略。同时请注意，在活动事务期间无法更改`journal_mode`。
- en: <h _id="pragma_journal_size_limit" style="display:none">PRAGMA journal_size_limit</h>
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_journal_size_limit" style="display:none">PRAGMA journal_size_limit</h>
- en: '* * *'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA** *schema.***journal_size_limit'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA** *schema.***journal_size_limit'
- en: PRAGMA** *schema.***journal_size_limit =** *N* **;**
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA** *schema.***journal_size_limit =** *N* **;**'
- en: If a database connection is operating in [exclusive locking mode](pragma.html#pragma_locking_mode)
    or in [persistent journal mode](pragma.html#pragma_journal_mode) (PRAGMA journal_mode=persist)
    then after committing a transaction the [rollback journal](lockingv3.html#rollback)
    file may remain in the file-system. This increases performance for subsequent
    transactions since overwriting an existing file is faster than append to a file,
    but it also consumes file-system space. After a large transaction (e.g. a [VACUUM](lang_vacuum.html)),
    the rollback journal file may consume a very large amount of space.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据库连接处于[独占锁定模式](pragma.html#pragma_locking_mode)或[持久日志模式](pragma.html#pragma_journal_mode)（PRAGMA
    journal_mode=persist）下，提交事务后，[回滚日志](lockingv3.html#rollback)文件可能会保留在文件系统中。这会提升后续事务的性能，因为覆盖现有文件比向文件追加更快，但同时也会消耗文件系统空间。在大型事务（例如[VACUUM](lang_vacuum.html)）之后，回滚日志文件可能会占用非常大的空间。
- en: Similarly, in [WAL mode](wal.html), the write-ahead log file is not truncated
    following a [checkpoint](wal.html#ckpt). Instead, SQLite reuses the existing file
    for subsequent WAL entries since overwriting is faster than appending.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在[WAL模式](wal.html)下，写入前日志文件在[检查点](wal.html#ckpt)后不会被截断。相反，SQLite会重用现有文件来存储后续的WAL条目，因为覆盖比追加更快速。
- en: The journal_size_limit pragma may be used to limit the size of rollback-journal
    and WAL files left in the file-system after transactions or checkpoints. Each
    time a transaction is committed or a WAL file resets, SQLite compares the size
    of the rollback journal file or WAL file left in the file-system to the size limit
    set by this pragma and if the journal or WAL file is larger it is truncated to
    the limit.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`journal_size_limit` pragma可用于限制事务或检查点后在文件系统中保留的回滚日志和WAL文件的大小。每次提交事务或WAL文件重置时，SQLite会将文件系统中保留的回滚日志文件或WAL文件的大小与此pragma设置的大小限制进行比较，如果日志或WAL文件超过限制大小，则会截断到限制大小。'
- en: The second form of the pragma listed above is used to set a new limit in bytes
    for the specified database. A negative number implies no limit. To always truncate
    rollback journals and WAL files to their minimum size, set the journal_size_limit
    to zero. Both the first and second forms of the pragma listed above return a single
    result row containing a single integer column - the value of the journal size
    limit in bytes. The default journal size limit is -1 (no limit). The [SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT](compile.html#default_journal_size_limit)
    preprocessor macro can be used to change the default journal size limit at compile-time.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 上述第二种pragma形式用于为指定的数据库设置以字节为单位的新限制。负数表示无限制。要始终将回滚日志和WAL文件截断到其最小大小，请将journal_size_limit设置为零。上述第一和第二种pragma形式均返回一个包含单个整数列的单行结果行
    - 字节中的日志大小限制的值。默认的日志大小限制为-1（无限制）。[SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT](compile.html#default_journal_size_limit)预处理宏可用于在编译时更改默认的日志大小限制。
- en: This pragma only operates on the single database specified prior to the pragma
    name (or on the "main" database if no database is specified.) There is no way
    to change the journal size limit on all attached databases using a single PRAGMA
    statement. The size limit must be set separately for each attached database. <h
    _id="pragma_legacy_alter_table" style="display:none">PRAGMA legacy_alter_table</h>
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 此pragma仅在在pragma名称之前指定的单个数据库上操作（如果未指定数据库，则在“main”数据库上操作）。无法使用单个PRAGMA语句更改所有附加数据库的日志大小限制。必须为每个附加数据库分别设置大小限制。<h
    _id="pragma_legacy_alter_table" style="display:none">PRAGMA legacy_alter_table</h>
- en: '* * *'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA legacy_alter_table;'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA legacy_alter_table;'
- en: PRAGMA legacy_alter_table = *boolean***
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA legacy_alter_table = *boolean***
- en: 'This pragma sets or queries the value of the legacy_alter_table flag. When
    this flag is on, the [ALTER TABLE RENAME](lang_altertable.html#altertabrename)
    command (for changing the name of a table) works as it did in SQLite 3.24.0 (2018-06-04)
    and earlier. More specifically, when this flag is on the [ALTER TABLE RENAME](lang_altertable.html#altertabrename)
    command only rewrites the initial occurrence of the table name in its [CREATE
    TABLE](lang_createtable.html) statement and in any associated [CREATE INDEX](lang_createindex.html)
    and [CREATE TRIGGER](lang_createtrigger.html) statements. Other references to
    the table are unmodified, including:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 此pragma设置或查询legacy_alter_table标志的值。当此标志打开时，[ALTER TABLE RENAME](lang_altertable.html#altertabrename)命令（用于更改表名称）的工作方式与SQLite
    3.24.0（2018-06-04）及更早版本相同。更具体地说，当此标志打开时，[ALTER TABLE RENAME](lang_altertable.html#altertabrename)命令仅重写其[CREATE
    TABLE](lang_createtable.html)语句及其相关的[CREATE INDEX](lang_createindex.html)和[CREATE
    TRIGGER](lang_createtrigger.html)语句中表名称的初始出现。对表的其他引用保持不变，包括：
- en: References to the table within the bodies of triggers and views.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在触发器和视图的主体内引用表。
- en: References to the table within CHECK constraints in the original CREATE TABLE
    statement.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在原始CREATE TABLE语句中的CHECK约束内引用表。
- en: References to the table within the WHERE clauses of [partial indexes](partialindex.html).
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[partial indexes](partialindex.html)的WHERE子句中引用表。
- en: The default setting for this pragma is OFF, which means that all references
    to the table anywhere in the schema are converted to the new name.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 此pragma的默认设置为OFF，这意味着在模式中对表的所有引用都会转换为新名称。
- en: This pragma is provided as a work-around for older programs that contain code
    that expect the incomplete behavior of [ALTER TABLE RENAME](lang_altertable.html#altertabrename)
    found in older versions of SQLite. New applications should leave this flag turned
    off.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 此pragma提供了一个解决方案，用于包含期望旧版SQLite中发现的[ALTER TABLE RENAME](lang_altertable.html#altertabrename)的不完整行为的旧程序。新应用程序应保持此标志关闭。
- en: For compatibility with older [virtual table](vtab.html) implementations, this
    flag is turned on temporarily while the [sqlite3_module.xRename](vtab.html#xrename)
    method is being run. The value of this flag is restored after the [sqlite3_module.xRename](vtab.html#xrename)
    method finishes.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 为了兼容旧版[virtual table](vtab.html)实现，在执行[sqlite3_module.xRename](vtab.html#xrename)方法时临时开启此标志。此标志的值在[sqlite3_module.xRename](vtab.html#xrename)方法执行完毕后将会恢复。
- en: The legacy alter table behavior can also be toggled on and off using the [SQLITE_DBCONFIG_LEGACY_ALTER_TABLE](c3ref/c_dbconfig_defensive.html#sqlitedbconfiglegacyaltertable)
    option to the [sqlite3_db_config()](c3ref/db_config.html) interface.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用[SQLITE_DBCONFIG_LEGACY_ALTER_TABLE](c3ref/c_dbconfig_defensive.html#sqlitedbconfiglegacyaltertable)选项通过[sqlite3_db_config()](c3ref/db_config.html)接口切换legacy
    alter table行为的打开和关闭。
- en: The legacy alter table behavior is a per-connection setting. Turning this features
    on or off affects all attached database files within the [database connection](c3ref/sqlite3.html).
    The setting does not persist. Changing this setting in one connection does not
    affect any other connections. <h _id="pragma_legacy_file_format" style="display:none">PRAGMA
    legacy_file_format</h>
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的 alter table 行为是一个连接特定的设置。打开或关闭此功能会影响 [数据库连接](c3ref/sqlite3.html) 中所有附加的数据库文件。设置不会持久保存。在一个连接中更改此设置不会影响任何其他连接。
    <h _id="pragma_legacy_file_format" style="display:none">PRAGMA legacy_file_format</h>
- en: '* * *'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA legacy_file_format;**'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA legacy_file_format;**'
- en: This pragma no longer functions. It has become a no-op. The capabilities formerly
    provided by PRAGMA legacy_file_format are now available using the [SQLITE_DBCONFIG_LEGACY_FILE_FORMAT](c3ref/c_dbconfig_defensive.html#sqlitedbconfiglegacyfileformat)
    option to the [sqlite3_db_config()](c3ref/db_config.html) C-language interface.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `pragma` 不再起作用。它已成为无操作。由 `PRAGMA legacy_file_format` 提供的功能现在可以使用 [SQLITE_DBCONFIG_LEGACY_FILE_FORMAT](c3ref/c_dbconfig_defensive.html#sqlitedbconfiglegacyfileformat)
    选项通过 [sqlite3_db_config()](c3ref/db_config.html) C 语言接口获得。
- en: <h _id="pragma_locking_mode" style="display:none">PRAGMA locking_mode</h>
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_locking_mode" style="display:none">PRAGMA locking_mode</h>
- en: '* * *'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA** *schema.***locking_mode;'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA** *schema.***locking_mode;'
- en: PRAGMA** *schema.***locking_mode = *NORMAL | EXCLUSIVE***
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA** *schema.***locking_mode = *NORMAL | EXCLUSIVE***
- en: This pragma sets or queries the database connection locking-mode. The locking-mode
    is either NORMAL or EXCLUSIVE.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 此 pragma 设置或查询数据库连接的锁定模式。锁定模式可以是 NORMAL 或 EXCLUSIVE。
- en: In NORMAL locking-mode (the default unless overridden at compile-time using
    [SQLITE_DEFAULT_LOCKING_MODE](compile.html#default_locking_mode)), a database
    connection unlocks the database file at the conclusion of each read or write transaction.
    When the locking-mode is set to EXCLUSIVE, the database connection never releases
    file-locks. The first time the database is read in EXCLUSIVE mode, a shared lock
    is obtained and held. The first time the database is written, an exclusive lock
    is obtained and held.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在 NORMAL 锁定模式下（默认情况下，除非在编译时使用 [SQLITE_DEFAULT_LOCKING_MODE](compile.html#default_locking_mode)
    进行了覆盖），数据库连接在每个读或写事务结束时解锁数据库文件。当锁定模式设置为 EXCLUSIVE 时，数据库连接永远不会释放文件锁。第一次以 EXCLUSIVE
    模式读取数据库时，获取并持有共享锁。第一次写入数据库时，获取并持有独占锁。
- en: Database locks obtained by a connection in EXCLUSIVE mode may be released either
    by closing the database connection, or by setting the locking-mode back to NORMAL
    using this pragma and then accessing the database file (for read or write). Simply
    setting the locking-mode to NORMAL is not enough - locks are not released until
    the next time the database file is accessed.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 连接在 EXCLUSIVE 模式下获取的数据库锁可以通过关闭数据库连接或者通过将锁定模式设置回 NORMAL，并访问数据库文件（读或写）来释放。仅仅将锁定模式设置为
    NORMAL 是不够的 - 锁定直到下次访问数据库文件才会释放。
- en: There are three reasons to set the locking-mode to EXCLUSIVE.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 将锁定模式设置为 EXCLUSIVE 有三个理由。
- en: The application wants to prevent other processes from accessing the database
    file.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序希望阻止其他进程访问数据库文件。
- en: The number of system calls for filesystem operations is reduced, possibly resulting
    in a small performance increase.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 减少文件系统操作的系统调用次数，可能导致轻微的性能提升。
- en: '[WAL](wal.html) databases can be accessed in EXCLUSIVE mode without the use
    of shared memory. ([Additional information](wal.html#noshm))'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[WAL](wal.html) 数据库可以在没有共享内存的情况下以 EXCLUSIVE 模式访问。([附加信息](wal.html#noshm))'
- en: 'When the locking_mode pragma specifies a particular database, for example:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 当 locking_mode pragma 指定特定数据库时，例如：
- en: PRAGMA **main.**locking_mode=EXCLUSIVE;
  id: totrans-397
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: PRAGMA **main.**locking_mode=EXCLUSIVE;
- en: then the locking mode applies only to the named database. If no database name
    qualifier precedes the "locking_mode" keyword then the locking mode is applied
    to all databases, including any new databases added by subsequent [ATTACH](lang_attach.html)
    commands.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 那么锁定模式仅适用于命名数据库。如果没有数据库名称限定符在 "locking_mode" 关键字之前，则锁定模式适用于所有数据库，包括后续使用 [ATTACH](lang_attach.html)
    命令添加的任何新数据库。
- en: The "temp" database (in which TEMP tables and indices are stored) and [in-memory
    databases](inmemorydb.html) always uses exclusive locking mode. The locking mode
    of temp and [in-memory databases](inmemorydb.html) cannot be changed. All other
    databases use the normal locking mode by default and are affected by this pragma.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '"temp"数据库（用于存储TEMP表和索引）和[内存数据库](inmemorydb.html)总是使用独占锁定模式。temp和[内存数据库](inmemorydb.html)的锁定模式不能更改。所有其他数据库默认使用正常锁定模式，并受此PRAGMA影响。'
- en: If the locking mode is EXCLUSIVE when first entering [WAL journal mode](wal.html),
    then the locking mode cannot be changed to NORMAL until after exiting WAL journal
    mode. If the locking mode is NORMAL when first entering WAL journal mode, then
    the locking mode can be changed between NORMAL and EXCLUSIVE and back again at
    any time and without needing to exit WAL journal mode.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 如果首次进入[WAL日志模式](wal.html)时锁定模式为EXCLUSIVE，则在退出WAL日志模式之前无法将锁定模式更改为NORMAL。如果首次进入WAL日志模式时锁定模式为NORMAL，则可以随时在NORMAL和EXCLUSIVE之间更改锁定模式，而无需退出WAL日志模式。
- en: <h _id="pragma_max_page_count" style="display:none">PRAGMA max_page_count</h>
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_max_page_count" style="display:none">PRAGMA max_page_count</h>
- en: '* * *'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA** *schema.***max_page_count;'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA** *schema.***max_page_count;'
- en: PRAGMA** *schema.***max_page_count =** *N***;**
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA** *schema.***max_page_count =** *N***;**'
- en: Query or set the maximum number of pages in the database file. Both forms of
    the pragma return the maximum page count. The second form attempts to modify the
    maximum page count. The maximum page count cannot be reduced below the current
    database size.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 查询或设置数据库文件中的最大页面数。两种形式的PRAGMA返回最大页面数。第二种形式尝试修改最大页面数。最大页面数不能低于当前数据库大小。
- en: <h _id="pragma_mmap_size" style="display:none">PRAGMA mmap_size</h>
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_mmap_size" style="display:none">PRAGMA mmap_size</h>
- en: '* * *'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA** *schema.***mmap_size;'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA** *schema.***mmap_size;'
- en: PRAGMA** *schema.***mmap_size=***N*
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA** *schema.***mmap_size=***N*'
- en: Query or change the maximum number of bytes that are set aside for memory-mapped
    I/O on a single database. The first form (without an argument) queries the current
    limit. The second form (with a numeric argument) sets the limit for the specified
    database, or for all databases if the optional database name is omitted. In the
    second form, if the database name is omitted, the limit that is set becomes the
    default limit for all databases that are added to the [database connection](c3ref/sqlite3.html)
    by subsequent [ATTACH](lang_attach.html) statements.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 查询或更改单个数据库上设置的用于内存映射I/O的最大字节数。第一种形式（无参数）查询当前限制。第二种形式（带有数值参数）为指定的数据库或所有数据库（如果省略了可选数据库名称）设置限制。在第二种形式中，如果省略了数据库名称，则设置的限制将成为后续由[ATTACH](lang_attach.html)语句添加到数据库连接的所有数据库的默认限制。
- en: The argument N is the maximum number of bytes of the database file that will
    be accessed using memory-mapped I/O. If N is zero then memory mapped I/O is disabled.
    If N is negative, then the limit reverts to the default value determined by the
    most recent [sqlite3_config](c3ref/config.html)([SQLITE_CONFIG_MMAP_SIZE](c3ref/c_config_covering_index_scan.html#sqliteconfigmmapsize)),
    or to the compile time default determined by [SQLITE_DEFAULT_MMAP_SIZE](compile.html#default_mmap_size)
    if not start-time limit has been set.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 参数N是将使用内存映射I/O访问的数据库文件的最大字节数。如果N为零，则禁用内存映射I/O。如果N为负数，则限制将恢复为最近的[sqlite3_config](c3ref/config.html)([SQLITE_CONFIG_MMAP_SIZE](c3ref/c_config_covering_index_scan.html#sqliteconfigmmapsize))设定的默认值，或者如果未设置启动时限制，则为编译时默认值[SQLITE_DEFAULT_MMAP_SIZE](compile.html#default_mmap_size)。
- en: The [PRAGMA mmap_size](pragma.html#pragma_mmap_size) statement will never increase
    the amount of address space used for memory-mapped I/O above the hard limit set
    by the [SQLITE_MAX_MMAP_SIZE](compile.html#max_mmap_size) compile-time option,
    nor the hard limit set at startup-time by the second argument to sqlite3_config([SQLITE_CONFIG_MMAP_SIZE](c3ref/c_config_covering_index_scan.html#sqliteconfigmmapsize))
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRAGMA mmap_size](pragma.html#pragma_mmap_size)语句不会增加内存映射I/O使用的地址空间超过[SQLITE_MAX_MMAP_SIZE](compile.html#max_mmap_size)编译时选项设定的硬限制，也不会超过由sqlite3_config([SQLITE_CONFIG_MMAP_SIZE](c3ref/c_config_covering_index_scan.html#sqliteconfigmmapsize))函数的第二个参数在启动时设定的硬限制。'
- en: The size of the memory-mapped I/O region cannot be changed while the memory-mapped
    I/O region is in active use, to avoid unmapping memory out from under running
    SQL statements. For this reason, the mmap_size pragma may be a no-op if the prior
    mmap_size is non-zero and there are other SQL statements running concurrently
    on the same [database connection](c3ref/sqlite3.html).
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用内存映射I/O区域时，不能在活动使用中更改内存映射I/O区域的大小，以避免在运行SQL语句时取消映射内存。因此，如果先前的mmap_size非零且同一[数据库连接](c3ref/sqlite3.html)上有其他SQL语句并发运行，则mmap_size
    pragma可能是一个空操作。
- en: <h _id="pragma_module_list" style="display:none">PRAGMA module_list</h>
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_module_list" style="display:none">PRAGMA 模块列表</h>
- en: '* * *'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA module_list;**'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA 模块列表;**'
- en: This pragma returns a list of [virtual table](vtab.html) modules registered
    with the database connection. <h _id="pragma_optimize" style="display:none">PRAGMA
    optimize</h>
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令返回注册到数据库连接的[虚拟表](vtab.html)模块列表。 <h _id="pragma_optimize" style="display:none">PRAGMA
    优化</h>
- en: '* * *'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA optimize;'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA optimize;'
- en: PRAGMA optimize(***MASK***);
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA optimize(***MASK***);
- en: PRAGMA** *schema***.optimize;
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA** *schema***.optimize;
- en: PRAGMA** *schema***.optimize(***MASK***);**
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA** *schema***.optimize(***MASK***);**
- en: Attempt to optimize the database. All schemas are optimized in the first two
    forms, and only the specified schema is optimized in the latter two.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试优化数据库。前两种形式中的所有模式都会被优化，而在后两种形式中仅会优化指定的模式。
- en: 'In most applications, using PRAGMA optimize as follows will help SQLite to
    achieve the best possible query performance:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数应用程序中，按以下方式使用PRAGMA optimize将帮助SQLite实现最佳的查询性能：
- en: Applications with short-lived database connections should run "PRAGMA optimize;"
    once, just prior to closing each database connection.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用短期数据库连接的应用程序应在每次关闭数据库连接之前运行"PRAGMA optimize;"一次。
- en: Applications that use long-lived database connections should run "PRAGMA optimize=0x10002;"
    when the connection is first opened, and then also run "PRAGMA optimize;" periodically,
    perhaps once per day or once per hour.
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用长期数据库连接的应用程序在首次打开连接时应运行"PRAGMA optimize=0x10002;"，然后定期运行"PRAGMA optimize;"，比如每天或每小时运行一次。
- en: All applications should run "PRAGMA optimize;" after a schema change, especially
    after one or more [CREATE INDEX](lang_createindex.html) statements.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有应用程序在模式更改后，特别是在一个或多个[CREATE INDEX](lang_createindex.html)语句后，应运行"PRAGMA optimize;"。
- en: This pragma is usually a no-op or nearly so and is very fast. On the occasions
    where it does need to run ANALYZE on one or more tables, it sets a temporary [analysis
    limit](pragma.html#pragma_analysis_limit), valid for the duration of this pragma
    only, that prevents the ANALYZE invocations from running for to long.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，此命令几乎不会执行操作，并且非常快速。只有在需要对一个或多个表执行ANALYZE时，才会设置一个临时的[分析限制](pragma.html#pragma_analysis_limit)，该限制仅在此命令执行期间有效，以防止ANALYZE运行时间过长。
- en: Recommended practice is that applications with short-lived database connections
    should run "PRAGMA optimize" once when the database connection closes. Applications
    with long-lived database connections should run "PRAGMA optimize=0x10002" when
    the database connection first opens, then run "PRAGMA optimize" again at periodic
    intervals - perhaps once per day. All applications should run "PRAGMA optimize"
    after schema changes, especially [CREATE INDEX](lang_createindex.html).
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 建议实践是，使用短期数据库连接的应用程序应在关闭数据库连接时运行"PRAGMA optimize"一次。使用长期数据库连接的应用程序应在首次打开数据库连接时运行"PRAGMA
    optimize=0x10002"，然后定期运行"PRAGMA optimize" - 比如每天运行一次。所有应用程序应在模式更改后运行"PRAGMA optimize"，特别是[CREATE
    INDEX](lang_createindex.html)之后。
- en: The details of optimizations performed by this pragma are expected to change
    and improve over time. Applications should anticipate that this pragma will perform
    new optimizations in future releases.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 预计此命令执行的优化细节会随时间改变和改进。应用程序应预期该命令将在未来版本中执行新的优化。
- en: 'The optional MASK argument is a bitmask of optimizations to perform:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的MASK参数是执行优化的位掩码：
- en: '| 0x00001 | Debugging mode. Do not actually perform any optimizations but instead
    return one line of text for each optimization that would have been done. Off by
    default. |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '| 0x00001 | 调试模式。实际上不执行任何优化，而是返回每个将要执行的优化的一行文本。默认关闭。 |'
- en: '| 0x00002 | Run [ANALYZE](lang_analyze.html) on tables that might benefit.
    On by default. |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '| 0x00002 | 对可能受益的表运行[ANALYZE](lang_analyze.html)。默认开启。 |'
- en: '| 0x00010 | When running [ANALYZE](lang_analyze.html), set a temporary [PRAGMA
    analysis_limit](pragma.html#pragma_analysis_limit) to prevent excess run-time.
    On by default. |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
  zh: '| 0x00010 | 在运行[ANALYZE](lang_analyze.html)时，设置临时的[PRAGMA analysis_limit](pragma.html#pragma_analysis_limit)以防止过多运行时间。默认启用。
    |'
- en: '| 0x10000 | Check the size of all tables, not just tables that have not been
    recently used, to see if any have grown and shrunk significantly and hence might
    benefit from being re-analyzed. Off by default. |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
  zh: '| 0x10000 | 检查所有表的大小，而不仅仅是最近未被使用的表，看看是否有任何表显著增长和缩小，因此可能受益于重新分析。默认情况下关闭。 |'
- en: The default MASK is 0xfffe.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 默认MASK为0xfffe。
- en: To see all optimizations that would have been done without actually doing them,
    run "PRAGMA optimize(-1)".
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看在不实际执行优化的情况下应执行的所有优化，请运行"PRAGMA optimize(-1)"。
- en: '**Determination Of When To Run Analyze**'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '**确定何时运行分析**'
- en: 'In the current implementation, a table is analyzed if and only if all of the
    following are true:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前实现中，仅当以下所有条件均为真时，才分析表：
- en: MASK bit 0x02 is set.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MASK位0x02被设置。
- en: The table is an ordinary table, not a view or virtual table.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该表是普通表，而不是视图或虚拟表。
- en: The table name does not begin with "sqlite_".
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表名不以"sqlite_"开头。
- en: 'One or more of the following are true:'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下一个或多个为真：
- en: The 0x10000 bit of MASK is set
  id: totrans-444
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: MASK的0x10000位被设置
- en: One or more indexes on the table lack entries in the sqlite_stat1 table.
  id: totrans-445
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该表上的一个或多个索引缺少sqlite_stat1表中的条目。
- en: The query planner used sqlite_stat1 statistics for one or more indexes of this
    table at some point during the lifetime of the current database connection.
  id: totrans-446
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询规划器在当前数据库连接的生命周期内，某个时刻对该表的一个或多个索引使用了sqlite_stat1统计信息。
- en: 'One or more of the following are true:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下一个或多个为真：
- en: One or more indexes on the table lack entries in the sqlite_stat1 table.
  id: totrans-448
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该表上的一个或多个索引缺少sqlite_stat1表中的条目。
- en: The number of rows in the table has increased or decreased by 10-fold since
    the last time ANALYZE was run on the table.
  id: totrans-449
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与上次在表上运行ANALYZE时，表中的行数增加或减少了10倍。
- en: The rules for when tables are analyzed are likely to change in future releases.
    New MASK values may be added in the future. Future versions of this pragma might
    accept a string literal argument instead of a bit mask, though the bit mask argument
    will continue to be supported for backwards compatibility. <h _id="pragma_page_count"
    style="display:none">PRAGMA page_count</h>
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 未来版本中，表分析的规则可能会发生变化。未来可能会添加新的MASK值。对于向后兼容性，未来版本的此Pragma可能会接受字符串字面参数，而不是位掩码参数。
    <h _id="pragma_page_count" style="display:none">PRAGMA page_count</h>
- en: '* * *'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA** *schema.***page_count;**'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA** *schema.* ***page_count;***'
- en: Return the total number of pages in the database file.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 返回数据库文件中的总页面数。
- en: <h _id="pragma_page_size" style="display:none">PRAGMA page_size</h>
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_page_size" style="display:none">PRAGMA page_size</h>
- en: '* * *'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA** *schema.***page_size;'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA** *schema.* ***page_size;***'
- en: PRAGMA** *schema.***page_size =** *bytes***;**
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA** *schema.* ***page_size =** *bytes***;**
- en: Query or set the page size of the database. The page size must be a power of
    two between 512 and 65536 inclusive.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 查询或设置数据库的页面大小。页面大小必须是512到65536之间的2的幂次方数。
- en: When a new database is created, SQLite assigns a page size to the database based
    on platform and filesystem. For many years, the default page size was almost always
    1024 bytes, but beginning with SQLite [version 3.12.0](releaselog/3_12_0.html)
    (2016-03-29), the default page size increased to 4096. The default page size is
    recommended for most applications.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建新数据库时，SQLite根据平台和文件系统为数据库分配页面大小。多年来，默认页面大小几乎总是1024字节，但从SQLite [版本3.12.0](releaselog/3_12_0.html)（2016-03-29）开始，默认页面大小增加到4096字节。默认页面大小适用于大多数应用程序。
- en: Specifying a new page size does not change the page size immediately. Instead,
    the new page size is remembered and is used to set the page size when the database
    is first created, if it does not already exist when the page_size pragma is issued,
    or at the next [VACUUM](lang_vacuum.html) command that is run on the same database
    connection while not in [WAL mode](wal.html).
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 指定新的页面大小不会立即更改页面大小。相反，新页面大小将被记住，并在首次创建数据库时使用，如果在发出page_size pragma时数据库尚不存在，或者在不处于[WAL模式](wal.html)的情况下运行同一数据库连接上的下一个[VACUUM](lang_vacuum.html)命令时使用。
- en: The [SQLITE_DEFAULT_PAGE_SIZE](compile.html#default_page_size) compile-time
    option can be used to change the default page size assigned to new databases.
    <h _id="pragma_parser_trace" style="display:none">PRAGMA parser_trace</h>
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQLITE_DEFAULT_PAGE_SIZE](compile.html#default_page_size) 编译时选项可以用来更改分配给新数据库的默认页面大小。
    <h _id="pragma_parser_trace" style="display:none">PRAGMA parser_trace</h>'
- en: '* * *'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA parser_trace =** *boolean***;**'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA parser_trace =** *boolean***;**'
- en: If SQLite has been compiled with the [SQLITE_DEBUG](compile.html#debug) compile-time
    option, then the parser_trace pragma can be used to turn on tracing for the SQL
    parser used internally by SQLite. This feature is used for debugging SQLite itself.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 SQLite 是使用 [SQLITE_DEBUG](compile.html#debug) 编译选项编译的，那么 parser_trace pragma
    可以用来启用对 SQLite 内部使用的 SQL 解析器的跟踪。此功能用于调试 SQLite 本身。
- en: This pragma is intended for use when debugging SQLite itself. It is only available
    when the [SQLITE_DEBUG](compile.html#debug) compile-time option is used.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 此 pragma 用于在调试 SQLite 本身时使用。仅在使用 [SQLITE_DEBUG](compile.html#debug) 编译选项时可用。
- en: <h _id="pragma_pragma_list" style="display:none">PRAGMA pragma_list</h>
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_pragma_list" style="display:none">PRAGMA pragma_list</h>
- en: '* * *'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA pragma_list;**'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA pragma_list;**'
- en: This pragma returns a list of PRAGMA commands known to the database connection.
    <h _id="pragma_query_only" style="display:none">PRAGMA query_only</h>
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 此 pragma 返回数据库连接已知的 PRAGMA 命令列表。 <h _id="pragma_query_only" style="display:none">PRAGMA
    query_only</h>
- en: '* * *'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA query_only;'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA query_only;'
- en: PRAGMA query_only =** *boolean***;**
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA query_only =** *boolean***;**
- en: The query_only pragma prevents data changes on database files when enabled.
    When this pragma is enabled, any attempt to CREATE, DELETE, DROP, INSERT, or UPDATE
    will result in an [SQLITE_READONLY](rescode.html#readonly) error. However, the
    database is not truly read-only. You can still run a [checkpoint](wal.html#ckpt)
    or a [COMMIT](lang_transaction.html) and the return value of the [sqlite3_db_readonly()](c3ref/db_readonly.html)
    routine is not affected.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: query_only pragma 在启用时防止对数据库文件进行数据更改。当启用此 pragma 时，任何尝试创建、删除、删除、插入或更新都将导致 [SQLITE_READONLY](rescode.html#readonly)
    错误。然而，数据库并非真正只读。您仍然可以运行 [checkpoint](wal.html#ckpt) 或 [COMMIT](lang_transaction.html)，并且
    [sqlite3_db_readonly()](c3ref/db_readonly.html) 的返回值不受影响。
- en: <h _id="pragma_quick_check" style="display:none">PRAGMA quick_check</h>
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_quick_check" style="display:none">PRAGMA quick_check</h>
- en: '* * *'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA** *schema.***quick_check;'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA** *schema.***quick_check;'
- en: PRAGMA** *schema.***quick_check(***N***)**
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA** *schema.***quick_check(***N***)**
- en: PRAGMA *schema.***quick_check(***TABLENAME***)**
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA *schema.***quick_check(***TABLENAME***)**
- en: The pragma is like [integrity_check](pragma.html#pragma_integrity_check) except
    that it does not verify UNIQUE constraints and does not verify that index content
    matches table content. By skipping UNIQUE and index consistency checks, quick_check
    is able to run faster. PRAGMA quick_check runs in O(N) time whereas [PRAGMA integrity_check](pragma.html#pragma_integrity_check)
    requires O(NlogN) time where N is the total number of rows in the database. Otherwise
    the two pragmas are the same.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: pragma 与 [integrity_check](pragma.html#pragma_integrity_check) 类似，但它不验证 UNIQUE
    约束，也不验证索引内容是否匹配表内容。通过跳过 UNIQUE 和索引一致性检查，quick_check 能够运行得更快。PRAGMA quick_check
    的运行时间为 O(N)，而 [PRAGMA integrity_check](pragma.html#pragma_integrity_check) 需要
    O(NlogN) 的时间，其中 N 是数据库中的总行数。否则两个 pragma 是相同的。
- en: <h _id="pragma_read_uncommitted" style="display:none">PRAGMA read_uncommitted</h>
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_read_uncommitted" style="display:none">PRAGMA read_uncommitted</h>
- en: '* * *'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA read_uncommitted;'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA read_uncommitted;'
- en: PRAGMA read_uncommitted =** *boolean***;**
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA read_uncommitted =** *boolean***;**
- en: Query, set, or clear READ UNCOMMITTED isolation. The default isolation level
    for SQLite is SERIALIZABLE. Any process or thread can select READ UNCOMMITTED
    isolation, but SERIALIZABLE will still be used except between connections that
    share a common page and schema cache. Cache sharing is enabled using the [sqlite3_enable_shared_cache()](c3ref/enable_shared_cache.html)
    API. Cache sharing is disabled by default.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 查询、设置或清除 READ UNCOMMITTED 隔离级别。SQLite 的默认隔离级别为 SERIALIZABLE。任何进程或线程都可以选择 READ
    UNCOMMITTED 隔离级别，但在共享常规页面和模式缓存的连接之间仍将使用 SERIALIZABLE。使用 [sqlite3_enable_shared_cache()](c3ref/enable_shared_cache.html)
    API 可以启用缓存共享。默认情况下禁用缓存共享。
- en: See [SQLite Shared-Cache Mode](sharedcache.html) for additional information.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参阅 [SQLite Shared-Cache Mode](sharedcache.html)。
- en: <h _id="pragma_recursive_triggers" style="display:none">PRAGMA recursive_triggers</h>
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_recursive_triggers" style="display:none">PRAGMA recursive_triggers</h>
- en: '* * *'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA recursive_triggers;'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA recursive_triggers;'
- en: PRAGMA recursive_triggers =** *boolean***;**
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA recursive_triggers =** *boolean***;**
- en: Query, set, or clear the recursive trigger capability.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 查询、设置或清除递归触发器的功能。
- en: Changing the recursive_triggers setting affects the execution of all statements
    prepared using the database connection, including those prepared before the setting
    was changed. Any existing statements prepared using the legacy [sqlite3_prepare()](c3ref/prepare.html)
    interface may fail with an [SQLITE_SCHEMA](rescode.html#schema) error after the
    recursive_triggers setting is changed.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 更改recursive_triggers设置会影响使用数据库连接准备的所有语句的执行，包括更改设置之前准备的语句。使用旧版[sqlite3_prepare()](c3ref/prepare.html)接口准备的现有语句在更改recursive_triggers设置后可能会因为[SQLITE_SCHEMA](rescode.html#schema)错误而失败。
- en: Prior to SQLite [version 3.6.18](releaselog/3_6_18.html) (2009-09-11), recursive
    triggers were not supported. The behavior of SQLite was always as if this pragma
    was set to OFF. Support for recursive triggers was added in version 3.6.18 but
    was initially turned OFF by default, for compatibility. Recursive triggers may
    be turned on by default in future versions of SQLite.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQLite [版本 3.6.18](releaselog/3_6_18.html) (2009-09-11) 之前，不支持递归触发器。SQLite
    的行为总是假定这个编译指示已关闭。支持递归触发器是从版本 3.6.18 开始添加的，但最初默认关闭，以保证兼容性。未来的SQLite版本可能会默认打开递归触发器。
- en: The depth of recursion for triggers has a hard upper limit set by the [SQLITE_MAX_TRIGGER_DEPTH](limits.html#max_trigger_depth)
    compile-time option and a run-time limit set by [sqlite3_limit](c3ref/limit.html)(db,[SQLITE_LIMIT_TRIGGER_DEPTH](c3ref/c_limit_attached.html#sqlitelimittriggerdepth),...).
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器的递归深度受到[SQLITE_MAX_TRIGGER_DEPTH](limits.html#max_trigger_depth)编译时选项设定的严格上限以及运行时由[sqlite3_limit](c3ref/limit.html)(db,[SQLITE_LIMIT_TRIGGER_DEPTH](c3ref/c_limit_attached.html#sqlitelimittriggerdepth),...)设定的限制。
- en: <h _id="pragma_reverse_unordered_selects" style="display:none">PRAGMA reverse_unordered_selects</h>
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_reverse_unordered_selects" style="display:none">PRAGMA reverse_unordered_selects</h>
- en: '* * *'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA reverse_unordered_selects;'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA reverse_unordered_selects;'
- en: PRAGMA reverse_unordered_selects =** *boolean***;**
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA reverse_unordered_selects =** *boolean***;**
- en: When enabled, this PRAGMA causes many [SELECT](lang_select.html) statements
    without an ORDER BY clause to emit their results in the reverse order from what
    they normally would. This can help debug applications that are making invalid
    assumptions about the result order. The reverse_unordered_selects pragma works
    for most SELECT statements, however the query planner may sometimes choose an
    algorithm that is not easily reversed, in which case the output will appear in
    the same order regardless of the reverse_unordered_selects setting.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 启用此PRAGMA后，许多没有ORDER BY子句的[SELECT](lang_select.html)语句会以它们通常所产生结果的相反顺序输出。这可以帮助调试那些对结果顺序做出无效假设的应用程序。reverse_unordered_selects
    PRAGMA适用于大多数SELECT语句，但查询规划器有时可能会选择不易反转的算法，此时输出将以相同顺序出现，不受reverse_unordered_selects设置影响。
- en: SQLite makes no guarantees about the order of results if a SELECT omits the
    ORDER BY clause. Even so, the order of results does not change from one run to
    the next, and so many applications mistakenly come to depend on the arbitrary
    output order whatever that order happens to be. However, sometimes new versions
    of SQLite will contain optimizer enhancements that will cause the output order
    of queries without ORDER BY clauses to shift. When that happens, applications
    that depend on a certain output order might malfunction. By running the application
    multiple times with this pragma both disabled and enabled, cases where the application
    makes faulty assumptions about output order can be identified and fixed early,
    reducing problems that might be caused by linking against a different version
    of SQLite.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 如果SELECT语句省略了ORDER BY子句，SQLite不保证结果的顺序。尽管如此，结果的顺序在多次运行中不会改变，因此许多应用程序错误地依赖于任意的输出顺序。然而，有时新版本的SQLite会包含优化器增强，导致没有ORDER
    BY子句的查询的输出顺序发生变化。当发生这种情况时，依赖于特定输出顺序的应用程序可能会出现故障。通过在此PRAGMA禁用和启用的情况下多次运行应用程序，可以早期识别和修复应用程序对输出顺序做出错误假设可能导致的问题，减少因链接到不同版本的SQLite而可能引起的问题。
- en: <h _id="pragma_schema_version" style="display:none">PRAGMA schema_version</h>
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_schema_version" style="display:none">PRAGMA schema_version</h>
- en: '* * *'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA** *schema.***schema_version;'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA** *schema.***schema_version;'
- en: PRAGMA** *schema.***schema_version =** *integer* ;
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA** *schema.***schema_version =** *integer* ;
- en: The schema_version pragma will get or set the value of the schema-version integer
    at offset 40 in the [database header](fileformat2.html#database_header).
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: schema_version PRAGMA 将获取或设置在[数据库头部](fileformat2.html#database_header)的偏移量40处的模式版本整数值。
- en: SQLite automatically increments the schema-version whenever the schema changes.
    As each SQL statement runs, the schema version is checked to ensure that the schema
    has not changed since the SQL statement was [prepared](c3ref/prepare.html). Subverting
    this mechanism by using "PRAGMA schema_version=N" to change the value of the schema_version
    may cause SQL statement to run using an obsolete schema, which can lead to incorrect
    answers and/or [database corruption](howtocorrupt.html#cfgerr). It is always safe
    to read the schema_version, but changing the schema_version can cause problems.
    For this reason, attempts to change the value of schema_version are a silent no-op
    when [defensive mode](c3ref/c_dbconfig_defensive.html#sqlitedbconfigdefensive)
    is enabled for a database connection.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 每当模式更改时，SQLite 会自动增加模式版本。每个 SQL 语句运行时都会检查模式版本，以确保与 SQL 语句 [准备](c3ref/prepare.html)
    时的模式没有变化。通过使用 "PRAGMA schema_version=N" 来改变 schema_version 的值来破坏此机制，可能导致 SQL 语句使用过时的模式运行，这会导致错误的结果和/或
    [数据库损坏](howtocorrupt.html#cfgerr)。读取 schema_version 总是安全的，但改变 schema_version 的值可能会引发问题。因此，当为数据库连接启用
    [防御模式](c3ref/c_dbconfig_defensive.html#sqlitedbconfigdefensive) 时，试图改变 schema_version
    值会默默失败。
- en: '**Warning:** Misuse of this pragma can result in [database corruption](howtocorrupt.html#cfgerr).'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告：** 滥用此 pragma 可能导致 [数据库损坏](howtocorrupt.html#cfgerr)。'
- en: For the purposes of this pragma, the [VACUUM](lang_vacuum.html) command is considered
    a schema change, since [VACUUM](lang_vacuum.html) will usually alter the "rootpage"
    values for entries in the [sqlite_schema table](schematab.html).
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此 pragma，[VACUUM](lang_vacuum.html) 命令被视为模式更改，因为 [VACUUM](lang_vacuum.html)
    通常会改变 [sqlite_schema 表](schematab.html) 中条目的 "rootpage" 值。
- en: See also the [application_id pragma](pragma.html#pragma_application_id) and
    [user_version pragma](pragma.html#pragma_user_version). <h _id="pragma_secure_delete"
    style="display:none">PRAGMA secure_delete</h>
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅 [application_id pragma](pragma.html#pragma_application_id) 和 [user_version
    pragma](pragma.html#pragma_user_version)。 <h _id="pragma_secure_delete" style="display:none">PRAGMA
    secure_delete</h>
- en: '* * *'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA** *schema.***secure_delete;'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA** *schema.***secure_delete;'
- en: PRAGMA** *schema.***secure_delete =** *boolean*|**FAST**
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA** *schema.***secure_delete =** *boolean*|**FAST**
- en: Query or change the secure-delete setting. When secure_delete is on, SQLite
    overwrites deleted content with zeros. The default setting for secure_delete is
    determined by the [SQLITE_SECURE_DELETE](compile.html#secure_delete) compile-time
    option and is normally off. The off setting for secure_delete improves performance
    by reducing the number of CPU cycles and the amount of disk I/O. Applications
    that wish to avoid leaving forensic traces after content is deleted or updated
    should enable the secure_delete pragma prior to performing the delete or update,
    or else run [VACUUM](lang_vacuum.html) after the delete or update.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 查询或更改安全删除设置。当 `secure_delete` 开启时，SQLite 会用零覆盖已删除的内容。安全删除的默认设置由 [SQLITE_SECURE_DELETE](compile.html#secure_delete)
    编译时选项决定，默认情况下是关闭的。关闭安全删除设置可以通过减少 CPU 循环和磁盘 I/O 的次数来提升性能。希望在删除或更新内容后避免留下法证痕迹的应用程序应在执行删除或更新操作之前启用安全删除
    pragma，或者在执行删除或更新操作后运行 [VACUUM](lang_vacuum.html)。
- en: The "fast" setting for secure_delete (added circa 2017-08-01) is an intermediate
    setting in between "on" and "off". When secure_delete is set to "fast", SQLite
    will overwrite deleted content with zeros only if doing so does not increase the
    amount of I/O. In other words, the "fast" setting uses more CPU cycles but does
    not use more I/O. This has the effect of purging all old content from [b-tree
    pages](fileformat2.html#btree), but leaving forensic traces on [freelist pages](fileformat2.html#freelist).
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '"fast" 设置安全删除（大约在 2017-08-01 添加）是介于 "on" 和 "off" 之间的中间设置。当安全删除设置为 "fast" 时，SQLite
    只有在不增加 I/O 的情况下才会用零覆盖已删除的内容。换句话说，"fast" 设置会使用更多的 CPU 循环，但不会增加更多的 I/O。这将从 [b-tree
    页面](fileformat2.html#btree) 中清除所有旧内容，但在 [freelist 页面](fileformat2.html#freelist)
    上留下法证痕迹。'
- en: When there are [attached databases](lang_attach.html) and no database is specified
    in the pragma, all databases have their secure-delete setting altered. The secure-delete
    setting for newly attached databases is the setting of the main database at the
    time the ATTACH command is evaluated.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在 [附加数据库](lang_attach.html) 且未指定任何数据库时，所有数据库的安全删除设置将被更改。新附加数据库的安全删除设置是在评估
    ATTACH 命令时主数据库的设置。
- en: When multiple database connections share the same cache, changing the secure-delete
    flag on one database connection changes it for them all.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个数据库连接共享同一缓存时，更改一个数据库连接上的安全删除标志会影响所有连接。
- en: '**Limitation:** The secure_delete pragma only causes deleted content to be
    scrubbed from ordinary tables. If [virtual tables](vtab.html) store content in
    [shadow tables](vtab.html#xshadowname), then deleting content from the virtual
    table does not necessarily remove forensic traces from the shadow tables. In particular,
    the [FTS3](fts3.html) and [FTS5](fts5.html) virtual tables that come bundled with
    SQLite might leave forensic traces in their shadow tables even if the secure_delete
    pragma is enabled.'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '**限制：** secure_delete pragma 仅导致从普通表中删除的内容被擦除。如果[虚拟表](vtab.html)在[影子表](vtab.html#xshadowname)中存储内容，则从虚拟表中删除内容并不一定会从影子表中完全移除法庭取证痕迹。特别地，与
    SQLite 捆绑的[FTS3](fts3.html)和[FTS5](fts5.html)虚拟表即使启用 secure_delete pragma，仍可能在其影子表中留下法庭取证痕迹。'
- en: <h _id="pragma_short_column_names" style="display:none">PRAGMA short_column_names</h>
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_short_column_names" style="display:none">PRAGMA short_column_names</h>
- en: '* * *'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA short_column_names;'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA short_column_names;**'
- en: PRAGMA short_column_names =** *boolean***;**
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA short_column_names =** *boolean***;**
- en: Query or change the short-column-names flag. This flag affects the way SQLite
    names columns of data returned by [SELECT](lang_select.html) statements. See the
    [full_column_names](pragma.html#pragma_full_column_names) pragma for full details.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 查询或更改短列名标志。此标志影响SQLite在[SELECT](lang_select.html)语句返回的数据列命名方式。详细信息请参阅[full_column_names](pragma.html#pragma_full_column_names)
    pragma。
- en: '**This pragma is deprecated** and exists for backwards compatibility only.
    New applications should avoid using this pragma. Older applications should discontinue
    use of this pragma at the earliest opportunity. This pragma may be omitted from
    the build when SQLite is compiled using [SQLITE_OMIT_DEPRECATED](compile.html#omit_deprecated).'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '**此 pragma 已被弃用**，仅供向后兼容性使用。新应用程序应避免使用此 pragma。旧应用程序应尽早停止使用此 pragma。当使用[SQLITE_OMIT_DEPRECATED](compile.html#omit_deprecated)编译
    SQLite 时，此 pragma 可能会被省略。'
- en: <h _id="pragma_shrink_memory" style="display:none">PRAGMA shrink_memory</h>
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_shrink_memory" style="display:none">PRAGMA shrink_memory</h>
- en: '* * *'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA shrink_memory**'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA shrink_memory**'
- en: This pragma causes the database connection on which it is invoked to free up
    as much memory as it can, by calling [sqlite3_db_release_memory()](c3ref/db_release_memory.html).
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 此 pragma 会导致调用其上的数据库连接尽可能释放内存，通过调用[sqlite3_db_release_memory()](c3ref/db_release_memory.html)实现。
- en: <h _id="pragma_soft_heap_limit" style="display:none">PRAGMA soft_heap_limit</h>
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_soft_heap_limit" style="display:none">PRAGMA soft_heap_limit</h>
- en: '* * *'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA soft_heap_limit'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA soft_heap_limit**'
- en: PRAGMA soft_heap_limit=***N*
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA soft_heap_limit=***N***
- en: This pragma invokes the [sqlite3_soft_heap_limit64()](c3ref/hard_heap_limit64.html)
    interface with the argument N, if N is specified and is a non-negative integer.
    The soft_heap_limit pragma always returns the same integer that would be returned
    by the [sqlite3_soft_heap_limit64](c3ref/hard_heap_limit64.html)(-1) C-language
    function.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 此 pragma 通过指定的非负整数 N 调用[sqlite3_soft_heap_limit64()](c3ref/hard_heap_limit64.html)接口。如果指定了
    N，则 soft_heap_limit pragma 总是返回与[sqlite3_soft_heap_limit64](c3ref/hard_heap_limit64.html)(-1)
    C 语言函数相同的整数。
- en: See also the [hard_heap_limit pragma](pragma.html#pragma_hard_heap_limit). <h
    _id="pragma_stats" style="display:none">PRAGMA stats</h>
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅[hard_heap_limit pragma](pragma.html#pragma_hard_heap_limit)。<h _id="pragma_stats"
    style="display:none">PRAGMA stats</h>
- en: '* * *'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA stats;**'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA stats;**'
- en: This pragma returns auxiliary information about tables and indices. The returned
    information is used during testing to help verify that the query planner is operating
    correctly. The format and meaning of this pragma will likely change from one release
    to the next. Because of its volatility, the behavior and output format of this
    pragma are deliberately undocumented.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 此 pragma 返回关于表和索引的辅助信息。返回的信息在测试期间用于帮助验证查询规划器的正确操作。此 pragma 的格式和含义可能会随后的版本发生变化。由于其易变性，故意不记录此
    pragma 的行为和输出格式。
- en: The intended use of this pragma is only for testing and validation of SQLite.
    This pragma is subject to change without notice and is not recommended for use
    by application programs.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 此 pragma 的预期使用仅限于测试和验证 SQLite。此 pragma 可能会在无通知的情况下更改，不建议应用程序使用。
- en: <h _id="pragma_synchronous" style="display:none">PRAGMA synchronous</h>
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_synchronous" style="display:none">PRAGMA synchronous</h>
- en: '* * *'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA** *schema.***synchronous;'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA** *schema.***synchronous;**'
- en: PRAGMA** *schema.***synchronous =** *0 | OFF | 1 | NORMAL | 2 | FULL | 3 | EXTRA***;**
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA** *schema.***synchronous =** *0 | OFF | 1 | NORMAL | 2 | FULL | 3 | EXTRA***;**
- en: 'Query or change the setting of the "synchronous" flag. The first (query) form
    will return the synchronous setting as an integer. The second form changes the
    synchronous setting. The meanings of the various synchronous settings are as follows:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 查询或更改"synchronous"标志的设置。第一个（查询）形式将返回同步设置为整数。第二个形式更改同步设置。各种同步设置的含义如下：
- en: '**EXTRA** (3)'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '**EXTRA** (3)'
- en: EXTRA synchronous is like FULL with the addition that the directory containing
    a [rollback journal](lockingv3.html#rollback) is synced after that journal is
    unlinked to commit a transaction in DELETE mode. EXTRA provides additional durability
    if the commit is followed closely by a power loss.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: EXTRA同步与FULL类似，但额外增加了在DELETE模式下提交事务后，同步包含[回滚日志](lockingv3.html#rollback)的目录。如果提交后紧随电源故障，EXTRA可以提供额外的持久性。
- en: '**FULL** (2)'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '**FULL** (2)'
- en: When synchronous is FULL (2), the SQLite database engine will use the xSync
    method of the [VFS](vfs.html) to ensure that all content is safely written to
    the disk surface prior to continuing. This ensures that an operating system crash
    or power failure will not corrupt the database. FULL synchronous is very safe,
    but it is also slower. FULL is the most commonly used synchronous setting when
    not in [WAL mode](wal.html).
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 当同步为FULL（2）时，SQLite 数据库引擎将使用[VFS](vfs.html)的xSync方法确保所有内容在继续之前都已安全写入磁盘表面。这确保操作系统崩溃或电源故障不会损坏数据库。FULL同步非常安全，但速度较慢。当不处于[WAL模式](wal.html)时，FULL是最常用的同步设置。
- en: '**NORMAL** (1)'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '**NORMAL** (1)'
- en: When synchronous is NORMAL (1), the SQLite database engine will still sync at
    the most critical moments, but less often than in FULL mode. There is a very small
    (though non-zero) chance that a power failure at just the wrong time could corrupt
    the database in [journal_mode](pragma.html#pragma_journal_mode)=DELETE on an older
    filesystem. [WAL mode](wal.html) is safe from corruption with synchronous=NORMAL,
    and probably DELETE mode is safe too on modern filesystems. WAL mode is always
    consistent with synchronous=NORMAL, but WAL mode does lose durability. A transaction
    committed in WAL mode with synchronous=NORMAL might roll back following a power
    loss or system crash. Transactions are durable across application crashes regardless
    of the synchronous setting or journal mode. The synchronous=NORMAL setting is
    a good choice for most applications running in [WAL mode](wal.html).
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 当同步为NORMAL（1）时，SQLite 数据库引擎仍会在最关键的时刻进行同步，但频率比FULL模式低。在旧文件系统上，在[journal_mode](pragma.html#pragma_journal_mode)=DELETE模式下，恰好在错误的时间断电可能会导致数据库损坏，虽然概率非常小（但不为零）。在现代文件系统上，使用synchronous=NORMAL模式可能会安全，WAL模式使用synchronous=NORMAL模式始终一致，但WAL模式会失去持久性。使用synchronous=NORMAL模式提交的事务可能在断电或系统崩溃后回滚。无论同步设置或日志模式如何，事务在应用程序崩溃时都是持久的。对于大多数运行在[WAL模式](wal.html)下的应用程序来说，synchronous=NORMAL设置是一个不错的选择。
- en: '**OFF** (0)'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '**OFF** (0)'
- en: With synchronous OFF (0), SQLite continues without syncing as soon as it has
    handed data off to the operating system. If the application running SQLite crashes,
    the data will be safe, but the database [might become corrupted](howtocorrupt.html#cfgerr)
    if the operating system crashes or the computer loses power before that data has
    been written to the disk surface. On the other hand, commits can be orders of
    magnitude faster with synchronous OFF.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 当同步为OFF（0）时，SQLite 在将数据交给操作系统后立即继续运行而无需同步。如果运行 SQLite 的应用程序崩溃，数据将是安全的，但如果操作系统崩溃或计算机在数据写入磁盘表面之前失电，数据库可能会损坏。另一方面，同步为OFF时，提交操作可以快上数个数量级。
- en: In [WAL](wal.html) mode when synchronous is NORMAL (1), the WAL file is synchronized
    before each [checkpoint](wal.html#ckpt) and the database file is synchronized
    after each completed [checkpoint](wal.html#ckpt) and the WAL file header is synchronized
    when a WAL file begins to be reused after a checkpoint, but no sync operations
    occur during most transactions. With synchronous=FULL in WAL mode, an additional
    sync operation of the WAL file happens after each transaction commit. The extra
    WAL sync following each transaction helps ensure that transactions are durable
    across a power loss. Transactions are consistent with or without the extra syncs
    provided by synchronous=FULL. If durability is not a concern, then synchronous=NORMAL
    is normally all one needs in WAL mode.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 在[WAL](wal.html)模式下，当同步设置为NORMAL（1）时，在每个[checkpoint](wal.html#ckpt)之前同步WAL文件，每个完成的[checkpoint](wal.html#ckpt)后同步数据库文件，并在检查点后开始重用WAL文件时同步WAL文件头部，但在大多数事务中不进行同步操作。在WAL模式下设置为FULL时，在每个事务提交后额外同步WAL文件。在每个事务后的额外WAL同步有助于确保事务在断电后仍然可靠。使用synchronous=FULL或者synchronous=NORMAL均可以确保事务一致性，但如果耐久性不是问题，则通常情况下在WAL模式下仅需要synchronous=NORMAL。
- en: The TEMP schema always has synchronous=OFF since the content of of TEMP is ephemeral
    and is not expected to survive a power outage. Attempts to change the synchronous
    setting for TEMP are silently ignored.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: TEMP模式始终具有synchronous=OFF，因为TEMP的内容是短暂的，不会预期在断电后保留。尝试更改TEMP的同步设置会被静默忽略。
- en: See also the [fullfsync](pragma.html#pragma_fullfsync) and [checkpoint_fullfsync](pragma.html#pragma_checkpoint_fullfsync)
    pragmas.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅[fullfsync](pragma.html#pragma_fullfsync)和[checkpoint_fullfsync](pragma.html#pragma_checkpoint_fullfsync)
    pragma。
- en: <h _id="pragma_table_info" style="display:none">PRAGMA table_info</h>
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_table_info" style="display:none">PRAGMA table_info</h>
- en: '* * *'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA** *schema.***table_info(***table-name***);**'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA** *schema.***table_info(***table-name***);**'
- en: 'This pragma returns one row for each normal column in the named table. Columns
    in the result set include: "name" (its name); "type" (data type if given, else
    ''''); "notnull" (whether or not the column can be NULL); "dflt_value" (the default
    value for the column); and "pk" (either zero for columns that are not part of
    the primary key, or the 1-based index of the column within the primary key).'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 此 **pragma** 为指定表中的每个普通列返回一行。结果集中的列包括："name"（列名）；"type"（数据类型，如果有的话，否则为空）；"notnull"（列是否可为NULL）；"dflt_value"（列的默认值）；和
    "pk"（对于非主键列为零，对于主键列为基于1的索引）。
- en: The "cid" column should not be taken to mean more than "rank within the current
    result set".
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '"cid"列不应被视为比"当前结果集中的排名"更多的意义。'
- en: The table named in the table_info pragma can also be a view.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 在table_info pragma中指定的表也可以是视图。
- en: This pragma does not show information about [generated columns](gencol.html)
    or [hidden columns](vtab.html#hiddencol). Use [PRAGMA table_xinfo](pragma.html#pragma_table_xinfo)
    to get a more complete list of columns that includes generated and hidden columns.
    <h _id="pragma_table_list" style="display:none">PRAGMA table_list</h>
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 此 **pragma** 不会显示关于[生成列](gencol.html)或[隐藏列](vtab.html#hiddencol)的信息。使用[PRAGMA
    table_xinfo](pragma.html#pragma_table_xinfo)可以获取包含生成列和隐藏列在内的更完整的列列表。 <h _id="pragma_table_list"
    style="display:none">PRAGMA table_list</h>
- en: '* * *'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA table_list;'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA table_list;'
- en: PRAGMA** *schema.***table_list;
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA** *schema.***table_list;
- en: PRAGMA table_list(***table-name***);**
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA table_list(***table-name***);**
- en: This pragma returns information about the tables and views in the schema, one
    table per row of output. The table_list pragma first appeared in SQLite version
    3.37.0 (2021-11-27). As of its initial release the columns returned by the table_list
    pragma include those listed below. Future versions of SQLite will probably add
    additional columns of output.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 此 **pragma** 返回关于模式中表和视图的信息，每行输出一张表。table_list pragma首次出现在SQLite版本3.37.0（2021-11-27）中。在其初始版本中，table_list
    pragma返回的列包括下面列出的列。未来版本的SQLite可能会添加额外的输出列。
- en: '**schema**: the schema in which the table or view appears (for example "main"
    or "temp").'
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**schema**：表或视图所在的模式（例如"main"或"temp"）。'
- en: '**name**: the name of the table or view.'
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**name**：表或视图的名称。'
- en: '**type**: the type of object - one of "table", "view", "shadow" (for [shadow
    tables](vtab.html#xshadowname)), or "virtual" for [virtual tables](vtab.html).'
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**type**：对象的类型 - 可能是"table"、"view"、"shadow"（用于[shadow tables](vtab.html#xshadowname)）或"virtual"（用于[virtual
    tables](vtab.html)）。'
- en: '**ncol**: the number of columns in the table, including [generated columns](gencol.html)
    and [hidden columns](vtab.html#hiddencol).'
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**ncol**：表中的列数，包括[生成列](gencol.html)和[隐藏列](vtab.html#hiddencol)。'
- en: '**wr**: 1 if the table is a [WITHOUT ROWID](withoutrowid.html) table or 0 if
    is not.'
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**wr**: 如果表是[WITHOUT ROWID](withoutrowid.html)表则为1，否则为0。'
- en: '**strict**: 1 if the table is a [STRICT table](stricttables.html) or 0 if it
    is not.'
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**strict**: 如果表是[STRICT表](stricttables.html)则为1，否则为0。'
- en: '*Additional columns will likely be added in future releases.*'
  id: totrans-571
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*未来版本可能会添加额外的列。*'
- en: The default behavior is to show all tables in all schemas. If the *schema.*
    name appears before the pragma, then only tables in that one schema are shown.
    If a *table-name* argument is supplied, then only information about that one table
    is returned. <h _id="pragma_table_xinfo" style="display:none">PRAGMA table_xinfo</h>
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 默认行为是显示所有模式中的所有表。如果在指示之前出现*模式.*名称，则仅显示该模式中的表。如果提供了*表名*参数，则仅返回关于该表的信息。 <h _id="pragma_table_xinfo"
    style="display:none">PRAGMA table_xinfo</h>
- en: '* * *'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA** *schema.***table_xinfo(***table-name***);**'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA** *模式.***table_xinfo(***表名***);**'
- en: This pragma returns one row for each column in the named table, including [generated
    columns](gencol.html) and [hidden columns](vtab.html#hiddencol). The output has
    the same columns as for [PRAGMA table_info](pragma.html#pragma_table_info) plus
    a column, "hidden", whose value signifies a normal column (0), a dynamic or stored
    generated column (2 or 3), or a hidden column in a virtual table (1). The rows
    for which this field is non-zero are those omitted for [PRAGMA table_info](pragma.html#pragma_table_info).
    <h _id="pragma_temp_store" style="display:none">PRAGMA temp_store</h>
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 此指示返回指定表中每一列的一行，包括[生成的列](gencol.html)和[隐藏的列](vtab.html#hiddencol)。输出与[PRAGMA
    table_info](pragma.html#pragma_table_info)的输出相同，另外还有一个名为"hidden"的列，其值表示普通列（0）、动态或存储生成的列（2或3）或虚拟表中的隐藏列（1）。对于这些字段非零的行，是[PRAGMA
    table_info](pragma.html#pragma_table_info)中省略的行。 <h _id="pragma_temp_store" style="display:none">PRAGMA
    temp_store</h>
- en: '* * *'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA temp_store;'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA temp_store;'
- en: PRAGMA temp_store =** *0 | DEFAULT | 1 | FILE | 2 | MEMORY***;**
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA temp_store =** *0 | 默认 | 1 | 文件 | 2 | 内存***;**
- en: Query or change the setting of the "**temp_store**" parameter. When temp_store
    is DEFAULT (0), the compile-time C preprocessor macro [SQLITE_TEMP_STORE](compile.html#temp_store)
    is used to determine where temporary tables and indices are stored. When temp_store
    is MEMORY (2) [temporary tables](inmemorydb.html#temp_db) and indices are kept
    as if they were in pure [in-memory databases](inmemorydb.html). When temp_store
    is FILE (1) [temporary tables](inmemorydb.html#temp_db) and indices are stored
    in a file. The [temp_store_directory](pragma.html#pragma_temp_store_directory)
    pragma can be used to specify the directory containing temporary files when **FILE**
    is specified. When the temp_store setting is changed, all existing temporary tables,
    indices, triggers, and views are immediately deleted.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 查询或更改"temp_store"参数的设置。当temp_store为DEFAULT（0）时，使用编译时C预处理宏[SQLITE_TEMP_STORE](compile.html#temp_store)确定临时表和索引的存储位置。当temp_store为MEMORY（2）时，临时表和索引保留在纯[内存数据库](inmemorydb.html#temp_db)中。当temp_store为FILE（1）时，临时表和索引存储在文件中。当指定FILE时，可以使用[temp_store_directory](pragma.html#pragma_temp_store_directory)指示来指定包含临时文件的目录。更改temp_store设置时，所有现有的临时表、索引、触发器和视图将立即被删除。
- en: 'It is possible for the library compile-time C preprocessor symbol [SQLITE_TEMP_STORE](compile.html#temp_store)
    to override this pragma setting. The following table summarizes the interaction
    of the [SQLITE_TEMP_STORE](compile.html#temp_store) preprocessor macro and the
    temp_store pragma:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 可能由库的编译时C预处理符号[SQLITE_TEMP_STORE](compile.html#temp_store)覆盖此指示设置。以下表格总结了[SQLITE_TEMP_STORE](compile.html#temp_store)预处理宏和temp_store指示的交互：
- en: '| [SQLITE_TEMP_STORE](compile.html#temp_store) | PRAGMA temp_store | Storage
    used for TEMP tables and indices |'
  id: totrans-581
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [SQLITE_TEMP_STORE](compile.html#temp_store) | PRAGMA temp_store | 用于TEMP表和索引的存储
    |'
- en: '| 0 | *any* | file |'
  id: totrans-582
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 0 | *任意* | 文件 |'
- en: '| 1 | 0 | file |'
  id: totrans-583
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 1 | 0 | 文件 |'
- en: '| 1 | 1 | file |'
  id: totrans-584
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 1 | 1 | 文件 |'
- en: '| 1 | 2 | memory |'
  id: totrans-585
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 1 | 2 | 内存 |'
- en: '| 2 | 0 | memory |'
  id: totrans-586
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 2 | 0 | 内存 |'
- en: '| 2 | 1 | file |'
  id: totrans-587
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 2 | 1 | 文件 |'
- en: '| 2 | 2 | memory |'
  id: totrans-588
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 2 | 2 | 内存 |'
- en: '| 3 | *any* | memory |'
  id: totrans-589
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 3 | *任意* | 内存 |'
- en: <h _id="pragma_temp_store_directory" style="display:none">PRAGMA temp_store_directory</h>
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_temp_store_directory" style="display:none">PRAGMA temp_store_directory</h>
- en: '* * *'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA temp_store_directory;'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA temp_store_directory;'
- en: PRAGMA temp_store_directory = '***directory-name***';**
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA temp_store_directory = '***目录名***';**
- en: Query or change the value of the [sqlite3_temp_directory](c3ref/temp_directory.html)
    global variable, which many operating-system interface backends use to determine
    where to store [temporary tables](inmemorydb.html#temp_db) and indices.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 查询或更改[sqlite3_temp_directory](https://sqlite.org/c3ref/temp_directory.html)全局变量的值，许多操作系统接口后端使用此变量确定存储[临时表](https://sqlite.org/inmemorydb.html#temp_db)和索引的位置。
- en: When the temp_store_directory setting is changed, all existing temporary tables,
    indices, triggers, and viewers in the database connection that issued the pragma
    are immediately deleted. In practice, temp_store_directory should be set immediately
    after the first database connection for a process is opened. If the temp_store_directory
    is changed for one database connection while other database connections are open
    in the same process, then the behavior is undefined and probably undesirable.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 更改temp_store_directory设置时，立即删除发出该命令的数据库连接中的所有现有临时表、索引、触发器和视图。在实践中，应在打开进程的第一个数据库连接后立即设置temp_store_directory。如果在同一进程中的其他数据库连接打开时更改temp_store_directory，则行为是未定义的，并且可能是不希望的。
- en: Changing the temp_store_directory setting is not threadsafe. Never change the
    temp_store_directory setting if another thread within the application is running
    any SQLite interface at the same time. Doing so results in undefined behavior.
    Changing the temp_store_directory setting writes to the [sqlite3_temp_directory](c3ref/temp_directory.html)
    global variable and that global variable is not protected by a mutex.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 更改temp_store_directory设置不是线程安全的。如果应用程序内的另一个线程同时运行任何SQLite接口，则永远不要更改temp_store_directory设置。这样做会导致未定义的行为。更改temp_store_directory设置会写入[sqlite3_temp_directory](https://sqlite.org/c3ref/temp_directory.html)全局变量，该全局变量未受到互斥锁保护。
- en: The value *directory-name* should be enclosed in single quotes. To revert the
    directory to the default, set the *directory-name* to an empty string, e.g., *PRAGMA
    temp_store_directory = ''*. An error is raised if *directory-name* is not found
    or is not writable.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 值*directory-name*应该用单引号括起来。要将目录恢复为默认设置，请将*directory-name*设置为空字符串，例如，*PRAGMA
    temp_store_directory = ''*。如果找不到*directory-name*或无法写入，则会引发错误。
- en: The default directory for temporary files depends on the OS. Some OS interfaces
    may choose to ignore this variable and place temporary files in some other directory
    different from the directory specified here. In that sense, this pragma is only
    advisory.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 临时文件的默认目录取决于操作系统。某些操作系统接口可能选择忽略此变量，并将临时文件放置在与此处指定的目录不同的其他目录中。从这个意义上说，此命令只是建议性的。
- en: '**This pragma is deprecated** and exists for backwards compatibility only.
    New applications should avoid using this pragma. Older applications should discontinue
    use of this pragma at the earliest opportunity. This pragma may be omitted from
    the build when SQLite is compiled using [SQLITE_OMIT_DEPRECATED](compile.html#omit_deprecated).'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '**此命令已弃用**，仅为向后兼容性而存在。新应用程序应避免使用此命令。旧应用程序应尽快停止使用此命令。在使用[SQLITE_OMIT_DEPRECATED](https://sqlite.org/compile.html#omit_deprecated)编译时选项编译SQLite时，可能会从构建中省略此命令。'
- en: <h _id="pragma_threads" style="display:none">PRAGMA threads</h>
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_threads" style="display:none">PRAGMA threads</h>
- en: '* * *'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA threads;'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA threads;**'
- en: PRAGMA threads =** *N***;**
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA threads = **N**;
- en: Query or change the value of the [sqlite3_limit](c3ref/limit.html)(db,[SQLITE_LIMIT_WORKER_THREADS](c3ref/c_limit_attached.html#sqlitelimitworkerthreads),...)
    limit for the current database connection. This limit sets an upper bound on the
    number of auxiliary threads that a [prepared statement](c3ref/stmt.html) is allowed
    to launch to assist with a query. The default limit is 0 unless it is changed
    using the [SQLITE_DEFAULT_WORKER_THREADS](compile.html#default_worker_threads)
    compile-time option. When the limit is zero, that means no auxiliary threads will
    be launched.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 查询或更改当前数据库连接的[sqlite3_limit](https://sqlite.org/c3ref/limit.html)(db,[SQLITE_LIMIT_WORKER_THREADS](https://sqlite.org/c3ref/c_limit_attached.html#sqlitelimitworkerthreads),...)限制的值。此限制设置了辅助线程数量的上限，这些线程允许在查询中启动以帮助处理预处理语句。默认限制为0，除非使用[SQLITE_DEFAULT_WORKER_THREADS](https://sqlite.org/compile.html#default_worker_threads)编译时选项进行更改。当限制为零时，意味着不会启动任何辅助线程。
- en: This pragma is a thin wrapper around the [sqlite3_limit](c3ref/limit.html)(db,[SQLITE_LIMIT_WORKER_THREADS](c3ref/c_limit_attached.html#sqlitelimitworkerthreads),...)
    interface.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令是对[sqlite3_limit](https://sqlite.org/c3ref/limit.html)(db,[SQLITE_LIMIT_WORKER_THREADS](https://sqlite.org/c3ref/c_limit_attached.html#sqlitelimitworkerthreads),...)接口的简单包装。
- en: <h _id="pragma_trusted_schema" style="display:none">PRAGMA trusted_schema</h>
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_trusted_schema" style="display:none">PRAGMA trusted_schema</h>
- en: '* * *'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA trusted_schema;'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA trusted_schema;**'
- en: PRAGMA trusted_schema =** *boolean***;**
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA trusted_schema =** *boolean***;**
- en: The trusted_schema setting is a per-connection boolean that determines whether
    or not SQL functions and virtual tables that have not been security audited are
    allowed to be run by views, triggers, or in expressions of the schema such as
    [CHECK constraints](lang_createtable.html#ckconst), [DEFAULT clauses](lang_createtable.html#dfltval),
    [generated columns](gencol.html), [expression indexes](expridx.html), and/or [partial
    indexes](partialindex.html). This setting can also be controlled using the [sqlite3_db_config](c3ref/db_config.html)(db,[SQLITE_DBCONFIG_TRUSTED_SCHEMA](c3ref/c_dbconfig_defensive.html#sqlitedbconfigtrustedschema),...)
    C-language interface.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: trusted_schema 设置是一个每个连接的布尔值，用于确定未经安全审计的 SQL 函数和虚拟表是否允许由视图、触发器或模式表达式（如[CHECK
    约束](lang_createtable.html#ckconst)、[DEFAULT 子句](lang_createtable.html#dfltval)、[生成列](gencol.html)、[表达式索引](expridx.html)和/或[部分索引](partialindex.html)）运行。还可以使用[C
    语言接口](c3ref/db_config.html)(db，[SQLITE_DBCONFIG_TRUSTED_SCHEMA](c3ref/c_dbconfig_defensive.html#sqlitedbconfigtrustedschema),...)控制此设置。
- en: In order to maintain backwards compatibility, this setting is ON by default.
    There are advantages to turning it off, and most applications will be unaffected
    if it is turned off. For that reason, all applications are encouraged to switch
    this setting off on every database connection as soon as that connection is opened.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持向后兼容性，默认情况下此设置为 ON。关闭它有利有弊，大多数应用程序关闭后不受影响。因此，建议所有应用程序在打开数据库连接时立即关闭此设置。
- en: The [-DSQLITE_TRUSTED_SCHEMA=0](compile.html#trusted_schema) compile-time option
    will cause this setting to default to OFF. <h _id="pragma_user_version" style="display:none">PRAGMA
    user_version</h>
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 编译时选项[-DSQLITE_TRUSTED_SCHEMA=0](compile.html#trusted_schema)将导致此设置默认为 OFF。
    <h _id="pragma_user_version" style="display:none">PRAGMA user_version</h>
- en: '* * *'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA** *schema.***user_version;'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA** *schema.***user_version;'
- en: PRAGMA** *schema.***user_version =** *integer* **;**
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA** *schema.***user_version =** *integer* **;**
- en: The user_version pragma will get or set the value of the user-version integer
    at offset 60 in the [database header](fileformat2.html#database_header). The user-version
    is an integer that is available to applications to use however they want. SQLite
    makes no use of the user-version itself.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: user_version pragma 将获取或设置数据库头部[fileformat2.html#database_header]中偏移量 60 处的用户版本整数的值。用户版本是一个整数，应用程序可以根据需要自行使用。SQLite
    本身不使用用户版本。
- en: See also the [application_id pragma](pragma.html#pragma_application_id) and
    [schema_version pragma](pragma.html#pragma_schema_version). <h _id="pragma_vdbe_addoptrace"
    style="display:none">PRAGMA vdbe_addoptrace</h>
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅[application_id pragma](pragma.html#pragma_application_id)和[schema_version
    pragma](pragma.html#pragma_schema_version)。 <h _id="pragma_vdbe_addoptrace" style="display:none">PRAGMA
    vdbe_addoptrace</h>
- en: '* * *'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA vdbe_addoptrace =** *boolean***;**'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA vdbe_addoptrace =** *boolean***;**'
- en: If SQLite has been compiled with the [SQLITE_DEBUG](compile.html#debug) compile-time
    option, then the vdbe_addoptrace pragma can be used to cause a complete VDBE opcodes
    to be displayed as they are created during code generation. This feature is used
    for debugging SQLite itself. See the [VDBE documentation](vdbe.html#trace) for
    more information.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 SQLite 使用[SQLITE_DEBUG](compile.html#debug)编译时选项编译，则 vdbe_addoptrace pragma
    可用于在代码生成期间创建时显示完整的 VDBE 操作码。此功能用于调试 SQLite 本身。有关更多信息，请参阅[VDBE 文档](vdbe.html#trace)。
- en: This pragma is intended for use when debugging SQLite itself. It is only available
    when the [SQLITE_DEBUG](compile.html#debug) compile-time option is used.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 pragma 用于在调试 SQLite 本身时使用。只有在使用[SQLITE_DEBUG](compile.html#debug)编译时选项时才可用。
- en: <h _id="pragma_vdbe_debug" style="display:none">PRAGMA vdbe_debug</h>
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_vdbe_debug" style="display:none">PRAGMA vdbe_debug</h>
- en: '* * *'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA vdbe_debug =** *boolean***;**'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA vdbe_debug =** *boolean***;**'
- en: 'If SQLite has been compiled with the [SQLITE_DEBUG](compile.html#debug) compile-time
    option, then the vdbe_debug pragma is a shorthand for three other debug-only pragmas:
    vdbe_addoptrace, vdbe_listing, and vdbe_trace. This feature is used for debugging
    SQLite itself. See the [VDBE documentation](vdbe.html#trace) for more information.'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 SQLite 使用[SQLITE_DEBUG](compile.html#debug)编译时选项编译，则 vdbe_debug pragma 是三个仅供调试使用的快捷
    pragma 的简写：vdbe_addoptrace、vdbe_listing 和 vdbe_trace。此功能用于调试 SQLite 本身。有关更多信息，请参阅[VDBE
    文档](vdbe.html#trace)。
- en: This pragma is intended for use when debugging SQLite itself. It is only available
    when the [SQLITE_DEBUG](compile.html#debug) compile-time option is used.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 pragma 用于在调试 SQLite 本身时使用。只有在使用[SQLITE_DEBUG](compile.html#debug)编译时选项时才可用。
- en: <h _id="pragma_vdbe_listing" style="display:none">PRAGMA vdbe_listing</h>
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_vdbe_listing" style="display:none">PRAGMA vdbe_listing</h>
- en: '* * *'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA vdbe_listing =** *boolean***;**'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA vdbe_listing =** *boolean***;**'
- en: If SQLite has been compiled with the [SQLITE_DEBUG](compile.html#debug) compile-time
    option, then the vdbe_listing pragma can be used to cause a complete listing of
    the virtual machine opcodes to appear on standard output as each statement is
    evaluated. With listing is on, the entire content of a program is printed just
    prior to beginning execution. The statement executes normally after the listing
    is printed. This feature is used for debugging SQLite itself. See the [VDBE documentation](vdbe.html#trace)
    for more information.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 如果SQLite使用[SQLITE_DEBUG](compile.html#debug)编译选项编译，那么vdbe_listing pragma可以用来在每个语句执行时在标准输出中显示虚拟机操作码的完整列表。打开列表后，在开始执行之前会打印出整个程序的内容。此功能用于调试SQLite本身。更多信息请参阅[VDBE文档](vdbe.html#trace)。
- en: This pragma is intended for use when debugging SQLite itself. It is only available
    when the [SQLITE_DEBUG](compile.html#debug) compile-time option is used.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 这个pragma仅用于调试SQLite本身。只有在使用[SQLITE_DEBUG](compile.html#debug)编译选项时才可用。
- en: <h _id="pragma_vdbe_trace" style="display:none">PRAGMA vdbe_trace</h>
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_vdbe_trace" style="display:none">PRAGMA vdbe_trace</h>
- en: '* * *'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA vdbe_trace =** *boolean***;**'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA vdbe_trace =** *boolean***;**'
- en: If SQLite has been compiled with the [SQLITE_DEBUG](compile.html#debug) compile-time
    option, then the vdbe_trace pragma can be used to cause virtual machine opcodes
    to be printed on standard output as they are evaluated. This feature is used for
    debugging SQLite. See the [VDBE documentation](vdbe.html#trace) for more information.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 如果SQLite使用[SQLITE_DEBUG](compile.html#debug)编译选项编译，那么vdbe_trace pragma可以用来在标准输出中打印虚拟机操作码的执行过程。这个特性用于调试SQLite。更多信息请参阅[VDBE文档](vdbe.html#trace)。
- en: This pragma is intended for use when debugging SQLite itself. It is only available
    when the [SQLITE_DEBUG](compile.html#debug) compile-time option is used.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 这个pragma仅用于调试SQLite本身。只有在使用[SQLITE_DEBUG](compile.html#debug)编译选项时才可用。
- en: <h _id="pragma_wal_autocheckpoint" style="display:none">PRAGMA wal_autocheckpoint</h>
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_wal_autocheckpoint" style="display:none">PRAGMA wal_autocheckpoint</h>
- en: '* * *'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA wal_autocheckpoint;'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA wal_autocheckpoint;'
- en: PRAGMA wal_autocheckpoint=***N***;**
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: PRAGMA wal_autocheckpoint=***N***;**
- en: This pragma queries or sets the [write-ahead log](wal.html) [auto-checkpoint](wal.html#ckpt)
    interval. When the [write-ahead log](wal.html) is enabled (via the [journal_mode
    pragma](pragma.html#pragma_journal_mode)) a checkpoint will be run automatically
    whenever the write-ahead log equals or exceeds *N* pages in length. Setting the
    auto-checkpoint size to zero or a negative value turns auto-checkpointing off.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 这个pragma用于查询或设置[预写式日志](wal.html)的[自动checkpoint](wal.html#ckpt)间隔。当启用[预写式日志](wal.html)（通过[journal_mode
    pragma](pragma.html#pragma_journal_mode)）时，每当预写式日志长度等于或超过*N*页时，就会自动运行一个checkpoint。将自动checkpoint的大小设置为零或负数会关闭自动checkpoint功能。
- en: This pragma is a wrapper around the [sqlite3_wal_autocheckpoint()](c3ref/wal_autocheckpoint.html)
    C interface. All automatic checkpoints are [PASSIVE](c3ref/wal_checkpoint_v2.html).
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 这个pragma是[sqlite3_wal_autocheckpoint()](c3ref/wal_autocheckpoint.html) C接口的包装器。所有自动checkpoint都是[PASSIVE](c3ref/wal_checkpoint_v2.html)的。
- en: Autocheckpointing is enabled by default with an interval of 1000 or [SQLITE_DEFAULT_WAL_AUTOCHECKPOINT](compile.html#default_wal_autocheckpoint).
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，自动checkpoint的间隔为1000或[SQLITE_DEFAULT_WAL_AUTOCHECKPOINT](compile.html#default_wal_autocheckpoint)。
- en: <h _id="pragma_wal_checkpoint" style="display:none">PRAGMA wal_checkpoint</h>
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_wal_checkpoint" style="display:none">PRAGMA wal_checkpoint</h>
- en: '* * *'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA** *schema.***wal_checkpoint;**'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA** *schema.***wal_checkpoint;**'
- en: '**PRAGMA** *schema.***wal_checkpoint(PASSIVE);**'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA** *schema.***wal_checkpoint(PASSIVE);**'
- en: '**PRAGMA** *schema.***wal_checkpoint(FULL);**'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA** *schema.***wal_checkpoint(FULL);**'
- en: '**PRAGMA** *schema.***wal_checkpoint(RESTART);**'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA** *schema.***wal_checkpoint(RESTART);**'
- en: '**PRAGMA** *schema.***wal_checkpoint(TRUNCATE);**'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA** *schema.***wal_checkpoint(TRUNCATE);**'
- en: If the [write-ahead log](wal.html) is enabled (via the [journal_mode pragma](pragma.html#pragma_journal_mode)),
    this pragma causes a [checkpoint](wal.html#ckpt) operation to run on database
    *database*, or on all attached databases if *database* is omitted. If [write-ahead
    log](wal.html) mode is disabled, this pragma is a harmless no-op.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启用了[预写式日志](wal.html)（通过[journal_mode pragma](pragma.html#pragma_journal_mode)），这个pragma会导致对数据库*database*进行[checkpoint](wal.html#ckpt)操作，如果省略了*database*，则会对所有附加数据库进行操作。如果禁用了[预写式日志](wal.html)模式，这个pragma则是一个无害的空操作。
- en: Invoking this pragma without an argument is equivalent to calling the [sqlite3_wal_checkpoint()](c3ref/wal_checkpoint.html)
    C interface.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此编译指示而不带参数相当于调用[C接口sqlite3_wal_checkpoint()](c3ref/wal_checkpoint.html)。
- en: 'Invoking this pragma with an argument is equivalent to calling the [sqlite3_wal_checkpoint_v2()](c3ref/wal_checkpoint_v2.html)
    C interface with a [3rd parameter](c3ref/c_checkpoint_full.html) corresponding
    to the argument:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 使用参数调用此编译指示相当于调用[C接口sqlite3_wal_checkpoint_v2()](c3ref/wal_checkpoint_v2.html)，并使用第三个参数对应于[3rd
    parameter](c3ref/c_checkpoint_full.html)：
- en: PASSIVE
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 被动
- en: Checkpoint as many frames as possible without waiting for any database readers
    or writers to finish. Sync the db file if all frames in the log are checkpointed.
    This mode is the same as calling the [sqlite3_wal_checkpoint()](c3ref/wal_checkpoint.html)
    C interface. The [busy-handler callback](c3ref/busy_handler.html) is never invoked
    in this mode.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能检查多个帧而不等待任何数据库读取器或写入器完成。如果日志中的所有帧都已检查点，则同步数据库文件。此模式与调用[C接口sqlite3_wal_checkpoint()](c3ref/wal_checkpoint.html)相同。在此模式下，永远不会调用[忙处理程序回调](c3ref/busy_handler.html)。
- en: FULL
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 完全
- en: This mode blocks (invokes the [busy-handler callback](c3ref/busy_handler.html))
    until there is no database writer and all readers are reading from the most recent
    database snapshot. It then checkpoints all frames in the log file and syncs the
    database file. FULL blocks concurrent writers while it is running, but readers
    can proceed.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式阻止（调用[忙处理程序回调](c3ref/busy_handler.html)）直到没有数据库写入器和所有读取器从最新数据库快照中读取为止。然后，它检查点日志文件中的所有帧并同步数据库文件。完全在运行时阻止并发写入，但读取器可以继续进行。
- en: RESTART
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 重新开始
- en: This mode works the same way as FULL with the addition that after checkpointing
    the log file it blocks (calls the [busy-handler callback](c3ref/busy_handler.html))
    until all readers are finished with the log file. This ensures that the next client
    to write to the database file restarts the log file from the beginning. RESTART
    blocks concurrent writers while it is running, but allowed readers to proceed.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式的工作方式与完全相同，但在检查点日志文件后，它会阻塞（调用[忙处理程序回调](c3ref/busy_handler.html)），直到所有读取器完成对日志文件的操作。这确保了下一个写入数据库文件的客户端从头重新开始日志文件。重新开始在运行时阻止并发写入，但允许读取器继续进行。
- en: TRUNCATE
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 截断
- en: This mode works the same way as RESTART with the addition that the WAL file
    is truncated to zero bytes upon successful completion.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式的工作方式与重新开始相同，但在成功完成后，WAL文件将被截断为零字节。
- en: The wal_checkpoint pragma returns a single row with three integer columns. The
    first column is usually 0 but will be 1 if a RESTART or FULL or TRUNCATE checkpoint
    was blocked from completing, for example because another thread or process was
    actively using the database. In other words, the first column is 0 if the equivalent
    call to [sqlite3_wal_checkpoint_v2()](c3ref/wal_checkpoint_v2.html) would have
    returned [SQLITE_OK](rescode.html#ok) or 1 if the equivalent call would have returned
    [SQLITE_BUSY](rescode.html#busy). The second column is the number of modified
    pages that have been written to the write-ahead log file. The third column is
    the number of pages in the write-ahead log file that have been successfully moved
    back into the database file at the conclusion of the checkpoint. The second and
    third column are -1 if there is no write-ahead log, for example if this pragma
    is invoked on a database connection that is not in [WAL mode](wal.html).
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: wal_checkpoint编译指示返回一个具有三个整数列的单行。第一列通常为0，但如果由于其他线程或进程正在活动使用数据库而阻止完成，则为1，例如，如果等效调用[sqlite3_wal_checkpoint_v2()](c3ref/wal_checkpoint_v2.html)将返回[SQLITE_OK](rescode.html#ok)或1如果等效调用将返回[SQLITE_BUSY](rescode.html#busy)。第二列是已写入写前日志文件的修改页面数。第三列是在检查点结束时已成功移回数据库文件的写前日志文件中的页面数。如果没有写前日志，则第二列和第三列为-1，例如，如果在不在[WAL模式](wal.html)的数据库连接上调用此编译指示。
- en: <h _id="pragma_writable_schema" style="display:none">PRAGMA writable_schema</h>
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: <h _id="pragma_writable_schema" style="display:none">PRAGMA writable_schema</h>
- en: '* * *'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**PRAGMA writable_schema =** *boolean***;**'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA writable_schema =** *boolean***;**'
- en: '**PRAGMA writable_schema = RESET**'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRAGMA writable_schema = RESET**'
- en: When this pragma is on, and the [SQLITE_DBCONFIG_DEFENSIVE](c3ref/c_dbconfig_defensive.html#sqlitedbconfigdefensive)
    flag is off, then the [sqlite_schema](schematab.html) table can be changed using
    ordinary [UPDATE](lang_update.html), [INSERT](lang_insert.html), and [DELETE](lang_delete.html)
    statements. If the argument is "RESET" then schema writing is disabled (as with
    "PRAGMA writable_schema=OFF") and, in addition, the schema is reloaded. **Warning:**
    misuse of this pragma can easily result in a [corrupt database file](howtocorrupt.html#cfgerr).
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 当此编译指示开启，并且[SQLITE_DBCONFIG_DEFENSIVE](c3ref/c_dbconfig_defensive.html#sqlitedbconfigdefensive)标志关闭时，[sqlite_schema](schematab.html)表可以使用普通的[UPDATE](lang_update.html)、[INSERT](lang_insert.html)和[DELETE](lang_delete.html)语句进行更改。如果参数为"RESET"，则禁用模式写入（类似于"PRAGMA
    writable_schema=OFF"），并且重新加载模式。**警告：**滥用此编译指示很容易导致[数据库文件损坏](howtocorrupt.html#cfgerr)。
- en: '* * *'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
