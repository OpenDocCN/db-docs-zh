- en: Frequently Asked Questions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题解答
- en: 原文：[https://sqlite.com/faq.html](https://sqlite.com/faq.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://sqlite.com/faq.html](https://sqlite.com/faq.html)
- en: '[How do I create an AUTOINCREMENT field?](#q1)'
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**(1) 如何创建一个自动增量字段？**'
- en: '[What datatypes does SQLite support?](#q2)'
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[SQLite 支持哪些数据类型？](#q2)'
- en: '[SQLite lets me insert a string into a database column of type integer!](#q3)'
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[SQLite 允许我将字符串插入到类型为整数的数据库列中！](#q3)'
- en: '[Why doesn''t SQLite allow me to use ''0'' and ''0.0'' as the primary key on
    two different rows of the same table?](#q4)'
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[为什么 SQLite 不允许我在同一表的两行中使用 ''0'' 和 ''0.0'' 作为主键？](#q4)'
- en: '[Can multiple applications or multiple instances of the same application access
    a single database file at the same time?](#q5)'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[多个应用程序或同一个应用程序的多个实例可以同时访问单个数据库文件吗？](#q5)'
- en: '[Is SQLite threadsafe?](#q6)'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[SQLite 是线程安全的吗？](#q6)'
- en: '[How do I list all tables/indices contained in an SQLite database](#q7)'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[如何列出 SQLite 数据库中包含的所有表/索引？](#q7)'
- en: '[Are there any known size limits to SQLite databases?](#q8)'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[SQLite 数据库有已知的大小限制吗？](#q8)'
- en: '[What is the maximum size of a VARCHAR in SQLite?](#q9)'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[SQLite 中 VARCHAR 的最大尺寸是多少？](#q9)'
- en: '[Does SQLite support a BLOB type?](#q10)'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[SQLite 支持 BLOB 类型吗？](#q10)'
- en: '[How do I add, delete or rename columns from an existing table in SQLite?](#q11)'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[如何在 SQLite 中对现有表格添加、删除或重命名列？](#q11)'
- en: '[I deleted a lot of data but the database file did not get any smaller. Is
    this a bug?](#q12)'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[我删除了很多数据，但数据库文件并没有变小。这是一个 bug 吗？](#q12)'
- en: '[Can I use SQLite in my commercial product without paying royalties?](#q13)'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[我可以在商业产品中使用 SQLite 而不支付版税吗？](#q13)'
- en: '[How do I use a string literal that contains an embedded single-quote ('')
    character?](#q14)'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[如何使用包含嵌入单引号（''）字符的字符串字面值？](#q14)'
- en: '[What is an SQLITE_SCHEMA error, and why am I getting one?](#q15)'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[什么是 SQLITE_SCHEMA 错误，我为什么会遇到这个错误？](#q15)'
- en: '[I get some compiler warnings when I compile SQLite. Isn''t this a problem?
    Doesn''t it indicate poor code quality?](#q17)'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[当我编译 SQLite 时，我得到了一些编译器警告。这是个问题吗？这是否表明代码质量差？](#q17)'
- en: '[Case-insensitive matching of Unicode characters does not work.](#q18)'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[Unicode 字符的不区分大小写匹配不起作用。](#q18)'
- en: '[INSERT is really slow - I can only do few dozen INSERTs per second](#q19)'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[插入操作非常慢 - 每秒只能执行几十个 INSERT 操作](#q19)'
- en: '[I accidentally deleted some important information from my SQLite database.
    How can I recover it?](#q20)'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[我不小心从我的 SQLite 数据库中删除了一些重要信息。如何恢复它？](#q20)'
- en: '[What is an SQLITE_CORRUPT error? What does it mean for the database to be
    "malformed"? Why am I getting this error?](#q21)'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[什么是 SQLITE_CORRUPT 错误？数据库"畸形"意味着什么？为什么我会遇到这个错误？](#q21)'
- en: '[Does SQLite support foreign keys?](#q22)'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[SQLite 支持外键吗？](#q22)'
- en: '[I get a compiler error if I use the SQLITE_OMIT_... compile-time options when
    building SQLite.](#q23)'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[如果在构建 SQLite 时使用 SQLITE_OMIT_... 编译选项，我会得到编译器错误。](#q23)'
- en: '[My WHERE clause expression `column1="column1"` does not work. It causes every
    row of the table to be returned, not just the rows where column1 has the value
    "column1".](#q24)'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[我的 WHERE 子句表达式 `column1="column1"` 不起作用。它导致返回表中的每一行，而不仅仅是 column1 值为 "column1"
    的行。](#q24)'
- en: '[How are the syntax diagrams (a.k.a. "railroad" diagrams) for SQLite generated?](#q25)'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[SQLite 的语法图（也称为“铁路图”）是如何生成的？](#q25)'
- en: '[The SQL standard requires that a UNIQUE constraint be enforced even if one
    or more of the columns in the constraint are NULL, but SQLite does not do this.
    Isn''t that a bug?](#q26)'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[SQL 标准要求即使约束中的一个或多个列为 NULL，唯一约束也必须执行，但 SQLite 不执行。这不是一个 bug 吗？](#q26)'
- en: '[What is the Export Control Classification Number (ECCN) for SQLite?](#q27)'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[SQLite 的出口管制分类号（ECCN）是什么？](#q27)'
- en: '[My query does not return the column name that I expect. Is this a bug?](#q28)'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[我的查询没有返回我期望的列名。这是一个 bug 吗？](#q28)'
- en: '[Where did my database go? (Or: How did my database become empty?)](#q29)'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[我的数据库去哪了？（或者说：我的数据库怎么变空了？）](#q29)'
- en: '**(1) How do I create an AUTOINCREMENT field?**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**(1) 如何创建一个自动增量字段？**'
- en: 'Short answer: A column declared [INTEGER PRIMARY KEY](lang_createtable.html#rowid)
    will autoincrement.'
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 简短回答：声明为 [INTEGER PRIMARY KEY](lang_createtable.html#rowid) 的列会自动增长。
- en: ''
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Longer answer: If you declare a column of a table to be [INTEGER PRIMARY KEY](lang_createtable.html#rowid),
    then whenever you insert a NULL into that column of the table, the NULL is automatically
    converted into an integer which is one greater than the largest value of that
    column over all other rows in the table, or 1 if the table is empty. Or, if the
    largest existing integer key 9223372036854775807 is in use then an unused key
    value is chosen at random. For example, suppose you have a table like this:'
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 更长的答案：如果你声明表的某列为[INTEGER PRIMARY KEY](lang_createtable.html#rowid)，那么无论何时你在该列插入一个NULL，该NULL会自动转换为一个整数，该整数比表中所有其他行中该列的最大值大一，或者如果表为空则为1。或者，如果最大的现有整数键9223372036854775807正在使用，则会随机选择一个未使用的键值。例如，假设你有这样一张表：
- en: ''
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-35
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ''
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: With this table, the statement
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于这张表，语句
- en: ''
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-39
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ''
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'is logically equivalent to saying:'
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 逻辑上等同于说：
- en: ''
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-43
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ''
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There is a function named [sqlite3_last_insert_rowid()](c3ref/last_insert_rowid.html)
    which will return the integer key for the most recent insert operation.
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有一个名为[sqlite3_last_insert_rowid()](c3ref/last_insert_rowid.html)的函数，它将返回最近插入操作的整数键。
- en: ''
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note that the integer key is one greater than the largest key that was in the
    table just prior to the insert. The new key will be unique over all keys currently
    in the table, but it might overlap with keys that have been previously deleted
    from the table. To create keys that are unique over the lifetime of the table,
    add the [AUTOINCREMENT](autoinc.html) keyword to the [INTEGER PRIMARY KEY](lang_createtable.html#rowid)
    declaration. Then the key chosen will be one more than the largest key that has
    ever existed in that table. If the largest possible key has previously existed
    in that table, then the [INSERT](lang_insert.html) will fail with an [SQLITE_FULL](rescode.html#full)
    error code.
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请注意，整数键是插入前表中存在的最大键加一。新键将在当前表中所有键中是唯一的，但可能会与以前从表中删除的键重叠。为了创建在表的生命周期内唯一的键，请在[INTEGER
    PRIMARY KEY](lang_createtable.html#rowid)声明中添加[AUTOINCREMENT](autoinc.html)关键字。然后选择的键将比该表中曾经存在的最大键多一。如果以前在该表中存在最大可能的键，则[INSERT](lang_insert.html)将失败，并显示[SQLITE_FULL](rescode.html#full)错误代码。
- en: '**(2) What datatypes does SQLite support?**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**(2) SQLite支持哪些数据类型？**'
- en: SQLite uses [dynamic typing](datatype3.html). Content can be stored as INTEGER,
    REAL, TEXT, BLOB, or as NULL.
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQLite使用[dynamic typing](datatype3.html)。内容可以存储为INTEGER、REAL、TEXT、BLOB或NULL。
- en: '**(3) SQLite lets me insert a string into a database column of type integer!**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**(3) SQLite让我在整数类型的数据库列中插入字符串！**'
- en: 'This is a feature, not a bug. SQLite uses [dynamic typing](datatype3.html).
    It does not enforce data type constraints. Data of any type can (usually) be inserted
    into any column. You can put arbitrary length strings into integer columns, floating
    point numbers in boolean columns, or dates in character columns. The [datatype](datatype3.html)
    you assign to a column in the CREATE TABLE command does not restrict what data
    can be put into that column. Every column is able to hold an arbitrary length
    string. (There is one exception: Columns of type [INTEGER PRIMARY KEY](lang_createtable.html#rowid)
    may only hold a 64-bit signed integer. An error will result if you try to put
    anything other than an integer into an [INTEGER PRIMARY KEY](lang_createtable.html#rowid)
    column.)'
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这是一个特性，而不是错误。SQLite使用[dynamic typing](datatype3.html)。它不强制数据类型约束。可以（通常）将任何类型的数据插入到任何列中。可以将任意长度的字符串放入整数列中，将浮点数放入布尔列中，或将日期放入字符列中。在CREATE
    TABLE命令中分配给列的[datatype](datatype3.html)不限制可以放入该列的数据。每列能够容纳任意长度的字符串。（有一个例外：类型为[INTEGER
    PRIMARY KEY](lang_createtable.html#rowid)的列只能包含64位有符号整数。如果尝试将除整数外的任何内容放入[INTEGER
    PRIMARY KEY](lang_createtable.html#rowid)列中，则会报错。）
- en: ''
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: But SQLite does use the declared type of a column as a hint that you prefer
    values in that format. So, for example, if a column is of type INTEGER and you
    try to insert a string into that column, SQLite will attempt to convert the string
    into an integer. If it can, it inserts the integer instead. If not, it inserts
    the string. This feature is called [type affinity](datatype3.html#affinity).
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 但SQLite确实使用列的声明类型作为你偏好该格式值的提示。因此，例如，如果某列的类型为INTEGER并且你尝试将字符串插入该列，SQLite会尝试将字符串转换为整数。如果可以，它会插入整数。否则，它会插入字符串。这个特性被称为[type
    affinity](datatype3.html#affinity)。
- en: '**(4) Why doesn''t SQLite allow me to use ''0'' and ''0.0'' as the primary
    key on two different rows of the same table?**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**(4) 为什么SQLite不允许我在同一表的两行中使用''0''和''0.0''作为主键？**'
- en: This problem occurs when your primary key is a numeric type. Change the [datatype](datatype3.html)
    of your primary key to TEXT and it should work.
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当您的主键是数值类型时会出现这个问题。将您的主键的[数据类型](datatype3.html)更改为TEXT，问题应该就可以解决了。
- en: ''
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Every row must have a unique primary key. For a column with a numeric type,
    SQLite thinks that **'0'** and **'0.0'** are the same value because they compare
    equal to one another numerically. (See the previous question.) Hence the values
    are not unique.
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 每行必须具有唯一的主键。对于数值类型的列，SQLite认为**'0'**和**'0.0'**是相同的值，因为它们在数值上相等（请参见前面的问题）。因此这些值并不是唯一的。
- en: '**(5) Can multiple applications or multiple instances of the same application
    access a single database file at the same time?**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**（5）多个应用程序或同一应用程序的多个实例可以同时访问单个数据库文件吗？**'
- en: Multiple processes can have the same database open at the same time. Multiple
    processes can be doing a SELECT at the same time. But only one process can be
    making changes to the database at any moment in time, however.
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 多个进程可以同时打开同一个数据库。多个进程可以同时执行SELECT操作。但在任何时刻只有一个进程可以对数据库进行更改。
- en: ''
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'SQLite uses reader/writer locks to control access to the database. (Under Win95/98/ME
    which lacks support for reader/writer locks, a probabilistic simulation is used
    instead.) But use caution: this locking mechanism might not work correctly if
    the database file is kept on an NFS filesystem. This is because fcntl() file locking
    is broken on many NFS implementations. You should avoid putting SQLite database
    files on NFS if multiple processes might try to access the file at the same time.
    On Windows, Microsoft''s documentation says that locking may not work under FAT
    filesystems if you are not running the Share.exe daemon. People who have a lot
    of experience with Windows tell me that file locking of network files is very
    buggy and is not dependable. If what they say is true, sharing an SQLite database
    between two or more Windows machines might cause unexpected problems.'
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQLite使用读者/写者锁来控制对数据库的访问。（在缺乏读者/写者锁支持的Win95/98/ME上，将使用概率模拟。）但要小心：如果数据库文件保存在NFS文件系统上，此锁定机制可能无法正常工作。这是因为在许多NFS实现中，fcntl()文件锁定是有问题的。如果可能有多个进程尝试同时访问文件，请避免将SQLite数据库文件放在NFS上。在Windows上，微软的文档说如果您没有运行Share.exe守护程序，那么在FAT文件系统上锁定可能无法工作。那些对Windows有丰富经验的人告诉我，网络文件的文件锁定非常不稳定且不可靠。如果他们说的是真的，那么在两台或更多Windows机器之间共享SQLite数据库可能会导致意外的问题。
- en: ''
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We are aware of no other *embedded* SQL database engine that supports as much
    concurrency as SQLite. SQLite allows multiple processes to have the database file
    open at once, and for multiple processes to read the database at once. When any
    process wants to write, it must lock the entire database file for the duration
    of its update. But that normally only takes a few milliseconds. Other processes
    just wait on the writer to finish then continue about their business. Other embedded
    SQL database engines typically only allow a single process to connect to the database
    at once.
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们知道没有其他*嵌入式*SQL数据库引擎像SQLite那样支持如此多的并发性。SQLite允许多个进程同时打开数据库文件，并且允许多个进程同时读取数据库。当任何进程想要写入时，它必须锁定整个数据库文件以完成更新。但这通常只需要几毫秒。其他进程只需等待写入者完成，然后继续他们的工作。其他嵌入式SQL数据库引擎通常只允许一个进程同时连接到数据库。
- en: ''
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: However, client/server database engines (such as PostgreSQL, MySQL, or Oracle)
    usually support a higher level of concurrency and allow multiple processes to
    be writing to the same database at the same time. This is possible in a client/server
    database because there is always a single well-controlled server process available
    to coordinate access. If your application has a need for a lot of concurrency,
    then you should consider using a client/server database. But experience suggests
    that most applications need much less concurrency than their designers imagine.
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然而，客户端/服务器数据库引擎（如PostgreSQL、MySQL或Oracle）通常支持更高级别的并发，并允许多个进程同时向同一个数据库写入。这在客户端/服务器数据库中是可能的，因为总是有一个单一的、良好控制的服务器进程可用于协调访问。如果您的应用程序需要大量并发性，则应考虑使用客户端/服务器数据库。但经验表明，大多数应用程序所需的并发性远远少于其设计者想象的那么多。
- en: ''
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When SQLite tries to access a file that is locked by another process, the default
    behavior is to return SQLITE_BUSY. You can adjust this behavior from C code using
    the [sqlite3_busy_handler()](c3ref/busy_handler.html) or [sqlite3_busy_timeout()](c3ref/busy_timeout.html)
    API functions.
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当SQLite尝试访问由另一个进程锁定的文件时，默认行为是返回SQLITE_BUSY。您可以使用[C代码](c3ref/busy_handler.html)或[sqlite3_busy_timeout()](c3ref/busy_timeout.html)API函数来调整此行为。
- en: '**(6) Is SQLite threadsafe?**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**(6) SQLite是否是线程安全的？**'
- en: '[Threads are evil](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2006/EECS-2006-1.html).
    Avoid them.'
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[线程是邪恶的](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2006/EECS-2006-1.html)。避免使用它们。'
- en: ''
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SQLite is threadsafe. We make this concession since many users choose to ignore
    the advice given in the previous paragraph. But in order to be thread-safe, SQLite
    must be compiled with the SQLITE_THREADSAFE preprocessor macro set to 1\. Both
    the Windows and Linux precompiled binaries in the distribution are compiled this
    way. If you are unsure if the SQLite library you are linking against is compiled
    to be threadsafe you can call the [sqlite3_threadsafe()](c3ref/threadsafe.html)
    interface to find out.
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQLite是线程安全的。我们做出这个让步是因为许多用户选择忽略前一段中给出的建议。但是为了线程安全，SQLite必须使用`SQLITE_THREADSAFE`预处理宏设置为1进行编译。分发中的Windows和Linux预编译二进制文件都是这样编译的。如果您不确定您正在链接的SQLite库是否编译为线程安全，可以调用[sqlite3_threadsafe()](c3ref/threadsafe.html)接口来查找。
- en: ''
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SQLite is threadsafe because it uses mutexes to serialize access to common data
    structures. However, the work of acquiring and releasing these mutexes will slow
    SQLite down slightly. Hence, if you do not need SQLite to be threadsafe, you should
    disable the mutexes for maximum performance. See the [threading mode](threadsafe.html)
    documentation for additional information.
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQLite是线程安全的，因为它使用互斥锁来串行访问共享数据结构。然而，获取和释放这些互斥锁的工作会稍微减慢SQLite的速度。因此，如果不需要SQLite是线程安全的，应该禁用互斥锁以获得最大性能。有关更多信息，请参阅[线程模式](threadsafe.html)文档。
- en: ''
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Under Unix, you should not carry an open SQLite database across a fork() system
    call into the child process.
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在Unix环境下，不应该在`fork()`系统调用中将打开的SQLite数据库传递到子进程中。
- en: '**(7) How do I list all tables/indices contained in an SQLite database**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**(7) 我如何列出包含在SQLite数据库中的所有表/索引**'
- en: If you are running the **sqlite3** command-line access program you can type
    "**.tables**" to get a list of all tables. Or you can type "**.schema**" to see
    the complete database schema including all tables and indices. Either of these
    commands can be followed by a LIKE pattern that will restrict the tables that
    are displayed.
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您正在运行**sqlite3**命令行访问程序，可以键入"**.tables**"以获取所有表的列表。或者可以键入"**.schema**"以查看完整的数据库架构，包括所有表和索引。这些命令之一后面可以跟一个LIKE模式，该模式将限制显示的表。
- en: ''
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'From within a C/C++ program (or a script using Tcl/Ruby/Perl/Python bindings)
    you can get access to table and index names by doing a SELECT on a special table
    named "**SQLITE_SCHEMA**". Every SQLite database has an SQLITE_SCHEMA table that
    defines the schema for the database. The SQLITE_SCHEMA table looks like this:'
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在C/C++程序（或使用Tcl/Ruby/Perl/Python绑定的脚本）中，您可以通过对名为"**SQLITE_SCHEMA**"的特殊表进行SELECT来获取表和索引名称。每个SQLite数据库都有一个定义数据库模式的SQLITE_SCHEMA表。SQLITE_SCHEMA表如下所示：
- en: ''
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-81
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ''
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'For tables, the **type** field will always be **''table''** and the **name**
    field will be the name of the table. So to get a list of all tables in the database,
    use the following SELECT command:'
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于表，**type**字段将始终是**'table'**，**name**字段将是表的名称。因此，要获取数据库中所有表的列表，请使用以下SELECT命令：
- en: ''
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-85
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ''
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For indices, **type** is equal to **'index'**, **name** is the name of the index
    and **tbl_name** is the name of the table to which the index belongs. For both
    tables and indices, the **sql** field is the text of the original CREATE TABLE
    or CREATE INDEX statement that created the table or index. For automatically created
    indices (used to implement the PRIMARY KEY or UNIQUE constraints) the **sql**
    field is NULL.
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于索引，**type**等于**'index'**，**name**是索引的名称，**tbl_name**是索引所属的表的名称。对于表和索引，**sql**字段是创建表或索引的原始CREATE
    TABLE或CREATE INDEX语句的文本。对于自动创建的索引（用于实现PRIMARY KEY或UNIQUE约束），**sql**字段为NULL。
- en: ''
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The SQLITE_SCHEMA table cannot be modified using UPDATE, INSERT, or DELETE (except
    under [extraordinary conditions](pragma.html#pragma_writable_schema)). The SQLITE_SCHEMA
    table is automatically updated by commands like CREATE TABLE, CREATE INDEX, DROP
    TABLE, and DROP INDEX.
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQLITE_SCHEMA表不能使用UPDATE、INSERT或DELETE修改（除非在[特殊情况](pragma.html#pragma_writable_schema)下）。SQLITE_SCHEMA表会被像CREATE
    TABLE、CREATE INDEX、DROP TABLE和DROP INDEX等命令自动更新。
- en: ''
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Temporary tables do not appear in the SQLITE_SCHEMA table. Temporary tables
    and their indices and triggers occur in another special table named SQLITE_TEMP_SCHEMA.
    SQLITE_TEMP_SCHEMA works just like SQLITE_SCHEMA except that it is only visible
    to the application that created the temporary tables. To get a list of all tables,
    both permanent and temporary, one can use a command similar to the following:'
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 临时表不会出现在SQLITE_SCHEMA表中。临时表及其索引和触发器出现在另一个名为SQLITE_TEMP_SCHEMA的特殊表中。SQLITE_TEMP_SCHEMA的工作方式与SQLITE_SCHEMA相同，但只对创建临时表的应用程序可见。要获取所有表（包括永久和临时表）的列表，可以使用类似以下命令的命令：
- en: ''
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-93
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**(8) Are there any known size limits to SQLite databases?**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**(8) SQLite数据库有已知的大小限制吗？**'
- en: See [limits.html](limits.html) for a full discussion of the limits of SQLite.
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参见[limits.html](limits.html)以获取有关SQLite限制的完整讨论。
- en: '**(9) What is the maximum size of a VARCHAR in SQLite?**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**(9) SQLite中VARCHAR的最大大小是多少？**'
- en: SQLite does not enforce the length of a VARCHAR. You can declare a VARCHAR(10)
    and SQLite will be happy to store a 500-million character string there. And it
    will keep all 500-million characters intact. Your content is never truncated.
    SQLite understands the column type of "VARCHAR(*N*)" to be the same as "TEXT",
    regardless of the value of *N*.
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQLite不强制VARCHAR的长度。您可以声明一个VARCHAR(10)，SQLite将很高兴地在那里存储一个5亿字符的字符串。它将保持所有5亿个字符完整。您的内容不会被截断。SQLite将"VARCHAR(*N*)"列类型理解为"TEXT"，无论*N*的值如何。
- en: '**(10) Does SQLite support a BLOB type?**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**(10) SQLite支持BLOB类型吗？**'
- en: SQLite allows you to store BLOB data in any column, even columns that are declared
    to hold some other type. BLOBs can even be used as PRIMARY KEYs.
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQLite允许您在任何列中存储BLOB数据，即使声明为其他类型也可以。甚至可以将BLOB用作主键。
- en: '**(11) How do I add, delete or rename columns from an existing table in SQLite?**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**(11) 我如何在SQLite中的现有表中添加、删除或重命名列？**'
- en: SQLite has limited ALTER TABLE support that you can use to add, rename or drop
    columns or to change the name of a table as detailed at [ALTER TABLE](lang_altertable.html).
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQLite有限的ALTER TABLE支持可用于添加、重命名或删除列，或更改表名，详细信息请参见[ALTER TABLE](lang_altertable.html)。
- en: ''
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you want to make more complex changes in the structure or constraints of
    a table or its columns, you will have to recreate it. You can save existing data
    to a temporary table, drop the old table, create the new table, then copy the
    data back in from the temporary table. See [Making Other Kinds Of Table Schema
    Changes](lang_altertable.html#otheralter) for procedure.
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您想对表或其列的结构或约束进行更复杂的更改，您将不得不重新创建它。您可以将现有数据保存到临时表中，删除旧表，创建新表，然后将数据从临时表复制回来。请参阅[进行其他类型的表模式更改](lang_altertable.html#otheralter)以获取详细步骤。
- en: '**(12) I deleted a lot of data but the database file did not get any smaller.
    Is this a bug?**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**(12) 我删除了很多数据，但数据库文件大小没有变小。这是一个bug吗？**'
- en: No. When you delete information from an SQLite database, the unused disk space
    is added to an internal "free-list" and is reused the next time you insert data.
    The disk space is not lost. But neither is it returned to the operating system.
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不会。当您从SQLite数据库中删除信息时，未使用的磁盘空间将添加到内部的“空闲列表”，并在下次插入数据时重新使用。磁盘空间并没有丢失。但也没有归还给操作系统。
- en: ''
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you delete a lot of data and want to shrink the database file, run the [VACUUM](lang_vacuum.html)
    command. VACUUM will reconstruct the database from scratch. This will leave the
    database with an empty free-list and a file that is minimal in size. Note, however,
    that the VACUUM can take some time to run and it can use up to twice as much temporary
    disk space as the original file while it is running.
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您删除了大量数据并希望缩小数据库文件，请运行[VACUUM](lang_vacuum.html)命令。VACUUM将从头开始重建数据库。这将使数据库具有空的空闲列表和最小尺寸的文件。然而，请注意，VACUUM可能需要一些时间来运行，并且在运行时可能使用原始文件两倍的临时磁盘空间。
- en: ''
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An alternative to using the VACUUM command is auto-vacuum mode, enabled using
    the [auto_vacuum pragma](pragma.html#pragma_auto_vacuum).
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用[auto_vacuum pragma](pragma.html#pragma_auto_vacuum)来启用自动清理模式，而不是使用VACUUM命令的另一种选择。
- en: '**(13) Can I use SQLite in my commercial product without paying royalties?**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**(13) 我可以在我的商业产品中使用SQLite而无需支付版税吗？**'
- en: Yes. SQLite is in the [public domain](copyright.html). No claim of ownership
    is made to any part of the code. You can do anything you want with it.
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 是的。SQLite属于[公有领域](copyright.html)。我们对代码的任何部分都不主张所有权。你可以对其做任何想做的事情。
- en: '**(14) How do I use a string literal that contains an embedded single-quote
    ('') character?**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**(14) 如何使用包含嵌入式单引号（''）字符的字符串字面量？**'
- en: 'The SQL standard specifies that single-quotes in strings are escaped by putting
    two single quotes in a row. SQL works like the Pascal programming language in
    this regard. Example:'
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQL标准指定字符串中的单引号通过连续放置两个单引号来转义。在这方面，SQL的工作方式类似于Pascal编程语言。例如：
- en: ''
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-115
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**(15) What is an SQLITE_SCHEMA error, and why am I getting one?**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**(15) 什么是SQLITE_SCHEMA错误，为什么我会收到这个错误？**'
- en: An [SQLITE_SCHEMA](rescode.html#schema) error is returned when a prepared SQL
    statement is no longer valid and cannot be executed. When this occurs, the statement
    must be recompiled from SQL using the [sqlite3_prepare()](c3ref/prepare.html)
    API. An SQLITE_SCHEMA error can only occur when using the [sqlite3_prepare()](c3ref/prepare.html),
    and [sqlite3_step()](c3ref/step.html) interfaces to run SQL. You will never receive
    an [SQLITE_SCHEMA](rescode.html#schema) error from [sqlite3_exec()](c3ref/exec.html).
    Nor will you receive an error if you prepare statements using [sqlite3_prepare_v2()](c3ref/prepare.html)
    instead of [sqlite3_prepare()](c3ref/prepare.html).
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当准备的SQL语句不再有效且无法执行时，会返回一个[SQLITE_SCHEMA](rescode.html#schema)错误。发生这种情况时，必须使用[sqlite3_prepare()](c3ref/prepare.html)
    API重新从SQL编译语句。只有在使用[sqlite3_prepare()](c3ref/prepare.html)和[sqlite3_step()](c3ref/step.html)接口运行SQL时才会出现SQLITE_SCHEMA错误。从[sqlite3_exec()](c3ref/exec.html)执行语句时，你永远不会收到[SQLITE_SCHEMA](rescode.html#schema)错误。如果使用[sqlite3_prepare_v2()](c3ref/prepare.html)而不是[sqlite3_prepare()](c3ref/prepare.html)准备语句，也不会收到错误。
- en: ''
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The [sqlite3_prepare_v2()](c3ref/prepare.html) interface creates a [prepared
    statement](c3ref/stmt.html) that will automatically recompile itself if the schema
    changes. The easiest way to deal with [SQLITE_SCHEMA](rescode.html#schema) errors
    is to always use [sqlite3_prepare_v2()](c3ref/prepare.html) instead of [sqlite3_prepare()](c3ref/prepare.html).
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[sqlite3_prepare_v2()](c3ref/prepare.html)接口创建一个[准备语句](c3ref/stmt.html)，如果模式更改，它将自动重新编译。处理[SQLITE_SCHEMA](rescode.html#schema)错误的最简单方法是始终使用[sqlite3_prepare_v2()](c3ref/prepare.html)而不是[sqlite3_prepare()](c3ref/prepare.html)。'
- en: '**(17) I get some compiler warnings when I compile SQLite. Isn''t this a problem?
    Doesn''t it indicate poor code quality?**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**(17) 我在编译SQLite时收到一些编译器警告。这是问题吗？这是否表明代码质量不佳？**'
- en: Quality assurance in SQLite is done using [full-coverage testing](testing.html#coverage),
    not by compiler warnings or other static code analysis tools. In other words,
    we verify that SQLite actually gets the correct answer, not that it merely satisfies
    stylistic constraints. Most of the SQLite code base is devoted purely to testing.
    The SQLite test suite runs tens of thousands of separate test cases and many of
    those test cases are parameterized so that hundreds of millions of tests involving
    billions of SQL statements are run and evaluated for correctness prior to every
    release. The developers use code coverage tools to verify that all paths through
    the code are tested. Whenever a bug is found in SQLite, new test cases are written
    to exhibit the bug so that the bug cannot recur undetected in the future.
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQLite的质量保证通过[全覆盖测试](testing.html#coverage)进行，而不是通过编译器警告或其他静态代码分析工具。换句话说，我们验证SQLite确实得到了正确答案，而不仅仅是满足风格上的约束。大部分SQLite代码库完全用于测试。SQLite测试套件运行数以万计的单独测试用例，并且其中许多测试用例是参数化的，以便在每个发布之前运行和评估数十亿个SQL语句的数百万个测试，并验证其正确性。开发人员使用代码覆盖工具验证代码的所有路径是否都经过测试。每当在SQLite中发现错误时，都会编写新的测试用例来展示该错误，以确保将来不会再次无法检测到该错误。
- en: ''
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: During testing, the SQLite library is compiled with special instrumentation
    that allows the test scripts to simulate a wide variety of failures in order to
    verify that SQLite recovers correctly. Memory allocation is carefully tracked
    and no memory leaks occur, even following memory allocation failures. A custom
    VFS layer is used to simulate operating system crashes and power failures in order
    to ensure that transactions are atomic across these events. A mechanism for deliberately
    injecting I/O errors shows that SQLite is resilient to such malfunctions. (As
    an experiment, try inducing these kinds of errors on other SQL database engines
    and see what happens!)
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在测试期间，SQLite 库被编译时使用特殊的工具来允许测试脚本模拟各种故障，以验证 SQLite 的恢复能力。内存分配被仔细跟踪，即使在内存分配失败后也不会发生内存泄漏。自定义的
    VFS 层用于模拟操作系统崩溃和电源故障，以确保事务在这些事件中是原子性的。一种有意注入 I/O 错误的机制显示，SQLite 对这些故障有很强的恢复能力。（作为实验，请尝试在其他
    SQL 数据库引擎上引发这些类型的错误，看看会发生什么！）
- en: ''
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We also run SQLite using [Valgrind](http://valgrind.org) on Linux and verify
    that it detects no problems.
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们还在 Linux 上使用 [Valgrind](http://valgrind.org) 运行 SQLite 并验证其未发现问题。
- en: ''
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Some people say that we should eliminate all warnings because benign warnings
    mask real warnings that might arise in future changes. This is true enough. But
    in reply, the developers observe that all warnings have already been fixed in
    the builds used for SQLite development (various versions of GCC, MSVC, and clang).
    Compiler warnings usually only arise from compilers or compile-time options that
    the SQLite developers do not use themselves.
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有些人说我们应该消除所有警告，因为良性警告掩盖了可能在未来变更中出现的真正警告。这倒也有些道理。但开发者指出，所有警告已经在用于 SQLite 开发的构建中（各种版本的
    GCC、MSVC 和 clang）中修复过了。编译器警告通常只会因为 SQLite 开发者自己不使用的编译器或编译时选项而产生。
- en: '**(18) Case-insensitive matching of Unicode characters does not work.**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**(18) Unicode 字符的大小写不敏感匹配不起作用。**'
- en: The default configuration of SQLite only supports case-insensitive comparisons
    of ASCII characters. The reason for this is that doing full Unicode case-insensitive
    comparisons and case conversions requires tables and logic that would nearly double
    the size of the SQLite library. The SQLite developers reason that any application
    that needs full Unicode case support probably already has the necessary tables
    and functions and so SQLite should not take up space to duplicate this ability.
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQLite 的默认配置仅支持对 ASCII 字符的大小写不敏感比较。原因是，实现完整的 Unicode 大小写不敏感比较和大小写转换需要的表和逻辑将几乎使
    SQLite 库的大小增加一倍。SQLite 开发者认为，任何需要完整 Unicode 支持的应用程序可能已经具备了必要的表和函数，因此 SQLite 不应占用空间来复制这种能力。
- en: ''
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Instead of providing full Unicode case support by default, SQLite provides the
    ability to link against external Unicode comparison and conversion routines. The
    application can overload the built-in [NOCASE](datatype3.html#collation) collating
    sequence (using [sqlite3_create_collation()](c3ref/create_collation.html)) and
    the built-in [like()](lang_corefunc.html#like), [upper()](lang_corefunc.html#upper),
    and [lower()](lang_corefunc.html#lower) functions (using [sqlite3_create_function()](c3ref/create_function.html)).
    The SQLite source code includes an "ICU" extension that does these overloads.
    Or, developers can write their own overloads based on their own Unicode-aware
    comparison routines already contained within their project.
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQLite 不会默认提供完整的 Unicode 大小写支持，而是提供了链接外部 Unicode 比较和转换例程的能力。应用程序可以重载内置的[NOCASE](datatype3.html#collation)排序序列（使用[sqlite3_create_collation()](c3ref/create_collation.html)），以及内置的[like()](lang_corefunc.html#like)，[upper()](lang_corefunc.html#upper)，和[lower()](lang_corefunc.html#lower)函数（使用[sqlite3_create_function()](c3ref/create_function.html)）。SQLite
    源代码包含一个 "ICU" 扩展来实现这些重载。开发者也可以基于项目内已有的 Unicode 比较例程编写自己的重载。
- en: '**(19) INSERT is really slow - I can only do few dozen INSERTs per second**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**(19) 插入操作非常慢 - 我每秒只能做几十次插入。**'
- en: Actually, SQLite will easily do 50,000 or more [INSERT](lang_insert.html) statements
    per second on an average desktop computer. But it will only do a few dozen transactions
    per second. Transaction speed is limited by the rotational speed of your disk
    drive. A transaction normally requires two complete rotations of the disk platter,
    which on a 7200RPM disk drive limits you to about 60 transactions per second.
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实际上，SQLite在普通台式计算机上每秒可以轻松执行50,000个或更多[INSERT](lang_insert.html)语句。但是每秒只能执行几十个事务。事务速度受限于磁盘驱动器的旋转速度。一个事务通常需要磁盘盘片的两次完整旋转，在7200RPM磁盘驱动器上，这限制了你大约每秒执行60个事务。
- en: ''
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Transaction speed is limited by disk drive speed because (by default) SQLite
    actually waits until the data really is safely stored on the disk surface before
    the transaction is complete. That way, if you suddenly lose power or if your OS
    crashes, your data is still safe. For details, read about [atomic commit in SQLite.](atomiccommit.html).
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 事务速度受限于磁盘驱动器的速度，因为（默认情况下）SQLite会等待数据确实安全存储到磁盘表面后才完成事务。这样，如果突然断电或操作系统崩溃，你的数据仍然是安全的。详情请阅读关于[SQLite中的原子提交](atomiccommit.html)的内容。
- en: ''
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: By default, each INSERT statement is its own transaction. But if you surround
    multiple INSERT statements with [BEGIN](lang_transaction.html)...[COMMIT](lang_transaction.html)
    then all the inserts are grouped into a single transaction. The time needed to
    commit the transaction is amortized over all the enclosed insert statements and
    so the time per insert statement is greatly reduced.
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 默认情况下，每个INSERT语句都是自己的事务。但是，如果你用[BEGIN](lang_transaction.html)...[COMMIT](lang_transaction.html)将多个INSERT语句包裹起来，那么所有的插入将被组织成一个单独的事务。提交事务的时间摊销到所有的插入语句上，因此每个插入语句的时间大大缩短。
- en: ''
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Another option is to run [PRAGMA synchronous=OFF](pragma.html#pragma_synchronous).
    This command will cause SQLite to not wait on data to reach the disk surface,
    which will make write operations appear to be much faster. But if you lose power
    in the middle of a transaction, your database file might go corrupt.
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一个选项是运行[PRAGMA synchronous=OFF](pragma.html#pragma_synchronous)。此命令会导致SQLite不等待数据到达磁盘表面，这将使写入操作看起来更快。但是如果在事务进行中断电，你的数据库文件可能会损坏。
- en: '**(20) I accidentally deleted some important information from my SQLite database.
    How can I recover it?**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**(20) 我不小心从我的SQLite数据库中删除了一些重要信息。我如何恢复它？**'
- en: If you have a backup copy of your database file, recover the information from
    your backup.
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你有数据库文件的备份副本，可以从备份中恢复信息。
- en: ''
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you do not have a backup, recovery is very difficult. You might be able to
    find partial string data in a binary dump of the raw database file. Recovering
    numeric data might also be possible given special tools, though to our knowledge
    no such tools exist. SQLite is sometimes compiled with the [SQLITE_SECURE_DELETE](compile.html#secure_delete)
    option which overwrites all deleted content with zeros. If that is the case then
    recovery is clearly impossible. Recovery is also impossible if you have run [VACUUM](lang_vacuum.html)
    since the data was deleted. If SQLITE_SECURE_DELETE is not used and VACUUM has
    not been run, then some of the deleted content might still be in the database
    file, in areas marked for reuse. But, again, there exist no procedures or tools
    that we know of to help you recover that data.
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你没有备份，恢复会非常困难。你可能能在原始数据库文件的二进制转储中找到部分字符串数据。使用特殊工具可能也能恢复数值数据，尽管据我们所知目前没有这样的工具存在。SQLite有时会使用[SQLITE_SECURE_DELETE](compile.html#secure_delete)选项编译，这会用零覆盖所有已删除的内容。如果情况是这样的话，那么恢复显然是不可能的。如果在数据被删除后运行了[VACUUM](lang_vacuum.html)，恢复也是不可能的。如果没有使用SQLITE_SECURE_DELETE并且没有运行VACUUM，那么部分已删除的内容可能仍然存在于数据库文件中，位于标记为重用的区域。但是，据我们所知，不存在任何过程或工具可以帮助你恢复这些数据。
- en: '**(21) What is an SQLITE_CORRUPT error? What does it mean for the database
    to be "malformed"? Why am I getting this error?**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**(21) 什么是SQLITE_CORRUPT错误？数据库“格式错误”是什么意思？为什么我会收到这个错误？**'
- en: An [SQLITE_CORRUPT](rescode.html#corrupt) error is returned when SQLite detects
    an error in the structure, format, or other control elements of the database file.
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当SQLite检测到数据库文件的结构、格式或其他控制元素存在错误时，会返回[SQLITE_CORRUPT](rescode.html#corrupt)错误。
- en: ''
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SQLite does not corrupt database files without external help. If your application
    crashes in the middle of an update, your data is safe. The database is safe even
    if your OS crashes or takes a power loss. The crash-resistance of SQLite has been
    extensively studied and tested and is attested by years of real-world experience
    by billions of users.
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQLite 不会在没有外部帮助的情况下损坏数据库文件。如果应用程序在更新中崩溃，您的数据是安全的。即使操作系统崩溃或断电，数据库也是安全的。SQLite
    的崩溃抵抗性经过了广泛的研究和测试，并且已经由数十亿用户多年的实际经验证明。
- en: ''
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: That said, there are a number of things that external programs or bugs in your
    hardware or OS can do to corrupt a database file. See [How To Corrupt An SQLite
    Database File](howtocorrupt.html) for further information.
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 话虽如此，外部程序或硬件/操作系统中的错误可能会损坏数据库文件。有关详细信息，请参阅 [如何损坏 SQLite 数据库文件](howtocorrupt.html)。
- en: ''
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You can use [PRAGMA integrity_check](pragma.html#pragma_integrity_check) to
    do a thorough but time intensive test of the database integrity.
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您可以使用 [PRAGMA integrity_check](pragma.html#pragma_integrity_check) 对数据库完整性进行彻底但耗时的测试。
- en: ''
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You can use [PRAGMA quick_check](pragma.html#pragma_quick_check) to do a faster
    but less thorough test of the database integrity.
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您可以使用 [PRAGMA quick_check](pragma.html#pragma_quick_check) 对数据库完整性进行更快但不够彻底的测试。
- en: ''
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Depending how badly your database is corrupted, you may be able to recover some
    of the data by using the CLI to dump the schema and contents to a file and then
    recreate. Unfortunately, once humpty-dumpty falls off the wall, it is generally
    not possible to put him back together again.
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 取决于数据库的损坏程度，您可以尝试使用 CLI 将模式和内容转储到文件中，然后重新创建来恢复部分数据。不幸的是，一旦"破鸡蛋"从墙上掉下来，通常是无法再将其恢复。
- en: '**(22) Does SQLite support foreign keys?**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**(22) SQLite 支持外键吗？**'
- en: As of [version 3.6.19](releaselog/3_6_19.html) (2009-10-14), SQLite supports
    [foreign key constraints](foreignkeys.html). But enforcement of foreign key constraints
    is turned off by default (for backwards compatibility). To enable foreign key
    constraint enforcement, run [PRAGMA foreign_keys=ON](pragma.html#pragma_foreign_keys)
    or compile with [-DSQLITE_DEFAULT_FOREIGN_KEYS=1](compile.html#default_foreign_keys).
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 自 [版本 3.6.19](releaselog/3_6_19.html)（2009-10-14）起，SQLite 支持 [外键约束](foreignkeys.html)。但是默认情况下关闭了外键约束的执行（为了向后兼容性）。要启用外键约束执行，请运行
    [PRAGMA foreign_keys=ON](pragma.html#pragma_foreign_keys) 或使用 [-DSQLITE_DEFAULT_FOREIGN_KEYS=1](compile.html#default_foreign_keys)
    进行编译。
- en: '**(23) I get a compiler error if I use the SQLITE_OMIT_... compile-time options
    when building SQLite.**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**(23) 如果我在构建 SQLite 时使用 SQLITE_OMIT_... 编译时选项，会得到编译器错误。**'
- en: The [SQLITE_OMIT_...](compile.html#omitfeatures) compile-time options only work
    when building from canonical source files. They do not work when you build from
    the SQLite [amalgamation](amalgamation.html) or from the pre-processed source
    files.
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[SQLITE_OMIT_...](compile.html#omitfeatures) 编译时选项仅在从规范的源文件构建时起作用。在使用 SQLite
    [混合编译](amalgamation.html) 或预处理源文件构建时，不起作用。'
- en: ''
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It is possible to build a special [amalgamation](amalgamation.html) that will
    work with a predetermined set of SQLITE_OMIT_... options. Instructions for doing
    so can be found with the [SQLITE_OMIT_... documentation](compile.html#omitfeatures).
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可以构建一个特殊的 [混合编译](amalgamation.html)，以使用预设的 SQLITE_OMIT_... 选项集。有关如何执行此操作的说明可以在
    [SQLITE_OMIT_... 文档](compile.html#omitfeatures) 中找到。
- en: '**(24) My WHERE clause expression `column1="column1"` does not work. It causes
    every row of the table to be returned, not just the rows where column1 has the
    value "column1".**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**(24) 我的 WHERE 子句表达式 `column1="column1"` 不起作用。它导致返回表的每一行，而不仅仅是 column1 值为
    "column1" 的行。**'
- en: 'Use single-quotes, not double-quotes, around string literals in SQL. This is
    what the SQL standard requires. Your WHERE clause expression should read: `column1=''column1''`'
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 SQL 中，字符串字面量应使用单引号而不是双引号。这是 SQL 标准要求的。因此，您的 WHERE 子句表达式应该是：`column1='column1'`
- en: ''
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SQL uses double-quotes around identifiers (column or table names) that contains
    special characters or which are keywords. So double-quotes are a way of escaping
    identifier names. Hence, when you say `column1="column1"` that is equivalent to
    `column1=column1` which is obviously always true.
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQL 在包含特殊字符或是关键字的标识符（列或表名）周围使用双引号。因此，双引号是转义标识符名称的一种方式。因此，当您说 `column1="column1"`
    时，这等效于 `column1=column1`，显然始终为真。
- en: '**(25) How are the syntax diagrams (a.k.a. "railroad" diagrams) for SQLite
    generated?**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**(25) SQLite 的语法图（也称为 "铁路图"）是如何生成的？**'
- en: Each diagram is hand-written using the [Pikchr](https://pikchr.org/) diagramming
    language. These hand-written specifications are converted into SVG and inserted
    inline in the HTML files as part of the documentation build process.
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 每个图表都是使用[Pikchr](https://pikchr.org/)绘图语言手工编写的。这些手工编写的规范将被转换为SVG，并作为文档构建过程的一部分内联插入到HTML文件中。
- en: ''
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Many historical versions of the SQLite documentation used a different process
    for generating the syntax diagrams. The historical process was based on Tcl/Tk
    and is described at [http://wiki.tcl-lang.org/21708](http://wiki.tcl-lang.org/21708).
    The newer Pikchr-based syntax diagrams first landed on trunk on 2020-09-26.
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 许多历史版本的SQLite文档使用了不同的流程来生成语法图。历史流程基于Tcl/Tk，并在[http://wiki.tcl-lang.org/21708](http://wiki.tcl-lang.org/21708)中有描述。基于Pikchr的新语法图首次于2020-09-26登陆主干。
- en: '**(26) The SQL standard requires that a UNIQUE constraint be enforced even
    if one or more of the columns in the constraint are NULL, but SQLite does not
    do this. Isn''t that a bug?**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**(26) SQL标准要求即使约束中的一个或多个列为NULL，也必须强制执行唯一约束，但SQLite不这样做。这难道不是一个bug吗？**'
- en: 'Perhaps you are referring to the following statement from SQL92:'
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 或许您指的是SQL92中的以下声明：
- en: ''
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A unique constraint is satisfied if and only if no two rows in a table have
    the same non-null values in the unique columns.
  id: totrans-173
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 唯一约束条件只有当表中的两行在唯一列中没有相同的非空值时才得到满足。
- en: ''
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'That statement is ambiguous, having at least two possible interpretations:'
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 该语句有歧义，至少有两种可能的解释：
- en: ''
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A unique constraint is satisfied if and only if no two rows in a table have
    the same values and have non-null values in the unique columns.
  id: totrans-177
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 唯一约束条件只有当表中的两行在唯一列中没有相同的值且具有非空值时才得到满足。
- en: A unique constraint is satisfied if and only if no two rows in a table have
    the same values in the subset of unique columns that are not null.
  id: totrans-178
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 唯一约束条件只有当表中的两行在唯一列的非空值子集中没有相同的值时才得到满足。
- en: ''
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SQLite follows interpretation (1), as does PostgreSQL, MySQL, Oracle, and Firebird.
    It is true that Informix and Microsoft SQL Server use interpretation (2), however
    we the SQLite developers hold that interpretation (1) is the most natural reading
    of the requirement and we also want to maximize compatibility with other SQL database
    engines, and most other database engines also go with (1), so that is what SQLite
    does.
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQLite遵循解释（1），与PostgreSQL、MySQL、Oracle和Firebird一样。确实，Informix和Microsoft SQL
    Server使用解释（2），但SQLite开发人员认为解释（1）是对需求最自然的理解，并且我们也希望最大化与其他SQL数据库引擎的兼容性，大多数其他数据库引擎也选择了（1），所以SQLite也是如此。
- en: '**(27) What is the Export Control Classification Number (ECCN) for SQLite?**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**(27) SQLite的出口管制分类编号（ECCN）是什么？**'
- en: After careful review of the Commerce Control List (CCL), we are convinced that
    the core public-domain SQLite source code is not described by any ECCN, hence
    the ECCN should be reported as **EAR99**.
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 经过对商业控制清单（CCL）的仔细审查，我们确信核心公有领域的SQLite源代码没有被任何ECCN描述，因此ECCN应报告为**EAR99**。
- en: ''
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The above is true for the core public-domain SQLite. If you extend SQLite by
    adding new code, or if you statically link SQLite with your application, that
    might change the ECCN in your particular case.
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于核心公有领域的SQLite来说，上述说法是正确的。如果您通过添加新代码扩展了SQLite，或者将SQLite与您的应用程序静态链接，这可能会改变您特定情况下的ECCN。
- en: '**(28) My query does not return the column name that I expect. Is this a bug?**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**(28) 我的查询没有返回我期望的列名。这是一个bug吗？**'
- en: If the columns of your result set are named by AS clauses, then SQLite is guaranteed
    to use the identifier to the right of the AS keyword as the column name. If the
    result set does not use an AS clause, then SQLite is free to name the column anything
    it wants. See the [sqlite3_column_name()](c3ref/column_name.html) documentation
    for further information.
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您的结果集的列由AS子句命名，则SQLite保证使用AS关键字右侧的标识符作为列名。如果结果集没有使用AS子句，则SQLite可以随意命名列。有关更多信息，请参阅[sqlite3_column_name()](c3ref/column_name.html)文档。
- en: '**(29) Where did my database go? (Or: How did my database become empty?)**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**(29) 我的数据库去哪了？（或：我的数据库怎么变空了？）**'
- en: Unless opened with flags to prevent it, a SQLite database is created if it does
    not already exist. Newly created databases are initially empty. This can confuse
    people who inadvertantly open different database files in different contexts,
    due to either a typo in the filename or use of a relative pathname that is used
    with differing current directories for the opening processes.
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除非使用阻止它的标志打开，否则如果不存在，SQLite 数据库将被创建。新创建的数据库最初是空的。这可能会让人困惑，他们在不同的上下文中无意中打开不同的数据库文件，可能是由于文件名拼写错误或者相对路径名与打开过程中不同的当前目录使用有关。
