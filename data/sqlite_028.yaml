- en: 1\. Overview of FTS5
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1\. FTS5概述
- en: 原文：[https://sqlite.com/fts5.html](https://sqlite.com/fts5.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://sqlite.com/fts5.html](https://sqlite.com/fts5.html)
- en: FTS5 is an SQLite [virtual table module](c3ref/module.html) that provides [full-text
    search](https://en.wikipedia.org/wiki/Full_text_search) functionality to database
    applications. In their most elementary form, full-text search engines allow the
    user to efficiently search a large collection of documents for the subset that
    contain one or more instances of a search term. The search functionality provided
    to world wide web users by [Google](https://www.google.com/) is, among other things,
    a full-text search engine, as it allows users to search for all documents on the
    web that contain, for example, the term "fts5".
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: FTS5是SQLite提供给数据库应用程序的一个虚拟表模块，提供[全文搜索](https://en.wikipedia.org/wiki/Full_text_search)功能。在其最基本形式中，全文搜索引擎允许用户高效地搜索大量文档，以找到包含一个或多个搜索词实例的子集。例如，全球网络用户通过[Google](https://www.google.com/)提供的搜索功能，可以搜索包含术语“fts5”的所有网络文档。
- en: 'To use FTS5, the user creates an FTS5 virtual table with one or more columns.
    For example:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用FTS5，用户需要使用一个或多个列创建一个FTS5虚拟表。例如：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It is an error to add types, constraints or [PRIMARY KEY](lang_createtable.html#primkeyconst)
    declarations to a CREATE VIRTUAL TABLE statement used to create an FTS5 table.
    Once created, an FTS5 table may be populated using [INSERT](lang_insert.html),
    [UPDATE](lang_update.html) or [DELETE](lang_delete.html) statements like any other
    table. Like any other table with no PRIMARY KEY declaration, an FTS5 table has
    an implicit INTEGER PRIMARY KEY field named rowid.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在用于创建FTS5表的CREATE VIRTUAL TABLE语句中，添加类型、约束或[主键](lang_createtable.html#primkeyconst)声明是错误的。创建完成后，可以像操作任何其他表一样使用[INSERT](lang_insert.html)、[UPDATE](lang_update.html)或[DELETE](lang_delete.html)语句填充FTS5表。与没有主键声明的任何其他表一样，FTS5表有一个隐式的INTEGER
    PRIMARY KEY字段，名称为rowid。
- en: Not shown in the example above is that there are also [various options](fts5.html#fts5_table_creation_and_initialization)
    that may be provided to FTS5 as part of the CREATE VIRTUAL TABLE statement to
    configure various aspects of the new table. These may be used to modify the way
    in which the FTS5 table extracts terms from documents and queries, to create extra
    indexes on disk to speed up prefix queries, or to create an FTS5 table that acts
    as an index on content stored elsewhere.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 上面示例中未显示的是FTS5还可以提供[各种选项](fts5.html#fts5_table_creation_and_initialization)作为CREATE
    VIRTUAL TABLE语句的一部分，以配置新表的各个方面。这些选项可以用来修改FTS5表从文档和查询中提取术语的方式，创建额外的磁盘索引以加速前缀查询，或者创建一个作为存储在其他位置的内容的索引的FTS5表。
- en: 'Once populated, there are three ways to execute a full-text query against the
    contents of an FTS5 table:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦填充完成，有三种方法可以针对FTS5表的内容执行全文查询：
- en: Using a MATCH operator in the WHERE clause of a SELECT statement, or
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在SELECT语句的WHERE子句中使用MATCH运算符，或
- en: Using an equals ("=") operator in the WHERE clause of a SELECT statement, or
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在SELECT语句的WHERE子句中使用等号（"="）运算符，或
- en: using the [table-valued function](vtab.html#tabfunc2) syntax.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用[table-valued function](vtab.html#tabfunc2)语法。
- en: 'If using the MATCH or = operators, the expression to the left of the MATCH
    operator is usually the name of the FTS5 table (the exception is when [specifying
    a column-filter](fts5.html#fts5_column_filters)). The expression on the right
    must be a text value specifying the term to search for. For the table-valued function
    syntax, the term to search for is specified as the first table argument. For example:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用MATCH或=运算符，MATCH运算符左侧的表达式通常是FTS5表的名称（例外情况是在[指定列过滤器](fts5.html#fts5_column_filters)时）。右侧的表达式必须是指定要搜索的术语的文本值。对于表值函数语法，要搜索的术语被指定为第一个表参数。例如：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'By default, FTS5 full-text searches are case-independent. Like any other SQL
    query that does not contain an ORDER BY clause, the example above returns results
    in an arbitrary order. To sort results by relevance (most to least relevant),
    an ORDER BY may be added to a full-text query as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，FTS5全文搜索是大小写无关的。与不包含ORDER BY子句的任何其他SQL查询一样，上述示例以任意顺序返回结果。要按相关性（最相关到最不相关）对结果进行排序，可以在全文查询中添加ORDER
    BY如下：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As well as the column values and rowid of a matching row, an application may
    use [FTS5 auxiliary functions](fts5.html#_auxiliary_functions_) to retrieve extra
    information regarding the matched row. For example, an auxiliary function may
    be used to retrieve a copy of a column value for a matched row with all instances
    of the matched term surrounded by html <b></b> tags. Auxiliary functions are invoked
    in the same way as SQLite [scalar functions](lang_corefunc.html), except that
    the name of the FTS5 table is specified as the first argument. For example:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 除了匹配行的列值和 rowid 外，应用程序还可以使用 [FTS5 辅助函数](fts5.html#_auxiliary_functions_) 检索关于匹配行的额外信息。例如，可以使用辅助函数检索带有所有匹配术语实例的列值副本的匹配行，这些实例周围有
    html <b></b> 标记。辅助函数的调用方式与 SQLite [标量函数](lang_corefunc.html) 相同，唯一的区别是 FTS5 表名作为第一个参数指定。例如：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A description of the available auxiliary functions, and more details regarding
    configuration of the special "rank" column, are [available below](fts5.html#_auxiliary_functions_).
    [Custom auxiliary functions](fts5.html#custom_auxiliary_functions) may also be
    implemented in C and registered with FTS5, just as custom SQL functions may be
    registered with the SQLite core.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的辅助函数的描述，以及有关配置特殊的“rank”列的更多细节，详见 [下方可获得](fts5.html#_auxiliary_functions_)。可通过在
    C 中实现[自定义辅助函数](fts5.html#custom_auxiliary_functions)，并与 FTS5 注册，方式与自定义 SQL 函数注册
    SQLite 核心相同。
- en: 'As well as searching for all rows that contain a term, FTS5 allows the user
    to search for rows that contain:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 除了搜索包含特定术语的所有行外，FTS5 还允许用户搜索包含以下内容的行：
- en: any terms that begin with a specified prefix,
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以指定前缀开头的任何术语，
- en: '"phrases" - sequences of terms or prefix terms that must feature in a document
    for it to match the query,'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"phrases" - 文档中必须包含的术语或前缀术语的序列，以匹配查询，'
- en: sets of terms, prefix terms or phrases that appear within a specified proximity
    of each other (these are called "NEAR queries"), or
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 出现在指定的接近程度内的术语集合、前缀术语或短语（称为“NEAR 查询”），
- en: boolean combinations of any of the above.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上述任意组合的布尔值。
- en: Such advanced searches are requested by providing a more complicated FTS5 query
    string as the text to the right of the MATCH operator (or = operator, or as the
    first argument to a table-valued function syntax). The full query syntax is [described
    here](fts5.html#full_text_query_syntax).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供更复杂的 FTS5 查询字符串作为 MATCH 运算符右侧的文本（或 = 运算符，或作为表值函数语法的第一个参数），可以请求这些高级搜索。完整的查询语法
    [在此描述](fts5.html#full_text_query_syntax)。
- en: 2\. Compiling and Using FTS5
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2\. 编译和使用 FTS5
- en: 2.1\. Building FTS5 as part of SQLite
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1\. 构建 FTS5 作为 SQLite 的一部分
- en: As of [version 3.9.0](releaselog/3_9_0.html) (2015-10-14), FTS5 is included
    as part of the SQLite [amalgamation](amalgamation.html). If using one of the two
    autoconf build system, FTS5 is enabled by specifying the "--enable-fts5" option
    when running the configure script. (FTS5 is currently disabled by default for
    the source-tree configure script and enabled by default for the amalgamation configure
    script, but these defaults might change in the future.)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 [版本 3.9.0](releaselog/3_9_0.html) (2015-10-14)，FTS5 已作为 SQLite [合并](amalgamation.html)
    的一部分包含。如果使用其中一个 autoconf 构建系统，在运行配置脚本时通过指定“--enable-fts5”选项启用 FTS5。（FTS5 目前对于源树配置脚本默认禁用，对于合并配置脚本默认启用，但这些默认值可能在未来更改。）
- en: Or, if sqlite3.c is compiled using some other build system, by arranging for
    the SQLITE_ENABLE_FTS5 pre-processor symbol to be defined.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果使用其他构建系统编译 sqlite3.c，则通过定义 SQLITE_ENABLE_FTS5 预处理器符号来实现。
- en: 2.2\. Building a Loadable Extension
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2\. 构建可加载扩展
- en: Alternatively, FTS5 may be built as a loadable extension.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以将 FTS5 构建为可加载扩展。
- en: The canonical FTS5 source code consists of a series of *.c and other files in
    the "ext/fts5" directory of the SQLite source tree. A build process reduces this
    to just two files - "fts5.c" and "fts5.h" - which may be used to build an SQLite
    loadable extension.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 规范的 FTS5 源代码包括 SQLite 源树中“ext/fts5”目录中一系列 *.c 和其他文件。构建过程将这些文件减少到仅两个文件 - "fts5.c"
    和 "fts5.h" - 可用于构建 SQLite 可加载扩展。
- en: Obtain the latest SQLite code from fossil.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 fossil 获取最新的 SQLite 代码。
- en: Create a Makefile as described in [How To Compile SQLite](howtocompile.html).
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据 [如何编译SQLite](howtocompile.html) 创建一个 Makefile。
- en: Build the "fts5.c" target. Which also creates fts5.h.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建目标为 "fts5.c"。同时创建 fts5.h。
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The code in "fts5.c" may then be compiled into a loadable extension or statically
    linked into an application as described in [Compiling Loadable Extensions](loadext.html#build).
    There are two entry points defined, both of which do the same thing:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将"fts5.c"中的代码编译为可加载扩展或静态链接到应用程序中，如[编译可加载扩展](loadext.html#build)中所述。定义了两个入口点，它们都执行相同的操作：
- en: sqlite3_fts_init
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: sqlite3_fts_init
- en: sqlite3_fts5_init
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: sqlite3_fts5_init
- en: The other file, "fts5.h", is not required to compile the FTS5 extension. It
    is used by applications that implement [custom FTS5 tokenizers or auxiliary functions](fts5.html#extending_fts5).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个文件"fts5.h"不需要编译FTS5扩展。它由实现[自定义FTS5分词器或辅助函数](fts5.html#extending_fts5)的应用程序使用。
- en: 3\. Full-text Query Syntax
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3\. 全文查询语法
- en: The following block contains a summary of the FTS query syntax in BNF form.
    A detailed explanation follows.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下块以BNF形式总结了FTS查询语法。详细解释随后给出。
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 3.1\. FTS5 Strings
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1\. FTS5字符串
- en: 'Within an FTS expression a **string** may be specified in one of two ways:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在FTS表达式中，**字符串**可以用两种方式指定：
- en: By enclosing it in double quotes ("). Within a string, any embedded double quote
    characters may be escaped SQL-style - by adding a second double-quote character.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过双引号（"）将其括起来。在字符串内，可以通过添加第二个双引号字符来转义任何嵌入的双引号字符SQL样式。
- en: 'As an FTS5 bareword that is not "AND", "OR" or "NOT" (case sensitive). An FTS5
    bareword is a string of one or more consecutive characters that are all either:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为FTS5裸字，不是"AND"、"OR"或"NOT"（区分大小写）。FTS5裸字是一个由一个或多个连续字符组成的字符串，这些字符都是：
- en: Non-ASCII range characters (i.e. unicode codepoints greater than 127), or
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非ASCII范围的字符（即Unicode码点大于127），或
- en: One of the 52 upper and lower case ASCII characters, or
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASCII字符的52个大写和小写字符中的一个，或
- en: One of the 10 decimal digit ASCII characters, or
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十进制数字ASCII字符中的一个，或
- en: The underscore character (unicode codepoint 96).
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下划线字符（Unicode码点96）。
- en: The substitute character (unicode codepoint 26).Strings that include any other
    characters must be quoted. Characters that are not currently allowed in barewords,
    are not quote characters and do not currently serve any special purpose in FTS5
    query expressions may at some point in the future be allowed in barewords or used
    to implement new query functionality. This means that queries that are currently
    syntax errors because they include such a character outside of a quoted string
    may be interpreted differently by some future version of FTS5.
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替代字符（Unicode码点26）。包含任何其他字符的字符串必须加引号。目前在FTS5查询表达式中不允许的裸字中不是引号字符，并且目前没有任何特殊目的的字符可能在将来的某个时候允许用于裸字或用于实现新的查询功能。这意味着目前由于在引号字符串之外包含这样的字符而导致的语法错误的查询可能会被一些未来版本的FTS5解释得不同。
- en: 3.2\. FTS5 Phrases
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2\. FTS5短语
- en: Each string in an fts5 query is parsed ("tokenized") by the [tokenizer](fts5.html#tokenizers)
    and a list of zero or more **tokens**, or terms, extracted. For example, the default
    tokenizer tokenizes the string "alpha beta gamma" to three separate tokens - "alpha",
    "beta" and "gamma" - in that order.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: fts5查询中的每个字符串都由[分词器](fts5.html#tokenizers)解析（“标记化”），并提取零个或多个**标记**或术语。例如，默认分词器将字符串“alpha
    beta gamma”分词为三个单独的标记 - “alpha”，“beta”和“gamma”，依次。
- en: 'FTS queries are made up of **phrases**. A phrase is an ordered list of one
    or more tokens. The tokens from each string in the query each make up a single
    phrase. Two phrases can be concatenated into a single large phrase using the "+"
    operator. For example, assuming the tokenizer module being used tokenizes the
    input "one.two.three" to three separate tokens, the following four queries all
    specify the same phrase:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: FTS查询由**短语**组成。短语是一个包含一个或多个标记的有序列表。查询中的每个字符串的标记都组成一个单独的短语。可以使用“+”运算符将两个短语连接成一个较大的短语。例如，假设使用的分词器模块将输入“one.two.three”分词为三个单独的标记，那么以下四个查询都指定了相同的短语：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A phrase matches a document if the document contains at least one sub-sequence
    of tokens that matches the sequence of tokens that make up the phrase.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文档包含至少一个与构成短语的标记序列匹配的标记子序列，则短语与文档匹配。
- en: 3.3\. FTS5 Prefix Queries
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3\. FTS5前缀查询
- en: If a "*" character follows a string within an FTS expression, then the final
    token extracted from the string is marked as a **prefix token**. As you might
    expect, a prefix token matches any document token of which it is a prefix. For
    example, the first two queries in the following block will match any document
    that contains the token "one" immediately followed by the token "two" and then
    any token that begins with "thr".
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 FTS 表达式中的字符串之后跟随一个 "*" 字符，那么从字符串中提取的最终标记将被标记为**前缀标记**。正如你所预期的那样，前缀标记匹配任何它作为前缀的文档标记。例如，以下代码块中的前两个查询将匹配包含标记"one"紧接着标记"two"并以"thr"开头的任何文档中的标记。
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The final query in the block above may not work as expected. Because the "*"
    character is inside the double-quotes, it will be passed to the tokenizer, which
    will likely discard it (or perhaps, depending on the specific tokenizer in use,
    include it as part of the final token) instead of recognizing it as a special
    FTS character.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以上代码块中的最后一个查询可能不会按预期工作。因为 "*" 字符位于双引号内部，它将被传递给分词器，分词器可能会丢弃它（或者根据使用的具体分词器将其包含为最终标记的一部分），而不是将其识别为特殊的
    FTS 字符。
- en: 3.4\. FTS5 Initial Token Queries
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4\. FTS5 初始标记查询
- en: If a "^" character appears immediately before a phrase that is not part of a
    NEAR query, then that phrase only matches a document only if it starts at the
    first token in a column. The "^" syntax may be combined with a [column filter](fts5.html#fts5_column_filters),
    but may not be inserted into the middle of a phrase.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个 "^" 字符出现在不是 NEAR 查询的短语之前，那么只有该短语仅在列的第一个标记开始时才匹配文档。"^" 语法可以与 [列过滤器](fts5.html#fts5_column_filters)
    结合使用，但不能插入到短语的中间。
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 3.5\. FTS5 NEAR Queries
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5\. FTS5 NEAR 查询
- en: 'Two or more phrases may be grouped into a **NEAR group**. A NEAR group is specified
    by the token "NEAR" (case sensitive) followed by an open parenthesis character,
    followed by two or more whitespace separated phrases, optionally followed by a
    comma and the numeric parameter *N*, followed by a close parenthesis. For example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 两个或更多个短语可以组成**NEAR 组**。NEAR 组由标记"NEAR"（区分大小写）后跟开放括号字符指定，后跟两个或更多个空格分隔的短语，可选地跟随逗号和数字参数
    *N*，然后跟闭括号。例如：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If no *N* parameter is supplied, it defaults to 10\. A NEAR group matches a
    document if the document contains at least one clump of tokens that:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有提供 *N* 参数，则默认为 10\. NEAR 组在一个文档中匹配至少包含一组标记的情况，其中：
- en: contains at least one instance of each phrase, and
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含至少一个短语的实例，并且
- en: for which the number of tokens between the end of the first phrase and the beginning
    of the last phrase in the clump is less than or equal to *N*.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其中第一个短语的结束和最后一个短语的开始之间的标记数量少于或等于 *N*。
- en: 'For example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 3.6\. FTS5 Column Filters
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.6\. FTS5 列过滤器
- en: A single phrase or NEAR group may be restricted to matching text within a specified
    column of the FTS table by prefixing it with the column name followed by a colon
    character. Or to a set of columns by prefixing it with a whitespace separated
    list of column names enclosed in parenthesis ("curly brackets") followed by a
    colon character. Column names may be specified using either of the two forms described
    for strings above. Unlike strings that are part of phrases, column names are not
    passed to the tokenizer module. Column names are case-insensitive in the usual
    way for SQLite column names - upper/lower case equivalence is understood for ASCII-range
    characters only.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 单个短语或 NEAR 组可以通过在 FTS 表的指定列内加上列名后跟随冒号字符来限定其匹配范围。或者通过在括号（"curly brackets"）内包含列名的空格分隔列表后跟随冒号字符来限定一组列。列名可以使用上述描述的两种形式之一指定。与作为短语一部分的字符串不同，列名不会传递给分词器模块。列名对于
    SQLite 列名通常的方式是不区分大小写的 - 仅对 ASCII 范围字符进行大小写等效。
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If a column filter specification is preceded by a "-" character, then it is
    interpreted as a list of column not to match against. For example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列过滤器规范前面有一个 "-" 字符，则解释为不匹配的列列表。例如：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Column filter specifications may also be applied to arbitrary expressions enclosed
    in parenthesis. In this case the column filter applies to all phrases within the
    expression. Nested column filter operations may only further restrict the subset
    of columns matched, they can not be used to re-enable filtered columns. For example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列过滤器规范也可以应用于括号中的任意表达式。在这种情况下，列过滤器适用于表达式中的所有短语。嵌套的列过滤器操作只能进一步限制匹配的列子集，不能用于重新启用被过滤的列。例如：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, a column filter for a single column may be specified by using the
    column name as the LHS of a MATCH operator (instead of the usual table name).
    For example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以通过将列名用作 MATCH 运算符的 LHS 来指定单列的列过滤器（而不是通常的表名）。例如：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 3.7\. FTS5 Boolean Operators
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.7\. FTS5 布尔运算符
- en: 'Phrases and NEAR groups may be arranged into expressions using **boolean operators**.
    In order of precedence, from highest (tightest grouping) to lowest (loosest grouping),
    the operators are:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用**布尔运算符**将短语和 NEAR 组排列成表达式。按优先级从高（最紧密的分组）到低（最松散的分组）的顺序，运算符如下：
- en: '| Operator | Function |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 功能 |'
- en: '| `<query1> NOT <query2>` | Matches if query1 matches and query2 does not match.
    |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `<query1> NOT <query2>` | 如果 query1 匹配且 query2 不匹配，则匹配。 |'
- en: '| `<query1> AND <query2>` | Matches if both query1 and query2 match. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `<query1> AND <query2>` | 如果 query1 和 query2 都匹配，则匹配。 |'
- en: '| `<query1> OR <query2>` | Matches if either query1 or query2 match. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `<query1> OR <query2>` | 如果 query1 或 query2 匹配，则匹配。 |'
- en: 'Parenthesis may be used to group expressions in order to modify operator precedence
    in the usual ways. For example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用括号来分组表达式，以修改操作符的优先级。例如：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Phrases and NEAR groups may also be connected by **implicit AND operators**.
    For simplicity, these are not shown in the BNF grammar above. Essentially, any
    sequence of phrases or NEAR groups (including those restricted to matching specified
    columns) separated only by whitespace are handled as if there were an implicit
    AND operator between each pair of phrases or NEAR groups. Implicit AND operators
    are never inserted after or before an expression enclosed in parenthesis. Implicit
    AND operators group more tightly than all other operators, including NOT. For
    example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 短语和 NEAR 组也可以由**隐式 AND 运算符**连接。为简单起见，在上述 BNF 语法中未显示。基本上，任何由空白分隔的短语或 NEAR 组序列（包括限定匹配指定列的序列）都会被处理为每对短语或
    NEAR 组之间隐式 AND 运算符。在圆括号内的表达式之后或之前不会插入隐式 AND 运算符。隐式 AND 运算符比所有其他运算符（包括 NOT）更紧密地分组。例如：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 4\. FTS5 Table Creation and Initialization
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4\. FTS5 表的创建和初始化
- en: Each argument specified as part of a "CREATE VIRTUAL TABLE ... USING fts5 ..."
    statement is either a column declaration or a configuration option. A **column
    declaration** consists of one or more whitespace separated FTS5 barewords or string
    literals quoted in any manner acceptable to SQLite.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 "CREATE VIRTUAL TABLE ... USING fts5 ..." 语句的一部分指定的每个参数都是列声明或配置选项。**列声明**由一个或多个以空白分隔的
    FTS5 裸字或按 SQLite 可接受的任何方式引用的字符串文字组成。
- en: The first string or bareword in a column declaration is the column name. It
    is an error to attempt to name an fts5 table column "rowid" or "rank", or to assign
    the same name to a column as is used by the table itself. This is not supported.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列声明中的第一个字符串或裸字是列名。试图将 fts5 表列命名为 "rowid" 或 "rank"，或者将列名与表本身使用的相同名称分配给列都是错误的。不支持这样做。
- en: Each subsequent string or bareword in a column declaration is a column option
    that modifies the behaviour of that column. Column options are case-independent.
    Unlike the SQLite core, FTS5 considers unrecognized column options to be errors.
    Currently, the only option recognized is ["UNINDEXED" (see below)](fts5.html#the_unindexed_column_option).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列声明中的每个后续字符串或裸字都是修改该列行为的列选项。列选项不区分大小写。与 SQLite 核心不同，FTS5 将无法识别的列选项视为错误。目前，唯一识别的选项是
    ["UNINDEXED"（见下文）](fts5.html#the_unindexed_column_option)。
- en: 'A **configuration option** consists of an FTS5 bareword - the option name -
    followed by an "=" character, followed by the option value. The option value is
    specified using either a single FTS5 bareword or a string literal, again quoted
    in any manner acceptable to the SQLite core. For example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**配置选项**由一个 FTS5 裸字（选项名）组成，后跟一个 "=" 字符，再跟一个选项值。选项值可以使用单个 FTS5 裸字或字符串文字指定，这些字符串文字可以按照
    SQLite 核心接受的任何方式进行引用。例如：'
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There are currently the following configuration options:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有以下配置选项：
- en: The "tokenize" option, used to configure a [custom tokenizer](fts5.html#tokenizers).
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"tokenize" 选项，用于配置 [自定义分词器](fts5.html#tokenizers)。'
- en: The "prefix" option, used to add [prefix indexes](fts5.html#prefix_indexes)
    to an FTS5 table.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"prefix" 选项，用于向 FTS5 表添加 [前缀索引](fts5.html#prefix_indexes)。'
- en: The "content" option, used to make the FTS5 table an [external content or contentless
    table](fts5.html#external_content_and_contentless_tables).
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"content" 选项，用于使 FTS5 表成为 [外部内容或无内容表](fts5.html#external_content_and_contentless_tables)。'
- en: The "content_rowid" option, used to set the rowid field of an [external content
    table](fts5.html#external_content_tables).
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"content_rowid" 选项，用于设置[外部内容表](fts5.html#external_content_tables)的 rowid 字段。'
- en: The ["columnsize" option](fts5.html#the_columnsize_option), used to configure
    whether or not the size in tokens of each value in the FTS5 table is stored separately
    within the database.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '["columnsize" 选项](fts5.html#the_columnsize_option)，用于配置是否在数据库中单独存储 FTS5 表中每个值的令牌大小。'
- en: The ["detail" option](fts5.html#the_detail_option). This option may be used
    to reduce the size of the FTS index on disk by omitting some information from
    it.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '["detail" 选项](fts5.html#the_detail_option)。此选项可以通过省略一些信息来减小 FTS 索引在磁盘上的大小。'
- en: 4.1\. The UNINDEXED column option
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1\. UNINDEXED 列选项
- en: The contents of columns qualified with the UNINDEXED column option are not added
    to the FTS index. This means that for the purposes of MATCH queries and [FTS5
    auxiliary functions](fts5.html#_auxiliary_functions_), the column contains no
    matchable tokens.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 UNINDEXED 列选项限定的列内容不会添加到 FTS 索引中。这意味着对于 MATCH 查询和[FTS5 辅助函数](fts5.html#_auxiliary_functions_)，该列不包含可匹配的令牌。
- en: 'For example, to avoid adding the contents of the "uuid" field to the FTS index:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了避免将 "uuid" 字段的内容添加到 FTS 索引中：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 4.2\. Prefix Indexes
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2\. 前缀索引
- en: By default, FTS5 maintains a single index recording the location of each token
    instance within the document set. This means that querying for complete tokens
    is fast, as it requires a single lookup, but querying for a prefix token can be
    slow, as it requires a range scan. For example, to query for the prefix token
    "abc*" requires a range scan of all tokens greater than or equal to "abc" and
    less than "abd".
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，FTS5 维护一个单一索引，记录文档集中每个令牌实例的位置。这意味着查询完整令牌很快，因为它只需要一个查找，但查询前缀令牌可能很慢，因为它需要一个范围扫描。例如，查询前缀令牌
    "abc*" 需要对大于或等于 "abc" 且小于 "abd" 的所有令牌进行范围扫描。
- en: A prefix index is a separate index that records the location of all instances
    of prefix tokens of a certain length in characters used to speed up queries for
    prefix tokens. For example, optimizing a query for prefix token "abc*" requires
    a prefix index of three-character prefixes.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀索引是记录特定长度字符中前缀令牌所有实例位置的单独索引，用于加速前缀令牌的查询。例如，优化查询前缀令牌 "abc*" 需要一个三字符前缀索引。
- en: To add prefix indexes to an FTS5 table, the "prefix" option is set to either
    a single positive integer or a text value containing a white-space separated list
    of one or more positive integer values. A prefix index is created for each integer
    specified. If more than one "prefix" option is specified as part of a single CREATE
    VIRTUAL TABLE statement, all apply.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要向 FTS5 表添加前缀索引，将 "prefix" 选项设置为单个正整数或包含一个或多个正整数值的文本值，以空格分隔。每个指定的整数都创建一个前缀索引。如果在单个
    CREATE VIRTUAL TABLE 语句中指定了多个 "prefix" 选项，则全部应用。
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 4.3\. Tokenizers
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3\. 分词器
- en: The CREATE VIRTUAL TABLE "tokenize" option is used to configure the specific
    tokenizer used by the FTS5 table. The option argument must be either an FTS5 bareword,
    or an SQL text literal. The text of the argument is itself treated as a white-space
    series of one or more FTS5 barewords or SQL text literals. The first of these
    is the name of the tokenizer to use. The second and subsequent list elements,
    if they exist, are arguments passed to the tokenizer implementation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: CREATE VIRTUAL TABLE "tokenize" 选项用于配置 FTS5 表使用的特定分词器。选项参数必须是 FTS5 关键字或 SQL
    文本文字。参数的文本本身被视为一个或多个 FTS5 关键字或 SQL 文本文字的空格系列。其中第一个是要使用的分词器的名称。如果存在第二个及更多列表元素，则是传递给分词器实现的参数。
- en: 'Unlike option values and column names, SQL text literals intended as tokenizers
    must be quoted using single quote characters. For example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与选项值和列名不同，作为分词器的 SQL 文本文字必须使用单引号字符引用。例如：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'FTS5 features four built-in tokenizer modules, described in subsequent sections:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: FTS5 具有四个内置的分词器模块，在后续章节中进行描述：
- en: The **unicode61** tokenizer, based on the Unicode 6.1 standard. This is the
    default.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**unicode61** 分词器，基于 Unicode 6.1 标准。这是默认设置。'
- en: The **ascii** tokenizer, which assumes all characters outside of the ASCII codepoint
    range (0-127) are to be treated as token characters.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ascii** 分词器，假设 ASCII 代码点范围（0-127）之外的所有字符都是分词字符。'
- en: The **porter** tokenizer, which implements the [porter stemming algorithm](https://tartarus.org/martin/PorterStemmer).
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**porter** 分词器，实现了[波特词干算法](https://tartarus.org/martin/PorterStemmer)。'
- en: The **trigram** tokenizer, which treats each contiguous sequence of three characters
    as a token, allowing FTS5 to support more general substring matching.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**三元分词**标记器，将每个连续的三个字符序列视为一个标记，从而使 FTS5 能够支持更一般的子字符串匹配。'
- en: It is also possible to create custom tokenizers for FTS5\. The API for doing
    so is [described here](fts5.html#custom_tokenizers).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以为 FTS5 创建自定义标记器。有关如何执行此操作的 API，请参阅[此处](fts5.html#custom_tokenizers)。
- en: 4.3.1\. Unicode61 Tokenizer
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1\. Unicode61 标记器
- en: The unicode tokenizer classifies all unicode characters as either "separator"
    or "token" characters. By default all space and punctuation characters, as defined
    by Unicode 6.1, are considered separators, and all other characters as token characters.
    More specifically, all unicode characters assigned to a [general category](https://en.wikipedia.org/wiki/Unicode_character_property#General_Category)
    beginning with "L" or "N" (letters and numbers, specifically) or to category "Co"
    ("other, private use") are considered tokens. All other characters are separators.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 标记器将所有 Unicode 字符分类为“分隔符”或“标记”字符。默认情况下，根据 Unicode 6.1 的定义，所有空格和标点字符都被视为分隔符，而所有其他字符都被视为标记。具体来说，所有分配给以“L”或“N”（即字母和数字）开头的[通用类别](https://en.wikipedia.org/wiki/Unicode_character_property#General_Category)或类别为“Co”（“其他，私有用途”）的所有
    Unicode 字符都被视为标记。所有其他字符被视为分隔符。
- en: Each contiguous run of one or more token characters is considered to be a token.
    The tokenizer is case-insensitive according to the rules defined by Unicode 6.1.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 每个连续的一个或多个标记字符的运行被视为一个标记。标记器是根据 Unicode 6.1 中定义的规则不区分大小写的。
- en: By default, diacritics are removed from all Latin script characters. This means,
    for example, that "A", "a", "À", "à", "Â" and "â" are all considered to be equivalent.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有拉丁文字符的变音符号都将被移除。这意味着，例如，“A”、“a”、“À”、“à”、“Â”和“â”都被视为等效。
- en: 'Any arguments following "unicode61" in the token specification are treated
    as a list of alternating option names and values. Unicode61 supports the following
    options:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在标记规范中的“unicode61”后的任何参数都被视为一组交替的选项名称和值的列表。Unicode61 支持以下选项：
- en: '| Option | Usage |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 用法 |'
- en: '| remove_diacritics | This option should be set to "0", "1" or "2". The default
    value is "1". If it is set to "1" or "2", then diacritics are removed from Latin
    script characters as described above. However, if it is set to "1", then diacritics
    are not removed in the fairly uncommon case where a single unicode codepoint is
    used to represent a character with more that one diacritic. For example, diacritics
    are not removed from codepoint 0x1ED9 ("LATIN SMALL LETTER O WITH CIRCUMFLEX AND
    DOT BELOW"). This is technically a bug, but cannot be fixed without creating backwards
    compatibility problems. If this option is set to "2", then diacritics are correctly
    removed from all Latin characters. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| remove_diacritics | 此选项应设置为 "0"、"1" 或 "2"。默认值为 "1"。如果设置为 "1" 或 "2"，则从上述描述的拉丁文字符中删除变音符号。但是，如果设置为
    "1"，则在表示带有超过一个变音符号的字符的单个 Unicode 代码点的相当罕见的情况下，不会移除变音符号。例如，不会从代码点 0x1ED9（“LATIN
    SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW”）中移除变音符号。这在技术上是一个错误，但无法修复而不会产生向后兼容性问题。如果此选项设置为
    "2"，则所有拉丁文字符的变音符号将被正确地移除。'
- en: '| categories | This option may be used to modify the set of Unicode general
    categories that are considered to correspond to token characters. The argument
    must consist of a space separated list of two-character general category abbreviations
    (e.g. "Lu" or "Nd"), or of the same with the second character replaced with an
    asterisk ("*"), interpreted as a glob pattern. The default value is "L* N* Co".
    |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| categories | 此选项可用于修改应视为对应标记字符的 Unicode 通用类别的集合。参数必须由一个以空格分隔的两字符通用类别缩写列表（例如，“Lu”或“Nd”），或者带有第二个字符替换为星号（“*”）的相同字符串（解释为
    glob 模式）组成。默认值为 "L* N* Co"。'
- en: '| tokenchars | This option is used to specify additional unicode characters
    that should be considered token characters, even if they are white-space or punctuation
    characters according to Unicode 6.1\. All characters in the string that this option
    is set to are considered token characters. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| tokenchars | 此选项用于指定应将其视为标记字符的其他 Unicode 字符，即使它们根据 Unicode 6.1 中的定义是空格或标点字符。将设置为此选项的字符串中的所有字符都被视为标记字符。'
- en: '| separators | This option is used to specify additional unicode characters
    that should be considered as separator characters, even if they are token characters
    according to Unicode 6.1\. All characters in the string that this option is set
    to are considered separators. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 分隔符 | 此选项用于指定应将其视为分隔符的其他 Unicode 字符，即使根据 Unicode 6.1，它们也是标记字符。将此选项设置为的字符串中的所有字符都被视为分隔符。
    |'
- en: 'For example:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'or:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 或：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The fts5 unicode61 tokenizer is byte-for-byte compatible with the fts3/4 unicode61
    tokenizer.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: fts5 unicode61 分词器与 fts3/4 unicode61 分词器完全兼容。
- en: 4.3.2\. Ascii Tokenizer
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2\. Ascii 分词器
- en: 'The Ascii tokenizer is similar to the Unicode61 tokenizer, except that:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Ascii 分词器类似于 Unicode61 分词器，但有一点不同：
- en: All non-ASCII characters (those with codepoints greater than 127) are always
    considered token characters. If any non-ASCII characters are specified as part
    of the separators option, they are ignored.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有非 ASCII 字符（代码点大于 127 的字符）始终被视为标记字符。如果将任何非 ASCII 字符指定为分隔符选项的一部分，则它们将被忽略。
- en: Case-folding is only performed for ASCII characters. So while "A" and "a" are
    considered to be equivalent, "Ã" and "ã" are distinct.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅对 ASCII 字符执行大小写折叠。因此，“A” 和 “a” 被视为等效，而 “Ã” 和 “ã” 是不同的。
- en: The remove_diacritics option is not supported.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持 remove_diacritics 选项。
- en: 'For example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 4.3.3\. Porter Tokenizer
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.3\. Porter 分词器
- en: The porter tokenizer is a wrapper tokenizer. It takes the output of some other
    tokenizer and applies the [porter stemming algorithm](https://tartarus.org/martin/PorterStemmer/)
    to each token before it returns it to FTS5\. This allows search terms like "correction"
    to match similar words such as "corrected" or "correcting". The porter stemmer
    algorithm is designed for use with English language terms only - using it with
    other languages may or may not improve search utility.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: porter 分词器是一个包装器分词器。它将其他分词器的输出作为输入，并在将其返回到 FTS5 之前对每个标记应用 [porter 词干提取算法](https://tartarus.org/martin/PorterStemmer/)。这允许搜索术语如
    “correction” 匹配类似词如 “corrected” 或 “correcting”。porter 词干提取算法仅设计用于英语术语 - 在其他语言中使用它可能或可能不会提高搜索效用。
- en: 'By default, the porter tokenizer operates as a wrapper around the default tokenizer
    (unicode61). Or, if one or more extra arguments are added to the "tokenize" option
    following "porter", they are treated as a specification for the underlying tokenizer
    that the porter stemmer uses. For example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，porter 分词器作为默认分词器（unicode61）的包装器运行。或者，如果在 "porter" 后面的 "tokenize" 选项中添加了一个或多个额外参数，则它们将被视为
    porter 词干提取器使用的基础分词器的规范。例如：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 4.3.4\. The Trigram Tokenizer
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.4\. 三元分词器
- en: 'The trigram tokenizer extends FTS5 to support substring matching in general,
    instead of the usual token matching. When using the trigram tokenizer, a query
    or phrase token may match any sequence of characters within a row, not just a
    complete token. For example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 三元分词器扩展了 FTS5 以支持一般的子字符串匹配，而不是仅限于标记匹配。使用三元分词器时，查询或短语标记可以匹配行内的任何字符序列，而不仅仅是完整的标记。例如：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The trigram tokenizer supports the following options:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 三元分词器支持以下选项：
- en: '| Option | Usage |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 用法 |'
- en: '| case_sensitive | This value may be set to 1 or 0 (the default). If it is
    set to 1, then matching is case sensitive. Otherwise, if this option is set to
    0, matching is case insensitive. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| case_sensitive | 此值可以设置为 1 或 0（默认值）。如果设置为 1，则匹配区分大小写。否则，如果此选项设置为 0，则匹配不区分大小写。
    |'
- en: '| remove_diacritics | This value may also be set to 1 or 0 (the default). It
    may only be set to 1 if the case_sensitive options is set to 0 - setting both
    options to 1 is an error. If this option is set, then diacritics are removed from
    the text before matching (e.g. so that "á" matches "a"). |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| remove_diacritics | 此值也可以设置为 1 或 0（默认值）。仅当 case_sensitive 选项设置为 0 时，才可以将其设置为
    1 - 将这两个选项都设置为 1 是错误的。如果设置了此选项，则在匹配之前会从文本中删除变音符号（例如，“á” 匹配 “a”）。 |'
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Unless the remove_diacritics option is set, FTS5 tables that use the trigram
    tokenizer also support indexed GLOB and LIKE pattern matching. For example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 除非设置了 remove_diacritics 选项，否则使用三元分词器的 FTS5 表还支持索引化的 GLOB 和 LIKE 模式匹配。例如：
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If an FTS5 trigram tokenizer is created with the case_sensitive option set to
    1, it may only index GLOB queries, not LIKE.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 case_sensitive 选项将 FTS5 三元分词器创建为 1，则仅可以索引 GLOB 查询，而不是 LIKE。
- en: 'Notes:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：
- en: Substrings consisting of fewer than 3 unicode characters do not match any rows
    when used with a full-text query. If a LIKE or GLOB pattern does not contain at
    least one sequence of non-wildcard unicode characters, FTS5 falls back to a linear
    scan of the entire table.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用少于 3 个 Unicode 字符的子字符串进行全文查询时不会匹配任何行。如果 LIKE 或 GLOB 模式不包含至少一个非通配符 Unicode
    字符的序列，FTS5 会回退到对整个表的线性扫描。
- en: If the FTS5 table is created with the detail=none or detail=column option specified,
    full-text queries may not contain any tokens longer than 3 unicode characters.
    LIKE and GLOB pattern matching may be slightly slower, but still works. If the
    index is to be used only for LIKE and/or GLOB pattern matching, these options
    are worth experimenting with to reduce the index size.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用 detail=none 或 detail=column 选项创建 FTS5 表，全文查询可能不包含超过 3 个 Unicode 字符长的任何标记。LIKE
    和 GLOB 模式匹配可能稍慢，但仍可正常工作。如果索引仅用于 LIKE 和/或 GLOB 模式匹配，这些选项值得尝试，以减少索引大小。
- en: The index cannot be used to optimize LIKE patterns if the LIKE operator has
    an ESCAPE clause.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 LIKE 操作符带有 ESCAPE 子句，则索引不能用于优化 LIKE 模式。
- en: 4.4\. External Content and Contentless Tables
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4\. 外部内容和内容为空的表
- en: Normally, when a row is inserted into an FTS5 table, in addition to building
    the index, FTS5 makes a copy of the original row content. When column values are
    requested from the FTS5 table by the user or by an auxiliary function implementation,
    those values are read from that private copy of the content. The "content" option
    may be used to create an FTS5 table that stores only FTS full-text index entries.
    Because the column values themselves are usually much larger than the associated
    full-text index entries, this can save significant database space.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，向 FTS5 表插入行时，除了构建索引外，FTS5 还会复制原始行内容的副本。当用户或辅助函数实现从 FTS5 表请求列值时，这些值是从该私有内容的副本中读取的。可以使用
    "content" 选项创建仅存储 FTS 全文索引条目的 FTS5 表。因为列值本身通常比相关的全文索引条目要大得多，所以这可以节省显著的数据库空间。
- en: 'There are two ways to use the "content" option:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以使用 "content" 选项：
- en: By setting it to an empty string to create a contentless FTS5 table. In this
    case FTS5 assumes that the original column values are unavailable to it when processing
    queries. Full-text queries and some auxiliary functions can still be used, but
    no column values apart from the rowid may be read from the table.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其设置为空字符串以创建内容为空的 FTS5 表。在这种情况下，FTS5 假设在处理查询时原始列值对其不可用。仍可使用全文查询和一些辅助函数，但不能从表中读取除
    rowid 外的任何列值。
- en: By setting it to the name of a database object (table, virtual table or view)
    that may be queried by FTS5 at any time to retrieve the column values. This is
    known as an "external content" table. In this case all FTS5 functionality may
    be used, but it is the responsibility of the user to ensure that the contents
    of the full-text index are consistent with the named database object. If they
    are not, query results may be unpredictable.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其设置为数据库对象（表、虚拟表或视图）的名称，FTS5 随时可以查询以检索列值。这被称为 "外部内容" 表。在这种情况下，可以使用所有 FTS5 功能，但用户有责任确保全文索引的内容与命名的数据库对象一致。如果不一致，查询结果可能是不可预测的。
- en: 4.4.1\. Contentless Tables
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.1\. 内容为空的表
- en: 'A contentless FTS5 table is created by setting the "content" option to an empty
    string. For example:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个内容为空的 FTS5 表，只需将 "content" 选项设置为空字符串即可。例如：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Contentless FTS5 tables do not support UPDATE or DELETE statements, or INSERT
    statements that do not supply a non-NULL value for the rowid field. Contentless
    tables do not support REPLACE conflict handling. REPLACE and INSERT OR REPLACE
    statements are treated as regular INSERT statements. Rows may be deleted from
    a contentless table using an [FTS5 delete command](fts5.html#the_delete_command).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 内容为空的 FTS5 表不支持 UPDATE 或 DELETE 语句，也不支持未为 rowid 字段提供非 NULL 值的 INSERT 语句。内容为空的表不支持
    REPLACE 冲突处理。REPLACE 和 INSERT OR REPLACE 语句被视为常规 INSERT 语句处理。可以使用 [FTS5 delete
    command](fts5.html#the_delete_command) 从内容为空的表中删除行。
- en: Attempting to read any column value except the rowid from a contentless FTS5
    table returns an SQL NULL value.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试从内容为空的 FTS5 表中读取除 rowid 以外的任何列值都会返回 SQL NULL 值。
- en: 4.4.2\. Contentless-Delete Tables
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.2\. 内容为空删除表
- en: 'As of version 3.43.0, also available are contentless-delete tables. A contentless-delete
    table is created by setting the content option to an empty string and also setting
    the contentless_delete option to 1\. For example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本 3.43.0 起，还可使用无内容删除表。通过将内容选项设置为空字符串并同时将 contentless_delete 选项设置为 1 创建无内容删除表。例如：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A contentless-delete table differs from a contentless table in that:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 无内容删除表与无内容表的区别在于：
- en: Contentless-delete tables support both DELETE and "INSERT OR REPLACE INTO" statements.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Contentless-delete 表支持 DELETE 和 "INSERT OR REPLACE INTO" 语句。
- en: Contentless-delete tables support UPDATE statements, but only if new values
    are supplied for all user-defined columns of the fts5 table.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Contentless-delete 表支持 UPDATE 语句，但仅当为 fts5 表的所有用户定义列提供新值时。
- en: Contentless-delete tables do **not** support the [FTS5 delete command](fts5.html#the_delete_command).
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Contentless-delete 表**不**支持 [FTS5 delete 命令](fts5.html#the_delete_command)。
- en: '[PRE30]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Unless backwards compatibility is required, new code should prefer contentless-delete
    tables to contentless tables.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 除非需要向后兼容性，新代码应优先选择无内容删除表而不是无内容表。
- en: 4.4.3\. External Content Tables
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.3\. 外部内容表
- en: 'An external content FTS5 table is created by setting the content option to
    the name of a table, virtual table or view (hereafter the "content table") within
    the same database. Whenever column values are required by FTS5, it queries the
    content table as follows, with the rowid of the row for which values are required
    bound to the SQL variable:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将内容选项设置为同一数据库中的表、虚拟表或视图的名称（以下简称"内容表"），可以创建外部内容 FTS5 表。每当 FTS5 需要列值时，它按以下方式查询内容表，其中所需值的行
    ID 绑定到 SQL 变量：
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the above, <content> is replaced by the name of the content table. By default,
    <content_rowid> is replaced by the literal text "rowid". Or, if the "content_rowid"
    option is set within the CREATE VIRTUAL TABLE statement, by the value of that
    option. <cols> is replaced by a comma-separated list of the FTS5 table column
    names. For example:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述中，<content> 被内容表的名称替换。默认情况下，<content_rowid> 被文本字面值 "rowid" 替换。或者，如果在 CREATE
    VIRTUAL TABLE 语句中设置了 "content_rowid" 选项，则由该选项的值替换。<cols> 被逗号分隔的 FTS5 表列名替换。例如：
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The content table may also be queried as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以按以下方式查询内容表：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It is still the responsibility of the user to ensure that the contents of an
    external content FTS5 table are kept up to date with the content table. One way
    to do this is with triggers. For example:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然由用户负责确保外部内容 FTS5 表的内容与内容表保持同步。一种方法是使用触发器。例如：
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Like contentless tables, external content tables do not support REPLACE conflict
    handling. Any operations that specify REPLACE conflict handling are handled using
    ABORT.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 类似无内容删除表，外部内容表不支持 REPLACE 冲突处理。任何指定 REPLACE 冲突处理的操作都使用 ABORT 处理。
- en: 4.4.4\. External Content Table Pitfalls
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.4\. 外部内容表的陷阱
- en: It is the responsibility of the user to ensure that an FTS5 external content
    table (one with a non-empty content= option) is kept consistent with the content
    table itself (the table named by the content= option). If these are allowed to
    become inconsistent, then the results of queries against the FTS5 table may become
    unintuitive and appear inconsistent.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 用户有责任确保 FTS5 外部内容表（具有非空内容选项的表）与内容表本身保持一致（由内容选项指定的表）。如果允许它们变得不一致，则对 FTS5 表的查询结果可能会变得不直观且看似不一致。
- en: 'In these situations, the apparently inconsistent results produced by queries
    against the FTS5 external content table may be understood as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，针对 FTS5 外部内容表的查询产生的表面上不一致的结果可以理解如下：
- en: If the query does not use the full-text index - does not contain a MATCH operator
    or equivalent table-valued function syntax - then the query is effectively passed
    through to the external content table. In this case the contents of the FTS index
    have no effect on the results of the query.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果查询不使用全文索引 - 不包含 MATCH 操作符或等效的表值函数语法 - 则查询有效地传递给外部内容表。在这种情况下，FTS 索引的内容对查询结果没有影响。
- en: 'If the query does use the full text index, then the FTS5 module queries it
    for the set of rowid values corresponding to documents that match the query. For
    each such rowid, it then runs a query similar to the following to retrieve any
    required column values, where ''?'' is replaced by the rowid value, and <content>
    and <content_rowid> by the values specified for the content= and content_rowid=
    options:'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果查询确实使用全文索引，则 FTS5 模块将查询与查询匹配的文档对应的 rowid 值集合。对于每个这样的 rowid，然后运行类似以下的查询来检索任何所需的列值，其中
    '?' 被 rowid 值替换，<content> 和 <content_rowid> 被指定为 content= 和 content_rowid= 选项的值：
- en: '[PRE35]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'For example, if a database is created using the following script:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果使用以下脚本创建数据库：
- en: '[PRE36]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'then the content table contains two rows, but the FTS index contains no entries
    corresponding to them. In this case the following queries will return inconsistent
    results as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 那么内容表包含两行，但是 FTS 索引不包含与它们对应的任何条目。在这种情况下，以下查询将返回不一致的结果如下：
- en: '[PRE37]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Alternatively, if the database were created and populated as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果数据库是按以下方式创建和填充的：
- en: '[PRE38]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'then the content table is empty, but the FTS index contains entries for 6 different
    tokens. In this case the following queries will return inconsistent results as
    follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 那么内容表是空的，但是 FTS 索引包含了 6 个不同标记的条目。在这种情况下，以下查询将返回不一致的结果如下：
- en: '[PRE39]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As described in the previous section, triggers on the content table are a good
    way to ensure that an FTS5 external content table is kept consistent. However,
    triggers are only fired when rows are inserted, updated or deleted in the content
    table. This means that if, for example, a database is created as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所述，对内容表的触发器是确保 FTS5 外部内容表保持一致的良好方法。然而，触发器仅在内容表中插入、更新或删除行时触发。这意味着，例如，如果数据库是按以下方式创建的：
- en: '[PRE40]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: then the content table and external content FTS5 table are inconsistent, as
    creating the triggers does not copy existing rows from the content table into
    the FTS index. The triggers are only able to ensure that updates made to the content
    table after they are created are reflected in the FTS index.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 那么内容表和外部内容 FTS5 表不一致，因为创建触发器不会将内容表中的现有行复制到 FTS 索引中。触发器只能确保创建后对内容表进行的更新会反映在 FTS
    索引中。
- en: In this, and any other situation where the FTS index and its content table have
    become inconsistent, the ['rebuild'](#the_rebuild_command) command may be used
    to completely discard the contents of the FTS index and rebuild it based on the
    current contents of the content table.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在此以及任何 FTS 索引和其内容表不一致的情况下，可以使用 ['rebuild'](#the_rebuild_command) 命令完全丢弃 FTS
    索引的内容，并基于内容表的当前内容重建它。
- en: 4.5\. The Columnsize Option
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5\. `columnsize` 选项
- en: Normally, FTS5 maintains a special backing table within the database that stores
    the size of each column value in tokens inserted into the main FTS5 table in a
    separate table. This backing table is used by the [xColumnSize](#xColumnSize)
    API function, which is in turn used by the built-in [bm25 ranking function](fts5.html#the_bm25_function)
    (and is likely to be useful to other ranking functions as well).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，FTS5 在数据库中维护一个特殊的后备表，该表存储插入到主 FTS5 表中的每个列值的令牌大小。这个后备表被 [xColumnSize](#xColumnSize)
    API 函数使用，后者又被内置的 [bm25 ranking function](fts5.html#the_bm25_function) 使用（并且可能对其他排名函数也有用）。
- en: 'In order to save space, this backing table may be omitted by setting the columnsize
    option to zero. For example:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省空间，可以通过将 columnsize 选项设置为零来省略此后备表。例如：
- en: '[PRE41]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: It is an error to set the columnsize option to any value other than 0 or 1.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 `columnsize` 选项为除 `0` 或 `1` 以外的任何值都是错误的。
- en: If an FTS5 table is configured with columnsize=0 but is not a [contentless table](fts5.html#contentless_tables),
    the xColumnSize API function still works, but runs much more slowly. In this case,
    instead of reading the value to return directly from the database, it reads the
    text value itself and count the tokens within it on demand.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果配置了 columnsize=0 的 FTS5 表，但它不是[无内容表](fts5.html#contentless_tables)，则 xColumnSize
    API 函数仍然有效，但运行速度要慢得多。在这种情况下，它不是直接从数据库读取返回值，而是根据需要读取文本值本身，并计算其中的令牌数。
- en: 'Or, if the table is also a [contentless table](fts5.html#contentless_tables),
    then the following apply:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果表也是[无内容表](fts5.html#contentless_tables)，则适用以下规定：
- en: The xColumnSize API always returns -1\. There is no way to determine the number
    of tokens in a value stored within a contentless FTS5 table configured with columnsize=0.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: xColumnSize API 总是返回 -1。无法确定配置为 columnsize=0 的内容为空的 FTS5 表中存储的值中有多少个令牌。
- en: Each inserted row must be accompanied by an explicitly specified rowid value.
    If a contentless table is configured with columnsize=0, attempting to insert a
    NULL value into the rowid is an SQLITE_MISMATCH error.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每插入一行必须伴随显式指定的行号值。如果尝试将 NULL 值插入到列大小为 0 的内容为空的表格的行号中，则会出现 SQLITE_MISMATCH 错误。
- en: All queries on the table must be full-text queries. In other words, they must
    use the MATCH or = operator with the table-name column as the left-hand operand,
    or else use the table-valued function syntax. Any query that is not a full-text
    query results in an error.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表上的所有查询必须是全文查询。换句话说，它们必须使用 MATCH 或 = 运算符，并以表名列作为左操作数，否则使用表值函数语法。任何不是全文查询的查询都会导致错误。
- en: The name of the table in which the xColumnSize values are stored (unless columnsize=0
    is specified) is "<name>_docsize", where <name> is the name of the FTS5 table
    itself. The [sqlite3_analyzer](https://www.sqlite.org/download.html) tool may
    be used on an existing database in order to determine how much space might be
    saved by recreating an FTS5 table using columnsize=0.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: xColumnSize 值存储的表的名称（除非指定了 columnsize=0）为 "<name>_docsize"，其中 <name> 是 FTS5
    表的名称本身。可以在现有数据库上使用 [sqlite3_analyzer](https://www.sqlite.org/download.html) 工具来确定通过使用
    columnsize=0 重新创建 FTS5 表可以节省多少空间。
- en: 4.6\. The Detail Option
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6\. 详细选项
- en: For each term in a document, the FTS index maintained by FTS5 stores the rowid
    of the document, the column number of the column that contains the term and the
    offset of the term within the column value. The "detail" option may be used to
    omit some of this information. This reduces the space that the index consumes
    within the database file, but also reduces the capability and efficiency of the
    system.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文档中的每个术语，由 FTS5 维护的 FTS 索引存储文档的行号，包含术语的列号以及术语在列值中的偏移量。"详细" 选项可用于省略部分信息。这减少了索引在数据库文件中占用的空间，但也降低了系统的功能和效率。
- en: 'The detail option may be set to "full" (the default value), "column" or "none".
    For example:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 详细选项可以设置为 "full"（默认值），"column" 或 "none"。例如：
- en: '[PRE42]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If the detail option is set to **column**, then for each term the FTS index
    records the rowid and column number only, omitting the term offset information.
    This results in the following restrictions:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果详细选项设置为 **column**，那么对于每个术语，FTS 索引仅记录行号和列号，省略了术语偏移信息。这导致以下限制：
- en: NEAR queries are not available.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NEAR 查询不可用。
- en: Phrase queries are not available.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 短语查询不可用。
- en: Assuming the table is not also a [contentless table](fts5.html#contentless_tables),
    the [xInstCount](#xInstCount), [xInst](#xInst), [xPhraseFirst](#xPhraseFirst)
    and [xPhraseNext](#xPhraseNext) are slower than usual. This is because instead
    of reading the required data directly from the FTS index they have to load and
    tokenize the document text on demand.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设表格不是内容为空的 [表格](fts5.html#contentless_tables)，[xInstCount](#xInstCount)、[xInst](#xInst)、[xPhraseFirst](#xPhraseFirst)
    和 [xPhraseNext](#xPhraseNext) 的速度比平常慢。这是因为它们不直接从 FTS 索引中读取所需数据，而是按需加载和标记化文档文本。
- en: If the table is also a contentless table, the xInstCount, xInst, xPhraseFirst
    and xPhraseNext APIs behave as if the current row contains no phrase matches at
    all (i.e. xInstCount() returns 0).
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果表格也是内容为空的表格，xInstCount、xInst、xPhraseFirst 和 xPhraseNext API 的行为就像当前行根本没有短语匹配一样（即
    xInstCount() 返回 0）。
- en: 'If the detail option is set to **none**, then for each term the FTS index records
    just the rowid is stored. Both column and offset information are omitted. As well
    as the restrictions itemized above for detail=column mode, this imposes the following
    extra limitations:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果详细选项设置为 **none**，那么对于每个术语，FTS 索引仅记录行号，列号和偏移信息都被省略。除了详细=column 模式的上述限制外，还增加以下额外限制：
- en: Column filter queries are not available.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列过滤查询不可用。
- en: Assuming the table is not also a contentless table, the [xPhraseFirstColumn](#xPhraseFirstColumn)
    and [xPhraseNextColumn](#xPhraseNextColumn) are slower than usual.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设表格不是内容为空的表格，[xPhraseFirstColumn](#xPhraseFirstColumn) 和 [xPhraseNextColumn](#xPhraseNextColumn)
    的速度比平常慢。
- en: If the table is also a contentless table, the xPhraseFirstColumn and xPhraseNextColumn
    APIs behave as if the current row contains no phrase matches at all (i.e. xPhraseFirstColumn()
    sets the iterator to EOF).
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果表格也是一个无内容的表格，那么 xPhraseFirstColumn 和 xPhraseNextColumn API 的行为就像当前行根本没有短语匹配一样（即
    xPhraseFirstColumn() 将迭代器设置为 EOF）。
- en: In one test that indexed a large set of emails (1636 MiB on disk), the FTS index
    was 743 MiB on disk with detail=full, 340 MiB with detail=column and 134 MiB with
    detail=none.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个测试中，对一组大量电子邮件进行索引（磁盘上的 1636 MiB），FTS 索引为 743 MiB（detail=full）、340 MiB（detail=column）和
    134 MiB（detail=none）。
- en: 4.7\. The Tokendata Option
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.7\. The Tokendata Option
- en: This option is only useful to applications that implement [custom tokenizers](#custom_tokenizers).
    Usually, tokenizers may return tokens that consist of any sequence of bytes, including
    0x00 bytes. However, if the table specifies the tokendata=1 option, then fts5
    ignores the first 0x00 byte and any trailing data in the token for the purposes
    of matching. It still stores the entire token as returned by the tokenizer, but
    it is ignored by the fts5 core.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项仅对实现[自定义分词器](#custom_tokenizers)的应用程序有用。通常，分词器可以返回由任意字节序列组成的标记，包括 0x00 字节。但是，如果表格指定了
    tokendata=1 选项，那么 fts5 将忽略标记中的第一个 0x00 字节和任何尾随数据以进行匹配。它仍然按照分词器返回的整个标记进行存储，但 fts5
    核心将其忽略。
- en: The full version of the token, including any 0x00 byte and trailing data, is
    available to [custom auxiliary functions](#custom_auxiliary_functions) via the
    [xQueryToken](#xQueryToken) and [xInstToken](#xInstToken) APIs.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 完整版本的标记，包括任何 0x00 字节和尾随数据，可以通过[xQueryToken](#xQueryToken)和[xInstToken](#xInstToken)
    API提供给[自定义辅助函数](#custom_auxiliary_functions)使用。
- en: This may be useful for ranking functions. A custom tokenizer may add extra data
    to some document tokens allowing a ranking function to give more weight to hits
    of some tokens (e.g. those in document headings).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能对排名函数很有用。自定义分词器可以向一些文档标记添加额外的数据，允许排名函数给某些标记的击中增加权重（例如，那些在文档标题中的标记）。
- en: Alternatively, the combination of a custom tokenizer and a custom auxiliary
    function may be used to implement [asymmetric search](https://www.unicode.org/reports/tr10/tr10-41.html#Asymmetric_Search).
    The tokenizer could (say) for each document token return the case-normalized and
    unmarked version of the token, followed by an 0x00 byte, followed by the full
    text of the token from the document. When queried, fts5 would provide results
    as if all characters in the query were case-normalized and unmarked. The custom
    auxiliary function could then be used in the WHERE clause of the query to filter
    out any rows that do not match based on secondary or tertiary markings in the
    document or query terms.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以使用自定义分词器和自定义辅助函数的组合来实现[非对称搜索](https://www.unicode.org/reports/tr10/tr10-41.html#Asymmetric_Search)。分词器可以（比如）针对每个文档标记返回标准化的且未标记的版本，后跟一个
    0x00 字节，再跟文档中标记的完整文本。当进行查询时，fts5 将根据查询中的所有字符都进行标准化和未标记化的处理来提供结果。然后可以在查询的 WHERE
    子句中使用自定义辅助函数来基于文档或查询术语中的次要或三级标记来过滤不匹配的行。
- en: 5\. Auxiliary Functions
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5\. 辅助函数
- en: Auxiliary functions are similar to [SQL scalar functions](lang_corefunc.html),
    except that they may only be used within full-text queries (those that use the
    MATCH operator, or LIKE/GLOB with the trigram tokenizer) on an FTS5 table. Their
    results are calculated based not only on the arguments passed to them, but also
    on the current match and matched row. For example, an auxiliary function may return
    a numeric value indicating the accuracy of the match (see the [bm25()](fts5.html#the_bm25_function)
    function), or a fragment of text from the matched row that contains one or more
    instances of the search terms (see the [snippet()](fts5.html#the_snippet_function)
    function).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助函数类似于[SQL 标量函数](lang_corefunc.html)，但它们只能在全文查询中使用（使用 MATCH 运算符的查询或使用 trigram
    分词器的 LIKE/GLOB 查询）的 FTS5 表中使用。它们的结果不仅基于传递给它们的参数，还基于当前匹配和匹配的行。例如，辅助函数可以返回指示匹配准确度的数值（参见[bm25()](fts5.html#the_bm25_function)函数），或者匹配行中包含一个或多个搜索术语实例的文本片段（参见[snippet()](fts5.html#the_snippet_function)函数）。
- en: 'To invoke an auxiliary function, the name of the FTS5 table should be specified
    as the first argument. Other arguments may follow the first, depending on the
    specific auxiliary function being invoked. For example, to invoke the "highlight"
    function:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用辅助函数，应将 FTS5 表的名称指定为第一个参数。根据具体调用的辅助函数，可能会跟随第一个参数的其他参数。例如，要调用 "highlight"
    函数：
- en: '[PRE43]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The built-in auxiliary functions provided as part of FTS5 are described in the
    following section. Applications may also implement [custom auxiliary functions
    in C](fts5.html#custom_auxiliary_functions).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: FTS5 提供了以下部分描述的内置辅助函数。应用程序也可以在 [C 中实现自定义辅助函数](fts5.html#custom_auxiliary_functions)。
- en: 5.1\. Built-in Auxiliary Functions
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1\. 内置辅助函数
- en: 'FTS5 provides three built-in auxiliary functions:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: FTS5 提供了三个内置辅助函数：
- en: The [bm25() auxiliary function](fts5.html#the_bm25_function) returns a real
    value reflecting the accuracy of the current match. Better matches are assigned
    numerically lower values.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[bm25() 辅助函数](fts5.html#the_bm25_function) 返回一个实数值，反映当前匹配的准确度。匹配越好，分配的数值越低。'
- en: The [highlight() auxiliary function](fts5.html#the_highlight_function) returns
    a copy of the text from one of the columns of the current match with each instance
    of a queried term within the result surrounded by specified markup (for example
    "<b>" and "</b>").
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[highlight() 辅助函数](fts5.html#the_highlight_function) 返回当前匹配中一列文本的副本，其中每个查询词条实例都被指定的标记包围（例如
    "<b>" 和 "</b>"）。'
- en: The [snippet() auxiliary function](fts5.html#the_snippet_function) selects a
    short fragment of text from one of the columns of the matched row and returns
    it with each instance of a queried term surrounded by markup in the same manner
    as the highlight() function. The fragment of text is selected so as to maximize
    the number of distinct queried terms it contains. Higher weight is given to snippets
    that occur at the start of a column value, or that immediately follow "." or ":"
    characters in the text.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[snippet() 辅助函数](fts5.html#the_snippet_function) 从匹配行的一列文本中选择一个短片段，并以与 highlight()
    函数相同的方式返回，其中每个查询词条的实例都被标记包围。所选的文本片段被选择为最大化其包含的不同查询词条的数量。对于出现在列值开头或紧随 "." 或 ":"
    字符后的片段，给予更高的权重。'
- en: 5.1.1\. The bm25() function
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.1\. bm25() 函数
- en: 'The built-in auxiliary function bm25() returns a real value indicating how
    well the current row matches the full-text query. The better the match, the numerically
    smaller the value returned. A query such as the following may be used to return
    matches in order from best to worst match:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 内置辅助函数 bm25() 返回一个实数值，指示当前行与全文查询的匹配程度。匹配越好，返回的值越小。可以使用以下查询按照从最佳到最差的顺序返回匹配项：
- en: '[PRE44]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In order to calculate a documents score, the full-text query is separated into
    its component phrases. The bm25 score for document *D* and query *Q* is then calculated
    as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算文档的得分，全文查询被分解为其组成短语。然后计算文档 *D* 和查询 *Q* 的 bm25 分数如下：
- en: '![](../Images/b64870952e1c0766daa123ffbfbab530.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b64870952e1c0766daa123ffbfbab530.png)'
- en: In the above, *nPhrase* is the number of phrases in the query. *|D|* is the
    number of tokens in the current document, and *avgdl* is the average number of
    tokens in all documents within the FTS5 table. *k[1]* and *b* are both constants,
    hard-coded at 1.2 and 0.75 respectively.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述内容中，*nPhrase* 是查询中短语的数量。*|D|* 是当前文档中的标记数，*avgdl* 是 FTS5 表中所有文档的平均标记数。*k[1]*
    和 *b* 都是常数，分别为 1.2 和 0.75。
- en: The "-1" term at the start of the formula is not found in most implementations
    of the BM25 algorithm. Without it, a better match is assigned a numerically higher
    BM25 score. Since the default sorting order is "ascending", this means that appending
    "ORDER BY bm25(fts)" to a query would cause results to be returned in order from
    worst to best. The "DESC" keyword would be required in order to return the best
    matches first. In order to avoid this pitfall, the FTS5 implementation of BM25
    multiplies the result by -1 before returning it, ensuring that better matches
    are assigned numerically lower scores.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 公式开头的 "-1" 项在大多数 BM25 算法的实现中是不存在的。没有这个项，一个更好的匹配将被分配一个数值较高的 BM25 分数。由于默认的排序顺序是
    "升序"，因此将 "ORDER BY bm25(fts)" 附加到查询中将导致按照从最差到最佳的顺序返回结果。为了避免这种陷阱，FTS5 实现的 BM25
    在返回结果之前将结果乘以 -1，确保更好的匹配被分配数值较低的分数。
- en: '*IDF(q[i])* is the inverse-document-frequency of query phrase *i*. It is calculated
    as follows, where *N* is the total number of rows in the FTS5 table and *n(q[i])*
    is the total number of rows that contain at least one instance of phrase *i*:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '*IDF(q[i])* 是查询短语 *i* 的逆文档频率。计算方法如下，其中 *N* 是 FTS5 表中的总行数，*n(q[i])* 是至少包含一个短语
    *i* 实例的行数总和：'
- en: '![](../Images/9c8a7bac8e28c3dc8c2754263bfac684.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9c8a7bac8e28c3dc8c2754263bfac684.png)'
- en: 'Finally, *f(q[i],D)* is the phrase frequency of phrase *i*. By default, this
    is simply the number of occurrences of the phrase within the current row. However,
    by passing extra real value arguments to the bm25() SQL function, each column
    of the table may be assigned a different weight and the phrase frequency calculated
    as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*f(q[i],D)* 是短语 *i* 的短语频率。默认情况下，这仅仅是当前行中短语出现的次数。然而，通过向 bm25() SQL 函数传递额外的实数参数，可以为表的每一列分配不同的权重，并按如下方式计算短语频率：
- en: '![](../Images/cca3f6ea1536f386923f25444acb05da.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/cca3f6ea1536f386923f25444acb05da.png)'
- en: 'where *w[c]* is the weight assigned to column *c* and *n(q[i],c)* is the number
    of occurrences of phrase *i* in column *c* of the current row. The first argument
    passed to bm25() following the table name is the weight assigned to the leftmost
    column of the FTS5 table. The second is the weight assigned to the second leftmost
    column, and so on. If there are not enough arguments for all table columns, remaining
    columns are assigned a weight of 1.0\. If there are too many trailing arguments,
    the extras are ignored. For example:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *w[c]* 是分配给列 *c* 的权重，*n(q[i],c)* 是当前行列 *c* 中短语 *i* 的出现次数。传递给 bm25() 的第一个参数是分配给
    FTS5 表最左侧列的权重。第二个参数是分配给第二个最左侧列的权重，依此类推。如果所有表列的参数不足，则剩余列被分配权重 1.0。如果有太多的尾随参数，则多余的参数将被忽略。例如：
- en: '[PRE45]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Refer to wikipedia for [more information regarding BM25](https://en.wikipedia.org/wiki/Okapi_BM25)
    and its variants.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 参考维基百科了解关于 [BM25 的更多信息](https://en.wikipedia.org/wiki/Okapi_BM25) 及其变体。
- en: 5.1.2\. The highlight() function
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.2\. highlight() 函数
- en: The highlight() function returns a copy of the text from a specified column
    of the current row with extra markup text inserted to mark the start and end of
    phrase matches.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: highlight() 函数返回从当前行指定列中的文本副本，并插入额外的标记文本以标记短语匹配的开始和结束。
- en: 'The highlight() must be invoked with exactly three arguments following the
    table name. To be interpreted as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: highlight() 必须在表名后紧接着传递三个参数来调用。解释如下：
- en: An integer indicating the index of the FTS table column to read the text from.
    Columns are numbered from left to right starting at zero.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指示从 FTS 表中读取文本的列的索引整数。列从左到右编号，从零开始。
- en: The text to insert before each phrase match.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个短语匹配前在返回文本中插入的文本。
- en: The text to insert after each phrase match.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个短语匹配后在返回文本中插入的文本。
- en: 'For example:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE46]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In cases where two or more phrase instances overlap (share one or more tokens
    in common), a single open and close marker is inserted for each set of overlapping
    phrases. For example:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个或更多短语实例重叠的情况下（共享一个或多个标记），将为每组重叠的短语插入单个开放和关闭标记。例如：
- en: '[PRE47]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 5.1.3\. The snippet() function
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.3\. snippet() 函数
- en: 'The snippet() function is similar to highlight(), except that instead of returning
    entire column values, it automatically selects and extracts a short fragment of
    document text to process and return. The snippet() function must be passed five
    parameters following the table name argument:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: snippet() 函数类似于 highlight()，但不返回整个列值，它自动选择和提取文档文本的短片以处理和返回。在表名参数后必须传递五个参数给 snippet()
    函数：
- en: An integer indicating the index of the FTS table column to select the returned
    text from. Columns are numbered from left to right starting at zero. A negative
    value indicates that the column should be automatically selected.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指示从 FTS 表中选择返回文本的列的索引整数。列从左到右编号，从零开始。负值表示应自动选择该列。
- en: The text to insert before each phrase match within the returned text.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个短语匹配前在返回文本中插入的文本。
- en: The text to insert after each phrase match within the returned text.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个短语匹配后在返回文本中插入的文本。
- en: The text to add to the start or end of the selected text to indicate that the
    returned text does not occur at the start or end of its column, respectively.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加到选定文本的开头或结尾的文本，以指示返回文本不在其列的开头或结尾。
- en: The maximum number of tokens in the returned text. This must be greater than
    zero and equal to or less than 64.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回文本中的最大标记数量。这必须大于零且小于或等于 64。
- en: 5.2\. Sorting by Auxiliary Function Results
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2\. 按辅助函数结果排序
- en: All FTS5 tables feature a special hidden column named "rank". If the current
    query is not a full-text query (i.e. if it does not include a MATCH operator),
    the value of the "rank" column is always NULL. Otherwise, in a full-text query,
    column rank contains by default the same value as would be returned by executing
    the bm25() auxiliary function with no trailing arguments.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 所有FTS5表都有一个名为"rank"的特殊隐藏列。如果当前查询不是全文查询（即不包括MATCH操作符），则"rank"列的值始终为NULL。否则，在全文查询中，默认情况下，列rank包含与执行bm25()辅助函数不带尾随参数返回的相同值。
- en: The difference between reading from the rank column and using the bm25() function
    directly within the query is only significant when sorting by the returned value.
    In this case, using "rank" is faster than using bm25().
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 从排名列中读取和在查询中直接使用bm25()函数的唯一显著区别是在按返回值排序时。在这种情况下，使用"rank"要比使用bm25()更快。
- en: '[PRE48]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Instead of using bm25() with no trailing arguments, the specific auxiliary function
    mapped to the rank column may be configured either on a per-query basis, or by
    setting a different persistent default for the FTS table.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用不带尾随参数的bm25()，可以在每次查询的基础上配置映射到排名列的特定辅助函数，也可以通过设置FTS表的不同持久默认值进行配置。
- en: 'In order to change the mapping of the rank column for a single query, a term
    similar to either of the following is added to the WHERE clause of a query:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改变一次查询的排名列映射，应向查询的WHERE子句添加类似于以下的术语：
- en: '[PRE49]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The right-hand-side of the MATCH or = operator must be a constant expression
    that evaluates to a string consisting of the auxiliary function to invoke, followed
    by zero or more comma separated arguments within parenthesis. Arguments must be
    SQL literals. For example:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: MATCH或=操作符的右侧必须是一个评估为括号内的零个或多个逗号分隔参数的字符串的常量表达式，后面跟零个或多个逗号分隔参数。参数必须是SQL文本。例如：
- en: '[PRE50]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The table-valued function syntax may also be used to specify an alternative
    ranking function. In this case the text describing the ranking function should
    be specified as the second table-valued function argument. The following three
    queries are equivalent:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 表值函数语法也可以用于指定替代排序函数。在这种情况下，描述排序功能的文本应指定为第二个表值函数参数。以下三个查询是等价的：
- en: '[PRE51]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The default mapping of the rank column for a table may be modified using the
    [FTS5 rank configuration option](fts5.html#the_rank_configuration_option).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个表的排名列的默认映射可以使用[FTS5排名配置选项](fts5.html#the_rank_configuration_option)进行修改。
- en: 6\. Special INSERT Commands
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6\. 特殊的INSERT命令
- en: 6.1\. The 'automerge' Configuration Option
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 \. 'automerge'配置选项
- en: Instead of using a single data structure on disk to store the full-text index,
    FTS5 uses a series of b-trees. Each time a new transaction is committed, a new
    b-tree containing the contents of the committed transaction is written into the
    database file. When the full-text index is queried, each b-tree must be queried
    individually and the results merged before being returned to the user.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: FTS5不使用单个磁盘上的数据结构存储全文索引，而是使用一系列b树。每次提交新事务时，都会将包含已提交事务内容的新b树写入数据库文件中。当查询全文索引时，必须单独查询每个b树，并在返回给用户之前合并结果。
- en: In order to prevent the number of b-trees in the database from becoming too
    large (slowing down queries), smaller b-trees are periodically merged into single
    larger b-trees containing the same data. By default, this happens automatically
    within INSERT, UPDATE or DELETE statements that modify the full-text index. The
    'automerge' parameter determines how many smaller b-trees are merged together
    at a time. Setting it to a small value can speed up queries (as they have to query
    and merge the results from fewer b-trees), but can also slow down writing to the
    database (as each INSERT, UPDATE or DELETE statement has to do more work as part
    of the automatic merging process).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止数据库中的b树数量变得太大（导致查询变慢），较小的b树会周期性地合并成包含相同数据的单个更大的b树。默认情况下，这是在修改全文索引的INSERT、UPDATE或DELETE语句中自动发生的。'automerge'参数确定一次合并多少个较小的b树。将其设置为一个较小的值可以加快查询（因为它们必须查询并合并来自更少b树的结果），但也可能减慢写入数据库的速度（因为每个INSERT、UPDATE或DELETE语句都必须作为自动合并过程的一部分做更多工作）。
- en: Each of the b-trees that make up the full-text index is assigned to a "level"
    based on its size. Level-0 b-trees are the smallest, as they contain the contents
    of a single transaction. Higher level b-trees are the result of merging two or
    more level-0 b-trees together and so they are larger. FTS5 begins to merge b-trees
    together once there exist *M* or more b-trees with the same level, where *M* is
    the value of the 'automerge' parameter.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 组成全文索引的每个B树根据其大小分配到一个“级别”。级别-0的B树最小，因为它们包含单个事务的内容。更高级别的B树是将两个或更多级别-0的B树合并在一起的结果，因此它们更大。一旦在相同级别上存在*M*个或更多的B树，其中*M*是'automerge'参数的值，FTS5就开始合并B树。
- en: The maximum allowed value for the 'automerge' parameter is 16\. The default
    value is 4\. Setting the 'automerge' parameter to 0 disables the automatic incremental
    merging of b-trees altogether.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '''automerge''参数的最大允许值为16。默认值为4。将''automerge''参数设置为0会完全禁用B树的自动增量合并。'
- en: '[PRE52]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 6.2\. The 'crisismerge' Configuration Option
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2\. 'crisismerge'配置选项
- en: The 'crisismerge' option is similar to 'automerge', in that it determines how
    and how often the component b-trees that make up the full-text index are merged
    together. Once there exist *C* or more b-trees on a single level within the full-text
    index, where *C* is the value of the 'crisismerge' option, all b-trees on the
    level are immediately merged into a single b-tree.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '''crisismerge''选项类似于''automerge''，因为它确定组成全文索引的组件B树如何以及多久合并在一起。一旦在全文索引的单个级别上存在*C*个或更多的B树，其中*C*是''crisismerge''选项的值，则该级别上的所有B树将立即合并为单个B树。'
- en: The difference between this option and the 'automerge' option is that when the
    'automerge' limit is reached FTS5 only begins to merge the b-trees together. Most
    of the work is performed as part of subsequent INSERT, UPDATE or DELETE operations.
    Whereas when the 'crisismerge' limit is reached, the offending b-trees are all
    merged immediately. This means that an INSERT, UPDATE or DELETE that triggers
    a crisis-merge may take a long time to complete.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项与'automerge'选项的区别在于，当达到'automerge'限制时，FTS5仅开始将B树合并在一起。大部分工作是作为后续的INSERT、UPDATE或DELETE操作的一部分执行的。而当达到'crisismerge'限制时，有问题的B树会立即全部合并。这意味着触发危机合并的INSERT、UPDATE或DELETE可能需要很长时间才能完成。
- en: The default 'crisismerge' value is 16\. There is no maximum limit. Attempting
    to set the 'crisismerge' parameter to a value of 0 or 1 is equivalent to setting
    it to the default value (16). It is an error to attempt to set the 'crisismerge'
    option to a negative value.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的'crisismerge'值为16。没有最大限制。尝试将'crisismerge'参数设置为0或1等同于将其设置为默认值（16）。试图将'crisismerge'选项设置为负值是错误的。
- en: '[PRE53]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 6.3\. The 'delete' Command
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3\. 'delete'命令
- en: This command is only available with [external content](fts5.html#external_content_tables)
    and [contentless](fts5.html#contentless_tables) tables. It is used to delete the
    index entries associated with a single row from the full-text index. This command
    and the [delete-all](fts5.html#the_delete_all_command) command are the only ways
    to remove entries from the full-text index of a contentless table.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令仅适用于[外部内容](fts5.html#external_content_tables)和[无内容](fts5.html#contentless_tables)表。它用于从无内容表的全文索引中删除与单个行关联的索引条目。此命令和[delete-all](fts5.html#the_delete_all_command)命令是从无内容表的全文索引中删除条目的唯一方式。
- en: 'In order to use this command to delete a row, the text value ''delete'' must
    be inserted into the special column with the same name as the table. The rowid
    of the row to delete is inserted into the rowid column. The values inserted into
    the other columns must match the values currently stored in the table. For example:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用此命令删除一行，必须将文本值'delete'插入到与表同名的特殊列中。要删除的行的rowid插入到rowid列中。插入到其他列中的值必须与当前存储在表中的值匹配。例如：
- en: '[PRE54]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If the values "inserted" into the text columns as part of a 'delete' command
    are not the same as those currently stored within the table, the results may be
    unpredictable.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果作为'delete'命令的一部分插入到文本列中的值与当前存储在表中的值不同，则结果可能是不可预测的。
- en: 'The reason for this is easy to understand: When a document is inserted into
    the FTS5 table, an entry is added to the full-text index to record the position
    of each token within the new document. When a document is removed, the original
    data is required in order to determine the set of entries that need to be removed
    from the full-text index. So if the data supplied to FTS5 when a row is deleted
    using this command is different from that used to determine the set of token instances
    when it was inserted, some full-text index entries may not be correctly deleted,
    or FTS5 may try to remove index entries that do not exist. This can leave the
    full-text index in an unpredictable state, making future query results unreliable.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 其原因很容易理解：当将文档插入FTS5表时，将添加一个条目到全文索引中，以记录每个令牌在新文档中的位置。删除文档时，需要原始数据以确定需要从全文索引中删除的条目集。因此，如果用于删除行时提供给FTS5的数据与插入时用于确定令牌实例集的数据不同，可能会导致一些全文索引条目无法正确删除，或者FTS5可能尝试删除不存在的索引条目。这可能会使全文索引处于不可预测的状态，从而导致未来的查询结果不可靠。
- en: 6.4\. The 'delete-all' Command
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4\. 'delete-all' 命令
- en: This command is only available with [external content](fts5.html#external_content_tables)
    and [contentless](fts5.html#contentless_tables) tables (including [contentless-delete](fts5.html#contentless_delete_tables)
    tables. It deletes all entries from the full-text index.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令仅适用于[外部内容](fts5.html#external_content_tables)和[无内容](fts5.html#contentless_tables)表（包括[无内容删除](fts5.html#contentless_delete_tables)表）。它删除全文索引中的所有条目。
- en: '[PRE55]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 6.5\. The 'deletemerge' Configuration Option
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5\. 'deletemerge' 配置选项
- en: The 'deletemerge' option is only used by [contentless-delete](fts5.html#contentless_delete_tables)
    tables.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '''deletemerge'' 选项仅由[无内容删除](fts5.html#contentless_delete_tables)表使用。'
- en: When a row is deleted from a contentless-delete table, the entries associated
    with its tokens are not immediately removed from the FTS index. Instead, a "tombstone"
    marker containing the rowid of the deleted row is attached to the b-tree that
    contains the row's FTS index entries. When the b-tree is queried, any query result
    rows for which there exist tombstone markers are omitted from the results. When
    the b-tree is merged with other b-trees, both the deleted rows and their tombstone
    markers are discarded.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 当从一个无内容删除表中删除一行时，与其标记的令牌相关联的条目不会立即从FTS索引中移除。相反，将包含已删除行的行标识符的“墓碑”标记附加到包含行的FTS索引条目的B树上。当查询B树时，任何存在墓碑标记的查询结果行都将从结果中省略。当B树与其他B树合并时，已删除的行及其墓碑标记都将被丢弃。
- en: This option specifies a minimum percentage of rows in a b-tree that must have
    tombstone markers before the b-tree is made eligible for merging - either by [automatic](#the_automerge_configuration_option)
    merges or explicit user ['merge'](the_merge_command) commands - even if it does
    not meet the usual criteria as determined by the 'automerge' and ['usermerge'](#the_usermerge_configuration_option)
    options.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项指定B树中必须具有墓碑标记的最小行百分比，以便使其有资格进行合并 - 无论是通过[自动](#the_automerge_configuration_option)合并还是显式用户['merge'](the_merge_command)命令
    - 即使不符合'automerge'和['usermerge'](#the_usermerge_configuration_option)选项确定的通常标准。
- en: 'For example, to specify that FTS5 should consider merging a component b-tree
    after 15% of its rows have associated tombstone markers:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要指定FTS5在其组件B树的15%行具有相关联的墓碑标记后考虑合并：
- en: '[PRE56]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The default value of this option is 10\. Attempting to set it to less than zero
    restores the default value. Setting this option to 0 or to greater than 100 ensures
    that b-trees are never made eligible for merging due to tombstone markers.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项的默认值为10。尝试将其设置为小于零会恢复默认值。将此选项设置为0或大于100可确保B树永远不会因为墓碑标记而合并。
- en: 6.6\. The 'integrity-check' Command
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6\. 'integrity-check' 命令
- en: This command is used to verify that the full-text index is internally consistent,
    and, optionally, that it is consistent with any [external content](fts5.html#external_content_tables)
    table.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令用于验证全文索引的内部一致性，并可选地验证其与任何[外部内容](fts5.html#external_content_tables)表的一致性。
- en: 'The integrity-check command is invoked by inserting the text value ''integrity-check''
    into the special column with the same name as the FTS5 table. If a value is supplied
    for the "rank" column, it must be either 0 or 1\. For example:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 调用完整性检查命令是通过将文本值'integrity-check'插入与FTS5表同名的特殊列中来完成的。如果为"rank"列提供了值，则必须是0或1。例如：
- en: '[PRE57]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The three forms above are equivalent for all FTS tables that are not external
    content tables. They check that the index data structures are not corrupt, and,
    if the FTS table is not contentless, that the contents of the index match the
    contents of the table itself.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 上述三种形式对于所有非外部内容表的 FTS 表都是等效的。它们检查索引数据结构是否损坏，并且如果 FTS 表不是无内容的，则检查索引的内容是否与表本身的内容匹配。
- en: For an external content table, the contents of the index are only compared to
    the contents of the external content table if the value specified for the rank
    column is 1.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 对于外部内容表，仅当为 rank 列指定的值为 1 时，才会将索引的内容与外部内容表的内容进行比较。
- en: In all cases, if any discrepancies are found, the command fails with an [SQLITE_CORRUPT_VTAB](rescode.html#corrupt_vtab)
    error.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，如果发现任何差异，则命令将以 [SQLITE_CORRUPT_VTAB](rescode.html#corrupt_vtab) 错误失败。
- en: 6.7\. The 'merge' Command
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.7\. 'merge' 命令
- en: '[PRE58]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This command merges b-tree structures together until roughly N pages of merged
    data have been written to the database, where N is the absolute value of the parameter
    specified as part of the 'merge' command. The size of each page is as configured
    by the [FTS5 pgsz option](fts5.html#the_pgsz_configuration_option).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将合并 b 树结构，直到将大约 N 页合并数据写入数据库为止，其中 N 是作为 'merge' 命令的一部分指定的参数的绝对值。每页的大小由 [FTS5
    pgsz option](fts5.html#the_pgsz_configuration_option) 配置。
- en: 'If the parameter is a positive value, B-tree structures are only eligible for
    merging if one of the following is true:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数为正值，则只有在以下情况之一成立时才有资格将 B 树结构合并在一起：
- en: There are U or more such b-trees on a single level (see the documentation for
    the [FTS5 automerge option](fts5.html#the_automerge_configuration_option) for
    an explanation of b-tree levels), where U is the value assigned to the [FTS5 usermerge
    option](fts5.html#the_usermerge_configuration_option) option.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单个级别上存在 U 或更多此类 B 树（参见 [FTS5 automerge option](fts5.html#the_automerge_configuration_option)
    的文档以了解 B 树级别的说明），其中 U 是分配给 [FTS5 usermerge option](fts5.html#the_usermerge_configuration_option)
    选项的值。
- en: A merge has already been started (perhaps by a 'merge' command that specified
    a negative parameter).
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已经开始了合并操作（可能是通过指定负参数的 'merge' 命令）。
- en: It is possible to tell whether or not the 'merge' command found any b-trees
    to merge together by checking the value returned by the [sqlite3_total_changes()](c3ref/total_changes.html)
    API before and after the command is executed. If the difference between the two
    values is 2 or greater, then work was performed. If the difference is less than
    2, then the 'merge' command was a no-op. In this case there is no reason to execute
    the same 'merge' command again, at least until after the FTS table is next updated.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在执行命令之前和之后检查 [sqlite3_total_changes()](c3ref/total_changes.html) API 返回的值来判断
    'merge' 命令是否找到了任何需要合并的 B 树。如果两个值之间的差异大于等于 2，则表示进行了合并操作。如果差异小于 2，则 'merge' 命令是无效的。在这种情况下，至少在下次更新
    FTS 表之前，无需再次执行相同的 'merge' 命令。
- en: If the parameter is negative, and there are B-tree structures on more than one
    level within the FTS index, all B-tree structures are assigned to the same level
    before the merge operation is commenced. Additionally, if the parameter is negative,
    the value of the usermerge configuration option is not respected - as few as two
    b-trees from the same level may be merged together.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数为负，并且在 FTS 索引中存在多级别的 B 树结构，则在开始合并操作之前将所有 B 树结构分配到同一级别。此外，如果参数为负，则不会尊重 usermerge
    配置选项的值 - 可能会将来自同一级别的至少两个 B 树合并在一起。
- en: The above means that executing the 'merge' command with a negative parameter
    until the before and after difference in the return value of [sqlite3_total_changes()](c3ref/total_changes.html)
    is less than two optimizes the FTS index in the same way as the [FTS5 optimize
    command](fts5.html#the_optimize_command). However, if a new b-tree is added to
    the FTS index while this process is ongoing, FTS5 will move the new b-tree to
    the same level as the existing b-trees and restart the merge. To avoid this, only
    the first call to 'merge' should specify a negative parameter. Each subsequent
    call to 'merge' should specify a positive value so that the merge started by the
    first call is run to completion even if new b-trees are added to the FTS index.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 上述意味着，在执行带有负参数的“merge”命令，直到[sqlite3_total_changes()](c3ref/total_changes.html)的返回值前后差异小于两者之间，以与[FTS5优化命令](fts5.html#the_optimize_command)相同的方式优化FTS索引。然而，如果在此过程进行时向FTS索引添加新的B树，则FTS5会将新的B树移动到与现有B树相同的级别并重新启动合并。为了避免这种情况，只有第一次调用“merge”时应指定负参数。每次随后的“merge”调用都应指定正值，以便即使在FTS索引中添加了新的B树，也能完成由第一次调用开始的合并过程。
- en: 6.8\. The 'optimize' Command
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.8\. '优化' 命令
- en: This command merges all individual b-trees that currently make up the full-text
    index into a single large b-tree structure. This ensures that the full-text index
    consumes the minimum space within the database and is in the fastest form to query.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将当前组成全文索引的所有单独B树合并为单个大型B树结构。这确保全文索引在数据库中占用的空间最小，并且在查询时速度最快。
- en: Refer to the documentation for the [FTS5 automerge option](fts5.html#the_automerge_configuration_option)
    for more details regarding the relationship between the full-text index and its
    component b-trees.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 有关全文索引和其组件B树之间关系的更多详细信息，请参阅[FTS5 automerge option](fts5.html#the_automerge_configuration_option)的文档。
- en: '[PRE59]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Because it reorganizes the entire FTS index, the optimize command can take
    a long time to run. The [FTS5 merge command](fts5.html#the_merge_command) can
    be used to divide the work of optimizing the FTS index into multiple steps. To
    do this:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它重新组织整个FTS索引，所以优化命令可能需要很长时间才能运行。可以使用[FTS5 merge command](fts5.html#the_merge_command)将优化FTS索引的工作分成多个步骤来完成。要做到这一点：
- en: Invoke the 'merge' command once with the parameter set to -N, then
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将参数设置为-N，然后调用“merge”命令一次。
- en: Invoke the 'merge' command zero or more times with the parameter set to N.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将参数设置为N，然后调用“merge”命令零次或更多次。
- en: where N is the number of pages of data to merge within each invocation of the
    merge command. The application should stop invoking merge when the difference
    in the value returned by the sqlite3_total_changes() function before and after
    the merge command drops to below two. The merge commands may be issued as part
    of the same or separate transactions, and by the same or different database clients.
    Refer to the documentation for the [merge command](fts5.html#the_merge_command)
    for further details.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 其中N是在每次调用合并命令时要合并的数据页数。当调用合并命令前后sqlite3_total_changes()函数返回值的差异降低到低于两者时，应用程序应停止调用合并。合并命令可以作为同一事务或分开的事务的一部分发出，并由同一或不同的数据库客户端发出。有关更多详细信息，请参阅[merge
    command](fts5.html#the_merge_command)的文档。
- en: 6.9\. The 'pgsz' Configuration Option
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.9\. 'pgsz' 配置选项
- en: This command is used to set the persistent "pgsz" option.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令用于设置持久的“pgsz”选项。
- en: The full-text index maintained by FTS5 is stored as a series of fixed-size blobs
    in a database table. It is not strictly necessary for all blobs that make up a
    full-text index to be the same size. The pgsz option determines the size of all
    blobs created by subsequent index writers. The default value is 1000.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: FTS5维护的全文索引存储为数据库表中一系列固定大小的blob。所有组成全文索引的blob不一定非得是相同大小。pgsz选项确定后续索引写入器创建的所有blob的大小。默认值为1000。
- en: '[PRE60]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 6.10\. The 'rank' Configuration Option
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.10\. 'rank' 配置选项
- en: This command is used to set the persistent "rank" option.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令用于设置持久的“rank”选项。
- en: 'The rank option is used to change the default auxiliary function mapping for
    the rank column. The option should be set to a text value in the same format as
    described for ["rank MATCH ?"](fts5.html#sorting_by_auxiliary_function_results)
    terms above. For example:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '''rank'' 选项用于更改rank列的默认辅助函数映射。选项应设置为与上述["rank MATCH ?"](fts5.html#sorting_by_auxiliary_function_results)描述的格式相同的文本值。例如：'
- en: '[PRE61]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 6.11\. The 'rebuild' Command
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.11\. '重建' 命令
- en: This command first deletes the entire full-text index, then rebuilds it based
    on the contents of the table or [content table](fts5.html#external_content_tables).
    It is not available with [contentless tables](fts5.html#contentless_tables).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令首先删除整个全文索引，然后根据表或 [内容表](fts5.html#external_content_tables) 的内容重建它。它不适用于 [无内容表](fts5.html#contentless_tables)。
- en: '[PRE62]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 6.12\. The 'secure-delete' Configuration Option
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.12\. 'secure-delete' 配置选项
- en: 'This command is used to set the persistent boolean "secure-delete" option.
    For example:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令用于设置持久的布尔型 "secure-delete" 选项。例如：
- en: '[PRE63]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Normally, when an entry in an fts5 table is updated or deleted, instead of removing
    entries from the full-text index, delete-keys are added to the [new b-tree](#the_automerge_configuration_option)
    created by the transaction. This is efficient, but it means that the old full-text
    index entries remain in the database file until they are eventually removed by
    merge operations on the full-text index. Anyone with access to the database can
    use these entries to trivially reconstruct the contents of deleted FTS5 table
    rows. However, if the 'secure-delete' option is set to 1, then full-text entries
    are actually removed from the database when existing FTS5 table rows are updated
    or deleted. This is slower, but it prevents old full-text entries from being used
    to reconstruct deleted table rows.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，当更新或删除 fts5 表中的条目时，会在事务创建的新 B 树中添加删除键，而不是从全文索引中移除条目。这样做虽然高效，但意味着旧的全文索引条目会一直保留在数据库文件中，直到它们最终被全文索引的合并操作移除。任何有权访问数据库的人都可以使用这些条目轻松重建已删除的
    FTS5 表行的内容。然而，如果将 'secure-delete' 选项设置为 1，则在更新或删除现有的 FTS5 表行时，实际上会将全文条目从数据库中删除。这样做虽然较慢，但可以防止旧的全文条目被用来重建已删除的表行。
- en: This option ensures that old full-text entries are not available to attackers
    with SQL access to the database. To also ensure that they may not be recovered
    by attackers with access to the SQLite database file itself, the application must
    also enable the SQLite core secure-delete option with a command like ["PRAGMA
    secure_delete = 1"](pragma.html#pragma_secure_delete).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项确保旧的全文条目对于具有对数据库的 SQL 访问权限的攻击者不可用。为了确保它们也不能被访问 SQLite 数据库文件本身的攻击者恢复，应用程序还必须使用命令如
    ["PRAGMA secure_delete = 1"](pragma.html#pragma_secure_delete) 启用 SQLite 核心 secure-delete
    选项。
- en: '**Warning:** Once one or more table rows have been updated or deleted with
    this option set, the FTS5 table may no longer be read or written by any version
    of FTS5 earlier than 3.42.0 (the first version in which this option was available).
    Attempting to do so results in an error, with an error message like "invalid fts5
    file format (found 5, expected 4) - run ''rebuild''". The FTS5 file format may
    be reverted, so that it may be read by earlier versions of FTS5, by running the
    [''rebuild'' command](#the_rebuild_command) on the table using version 3.42.0
    or later.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告：** 一旦使用此选项更新或删除了一个或多个表行，则不能再使用任何早于 3.42.0 版本的 FTS5 读取或写入该 FTS5 表（这是该选项首次可用的版本）。尝试这样做会导致错误，并显示错误消息如“无效的
    fts5 文件格式（找到 5，预期 4） - 运行 ''rebuild''”。可以通过在版本 3.42.0 或更高版本上运行 [''rebuild'' 命令](#the_rebuild_command)
    来回滚 FTS5 文件格式，使其可以被早期版本的 FTS5 读取。'
- en: The default value of the secure-delete option is 0.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: secure-delete 选项的默认值为 0。
- en: 6.13\. The 'usermerge' Configuration Option
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.13\. 'usermerge' 配置选项
- en: This command is used to set the persistent "usermerge" option.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令用于设置持久的 "usermerge" 选项。
- en: 'The usermerge option is similar to the automerge and crisismerge options. It
    is the minimum number of b-tree segments that will be merged together by a ''merge''
    command with a positive parameter. For example:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: usermerge 选项类似于 automerge 和 crisismerge 选项。它是通过具有正参数的 'merge' 命令将一定数量的 B 树段合并在一起的最小数量。例如：
- en: '[PRE64]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The default value of the usermerge option is 4\. The minimum allowed value is
    2, and the maximum 16.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: usermerge 选项的默认值为 4\. 允许的最小值为 2，最大值为 16。
- en: 7\. Extending FTS5
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7\. 扩展 FTS5
- en: 'FTS5 features APIs allowing it to be extended by:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: FTS5 提供了一些 API 来允许通过以下方式进行扩展：
- en: Adding new auxiliary functions implemented in C, and
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新的由C实现的辅助函数，以及
- en: Adding new tokenizers, also implemented in C.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新的分词器，也由 C 实现。
- en: The built-in tokenizers and auxiliary functions described in this document are
    all implemented using the publicly available API described below.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 本文档描述的内置分词器和辅助函数均使用下面公开API实现。
- en: 'Before a new auxiliary function or tokenizer implementation may be registered
    with FTS5, an application must obtain a pointer to the "fts5_api" structure. There
    is one fts5_api structure for each database connection with which the FTS5 extension
    is registered. To obtain the pointer, the application invokes the SQL user-defined
    function fts5() with a single argument. That argument must be set to a pointer
    to a pointer to an fts5_api object using the [sqlite3_bind_pointer()](c3ref/bind_blob.html)
    interface. The following example code demonstrates the technique:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序能够向FTS5注册新的辅助函数或分词器实现之前，必须获取到“fts5_api”结构的指针。对于每个注册了FTS5扩展的数据库连接，都有一个fts5_api结构。应用程序通过调用SQL用户定义函数fts5()并将一个参数设置为指向fts5_api对象的指针来获取该指针，使用[sqlite3_bind_pointer()](c3ref/bind_blob.html)接口。以下示例代码演示了该技术：
- en: '[PRE65]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '**Backwards Compatibility Warning:** Prior to SQLite version 3.20.0 (2017-08-01),
    the fts5() worked slightly differently. Older applications that extend FTS5 must
    be revised to use the new technique shown above.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '**向后兼容性警告：** 在SQLite版本3.20.0（2017-08-01）之前，fts5()的工作方式略有不同。扩展FTS5的旧应用程序必须修改为使用上述新技术。'
- en: The fts5_api structure is defined as follows. It exposes three methods, one
    each for registering new auxiliary functions and tokenizers, and one for retrieving
    existing tokenizer. The latter is intended to facilitate the implementation of
    "tokenizer wrappers" similar to the built-in porter tokenizer.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: fts5_api结构定义如下。它公开了三种方法，分别用于注册新的辅助函数和分词器，以及用于检索现有分词器的方法。后者旨在便于实现类似内置波特分词器的“分词器包装器”。
- en: '[PRE66]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'To invoke a method of the fts5_api object, the fts5_api pointer itself should
    be passed as the methods first argument followed by the other, method specific,
    arguments. For example:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用fts5_api对象的方法，应将fts5_api指针本身作为方法的第一个参数传递，后跟其他特定于方法的参数。例如：
- en: '[PRE67]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The fts5_api structure methods are described individually in the following sections.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: fts5_api结构的方法在以下各节中分别描述。
- en: 7.1\. Custom Tokenizers
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1\. 自定义分词器
- en: 'To create a custom tokenizer, an application must implement three functions:
    a tokenizer constructor (xCreate), a destructor (xDelete) and a function to do
    the actual tokenization (xTokenize). The type of each function is as for the member
    variables of the fts5_tokenizer struct:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建自定义分词器，应用程序必须实现三个函数：一个分词器构造函数（xCreate），一个析构函数（xDelete）和一个执行实际分词化的函数（xTokenize）。每个函数的类型与fts5_tokenizer结构的成员变量一样：
- en: '[PRE68]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The implementation is registered with the FTS5 module by calling the xCreateTokenizer()
    method of the fts5_api object. If there is already a tokenizer with the same name,
    it is replaced. If a non-NULL xDestroy parameter is passed to xCreateTokenizer(),
    it is invoked with a copy of the pUserData pointer passed as the only argument
    when the database handle is closed or when the tokenizer is replaced.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用fts5_api对象的xCreateTokenizer()方法，将实现注册到FTS5模块中。如果已经存在同名的分词器，则会替换它。如果将非空的xDestroy参数传递给xCreateTokenizer()，则在关闭数据库句柄或替换分词器时，将使用传递的pUserData指针的副本调用它作为唯一参数。
- en: If successful, xCreateTokenizer() returns SQLITE_OK. Otherwise, it returns an
    SQLite error code. In this case the xDestroy function is **not** invoked.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，xCreateTokenizer()将返回SQLITE_OK。否则，它将返回SQLite错误代码。在这种情况下，xDestroy函数**不**会被调用。
- en: 'When an FTS5 table uses the custom tokenizer, the FTS5 core calls xCreate()
    once to create a tokenizer, then xTokenize() zero or more times to tokenize strings,
    then xDelete() to free any resources allocated by xCreate(). More specifically:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 当FTS5表使用自定义分词器时，FTS5核心首先调用xCreate()一次以创建分词器，然后零次或多次调用xTokenize()对字符串进行分词化，最后调用xDelete()释放xCreate()分配的任何资源。具体来说：
- en: '**xCreate:**'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '**xCreate:**'
- en: This function is used to allocate and initialize a tokenizer instance. A tokenizer
    instance is required to actually tokenize text.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于分配和初始化分词器实例。实际上，需要分词器实例来对文本进行分词。
- en: The first argument passed to this function is a copy of the (void*) pointer
    provided by the application when the fts5_tokenizer object was registered with
    FTS5 (the third argument to xCreateTokenizer()). The second and third arguments
    are an array of nul-terminated strings containing the tokenizer arguments, if
    any, specified following the tokenizer name as part of the CREATE VIRTUAL TABLE
    statement used to create the FTS5 table.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给此函数的第一个参数是应用程序在使用 CREATE VIRTUAL TABLE 语句创建 FTS5 表时，作为 fts5_tokenizer 对象注册到
    FTS5 时提供的（void*）指针的副本（即 xCreateTokenizer() 的第三个参数）。第二和第三个参数是一个以空字符结尾的字符串数组，包含作为
    CREATE VIRTUAL TABLE 语句的一部分，在标记器名称之后指定的任何标记器参数（如果有）。
- en: The final argument is an output variable. If successful, (*ppOut) should be
    set to point to the new tokenizer handle and SQLITE_OK returned. If an error occurs,
    some value other than SQLITE_OK should be returned. In this case, fts5 assumes
    that the final value of *ppOut is undefined.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个参数是一个输出变量。如果成功，(*ppOut) 应设置为指向新标记器句柄并返回 SQLITE_OK。如果发生错误，则应返回除 SQLITE_OK
    之外的某个值。在这种情况下，fts5 假定 *ppOut 的最终值是未定义的。
- en: '**xDelete:**'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '**xDelete:**'
- en: This function is invoked to delete a tokenizer handle previously allocated using
    xCreate(). Fts5 guarantees that this function will be invoked exactly once for
    each successful call to xCreate().
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此函数来删除先前使用 xCreate() 分配的标记器句柄。Fts5 保证将为每个成功调用 xCreate() 的调用确切调用此函数一次。
- en: '**xTokenize:**'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '**xTokenize:**'
- en: This function is expected to tokenize the nText byte string indicated by argument
    pText. pText may or may not be nul-terminated. The first argument passed to this
    function is a pointer to an Fts5Tokenizer object returned by an earlier call to
    xCreate().
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数预期对由参数 pText 指示的 nText 字节字符串进行分词。pText 可能有可能没有以空字符结尾。传递给此函数的第一个参数是一个指向由先前调用
    xCreate() 返回的 Fts5Tokenizer 对象的指针。
- en: 'The second argument indicates the reason that FTS5 is requesting tokenization
    of the supplied text. This is always one of the following four values:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数指示 FTS5 请求令牌化提供的文本的原因。这始终是以下四个值之一：
- en: '**FTS5_TOKENIZE_DOCUMENT** - A document is being inserted into or removed from
    the FTS table. The tokenizer is being invoked to determine the set of tokens to
    add to (or delete from) the FTS index.'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FTS5_TOKENIZE_DOCUMENT** - 正在向 FTS 表中插入或删除文档。调用标记器以确定要添加到（或从中删除）FTS 索引的令牌集。'
- en: '**FTS5_TOKENIZE_QUERY** - A MATCH query is being executed against the FTS index.
    The tokenizer is being called to tokenize a bareword or quoted string specified
    as part of the query.'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FTS5_TOKENIZE_QUERY** - 正在对 FTS 索引执行 MATCH 查询。调用标记器以对作为查询的一部分指定的裸词或带引号的字符串进行标记化。'
- en: '**(FTS5_TOKENIZE_QUERY | FTS5_TOKENIZE_PREFIX)** - Same as FTS5_TOKENIZE_QUERY,
    except that the bareword or quoted string is followed by a "*" character, indicating
    that the last token returned by the tokenizer will be treated as a token prefix.'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**(FTS5_TOKENIZE_QUERY | FTS5_TOKENIZE_PREFIX)** - 与 FTS5_TOKENIZE_QUERY 相同，但是裸词或带引号的字符串后跟
    "*" 字符，表示标记器返回的最后一个令牌将被视为令牌前缀。'
- en: '**FTS5_TOKENIZE_AUX** - The tokenizer is being invoked to satisfy an fts5_api.xTokenize()
    request made by an auxiliary function. Or an fts5_api.xColumnSize() request made
    by the same on a columnsize=0 database.'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FTS5_TOKENIZE_AUX** - 调用标记器以满足由辅助函数发出的 fts5_api.xTokenize() 请求。或由相同函数对列大小为
    0 的数据库发出的 fts5_api.xColumnSize() 请求。'
- en: For each token in the input string, the supplied callback xToken() must be invoked.
    The first argument to it should be a copy of the pointer passed as the second
    argument to xTokenize(). The third and fourth arguments are a pointer to a buffer
    containing the token text, and the size of the token in bytes. The 4th and 5th
    arguments are the byte offsets of the first byte of and first byte immediately
    following the text from which the token is derived within the input.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 对于输入字符串中的每个令牌，必须调用提供的回调 xToken()。其第一个参数应为作为 xTokenize() 第二个参数传递的指针的副本。第三和第四个参数是指向包含令牌文本的缓冲区以及令牌大小（以字节为单位）的指针。第四和第五个参数是令牌从输入文本中派生的文本的第一个字节和紧随其后的第一个字节的字节偏移量。
- en: The second argument passed to the xToken() callback ("tflags") should normally
    be set to 0\. The exception is if the tokenizer supports synonyms. In this case
    see the discussion below for details.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 xToken() 回调的第二个参数（"tflags"）通常应设置为 0。例外情况是如果标记器支持同义词。在这种情况下，请参阅下面的讨论以获取详细信息。
- en: FTS5 assumes the xToken() callback is invoked for each token in the order that
    they occur within the input text.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: FTS5 假定按照它们在输入文本中出现的顺序为每个令牌调用 xToken() 回调。
- en: If an xToken() callback returns any value other than SQLITE_OK, then the tokenization
    should be abandoned and the xTokenize() method should immediately return a copy
    of the xToken() return value. Or, if the input buffer is exhausted, xTokenize()
    should return SQLITE_OK. Finally, if an error occurs with the xTokenize() implementation
    itself, it may abandon the tokenization and return any error code other than SQLITE_OK
    or SQLITE_DONE.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 如果xToken()回调返回除SQLITE_OK以外的任何值，则应放弃分词并且xTokenize()方法应立即返回xToken()返回值的副本。或者，如果输入缓冲区耗尽，xTokenize()应返回SQLITE_OK。最后，如果xTokenize()实现本身出现错误，则可以放弃分词并返回除SQLITE_OK或SQLITE_DONE之外的任何错误代码。
- en: 7.1.1\. Synonym Support
  id: totrans-404
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.1\. 同义词支持
- en: Custom tokenizers may also support synonyms. Consider a case in which a user
    wishes to query for a phrase such as "first place". Using the built-in tokenizers,
    the FTS5 query 'first + place' will match instances of "first place" within the
    document set, but not alternative forms such as "1st place". In some applications,
    it would be better to match all instances of "first place" or "1st place" regardless
    of which form the user specified in the MATCH query text.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义分词器也可以支持同义词。考虑一个用户希望查询短语"first place"的情况。使用内置分词器，FTS5查询'first + place'将匹配文档集中的"first
    place"实例，但不匹配"1st place"等替代形式。在某些应用中，最好匹配用户在MATCH查询文本中指定的所有"first place"或"1st
    place"的实例。
- en: 'There are several ways to approach this in FTS5:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在FTS5中有几种方法可以解决这个问题：
- en: By mapping all synonyms to a single token. In this case, using the above example,
    this means that the tokenizer returns the same token for inputs "first" and "1st".
    Say that token is in fact "first", so that when the user inserts the document
    "I won 1st place" entries are added to the index for tokens "i", "won", "first"
    and "place". If the user then queries for '1st + place', the tokenizer substitutes
    "first" for "1st" and the query works as expected.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有同义词映射到一个单一的标记。在这种情况下，使用上述示例，这意味着分词器对输入的"first"和"1st"返回相同的标记。假设该标记实际上是"first"，因此当用户插入文档"I
    won 1st place"时，会为标记"i"、"won"、"first"和"place"添加条目到索引中。如果用户查询'1st + place'，分词器会将"1st"替换为"first"，查询将按预期工作。
- en: 'By querying the index for all synonyms of each query term separately. In this
    case, when tokenizing query text, the tokenizer may provide multiple synonyms
    for a single term within the document. FTS5 then queries the index for each synonym
    individually. For example, faced with the query:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过为每个查询项的所有同义词单独查询索引。在这种情况下，在对查询文本进行标记化时，分词器可能为文档内单个术语提供多个同义词。然后，FTS5为每个同义词单独查询索引。例如，面对查询时：
- en: '[PRE69]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'the tokenizer offers both "1st" and "first" as synonyms for the first token
    in the MATCH query and FTS5 effectively runs a query similar to:'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 分词器为MATCH查询中的第一个标记提供"1st"和"first"作为同义词，而FTS5有效地运行类似于以下查询：
- en: '[PRE70]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: except that, for the purposes of auxiliary functions, the query still appears
    to contain just two phrases - "(first OR 1st)" being treated as a single phrase.
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但是，对于辅助函数的目的，查询仍然看起来只包含两个短语——"(first OR 1st)"被视为单个短语。
- en: By adding multiple synonyms for a single term to the FTS index. Using this method,
    when tokenizing document text, the tokenizer provides multiple synonyms for each
    token. So that when a document such as "I won first place" is tokenized, entries
    are added to the FTS index for "i", "won", "first", "1st" and "place".
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过向FTS索引添加单个术语的多个同义词。使用这种方法，在对文档文本进行标记化时，分词器为每个标记提供多个同义词。因此，当文档如"I won first
    place"被标记化时，为"i"、"won"、"first"、"1st"和"place"在FTS索引中添加条目。
- en: This way, even if the tokenizer does not provide synonyms when tokenizing query
    text (it should not - to do so would be inefficient), it doesn't matter if the
    user queries for 'first + place' or '1st + place', as there are entries in the
    FTS index corresponding to both forms of the first token.
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，即使分词器在解析查询文本时不提供同义词（它不应该这样做——这样做效率低下），用户查询'first + place'或'1st + place'都不重要，因为FTS索引中存在与第一个标记的两种形式对应的条目。
- en: 'Whether it is parsing document or query text, any call to xToken that specifies
    a *tflags* argument with the FTS5_TOKEN_COLOCATED bit is considered to supply
    a synonym for the previous token. For example, when parsing the document "I won
    first place", a tokenizer that supports synonyms would call xToken() 5 times,
    as follows:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是解析文档还是查询文本，在调用带有FTS5_TOKEN_COLOCATED位的*tflags*参数的xToken时，都被视为为前一个标记提供同义词。例如，在解析文档"I
    won first place"时，支持同义词的分词器将调用xToken() 5次，如下所示：
- en: '[PRE71]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: It is an error to specify the FTS5_TOKEN_COLOCATED flag the first time xToken()
    is called. Multiple synonyms may be specified for a single token by making multiple
    calls to xToken(FTS5_TOKEN_COLOCATED) in sequence. There is no limit to the number
    of synonyms that may be provided for a single token.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次调用xToken()时指定FTS5_TOKEN_COLOCATED标志是一个错误。通过连续多次调用xToken(FTS5_TOKEN_COLOCATED)可以为单个标记指定多个同义词。对于单个标记可以提供的同义词数量没有限制。
- en: 'In many cases, method (1) above is the best approach. It does not add extra
    data to the FTS index or require FTS5 to query for multiple terms, so it is efficient
    in terms of disk space and query speed. However, it does not support prefix queries
    very well. If, as suggested above, the token "first" is substituted for "1st"
    by the tokenizer, then the query:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，方法（1）是最佳选择。它不会向FTS索引中添加额外的数据，也不需要FTS5来查询多个项，因此在磁盘空间和查询速度方面非常高效。然而，它对前缀查询的支持并不是很好。如果像上述建议那样，分词器用"first"替换"1st"，那么查询：
- en: '[PRE72]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: will not match documents that contain the token "1st" (as the tokenizer will
    probably not map "1s" to any prefix of "first").
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 将不会匹配包含标记"1st"的文档（因为分词器可能不会将"1s"映射到"first"的任何前缀）。
- en: For full prefix support, method (3) may be preferred. In this case, because
    the index contains entries for both "first" and "1st", prefix queries such as
    'fi*' or '1s*' will match correctly. However, because extra entries are added
    to the FTS index, this method uses more space within the database.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 对于完全支持前缀的方法（3），可能更加推荐。在这种情况下，由于索引包含"first"和"1st"两个条目，前缀查询如'fi*'或'1s*'将能正确匹配。然而，由于额外的条目被添加到FTS索引中，这种方法在数据库中使用了更多的空间。
- en: Method (2) offers a midpoint between (1) and (3). Using this method, a query
    such as '1s*' will match documents that contain the literal token "1st", but not
    "first" (assuming the tokenizer is not able to provide synonyms for prefixes).
    However, a non-prefix query like '1st' will match against "1st" and "first". This
    method does not require extra disk space, as no extra entries are added to the
    FTS index. On the other hand, it may require more CPU cycles to run MATCH queries,
    as separate queries of the FTS index are required for each synonym.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 方法（2）在（1）和（3）之间提供了一个折中方案。使用此方法，像'1s*'这样的查询将匹配包含字面标记"1st"的文档，但不会匹配"first"（假设分词器不能为前缀提供同义词）。然而，像'1st'这样的非前缀查询将匹配"1st"和"first"。这种方法不需要额外的磁盘空间，因为不会向FTS索引中添加额外的条目。但是，运行MATCH查询可能需要更多的CPU周期，因为每个同义词都需要单独查询FTS索引。
- en: When using methods (2) or (3), it is important that the tokenizer only provide
    synonyms when tokenizing document text (method (3)) or query text (method (2)),
    not both. Doing so will not cause any errors, but is inefficient.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用方法（2）或（3）时，重要的是分词器在标记文档文本（方法（3））或查询文本（方法（2））时仅提供同义词，而不是两者兼顾。这样做不会引起任何错误，但效率低下。
- en: 7.2\. Custom Auxiliary Functions
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2\. 自定义辅助函数
- en: 'Implementing a custom auxiliary function is similar to implementing a [scalar
    SQL function](appfunc.html). The implementation should be a C function of type
    fts5_extension_function, defined as follows:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 实现自定义辅助函数类似于实现[标量SQL函数](appfunc.html)。实现应该是fts5_extension_function类型的C函数，定义如下：
- en: '[PRE73]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The implementation is registered with the FTS5 module by calling the xCreateFunction()
    method of the fts5_api object. If there is already an auxiliary function with
    the same name, it is replaced by the new function. If a non-NULL xDestroy parameter
    is passed to xCreateFunction(), it is invoked with a copy of the pUserData pointer
    passed as the only argument when the database handle is closed or when the registered
    auxiliary function is replaced.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用fts5_api对象的xCreateFunction()方法将实现注册到FTS5模块。如果同名的辅助函数已经存在，将会被新函数替换。如果将xCreateFunction()传递非NULL的xDestroy参数，则在关闭数据库句柄或替换已注册的辅助函数时，会调用具有pUserData指针副本的xDestroy。
- en: If successful, xCreateFunction() returns SQLITE_OK. Otherwise, it returns an
    SQLite error code. In this case the xDestroy function is **not** invoked.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，xCreateFunction()返回SQLITE_OK。否则，返回一个SQLite错误代码。在这种情况下，xDestroy函数**不会**被调用。
- en: The final three arguments passed to the auxiliary function callback (pCtx, nVal
    and apVal above) are similar to the three arguments passed to the implementation
    of a scalar SQL function. The apVal[] array contains all SQL arguments except
    the first passed to the auxiliary function. The implementation should return a
    result or error via the content handle pCtx.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助函数回调函数的最后三个参数（pCtx、nVal 和 apVal 如上所述）与标量 SQL 函数的实现传递的三个参数类似。apVal[] 数组包含除辅助函数第一个参数之外的所有
    SQL 参数。实现应通过内容句柄 pCtx 返回结果或错误。
- en: 'The first argument passed to an auxiliary function callback is a pointer to
    a structure (pApi above) containing methods that may be invoked in order to obtain
    information regarding the current query or row. The second argument is an opaque
    handle (pFts above) that should be passed as the first argument to any such method
    invocation. For example, the following auxiliary function returns the total number
    of tokens in all columns of the current row:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助函数回调函数的第一个参数是一个指向包含方法的结构体的指针（如上所示的 pApi），可以调用这些方法以获取关于当前查询或行的信息。第二个参数是一个不透明句柄（如上所示的
    pFts），应作为任何此类方法调用的第一个参数传递。例如，以下辅助函数返回当前行所有列中的令牌总数：
- en: '[PRE74]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The following section describes the API offered to auxiliary function implementations
    in detail. Further examples may be found in the "fts5_aux.c" file of the source
    code.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节详细描述了提供给辅助函数实现的 API。在源代码的"fts5_aux.c"文件中可以找到更多示例。
- en: 7.2.1\. Custom Auxiliary Functions API Overview
  id: totrans-433
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.1\. 自定义辅助函数 API 概述
- en: This section provides an overview of the capabilities of the auxiliary function
    API. It does not describe every function. Refer to the [reference text](#custom_auxiliary_functions_api_reference)
    below for a complete description.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 本节概述了辅助函数 API 的功能。它不描述每个函数。详细描述请参阅下面的[参考文本](#custom_auxiliary_functions_api_reference)。
- en: 'When invoked, an auxiliary function implementation has access to APIs that
    allow it to query FTS5 for various information. Some of these APIs return information
    relating to the current row of the FTS5 table being visited, some relating to
    the entire set of rows that will be visited by the FTS5 query, and some relating
    to the FTS5 table. Given an FTS5 table populated as follows:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用时，辅助函数实现可以访问允许其查询 FTS5 的各种信息的 API。其中一些 API 返回与正在访问的 FTS5 表的当前行相关的信息，一些与将由
    FTS5 查询访问的整个行集相关，而一些与 FTS5 表相关。给定如下填充的 FTS5 表：
- en: '[PRE75]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'and the query:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 和查询：
- en: '[PRE76]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: then the custom auxiliary function will be invoked for rows 1 and 3 (all rows
    that contain the token "ab" and therefore match the query).
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将为行 1 和 3 调用自定义辅助函数（所有包含令牌"ab"的行，因此与查询匹配）。
- en: '**Number of rows/columns in table: xRowCount, xColumnCount**'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '**表中的行/列数：xRowCount, xColumnCount**'
- en: The system may be queried for the total number of rows in the FTS5 table using
    the [xRowCount](#xRowCount) API. This provides the total number of rows in the
    table, not the number that match the current query.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用[xRowCount](#xRowCount) API 查询 FTS5 表中的总行数。这提供了表中的总行数，而不是与当前查询匹配的行数。
- en: Table columns are numbered from left to right starting from 0\. The "rowid"
    column does not count - only user declared columns - so in the example above column
    "a" is column 0 and column "b" is column 1\. From within an auxiliary function
    implementation, the [xColumnCount](#xColumnCount) API may be used to determine
    how many columns the table being queried has. If the xColumnCount() API is invoked
    from within the implementation of the auxiliary function my_aux_function in the
    example above, it returns 2.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 表列从左到右从 0 开始编号。"rowid" 列不计数 - 只有用户声明的列 - 因此在上述示例中，列"a" 是列 0，列"b" 是列 1。在辅助函数实现中，可以使用[xColumnCount](#xColumnCount)
    API 来确定正在查询的表具有多少列。如果在上述示例中辅助函数 my_aux_function 的实现中调用 xColumnCount() API，则返回
    2。
- en: '**Data From Current Row: xColumnText, xRowid**'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '**当前行的数据：xColumnText, xRowid**'
- en: The [xRowid](#xRowid) API may be used to find the rowid value for the current
    row. The [xColumnText](#xColumnText) may be used to obtain the text stored in
    a specified column of the current row.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '[xRowid](#xRowid) API 可用于查找当前行的 rowid 值。[xColumnText](#xColumnText) 可用于获取当前行指定列中存储的文本。'
- en: '**Token Counts: xColumnSize, xColumnTotalSize**'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '**令牌计数：xColumnSize, xColumnTotalSize**'
- en: FTS5 divides documents inserted into an fts table into tokens. These are usually
    just words, perhaps folded to either upper or lower case and with any punctuation
    removed. For example, the default [unicode61 tokenizer](#unicode61_tokenizer)
    tokenizes the text "The tokenizer is case-insensitive" to a list of 5 tokens -
    "the", "tokenizer", is", "case" and "insensitive". Exactly how tokens are extracted
    from text is determined by the [tokenizer](#tokenizers).
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: FTS5 将插入到 fts 表中的文档分割为标记。这些通常只是单词，可能会折叠为大写或小写，并且去除任何标点符号。例如，默认的 [unicode61 tokenizer](#unicode61_tokenizer)
    将文本 "The tokenizer is case-insensitive" 分词为 5 个标记 - "the", "tokenizer", is", "case"
    和 "insensitive"。从文本中提取标记的确切方式由 [tokenizer](#tokenizers) 决定。
- en: The auxiliary functions API provides functions to query for both the number
    of tokens in a specified column of the current row (the [xColumnSize](#xColumnSize)
    API), or for the number of tokens in a specified column of all rows of the table
    (the [xColumnTotalSize](#xColumnTotalSize) API). For the example at the top of
    this section, when visiting row 1, xColumnSize returns 2 for column 0 and 3 for
    column 1\. xColumnTotalSize returns 6 for column 0 and 9 for column 1 regardless
    of the current row.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助函数 API 提供了查询当前行指定列中标记数量的函数（[xColumnSize](#xColumnSize) API），或者查询表中所有行指定列中标记总数的函数（[xColumnTotalSize](#xColumnTotalSize)
    API）。例如，在本节顶部的示例中，访问第 1 行时，xColumnSize 返回列 0 的 2 个标记和列 1 的 3 个标记。xColumnTotalSize
    返回列 0 的 6 个标记和列 1 的 9 个标记，而不管当前行如何。
- en: '**The Current Full-Text Query: xPhraseCount, xPhraseSize, xQueryToken**'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '**当前全文查询: xPhraseCount, xPhraseSize, xQueryToken**'
- en: 'An FTS5 query contains one or more [phrases](#fts5_phrases). The [xPhraseCount](#xPhraseCount),
    [xPhraseSize](#xPhraseSize) and [xQueryToken](#xQueryToken) APIs allow an auxiliary
    function implementation to query the system for details of the current query.
    The xPhraseCount API returns the number of phrases in the current query. For example,
    if an FTS5 table is queried as follows:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 'FTS5 查询包含一个或多个 [短语](#fts5_phrases)。[xPhraseCount](#xPhraseCount), [xPhraseSize](#xPhraseSize)
    和 [xQueryToken](#xQueryToken) APIs 允许辅助函数实现查询当前查询的详细信息。xPhraseCount API 返回当前查询中的短语数量。例如，如果查询一个
    FTS5 表格如下:'
- en: '[PRE77]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: and the xPhraseCount() API invoked from within the implementation of the auxiliary
    function, it returns 3 (the three phrases being "ab", "ce ef gh" and "ij kl").
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 并且在辅助函数的实现中调用 xPhraseCount() API，它会返回 3（三个短语分别为 "ab", "ce ef gh" 和 "ij kl"）。
- en: Phrases are numbered in order of appearance within a query starting from 0.
    The xPhraseSize() API may be used to query for the number of tokens in a specified
    phrase of the query. In the example above, phrase 0 contains 1 token, phrase 1
    contains 3 tokens, and phrase 2 contains 2.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 短语按照在查询中出现的顺序编号，从 0 开始。xPhraseSize() API 可用于查询查询中指定短语的标记数。在上面的示例中，短语 0 包含 1
    个标记，短语 1 包含 3 个标记，短语 2 包含 2 个标记。
- en: The xQueryToken API may be used to access the text of a specified token within
    a specified phrase of the query. Tokens are numbered within their phrases from
    left to right starting from 0\. For example, if the xQueryToken API is used to
    request token 1 of phrase 2 in the example above, it returns the text "kl". Token
    0 of phrase 0 is "ab".
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: xQueryToken API 可用于访问查询中指定短语的指定标记的文本。标记在其短语内从左到右从 0 开始编号。例如，如果在上述示例中使用 xQueryToken
    API 请求短语 2 的标记 1，则返回文本 "kl"。短语 0 的标记 0 是 "ab"。
- en: '**Phrase Hits in the Current Row: xPhraseFirst, xPhraseNext**'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '当前行中的短语命中: xPhraseFirst, xPhraseNext**'
- en: 'These two API functions may be used to iterate through the matches for a specified
    phrase of the query within the current row. Phrase matches are identified by the
    column and token offset within the current row. For example, say the following
    example table:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '这两个 API 函数可用于迭代查询中指定短语在当前行中的匹配项。短语匹配由当前行中的列和标记偏移量确定。例如，假设以下示例表格:'
- en: '[PRE78]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'is queried with:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '被查询的是:'
- en: '[PRE79]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The query above contains 5 phrases - "one two", "three", "four", "five" and
    "six". It matches all rows of the table, so the auxiliary function is invoked
    for each row.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询包含 5 个短语 - "one two", "three", "four", "five" 和 "six"。它匹配表格的所有行，因此辅助函数在每行中都会被调用。
- en: In row 1, for phrase 0, "one two", there is exactly one match to iterate through
    - at column 0 token offset 1\. The column number is 0 because the match appears
    in the left most column. The token offset is 1 because there is exactly one token
    ("xxx") before the phrase match in the column value. For phrase 1, "three", there
    are no matches. Phrase 2, "four", has one match, at column 1, token offset 0\.
    Phrase 3, "five", has one match at column 0, token offset 4, and phrase 4, "six",
    has one match at column 0 token offset 6.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，对于短语 0，“one two”，有一次精确匹配需要遍历 - 在列 0 的标记偏移为 1。列数是 0，因为匹配出现在最左边的列。标记偏移为 1，因为在列值中短语匹配前恰好有一个标记（"xxx"）。对于短语
    1，“three”，没有匹配。短语 2，“four”，在列 1 有一次匹配，标记偏移为 0。短语 3，“five”，在列 0 有一次匹配，标记偏移为 4，而短语
    4，“six”，在列 0 的标记偏移为 6 有一次匹配。
- en: 'The set of matches for each phrase in each row of the example is presented
    in the table below. Each match is notated as (column-number, token-offset):'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例表中，每行中每个短语的匹配集合如下所示。每个匹配均标注为 (列号，标记偏移)：
- en: '| Row | Phrase 0 | Phrase 1 | Phrase 2 | Phrase 3 | Phrase 4 |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '| 行 | 短语 0 | 短语 1 | 短语 2 | 短语 3 | 短语 4 |'
- en: '| 1 | (0, 1) |  | (1, 1) | (0, 4) | (0, 6) |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '| 1 | (0, 1) |  | (1, 1) | (0, 4) | (0, 6) |'
- en: '| 2 |  | (1,0) | (1, 1), (1,4) | (1, 2), (1, 5) | (1, 3), (1, 6) |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '| 2 |  | (1,0) | (1, 1), (1,4) | (1, 2), (1, 5) | (1, 3), (1, 6) |'
- en: The second row is slightly more complicated. There were no occurrences of phrase
    0\. Phrase 1 ("three") appears once, at column 1 token offset 0\. Although there
    are instances of phrase 2 ("four") in column 0, none of them are reported by the
    API, as phrase 4 has a [column filter](#fts5_column_filters) - "y:". Matches that
    are filtered out by column filters do not count. Similarly, although phrases 3
    and 4 do occur in column "x" of row 2, they are filtered out by the [NEAR filter](#fts5_near_queries).
    Matches that are filtered out by NEAR filters do not count either.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行稍微复杂些。短语 0 没有出现。短语 1（"three"）在列 1 的标记偏移为 0 处出现一次。虽然短语 2（"four"）在列 0 中有实例，但
    API 未报告任何实例，因为短语 4 有一个[列过滤器](#fts5_column_filters) - "y:"。通过列过滤器过滤掉的匹配不计入内。同样，虽然短语
    3 和短语 4 出现在第 2 行的列 "x" 中，但它们被[NEAR 过滤器](#fts5_near_queries)过滤掉。通过 NEAR 过滤器过滤掉的匹配也不计入内。
- en: '**Phrase Hits in the Current Row (2): xInstCount, xInst**'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '**当前行中的短语命中（2）：xInstCount，xInst**'
- en: The [xInstCount](#xInstCount) and [xInst](#xInst) APIs provide access to the
    same information as the xPhraseFirst and xPhraseNext described above. The difference
    is that instead of iterating through the matches for a single, specified phrase,
    the xInstCount/xInst APIs collate all matches into a single flat array, sorted
    in order of occurrence within the current row. Elements of this array may then
    be accessed randomly.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '[xInstCount](#xInstCount) 和 [xInst](#xInst) API 提供对与上述 xPhraseFirst/xPhraseNext
    相同的信息的访问。不同之处在于，xInstCount/xInst API 将所有匹配整合到一个单一的平面数组中，按当前行中出现顺序排序。可以随机访问此数组的元素。'
- en: 'Each array element consists of three values:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数组元素包括三个值：
- en: A phrase number,
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 短语编号，
- en: A column number, and
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列数，以及
- en: A token offset
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个标记偏移
- en: 'Using the same example data and query as for xPhraseFirst/xPhraseNext above,
    the array accessible via xInstCount/xInst consists of the following entries for
    each row:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与上述 xPhraseFirst/xPhraseNext 相同的示例数据和查询，通过 xInstCount/xInst 可访问的数组包括每行的以下条目：
- en: '| Row | xInstCount/xInst array |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '| 行 | xInstCount/xInst 数组 |'
- en: '| 1 | (0, 0, 1), (3, 0, 4), (4, 0, 6), (2, 1, 1) |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '| 1 | (0, 0, 1), (3, 0, 4), (4, 0, 6), (2, 1, 1) |'
- en: '| 2 | (1, 1, 0), (2, 1, 1), (3, 1, 2), (4, 1, 3), (2, 1, 4), (3, 1, 5), (4,
    1, 6) |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '| 2 | (1, 1, 0), (2, 1, 1), (3, 1, 2), (4, 1, 3), (2, 1, 4), (3, 1, 5), (4,
    1, 6) |'
- en: Each entry of the array is called a phrase match. Phrase matches are numbered
    in order, starting from 0\. So, in the example above, in row 2, phrase match 3
    is (4, 1, 3) - phrase 4 of the query matches at column 1, token offset 3.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的每个条目称为短语匹配。短语匹配按顺序编号，从 0 开始。因此，在上面的例子中，第 2 行中的短语匹配 3 是 (4, 1, 3) - 查询的第 4
    个短语在列 1，标记偏移 3 处匹配。
- en: 7.2.2\. Custom Auxiliary Functions API Reference
  id: totrans-477
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.2. 自定义辅助功能 API 参考
- en: '[PRE80]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '**void *(*xUserData)(Fts5Context*)**'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '**void *(*xUserData)(Fts5Context*)**'
- en: Return a copy of the pUserData pointer passed to the xCreateFunction() API when
    the extension function was registered.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 返回在注册扩展函数时通过 xCreateFunction() API 传递的 pUserData 指针的副本。
- en: '**int (*xColumnTotalSize)(Fts5Context*, int iCol, sqlite3_int64 *pnToken)**'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '**int (*xColumnTotalSize)(Fts5Context*, int iCol, sqlite3_int64 *pnToken)**'
- en: If parameter iCol is less than zero, set output variable *pnToken to the total
    number of tokens in the FTS5 table. Or, if iCol is non-negative but less than
    the number of columns in the table, return the total number of tokens in column
    iCol, considering all rows in the FTS5 table.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数 iCol 小于零，则将输出变量 *pnToken 设置为 FTS5 表中所有标记的总数。或者，如果 iCol 是非负数但小于表中列的数量，则返回考虑
    FTS5 表中所有行的第 iCol 列中的标记总数。
- en: If parameter iCol is greater than or equal to the number of columns in the table,
    SQLITE_RANGE is returned. Or, if an error occurs (e.g. an OOM condition or IO
    error), an appropriate SQLite error code is returned.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数 iCol 大于或等于表中的列数，则返回 SQLITE_RANGE。或者，如果发生错误（例如 OOM 条件或 IO 错误），则返回适当的 SQLite
    错误代码。
- en: '**int (*xColumnCount)(Fts5Context*)**'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '**int (*xColumnCount)(Fts5Context*)**'
- en: Return the number of columns in the table.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 返回表中的列数。
- en: '**int (*xColumnSize)(Fts5Context*, int iCol, int *pnToken)**'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '**int (*xColumnSize)(Fts5Context*, int iCol, int *pnToken)**'
- en: If parameter iCol is less than zero, set output variable *pnToken to the total
    number of tokens in the current row. Or, if iCol is non-negative but less than
    the number of columns in the table, set *pnToken to the number of tokens in column
    iCol of the current row.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数 iCol 小于零，则将输出变量 *pnToken 设置为当前行中所有标记的总数。或者，如果 iCol 是非负数但小于表中列的数量，则将 *pnToken
    设置为当前行中第 iCol 列的标记数量。
- en: If parameter iCol is greater than or equal to the number of columns in the table,
    SQLITE_RANGE is returned. Or, if an error occurs (e.g. an OOM condition or IO
    error), an appropriate SQLite error code is returned.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数 iCol 大于或等于表中的列数，则返回 SQLITE_RANGE。或者，如果发生错误（例如 OOM 条件或 IO 错误），则返回适当的 SQLite
    错误代码。
- en: This function may be quite inefficient if used with an FTS5 table created with
    the "columnsize=0" option.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 如果与 "columnsize=0" 选项创建的 FTS5 表一起使用，此函数可能非常低效。
- en: '**int (*xColumnText)(Fts5Context*, int iCol, const char **pz, int *pn)**'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '**int (*xColumnText)(Fts5Context*, int iCol, const char **pz, int *pn)**'
- en: If parameter iCol is less than zero, or greater than or equal to the number
    of columns in the table, SQLITE_RANGE is returned.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数 iCol 小于零，或大于或等于表中的列数，则返回 SQLITE_RANGE。
- en: Otherwise, this function attempts to retrieve the text of column iCol of the
    current document. If successful, (*pz) is set to point to a buffer containing
    the text in utf-8 encoding, (*pn) is set to the size in bytes (not characters)
    of the buffer and SQLITE_OK is returned. Otherwise, if an error occurs, an SQLite
    error code is returned and the final values of (*pz) and (*pn) are undefined.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，此函数尝试检索当前文档的第 iCol 列的文本。如果成功，(*pz) 被设置为指向包含 utf-8 编码文本的缓冲区，(*pn) 被设置为缓冲区的字节大小（而不是字符数），并返回
    SQLITE_OK。否则，如果发生错误，则返回 SQLite 错误代码，并且 (*pz) 和 (*pn) 的最终值是未定义的。
- en: '**int (*xPhraseCount)(Fts5Context*)**'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '**int (*xPhraseCount)(Fts5Context*)**'
- en: Returns the number of phrases in the current query expression.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 返回当前查询表达式中的短语数。
- en: '**int (*xPhraseSize)(Fts5Context*, int iPhrase)**'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '**int (*xPhraseSize)(Fts5Context*, int iPhrase)**'
- en: If parameter iCol is less than zero, or greater than or equal to the number
    of phrases in the current query, as returned by xPhraseCount, 0 is returned. Otherwise,
    this function returns the number of tokens in phrase iPhrase of the query. Phrases
    are numbered starting from zero.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数 iCol 小于零，或大于或等于由 xPhraseCount 返回的当前查询中的短语数，则返回 0。否则，返回查询中第 iPhrase 短语的标记数。短语编号从零开始。
- en: '**int (*xInstCount)(Fts5Context*, int *pnInst)**'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '**int (*xInstCount)(Fts5Context*, int *pnInst)**'
- en: Set *pnInst to the total number of occurrences of all phrases within the query
    within the current row. Return SQLITE_OK if successful, or an error code (i.e.
    SQLITE_NOMEM) if an error occurs.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 将 *pnInst 设置为查询中当前行内所有短语出现的总次数。如果成功，返回 SQLITE_OK；如果发生错误（即 SQLITE_NOMEM），则返回错误代码。
- en: This API can be quite slow if used with an FTS5 table created with the "detail=none"
    or "detail=column" option. If the FTS5 table is created with either "detail=none"
    or "detail=column" and "content=" option (i.e. if it is a contentless table),
    then this API always returns 0.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 如果与 "detail=none" 或 "detail=column" 选项创建的 FTS5 表一起使用，此 API 可能非常慢。如果 FTS5 表使用
    "detail=none" 或 "detail=column" 和 "content=" 选项创建（即为无内容表），则此 API 总是返回 0。
- en: '**int (*xInst)(Fts5Context*, int iIdx, int *piPhrase, int *piCol, int *piOff)**'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '**int (*xInst)(Fts5Context*, int iIdx, int *piPhrase, int *piCol, int *piOff)**'
- en: Query for the details of phrase match iIdx within the current row. Phrase matches
    are numbered starting from zero, so the iIdx argument should be greater than or
    equal to zero and smaller than the value output by xInstCount(). If iIdx is less
    than zero or greater than or equal to the value returned by xInstCount(), SQLITE_RANGE
    is returned.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 查询当前行中短语匹配 iIdx 的详细信息。短语匹配从零开始编号，因此 iIdx 参数应大于或等于零，并且小于 xInstCount() 输出的值。如果
    iIdx 小于零或大于或等于 xInstCount() 返回的值，返回 SQLITE_RANGE。
- en: Otherwise, output parameter *piPhrase is set to the phrase number, *piCol to
    the column in which it occurs and *piOff the token offset of the first token of
    the phrase. SQLITE_OK is returned if successful, or an error code (i.e. SQLITE_NOMEM)
    if an error occurs.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，输出参数 *piPhrase 被设定为短语编号，*piCol 被设定为其所在的列，*piOff 被设定为短语第一个标记的标记偏移量。如果成功，返回
    SQLITE_OK；如果出现错误，返回错误代码（例如 SQLITE_NOMEM）。
- en: This API can be quite slow if used with an FTS5 table created with the "detail=none"
    or "detail=column" option.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 如果与使用 "detail=none" 或 "detail=column" 选项创建的 FTS5 表一起使用，则此 API 可能非常慢。
- en: '**sqlite3_int64 (*xRowid)(Fts5Context*)**'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '**sqlite3_int64 (*xRowid)(Fts5Context*)**'
- en: Returns the rowid of the current row.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 返回当前行的 rowid。
- en: '**int (*xTokenize)(Fts5Context*, const char *pText, int nText, void *pCtx,
    int (*xToken)(void*, int, const char*, int, int, int) )**'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '**int (*xTokenize)(Fts5Context*, const char *pText, int nText, void *pCtx,
    int (*xToken)(void*, int, const char*, int, int, int) )**'
- en: Tokenize text using the tokenizer belonging to the FTS5 table.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 使用属于 FTS5 表的标记器对文本进行标记化。
- en: '**int (*xQueryPhrase)(Fts5Context*, int iPhrase, void *pUserData, int(*)(const
    Fts5ExtensionApi*,Fts5Context*,void*) )**'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '**int (*xQueryPhrase)(Fts5Context*, int iPhrase, void *pUserData, int(*)(const
    Fts5ExtensionApi*,Fts5Context*,void*) )**'
- en: 'This API function is used to query the FTS table for phrase iPhrase of the
    current query. Specifically, a query equivalent to:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 此 API 函数用于查询当前查询的 FTS 表中的短语 iPhrase。具体来说，等效于以下查询：
- en: '[PRE81]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: with $p set to a phrase equivalent to the phrase iPhrase of the current query
    is executed. Any column filter that applies to phrase iPhrase of the current query
    is included in $p. For each row visited, the callback function passed as the fourth
    argument is invoked. The context and API objects passed to the callback function
    may be used to access the properties of each matched row. Invoking Api.xUserData()
    returns a copy of the pointer passed as the third argument to pUserData.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 执行与当前查询的短语 iPhrase 等效的短语。适用于当前查询的任何列过滤器都包含在 $p 中。访问每个已匹配行的属性时，会调用作为第四个参数传递的回调函数。传递给回调函数的上下文和
    API 对象可用于访问每行的属性。调用 Api.xUserData() 返回传递给 pUserData 的指针的副本。
- en: If parameter iPhrase is less than zero, or greater than or equal to the number
    of phrases in the query, as returned by xPhraseCount(), this function returns
    SQLITE_RANGE.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数 iPhrase 小于零，或大于查询中的短语数（由 xPhraseCount() 返回），此函数返回 SQLITE_RANGE。
- en: If the callback function returns any value other than SQLITE_OK, the query is
    abandoned and the xQueryPhrase function returns immediately. If the returned value
    is SQLITE_DONE, xQueryPhrase returns SQLITE_OK. Otherwise, the error code is propagated
    upwards.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 如果回调函数返回除 SQLITE_OK 之外的任何值，则放弃查询，并立即返回 xQueryPhrase 函数。如果返回值为 SQLITE_DONE，则
    xQueryPhrase 返回 SQLITE_OK。否则，错误代码向上传播。
- en: If the query runs to completion without incident, SQLITE_OK is returned. Or,
    if some error occurs before the query completes or is aborted by the callback,
    an SQLite error code is returned.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 如果查询在没有问题的情况下完成，返回 SQLITE_OK。或者，如果在查询完成之前发生错误，或者被回调中止，则返回 SQLite 错误代码。
- en: '**int (*xSetAuxdata)(Fts5Context*, void *pAux, void(*xDelete)(void*))**'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '**int (*xSetAuxdata)(Fts5Context*, void *pAux, void(*xDelete)(void*))**'
- en: Save the pointer passed as the second argument as the extension function's "auxiliary
    data". The pointer may then be retrieved by the current or any future invocation
    of the same fts5 extension function made as part of the same MATCH query using
    the xGetAuxdata() API.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 将传递的第二个参数保存为扩展函数的“辅助数据”。然后，可以使用 xGetAuxdata() API 在同一 MATCH 查询的当前或任何将来的调用中检索指针。
- en: Each extension function is allocated a single auxiliary data slot for each FTS
    query (MATCH expression). If the extension function is invoked more than once
    for a single FTS query, then all invocations share a single auxiliary data context.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 每个扩展函数为每个 FTS 查询（MATCH 表达式）分配一个辅助数据槽。如果扩展函数在单个 FTS 查询中被调用多次，则所有调用共享一个辅助数据上下文。
- en: If there is already an auxiliary data pointer when this function is invoked,
    then it is replaced by the new pointer. If an xDelete callback was specified along
    with the original pointer, it is invoked at this point.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在调用此函数时已经有辅助数据指针，则将其替换为新指针。 如果在原始指针的同时指定了xDelete回调，则在此时调用它。
- en: The xDelete callback, if one is specified, is also invoked on the auxiliary
    data pointer after the FTS5 query has finished.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成FTS5查询后，还会在辅助数据指针上调用xDelete回调（如果指定了回调）。
- en: If an error (e.g. an OOM condition) occurs within this function, the auxiliary
    data is set to NULL and an error code returned. If the xDelete parameter was not
    NULL, it is invoked on the auxiliary data pointer before returning.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在此函数中发生错误（例如OOM条件），则辅助数据设置为NULL，并返回错误代码。 如果xDelete参数不为NULL，则在返回之前调用辅助数据指针。
- en: '**void *(*xGetAuxdata)(Fts5Context*, int bClear)**'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '**void *(*xGetAuxdata)(Fts5Context*, int bClear)**'
- en: Returns the current auxiliary data pointer for the fts5 extension function.
    See the xSetAuxdata() method for details.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 返回fts5扩展函数的当前辅助数据指针。 有关详细信息，请参阅xSetAuxdata()方法。
- en: If the bClear argument is non-zero, then the auxiliary data is cleared (set
    to NULL) before this function returns. In this case the xDelete, if any, is not
    invoked.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 如果bClear参数非零，则在此函数返回之前清除（设置为NULL）辅助数据。 在这种情况下，不调用xDelete（如果有）。
- en: '**int (*xRowCount)(Fts5Context*, sqlite3_int64 *pnRow)**'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '**int (*xRowCount)(Fts5Context*, sqlite3_int64 *pnRow)**'
- en: 'This function is used to retrieve the total number of rows in the table. In
    other words, the same value that would be returned by:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于检索表中的总行数。 换句话说，与以下内容返回的相同值：
- en: '[PRE82]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '**int (*xPhraseFirst)(Fts5Context*, int iPhrase, Fts5PhraseIter*, int*, int*)**'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '**int (*xPhraseFirst)(Fts5Context*, int iPhrase, Fts5PhraseIter*, int*, int*)**'
- en: 'This function is used, along with type Fts5PhraseIter and the xPhraseNext method,
    to iterate through all instances of a single query phrase within the current row.
    This is the same information as is accessible via the xInstCount/xInst APIs. While
    the xInstCount/xInst APIs are more convenient to use, this API may be faster under
    some circumstances. To iterate through instances of phrase iPhrase, use the following
    code:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数与类型Fts5PhraseIter和xPhraseNext方法一起使用，用于在当前行内迭代单个查询短语的所有实例。 这与通过xInstCount/xInst
    API可访问的信息相同。 虽然xInstCount/xInst API更方便使用，但在某些情况下，此API可能更快。 要迭代短语iPhrase的实例，请使用以下代码：
- en: '[PRE83]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The Fts5PhraseIter structure is defined above. Applications should not modify
    this structure directly - it should only be used as shown above with the xPhraseFirst()
    and xPhraseNext() API methods (and by xPhraseFirstColumn() and xPhraseNextColumn()
    as illustrated below).
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: Fts5PhraseIter结构如上所述。 应用程序不应直接修改此结构 - 它应仅如上所示与xPhraseFirst()和xPhraseNext() API方法（以及下面说明的xPhraseFirstColumn()和xPhraseNextColumn()）一起使用。
- en: This API can be quite slow if used with an FTS5 table created with the "detail=none"
    or "detail=column" option. If the FTS5 table is created with either "detail=none"
    or "detail=column" and "content=" option (i.e. if it is a contentless table),
    then this API always iterates through an empty set (all calls to xPhraseFirst()
    set iCol to -1).
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 如果与使用"detail=none"或"detail=column"选项创建的FTS5表一起使用，则此API可能非常慢。 如果使用"detail=none"或"detail=column"和"content="选项创建了FTS5表（即如果它是一个无内容的表），则此API总是遍历一个空集（所有调用xPhraseFirst()都将iCol设置为-1）。
- en: '**void (*xPhraseNext)(Fts5Context*, Fts5PhraseIter*, int *piCol, int *piOff)**'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '**void (*xPhraseNext)(Fts5Context*, Fts5PhraseIter*, int *piCol, int *piOff)**'
- en: See xPhraseFirst above.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 查看上面的xPhraseFirst。
- en: '**int (*xPhraseFirstColumn)(Fts5Context*, int iPhrase, Fts5PhraseIter*, int*)**'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '**int (*xPhraseFirstColumn)(Fts5Context*, int iPhrase, Fts5PhraseIter*, int*)**'
- en: 'This function and xPhraseNextColumn() are similar to the xPhraseFirst() and
    xPhraseNext() APIs described above. The difference is that instead of iterating
    through all instances of a phrase in the current row, these APIs are used to iterate
    through the set of columns in the current row that contain one or more instances
    of a specified phrase. For example:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数和xPhraseNextColumn()类似于上述xPhraseFirst()和xPhraseNext() API。 不同之处在于，这些API用于迭代当前行中包含指定短语的一个或多个列的集合。
    例如：
- en: '[PRE84]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This API can be quite slow if used with an FTS5 table created with the "detail=none"
    option. If the FTS5 table is created with either "detail=none" "content=" option
    (i.e. if it is a contentless table), then this API always iterates through an
    empty set (all calls to xPhraseFirstColumn() set iCol to -1).
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 如果与 "detail=none" 选项一起使用 FTS5 表，则此 API 可能非常慢。如果 FTS5 表使用 "detail=none" "content="
    选项之一创建（即它是一个无内容的表），则此 API 总是通过空集迭代（所有对 xPhraseFirstColumn() 的调用将 iCol 设置为 -1）。
- en: The information accessed using this API and its companion xPhraseFirstColumn()
    may also be obtained using xPhraseFirst/xPhraseNext (or xInst/xInstCount). The
    chief advantage of this API is that it is significantly more efficient than those
    alternatives when used with "detail=column" tables.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此 API 和其配对的 xPhraseFirstColumn() 可以获取的信息也可以通过 xPhraseFirst/xPhraseNext（或 xInst/xInstCount）获得。此
    API 的主要优势在于在与 "detail=column" 表一起使用时比这些替代方法效率显著更高。
- en: '**void (*xPhraseNextColumn)(Fts5Context*, Fts5PhraseIter*, int *piCol)**'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '**void (*xPhraseNextColumn)(Fts5Context*, Fts5PhraseIter*, int *piCol)**'
- en: See xPhraseFirstColumn above.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 参见上文的xPhraseFirstColumn。
- en: '**int (*xQueryToken)(Fts5Context*, int iPhrase, int iToken, const char **ppToken,
    int *pnToken )**'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '**int (*xQueryToken)(Fts5Context*, int iPhrase, int iToken, const char **ppToken,
    int *pnToken )**'
- en: This is used to access token iToken of phrase iPhrase of the current query.
    Before returning, output parameter *ppToken is set to point to a buffer containing
    the requested token, and *pnToken to the size of this buffer in bytes.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于访问当前查询的短语 iPhrase 的令牌 iToken。在返回之前，输出参数 *ppToken 被设置为指向包含请求的令牌的缓冲区，并且 *pnToken
    被设置为此缓冲区的字节数。
- en: If iPhrase or iToken are less than zero, or if iPhrase is greater than or equal
    to the number of phrases in the query as reported by xPhraseCount(), or if iToken
    is equal to or greater than the number of tokens in the phrase, SQLITE_RANGE is
    returned and *ppToken and *pnToken are both zeroed.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 iPhrase 或者 iToken 小于零，或者 iPhrase 大于或等于由 xPhraseCount() 报告的查询中短语的数量，或者 iToken
    等于或大于短语中令牌的数量，则返回 SQLITE_RANGE，并将 *ppToken 和 *pnToken 均归零。
- en: The output text is not a copy of the query text that specified the token. It
    is the output of the tokenizer module. For tokendata=1 tables, this includes any
    embedded 0x00 and trailing data.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 输出文本不是指定令牌的查询文本的副本。它是标记器模块的输出。对于 tokendata=1 的表，这包括任何嵌入的 0x00 和尾随数据。
- en: '**int (*xInstToken)(Fts5Context*, int iIdx, int iToken, const char**, int*)**'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '**int (*xInstToken)(Fts5Context*, int iIdx, int iToken, const char**, int*)**'
- en: This is used to access token iToken of phrase hit iIdx within the current row.
    If iIdx is less than zero or greater than or equal to the value returned by xInstCount(),
    SQLITE_RANGE is returned. Otherwise, output variable (*ppToken) is set to point
    to a buffer containing the matching document token, and (*pnToken) to the size
    of that buffer in bytes. This API is not available if the specified token matches
    a prefix query term. In that case both output variables are always set to 0.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于访问当前行中短语命中 iIdx 的令牌 iToken。如果 iIdx 小于零或大于等于由 xInstCount() 返回的值，将返回 SQLITE_RANGE。否则，输出变量
    (*ppToken) 被设置为指向包含匹配文档令牌的缓冲区，并且 (*pnToken) 设置为该缓冲区的字节数。如果指定的令牌匹配前缀查询项，则此 API
    不可用。在这种情况下，两个输出变量总是设置为 0。
- en: The output text is not a copy of the document text that was tokenized. It is
    the output of the tokenizer module. For tokendata=1 tables, this includes any
    embedded 0x00 and trailing data.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 输出文本不是标记化的文档文本的副本。它是标记器模块的输出。对于 tokendata=1 的表，这包括任何嵌入的 0x00 和尾随数据。
- en: This API can be quite slow if used with an FTS5 table created with the "detail=none"
    or "detail=column" option.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 如果与 "detail=none" 或 "detail=column" 选项一起使用 FTS5 表，则此 API 可能非常慢。
- en: 8\. The fts5vocab Virtual Table Module
  id: totrans-549
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8\. fts5vocab 虚拟表模块
- en: The fts5vocab virtual table module allows users to extract information from
    an FTS5 full-text index directly. The fts5vocab module is a part of FTS5 - it
    is available whenever FTS5 is.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: fts5vocab 虚拟表模块允许用户直接从 FTS5 全文索引中提取信息。 fts5vocab 模块是 FTS5 的一部分 - 在任何情况下都可用。
- en: Each fts5vocab table is associated with a single FTS5 table. An fts5vocab table
    is usually created by specifying two arguments in place of column names in the
    CREATE VIRTUAL TABLE statement - the name of the associated FTS5 table and the
    type of fts5vocab table. Currently there are three types of fts5vocab table; "row",
    "col" and "instance". Unless the fts5vocab table is created within the "temp"
    database, it must be part of the same database as the associated FTS5 table.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 fts5vocab 表与单个 FTS5 表关联。通常通过在 CREATE VIRTUAL TABLE 语句中的列名位置指定两个参数来创建 fts5vocab
    表 - 关联 FTS5 表的名称和 fts5vocab 表的类型。目前有三种类型的 fts5vocab 表；"row"、"col" 和 "instance"。除非
    fts5vocab 表在 "temp" 数据库内创建，否则它必须是与关联的 FTS5 表同一数据库的一部分。
- en: '[PRE85]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'If an fts5vocab table is created in the temp database, it may be associated
    with an FTS5 table in any attached database. In order to attach the fts5vocab
    table to an FTS5 table located in a database other than "temp", the name of the
    database is inserted before the FTS5 table name in the CREATE VIRTUAL TABLE arguments.
    For example:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在临时数据库中创建了一个 fts5vocab 表，则可以将其与任何附加数据库中的 FTS5 表关联起来。为了将 fts5vocab 表附加到位于 "temp"
    之外的数据库中的 FTS5 表，必须在 CREATE VIRTUAL TABLE 参数中的 FTS5 表名之前插入数据库名称。例如：
- en: '[PRE86]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Specifying three arguments when creating an fts5vocab table in any database
    other than "temp" results in an error.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 在除了 "temp" 之外的任何数据库中创建 fts5vocab 表时指定三个参数将导致错误。
- en: 'An fts5vocab table of type "row" contains one row for each distinct term in
    the associated FTS5 table. The table columns are as follows:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 类型为 "row" 的 fts5vocab 表包含关联 FTS5 表中每个不同术语的一行。表列如下：
- en: '| Column | Contents |'
  id: totrans-557
  prefs: []
  type: TYPE_TB
  zh: '| Column | 内容 |'
- en: '| term | The term, as stored in the FTS5 index. |'
  id: totrans-558
  prefs: []
  type: TYPE_TB
  zh: '| term | 存储在 FTS5 索引中的术语。 |'
- en: '| doc | The number of rows that contain at least one instance of the term.
    |'
  id: totrans-559
  prefs: []
  type: TYPE_TB
  zh: '| doc | 包含至少一个术语实例的行数。 |'
- en: '| cnt | The total number of instances of the term in the entire FTS5 table.
    |'
  id: totrans-560
  prefs: []
  type: TYPE_TB
  zh: '| cnt | 整个 FTS5 表中术语实例的总数。 |'
- en: 'An fts5vocab table of type "col" contains one row for each distinct term/column
    combination in the associated FTS5 table. Table columns are as follows:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 类型为 "col" 的 fts5vocab 表包含关联 FTS5 表中每个不同术语/列组合的一行。表列如下：
- en: '| Column | Contents |'
  id: totrans-562
  prefs: []
  type: TYPE_TB
  zh: '| Column | 内容 |'
- en: '| term | The term, as stored in the FTS5 index. |'
  id: totrans-563
  prefs: []
  type: TYPE_TB
  zh: '| term | 存储在 FTS5 索引中的术语。 |'
- en: '| col | The name of the FTS5 table column that contains the term. |'
  id: totrans-564
  prefs: []
  type: TYPE_TB
  zh: '| col | 包含术语的 FTS5 表列名。 |'
- en: '| doc | The number of rows in the FTS5 table for which column $col contains
    at least one instance of the term. |'
  id: totrans-565
  prefs: []
  type: TYPE_TB
  zh: '| doc | FTS5 表中列 $col 包含至少一个术语实例的行数。 |'
- en: '| cnt | The total number of instances of the term that appear in column $col
    of the FTS5 table (considering all rows). |'
  id: totrans-566
  prefs: []
  type: TYPE_TB
  zh: '| cnt | FTS5 表列 $col 中出现的术语实例的总数（考虑所有行）。 |'
- en: 'An fts5vocab table of type "instance" contains one row for each term instance
    stored in the associated FTS index. Assuming the FTS5 table is created with the
    ''detail'' option set to ''full'', table columns are as follows:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 类型为 "instance" 的 fts5vocab 表包含与关联的 FTS 索引中存储的每个术语实例对应的一行。假设 FTS5 表创建时选项 'detail'
    设置为 'full'，表列如下：
- en: '| Column | Contents |'
  id: totrans-568
  prefs: []
  type: TYPE_TB
  zh: '| Column | 内容 |'
- en: '| term | The term, as stored in the FTS5 index. |'
  id: totrans-569
  prefs: []
  type: TYPE_TB
  zh: '| term | 存储在 FTS5 索引中的术语。 |'
- en: '| doc | The rowid of the document that contains the term instance. |'
  id: totrans-570
  prefs: []
  type: TYPE_TB
  zh: '| doc | 包含术语实例的文档的 rowid。 |'
- en: '| col | The name of the column that contains the term instance. |'
  id: totrans-571
  prefs: []
  type: TYPE_TB
  zh: '| col | 包含术语实例的列的名称。 |'
- en: '| offset | The index of the term instance within its column. Terms are numbered
    in order of occurrence starting from 0. |'
  id: totrans-572
  prefs: []
  type: TYPE_TB
  zh: '| offset | 术语实例在其列中的索引。术语按出现顺序编号，从 0 开始。 |'
- en: If the FTS5 table is created with the 'detail' option set to 'col', then the
    *offset* column of an instance virtual table always contains NULL. In this case
    there is one row in the table for each unique term/doc/col combination. Or, if
    the FTS5 table is created with 'detail' set to 'none', then both *offset* and
    *col* always contain NULL values. For detail=none FTS5 tables, there is one row
    in the fts5vocab table for each unique term/doc combination.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 FTS5 表创建时选项 'detail' 设置为 'col'，则实例虚拟表的 *offset* 列始终包含 NULL。在这种情况下，对于每个唯一的术语/文档/列组合，表中有一行。或者，如果
    FTS5 表的 'detail' 设置为 'none'，则 *offset* 和 *col* 始终包含 NULL 值。对于 detail=none 的 FTS5
    表，fts5vocab 表中每个唯一的术语/文档组合都有一行。
- en: 'Example:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE87]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 9\. FTS5 Data Structures
  id: totrans-576
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9\. FTS5 数据结构
- en: This section describes at a high-level the way the FTS module stores its index
    and content in the database. It is not necessary to read or understand the material
    in this section in order to use FTS in an application. However, it may be useful
    to application developers attempting to analyze and understand FTS performance
    characteristics, or to developers contemplating enhancements to the existing FTS
    feature set.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 本节概述了 FTS 模块如何在数据库中存储其索引和内容的高级方式。并非使用 FTS 在应用程序中必须阅读或理解的材料。但对于试图分析和理解 FTS 性能特性的应用程序开发人员，或者考虑增强现有
    FTS 功能集的开发人员可能是有用的。
- en: When an FTS5 virtual table is created in a database, between 3 and 5 real tables
    are created in the database. These are known as "[shadow tables](vtab.html#xshadowname)",
    and are used by the virtual table module to store persistent data. They should
    not be accessed directly by the user. Many other virtual table modules, including
    [FTS3](fts3.html) and [rtree](rtree.html), also create and use shadow tables.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据库中创建了 FTS5 虚拟表时，会创建 3 到 5 个真实表。这些被称为“[影子表](vtab.html#xshadowname)”，由虚拟表模块用于存储持久化数据。用户不应直接访问这些表。许多其他虚拟表模块，包括
    [FTS3](fts3.html) 和 [rtree](rtree.html)，也创建和使用影子表。
- en: FTS5 creates the following shadow tables. In each case the actual table name
    is based on the name of the FTS5 virtual table (in the following, replace % with
    the name of the virtual table to find the actual shadow table name).
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: FTS5 创建以下影子表。在每种情况下，实际表名基于 FTS5 虚拟表的名称（在下文中，用虚拟表的名称替换 % 来找到实际影子表名称）。
- en: '[PRE88]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The following sections describe in more detail how these five tables are used
    to store FTS5 data.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的章节更详细地描述了这五个表如何用于存储 FTS5 数据。
- en: 9.1\. Varint Format
  id: totrans-582
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1\. 变长整数格式
- en: The sections below refer to 64-bit signed integers stored in "varint" form.
    FTS5 uses the same varint format as used in various places by the SQLite core.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的章节提到以“变长整数”形式存储的 64 位有符号整数。FTS5 使用与 SQLite 核心中各处使用的相同变长整数格式。
- en: 'A varint is between 1 and 9 bytes in length. The varint consists of either
    zero or more bytes which have the high-order bit set followed by a single byte
    with the high-order bit clear, or nine bytes, whichever is shorter. The lower
    seven bits of each of the first eight bytes and all 8 bits of the ninth byte are
    used to reconstruct the 64-bit twos-complement integer. Varints are big-endian:
    bits taken from the earlier byte of the varint are more significant than bits
    taken from the later bytes.'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 变长整数的长度在 1 到 9 字节之间。变长整数由设置了高位的零个或多个字节，后跟一个高位清除的单个字节，或九个字节（以较短者为准）组成。前八个字节的低七位和第九个字节的所有
    8 位用于重构 64 位二进制补码整数。变长整数是大端序的：从变长整数的早期字节中获取的位比后续字节中获取的位更重要。
- en: 9.2\. The FTS Index (%_idx and %_data tables)
  id: totrans-585
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2\. FTS 索引（%_idx 和 %_data 表）
- en: 'The FTS index is an ordered key-value store where the keys are document terms
    or term prefixes and the associated values are "doclists". A doclist is a packed
    array of varints that encodes the position of each instance of the term within
    the FTS5 table. The position of a single term instance is defined as the combination
    of:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: FTS 索引是一个有序的键-值存储，其中键是文档术语或术语前缀，相关的值是“文档列表”。文档列表是一个编码了每个术语实例在 FTS5 表内位置的紧凑数组的变长整数。单个术语实例的位置定义为以下组合：
- en: The rowid of the FTS5 table row it appears in,
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 出现在 FTS5 表行中的 rowid，
- en: The index of the column the term instance appears in (columns are numbered from
    left to right starting from zero), and
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 术语实例出现的列的索引（列从左到右编号，从零开始），以及
- en: The offset of the term within the column value (i.e. the number of tokens that
    appear within the column value before this one).
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 术语在列值中的偏移（即在此之前列值中出现的标记数）。
- en: The FTS index contains up to (nPrefix+1) entries for each token in the data
    set, where nPrefix is the number of defined [prefix indexes](#prefix_indexes).
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: FTS 索引对于数据集中的每个标记最多包含（nPrefix+1）个条目，其中 nPrefix 是定义的 [前缀索引](#prefix_indexes)
    的数量。
- en: Keys associated with the main FTS index (the one that is not a prefix index)
    are prefixed with the character "0". Keys for the first prefix index are prefixed
    with "1". Keys for the second prefix index are prefixed with "2", and so on. For
    example, if the token "document" is inserted into an FTS5 table with [prefix indexes](#prefix_indexes)
    specified by prefix="2 4", then the keys added to the FTS index would be "0document",
    "1do" and "2docu".
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 与主 FTS 索引关联的键（不是前缀索引的那个）以字符“0”作为前缀。第一个前缀索引的键以“1”作为前缀，第二个前缀索引的键以“2”作为前缀，依此类推。例如，如果将“document”令牌插入具有指定前缀索引的
    FTS5 表，前缀为“2 4”，则添加到 FTS 索引的键将是“0document”、“1do”和“2docu”。
- en: The FTS index entries are not stored in a single tree or hash table structure.
    Instead, they are stored in a series of immutable b-tree like structures referred
    to as "segment b-trees". Each time a write to the FTS5 table is committed, one
    or more (but usually just one) new segment b-trees are added containing both the
    new entries and tombstones for any deleted entries. When the FTS index is queried,
    the reader queries each segment b-tree in turn and merges the results, giving
    priority to newer data.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: FTS 索引条目未存储在单一的树或哈希表结构中。相反，它们存储在一系列不可变的类似 b 树的结构中，称为“段 b 树”。每当提交对 FTS5 表的写入时，会添加一个或多个（通常只有一个）新的段
    b 树，其中包含新条目以及任何已删除条目的墓碑。查询 FTS 索引时，阅读器依次查询每个段 b 树并合并结果，优先考虑较新的数据。
- en: Each segment b-tree is assigned a numerical level. When a new segment b-tree
    is written to the database as part of committing a transaction, it is assigned
    to level 0\. Segment b-trees belonging to a single level are periodically merged
    together to create a single, larger segment b-tree that is assigned to the next
    level (i.e. level 0 segment b-trees are merged to become a single level 1 segment
    b-tree). Thus the numerically larger levels contain older data in (usually) larger
    segment b-trees. Refer to the ['automerge'](#the_automerge_configuration_option),
    ['crisismerge'](#the_crisismerge_configuration_option) and ['usermerge'](#the_usermerge_configuration_option)
    options, along with the ['merge'](#the_merge_command) and ['optimize'](#the_optimize_command)
    commands for details on how to control the merging.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 每个段 b 树被分配一个数值级别。当作为提交事务的一部分将新的段 b 树写入数据库时，它被分配到级别 0\. 属于单个级别的段 b 树会定期合并在一起，形成一个更大的段
    b 树，分配到下一个级别（即级别 0 的段 b 树会合并成一个单一的级别 1 段 b 树）。因此，数值较大的级别包含较旧的数据，通常是较大的段 b 树。详细信息请参考['automerge'](#the_automerge_configuration_option)、['crisismerge'](#the_crisismerge_configuration_option)和['usermerge'](#the_usermerge_configuration_option)选项，以及['merge'](#the_merge_command)和['optimize'](#the_optimize_command)命令，了解如何控制合并操作。
- en: 'In cases where the doclist associated with a term or term prefix is very large,
    there may be an associated [doclist index](#doclist_index_format). A doclist index
    is similar to the set of internal nodes of a b-tree. It allows a large doclist
    to be efficiently queried for rowids or ranges of rowids. For example, when processing
    a query like:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 在与术语或术语前缀关联的 doclist 非常大的情况下，可能会存在关联的[doclist 索引](#doclist_index_format)。doclist
    索引类似于 b 树的内部节点集合。它允许有效地查询包含所需范围内的 rowid 或 rowid 范围的大 doclist。例如，在处理像以下查询时：
- en: '[PRE89]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: FTS5 uses the segment b-tree index to locate the doclist for term "term", then
    uses its doclist index (assuming it is present) to efficiently identify the subset
    of matches with rowids in the required range.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: FTS5 使用段 b 树索引定位术语“term”的 doclist，然后使用其 doclist 索引（假设存在）高效识别子集，其 rowid 在所需范围内。
- en: 9.2.1\. The %_data Table Rowid Space
  id: totrans-597
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.1\. %_data 表 Rowid 空间
- en: '[PRE90]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The %_data table is used to store three types of records:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '%_data 表用于存储三种类型的记录：'
- en: The special [structure record](#structure_record_format), stored with id=10.
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特殊的[结构记录](#structure_record_format)，存储在 id=10。
- en: The special [averages record](#averages_record_format), stored with id=1.
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特殊的[平均记录](#averages_record_format)，存储在 id=1。
- en: A record to store each [segment b-tree](#segment_b_tree_format) leaf and [doclist
    index](#doclist_index_format) leaf and internal node. See below for how id values
    are calculated for these records.
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录用于存储每个[段 b 树](#segment_b_tree_format)叶子和[doclist 索引](#doclist_index_format)叶子和内部节点。有关如何为这些记录计算
    id 值，请参见下文。
- en: Each segment b-tree in the system is assigned a unique 16-bit segment id. Segment
    ids may only be reused after the original owner segment b-tree is completely merged
    into a higher level segment b-tree. Within a segment b-tree, each leaf page is
    assigned a unique page number - 1 for the first leaf page, 2 for the second, and
    so on.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 系统中的每个段B树都被分配一个唯一的16位段ID。只有在原始所有者段B树完全合并到更高级别段B树之后，才能重新使用段ID。在段B树内部，每个叶页分配一个唯一的页号
    - 第一个叶页为1，第二个为2，依此类推。
- en: Each doclist index leaf page is also assigned a page number. The first (leftmost)
    leaf page in a doclist index is assigned the same page number as the segment b-tree
    leaf page on which its term appears (because doclist indexes are only created
    for terms with very long doclists, at most one term per segment b-tree leaf has
    an associated doclist index). Call this page number P. If the doclist is so large
    that it requires a second leaf, the second leaf is assigned page number P+1\.
    The third leaf P+2\. Each tier of a doclist index b-tree (leaves, parents of leaves,
    grandparents etc.) is assigned page numbers in this fashion, starting with page
    number P.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 每个doclist索引叶页也分配一个页号。在doclist索引中，第一个（最左边的）叶页分配与其术语出现的段B树叶页相同的页号（因为仅为具有非常长doclist的术语创建doclist索引，每个段B树叶最多有一个相关联的doclist索引）。将此页号称为P。如果doclist太大，需要第二个叶页，则第二个叶页分配页号P+1。第三个叶页分配页号P+2。每个doclist索引B树层级（叶页、叶页的父节点、祖父节点等）都以此方式分配页号，从页号P开始。
- en: 'The "id" value used in the %_data table to store any given segment b-tree leaf
    or doclist index leaf or node is composed as follows:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 在%_data表中用于存储任何给定段B树叶或doclist索引叶或节点的“id”值如下组成：
- en: '| Rowid Bits | Contents |'
  id: totrans-606
  prefs: []
  type: TYPE_TB
  zh: '| Rowid Bits | 内容 |'
- en: '| 38..43 | (16 bit) Segment b-tree id value. |'
  id: totrans-607
  prefs: []
  type: TYPE_TB
  zh: '| 38..43 |（16位）段B树ID值。|'
- en: '| 37 | (1 bit) Doclist index flag. Set for doclist index pages, clear for segment
    b-tree leaves. |'
  id: totrans-608
  prefs: []
  type: TYPE_TB
  zh: '| 37 |（1位）Doclist索引标志。对于doclist索引页面设置，对于段B树叶清除。|'
- en: '| 32..36 | (5 bits) Height in tree. This is set to 0 for segment b-tree and
    doclist index leaves, to 1 for the parents of doclist index leaves, 2 for the
    grandparents, etc. |'
  id: totrans-609
  prefs: []
  type: TYPE_TB
  zh: '| 32..36 |（5位）树高度。对于段B树和doclist索引叶，此值设置为0，对于doclist索引叶的父节点设置为1，对于祖父节点设置为2，依此类推。|'
- en: '| 0..31 | (32 bits) Page number |'
  id: totrans-610
  prefs: []
  type: TYPE_TB
  zh: '| 0..31 |（32位）页号 |'
- en: 9.2.2\. Structure Record Format
  id: totrans-611
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.2\. 结构记录格式
- en: 'The structure record identifies the set of segment b-trees that make up the
    current FTS index, along with details of any ongoing incremental merge operations.
    It is stored in the %_data table with id=10. A structure record begins with a
    single 32-bit unsigned value - the cookie value. This value is incremented each
    time the structure is modified. Following the cookie value are three varint values,
    as follows:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 结构记录标识组成当前FTS索引的段B树集合，以及任何正在进行的增量合并操作的详细信息。它存储在带有id=10的%_data表中。结构记录以单个32位无符号值
    - cookie值开始。每次修改结构时，此值递增。接下来是三个varint值，如下所示：
- en: The number of levels in the index (i.e. the maximum level associated with any
    segment b-tree plus one).
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引中的级别数（即与任何段B树相关联的最大级别加一）。
- en: The total number of segment b-trees in the index.
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引中段B树的总数。
- en: The total number of segment b-tree leaves written to level 0 trees since the
    FTS5 table was created.
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自FTS5表创建以来写入到0级树的段B树叶的总数。
- en: 'Then, for each level from 0 to nLevel:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于从0到nLevel的每个级别：
- en: The number of input segments from the previous level being used as inputs for
    the current incremental merge, or zero if there is no ongoing incremental merge
    to create a new segment b-tree for this level.
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自前一级别的输入段数，作为当前增量合并的输入，如果没有正在进行的增量合并来为此级别创建新的段B树，则为零。
- en: The total number of segment b-trees on the level.
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此级别上段B树的总数。
- en: 'Then, for each segment b-tree, from oldest to newest:'
  id: totrans-619
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，对于每个段B树，从最老到最新：
- en: The segment id.
  id: totrans-620
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 段ID。
- en: Page number of first leaf (often 1, always >0).
  id: totrans-621
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个叶页的页号（通常为1，始终 >0）。
- en: Page number of last leaf (always >0).
  id: totrans-622
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个叶页的页号（始终 >0）。
- en: 9.2.3\. Averages Record Format
  id: totrans-623
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.3\. 平均记录格式
- en: The averages record, which is always stored with id=1 in the %_data table, does
    not store the average of anything. Instead, it contains a vector of (nCol+1) packed
    varint values, where nCol is the number of columns in the FTS5 table, including
    unindexed columns. The first varint contains the total number of rows in the FTS5
    table. The second contains the total number of tokens in all values stored in
    the leftmost FTS5 table column. The third the number of tokens in all values for
    the next leftmost, and so on. The value for unindexed columns is always zero.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 平均记录始终存储在%_data表中的id=1中，并不存储任何内容的平均值。相反，它包含一个（nCol+1）个打包变长整数值的向量，其中nCol是FTS5表中的列数，包括未索引的列。第一个变长整数包含FTS5表中的总行数。第二个包含左侧FTS5表列中存储的所有值的总标记数。第三个包含下一个左侧列中所有值的标记数，依此类推。未索引列的值始终为零。
- en: 9.2.4\. Segment B-Tree Format
  id: totrans-625
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.4\. 段B-Tree格式
- en: 9.2.4.1\. The Key/Doclist Format
  id: totrans-626
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.4.1\. 键/文档列表格式
- en: The key/doclist format is a format used to store a series of keys (document
    terms or term prefixes prefixed by a single character to indentify the specific
    index to which they belong) in sorted order, each with their associated doclist.
    The format consists of alternating keys and doclists packed together.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 键/文档列表格式是用于按排序顺序存储一系列键（文档术语或术语前缀，由单个字符前缀标识其所属的特定索引）及其关联文档列表的格式。该格式由紧密打包的交替键和文档列表组成。
- en: 'The first key is stored as:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个键存储为：
- en: A varint indicating the number of bytes in the key (N), followed by
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示键中字节数（N）的变长整数（varint），接着是
- en: The key data itself (N bytes).
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键数据本身（N 字节）。
- en: 'Each subsequent key is stored as:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 每个后续键存储为：
- en: A varint indicating the size of the prefix that the key has in common with the
    previous key in bytes,
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示与前一个键具有共同前缀的前缀大小的变长整数（varint）（以字节为单位），
- en: A varint indicating the number of bytes in the key following the common prefix
    (N), followed by
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示在共同前缀后的键字节数（N）的变长整数（varint），接着是
- en: The key suffix data itself (N bytes).
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键后缀数据本身（N 字节）。
- en: For example, if the first two keys in an FTS5 key/doclist record are "0challenger"
    and "0chandelier", then the first key is stored as varint 11 followed by the 11
    bytes "0challenger", and the second key is stored as varints 4 and 7, followed
    by the 7 bytes "ndelier".
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果FTS5键/文档列表记录中的前两个键是"0challenger"和"0chandelier"，则第一个键存储为变长整数11，后跟11字节的"0challenger"，第二个键存储为变长整数4和7，后跟7字节的"ndelier"。
- en: <svg class="pikchr" viewBox="0 0 956.102 126.72"><text x="293" y="63" text-anchor="middle"
    fill="rgb(0,0,0)" dominant-baseline="central">doclist 0</text> <text x="682" y="63"
    text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">doclist 1</text>
    <text x="892" y="63" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">key/doclist 2...</text>
    <text x="120" y="114" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">key 0 data</text>
    <text x="77" y="12" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">key 0 size (varint)</text>
    <text x="358" y="114" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">key 1 prefix size (varint)</text>
    <text x="480" y="12" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">key 1 suffix size (varint)</text>
    <text x="585" y="114" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">key 1 prefix data</text></svg>
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="pikchr" viewBox="0 0 956.102 126.72"><text x="293" y="63" text-anchor="middle"
    fill="rgb(0,0,0)" dominant-baseline="central">文档列表 0</text> <text x="682" y="63"
    text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">文档列表 1</text>
    <text x="892" y="63" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">键/文档列表 2...</text>
    <text x="120" y="114" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">键 0 数据</text>
    <text x="77" y="12" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">键 0 大小（变长整数）</text>
    <text x="358" y="114" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">键 1 前缀大小（变长整数）</text>
    <text x="480" y="12" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">键 1 后缀大小（变长整数）</text>
    <text x="585" y="114" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">键 1 前缀数据</text></svg>
- en: '*Figure 1 - Term/Doclist Format*'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1 - 术语/文档列表格式*'
- en: Each doclist identifies the rows (by their rowid values) that contain at least
    one instance of the term or term prefix and an associated position list, or "poslist"
    enumerating the position of each term instance within the row. In this sense a
    "position" is defined as a column number and term offset within the column value.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文档列表标识包含术语或术语前缀的至少一个实例的行（通过其rowid值），以及一个名为"poslist"的关联位置列表，列出每个术语实例在行内的位置。在这种情况下，“位置”定义为列号和列值内术语的偏移量。
- en: Within a doclist, documents are always stored in order sorted by rowid. The
    first rowid in a doclist is stored as is, as a varint. It is immediately followed
    by its associated position list. Following this, the difference between the first
    rowid and the second, as a varint, followed by the doclist associated with the
    second rowid in the doclist. And so on.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 在文档列表中，文档始终按照rowid排序存储。文档列表中的第一个rowid按原样存储，作为一个varint。紧接着存储其关联的位置列表。随后，以varint形式存储第一个rowid与第二个rowid之间的差值，然后是文档列表中第二个rowid的相关文档。依此类推。
- en: There is no way to determine the size of a doclist by parsing it. This must
    be stored externally. See the [section below](#data_pagination) for details of
    how this is accomplished in FTS5.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 无法通过解析来确定文档列表的大小。这必须以外部方式存储。详见下文关于如何在FTS5中实现的[部分](#data_pagination)。
- en: <svg class="pikchr" viewBox="0 0 889.459 79.92"><text x="233" y="63" text-anchor="middle"
    fill="rgb(0,0,0)" dominant-baseline="central">position list 0</text> <text x="564"
    y="63" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">position list 1</text>
    <text x="822" y="63" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">position list 2...</text>
    <text x="67" y="12" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">rowid 0 (varint)</text>
    <text x="398" y="12" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">rowid 1 (delta-encoded varint)</text>
    <text x="730" y="12" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">rowid 3 (delta-encoded varint)</text></svg>
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="pikchr" viewBox="0 0 889.459 79.92"><text x="233" y="63" text-anchor="middle"
    fill="rgb(0,0,0)" dominant-baseline="central">位置列表 0</text> <text x="564" y="63"
    text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">位置列表 1</text>
    <text x="822" y="63" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">位置列表 2...</text>
    <text x="67" y="12" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">rowid 0 (varint)</text>
    <text x="398" y="12" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">rowid 1 (变量编码的varint)</text>
    <text x="730" y="12" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">rowid 3 (变量编码的varint)</text></svg>
- en: '*Figure 2 - Doclist Format*'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2 - 文档列表格式*'
- en: 'A position list - often shortened to "poslist" - identifies the column and
    token offset within the row of each instance of the token in question. The format
    of a poslist is:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 一个位置列表（通常简称为“poslist”），用于标识所讨论标记的每个实例在行内的列和标记偏移量。位置列表的格式如下：
- en: Varint set to twice the size of the poslist, not including this field, plus
    one if the "delete" flag is set on the entry.
  id: totrans-644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置为poslist大小的两倍，不包括此字段，如果条目上设置了“删除”标志，再加一。
- en: 'A (possibly empty) list of offsets for column 0 (the leftmost column) of the
    row. Each offset is stored as a varint. The first varint contains the value of
    the first offset, plus 2\. The second variant contains the difference between
    the second and first offsets, plus 2\. etc. For example, if the offset list is
    to contain offsets 0, 10, 15 and 16, it is encoded by packing the following values,
    encoded as varints, end to end:'
  id: totrans-645
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列0（最左列）的偏移列表（可能为空）。每个偏移都存储为varint。第一个varint包含第一个偏移值加2。第二个varint包含第二个和第一个偏移之间的差值加2。例如，如果偏移列表包含偏移0、10、15和16，则编码为连续的varint值：
- en: '[PRE91]'
  id: totrans-646
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'For each column other than column 0 that contains one of more instances of
    the token:'
  id: totrans-647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于除列0之外的每列包含标记的列：
- en: Byte value 0x01.
  id: totrans-648
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字节值0x01。
- en: The column number, as a varint.
  id: totrans-649
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列号，作为varint。
- en: An offset list, in the same format as the offset list for column 0.
  id: totrans-650
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个与列0的偏移列表格式相同的偏移列表。
- en: <svg class="pikchr" viewBox="0 0 785.606 133.92"><text x="265" y="63" text-anchor="middle"
    fill="rgb(0,0,0)" dominant-baseline="central">col 0 offset-list</text> <text x="430"
    y="63" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">0x01</text>
    <text x="639" y="63" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">col i offset-list</text>
    <text x="99" y="12" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">nSize*2 + bDel (varint)</text>
    <text x="473" y="12" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">column number (i)</text>
    <text x="452" y="121" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">nSize bytes</text></svg>
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="pikchr" viewBox="0 0 785.606 133.92"><text x="265" y="63" text-anchor="middle"
    fill="rgb(0,0,0)" dominant-baseline="central">col 0 offset-list</text> <text x="430"
    y="63" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">0x01</text>
    <text x="639" y="63" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">col i offset-list</text>
    <text x="99" y="12" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">nSize*2 + bDel (varint)</text>
    <text x="473" y="12" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">第i列偏移列表</text>
    <text x="452" y="121" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">nSize字节</text></svg>
- en: '*Figure 3 - Position List (poslist) With Offsets in Columns 0 and i*'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3 - 带有列0和i中的偏移量的位置列表（poslist）*'
- en: 9.2.4.2\. Pagination
  id: totrans-653
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.4.2\. 分页
- en: If it is small enough (by default this means smaller than 4000 bytes), the entire
    contents of a segment b-tree may be stored in the key/doclist format described
    in the previous section as a single blob within the %_data table. Otherwise, the
    key/doclist is split into pages (by default, of approximately 4000 bytes each)
    and stored in a contiguous set of entries in the %_data table ([see above](#data_structure)
    for details).
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 如果大小足够小（默认情况下意味着小于4000字节），则段B树的整个内容可以作为单个Blob存储在前一节描述的关键字/文档列表格式中。否则，关键字/文档列表将被分割成页面（默认情况下每个页面约4000字节），并存储在%_data表的连续条目中（详见上述“数据结构”部分）。
- en: 'When a key/doclist is divided into pages, the following modifications are made
    to the format:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 当关键字/文档列表被分割成页面时，将对格式进行以下修改：
- en: A single varint or key data field never spans two pages.
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个变长整数或关键数据字段不会跨越两个页面。
- en: The first key on each page is not prefix-compressed. It is stored in the format
    described above for the first key of a doclist - its size as a varint followed
    by the key data.
  id: totrans-657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个页面上的第一个关键字不进行前缀压缩。它按照上述文档列表第一个关键字的格式进行存储 - 作为一个变长整数后跟关键字数据的大小。
- en: If there are one or more rowids on a page before the first key, then the first
    of them is not delta compressed. It is stored as is, just as if it were the first
    rowid of its doclist (which it may or may not be).
  id: totrans-658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果页面上第一个关键字之前存在一个或多个行标识值，则其中的第一个不会进行增量压缩。它会按原样存储，就好像它是其文档列表中的第一个行标识值（这可能是或可能不是）。
- en: 'Each page also has fixed-size 4-byte header and a variably-sized footer. The
    header is divided into 2 16-bit big-endian integer fields. They contain:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 每个页面还有固定大小的4字节头和可变大小的页脚。头部分为2个16位大端整数字段。它们包含：
- en: The byte offset of the first rowid value on the page, if it occurs before the
    first key, or 0 otherwise.
  id: totrans-660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面上第一个行标识值的字节偏移量（如果出现在第一个关键字之前），否则为0。
- en: The byte offset of the page footer.
  id: totrans-661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面页脚的字节偏移量。
- en: The page footer consists of a series of varints containing the byte offset of
    each key that appears on the page. The page footer is zero bytes in size if there
    are no keys on the page.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 页面页脚由一系列包含页面上每个关键字的字节偏移量的变长整数组成。如果页面上没有关键字，则页面页脚的大小为零字节。
- en: <svg class="pikchr" viewBox="0 0 721.267 79.92"><text x="32" y="16" text-anchor="middle"
    fill="rgb(0,0,0)" dominant-baseline="central">hdr</text> <text x="342" y="16"
    text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">modified key/doclist data</text>
    <text x="666" y="16" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">footer</text>
    <text x="32" y="67" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">4 bytes</text>
    <text x="666" y="67" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">variable size</text></svg>
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="pikchr" viewBox="0 0 721.267 79.92"><text x="32" y="16" text-anchor="middle"
    fill="rgb(0,0,0)" dominant-baseline="central">hdr</text> <text x="342" y="16"
    text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">修改后的关键字/文档列表数据</text>
    <text x="666" y="16" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">footer</text>
    <text x="32" y="67" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">4字节</text>
    <text x="666" y="67" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">可变大小</text></svg>
- en: '*Figure 4 - Page Format*'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4 - 页面格式*'
- en: 9.2.4.3\. Segment Index Format
  id: totrans-665
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.4.3\. 段索引格式
- en: 'The result of formatting the contents of the segment b-tree in the key/doclist
    format and then splitting it into pages is something very similar to the leaves
    of a b+tree. Instead of creating a format for the internal nodes of this b+tree
    and storing them in the %_data table alongside the leaves, the keys that would
    have been stored on such nodes are added to the %_idx table, defined as:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 将段B树的内容按关键字/文档列表格式进行格式化，然后分割成页面的结果，与B+树的叶子非常相似。而不是为这个B+树的内部节点创建格式，并将它们与叶子一起存储在%_data表中，应将本来将存储在这些节点上的关键字添加到%_idx表中，定义如下：
- en: '[PRE92]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'For each "leaf" page that contains at least one key, an entry is added to the
    %_idx table. Fields are set as follows:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个包含至少一个关键字的“叶子”页面，将向%_idx表添加一条条目。字段设置如下：
- en: '| Column | Contents |'
  id: totrans-669
  prefs: []
  type: TYPE_TB
  zh: '| Column | 内容 |'
- en: '| segid | The integer segment id. |'
  id: totrans-670
  prefs: []
  type: TYPE_TB
  zh: '| segid | 整数段标识。 |'
- en: '| term | The smallest prefix of the first key on the page that is larger than
    all keys on the previous page. For the first page in a segment, this prefix is
    zero bytes in size. |'
  id: totrans-671
  prefs: []
  type: TYPE_TB
  zh: '| term | 页面上第一个关键字的最小前缀，该前缀比前一页上的所有关键字都大。对于段中的第一页，此前缀的大小为零字节。 |'
- en: '| pgno | This field encodes both the page number (within the segment - starting
    from 1) and the doclist index flag. The doclist index flag is set if the final
    key on the page has an [associated doclist index](#doclist_index_format). The
    value of this field is:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 文档列表索引叶子和内部节点使用相同的页面格式。第一个字节是“标志”字节。对于文档列表索引B树的根页面，设置为0x00，对于所有其他页面，设置为0x01。页面的其余部分是一系列紧密打包的变长整数，如下所示：
- en: '[PRE93]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '|'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 许多常见的搜索结果排名函数需要作为输入的结果文档中的令牌大小（因为在短文档中作为搜索词的命中被认为比长文档中的命中更重要）。为了提供对此信息的快速访问，在FTS5表中的每一行都存在一个相应的记录（具有相同的rowid），在%_docsize阴影表中包含该行中每个列值的令牌大小。
- en: 'Then, to find the leaf for segment i that may contain term t, instead of searching
    through internal nodes, FTS5 runs the query:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了找到可能包含术语t的段i的叶子页，而不是通过内部节点搜索，FTS5运行查询：
- en: '[PRE94]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 9.2.4.4\. Doclist Index Format
  id: totrans-677
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 如果子页面上没有rowid（这只能发生在“子”页面实际上是段B树叶页时），则为0x00，或
- en: The segment index described in the [previous section](#data_term_index) allows
    a segment b-tree to be efficiently queried by term or, assuming there is a prefix
    index of the required size, a term prefix. The data structure described in this
    section, doclist indexes, allows FTS5 to efficiently search for a rowid or range
    or rowids within the doclist associated with a single term or term prefix.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 在[上一节](#data_term_index)中描述的段索引允许段B树通过术语或前提条件索引高效查询。本节描述的数据结构，文档列表索引，允许FTS5高效地搜索与单个术语或术语前缀相关联的文档列表内的rowid或rowid范围。
- en: Not all keys have associated doclists indexes. By default, a doclist index is
    only added for a key if its doclist spans more than 4 segment b-tree leaf pages.
    Doclist indexes are themselves b-trees, with both leaves and internal nodes stored
    as entries in the %_data table, but in practice most doclists are small enough
    to fit on a single leaf. FTS5 uses the same rough size for doclist index node
    and leaves as it does for segment b-tree leaves (by default 4000 bytes).
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有键都有相关的文档列表索引。默认情况下，只有当键的文档列表跨越超过4个段B树叶页时，才会添加文档列表索引。文档列表索引本身是B树，其叶子和内部节点均存储在%_data表中的条目中，但实际上大多数文档列表都足够小，可以适应单个叶子。
- en: 'Doclist index leaves and internal nodes use the same page format. The first
    byte is a "flags" byte. This is set to 0x00 for the root page of the doclist index
    b-tree, and 0x01 for all other pages. The remainder of the page is a series of
    tightly packed varints, as follows:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: FTS5使用与段B树叶子相同的粗略大小来存储文档列表索引节点和叶子（默认为4000字节）。
- en: page number of leftmost child page, followed by
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 9.3\. 文档大小表（%_docsize表）
- en: the smallest rowid value on the left most child page, followed by
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最左子页面的页号，其后是
- en: 'one varint for each subsequent child page, containing the value:'
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '|'
- en: 0x00 if there are no rowids on the child page (this can only happen when the
    "child" page is actually a segment b-tree leaf), or
  id: totrans-684
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于文档列表索引中的最左叶子，在包含键本身的段B树叶页之后的第一个段B树叶是最左子页面。
- en: the difference between the smallest rowid on the child page and the previous
    rowid value stored on the doclist index page.
  id: totrans-685
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 9.2.4.4\. 文档列表索引格式
- en: For the leftmost doclist index leaf in a doclist index, the leftmost child page
    is the first segment b-tree leaf after the one that contains the key itself.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 最左子页面上的最小rowid值，其后是
- en: 9.3\. Document Sizes Table (%_docsize table)
  id: totrans-687
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后续每个子页面的一个变长整数，包含以下值：
- en: '[PRE95]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Many common search result ranking functions require as an input the size in
    tokens of the result document (as a search term hit in a short document is considered
    more significant than one in a long document). To provide fast access to this
    information, for each row in the FTS5 table there exists a corresponding record
    (with the same rowid) in the %_docsize shadow table that contains the size of
    each column value in the row, in tokens.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '| pgno | 此字段同时编码页面号（在段内从1开始）和文档列表索引标志。如果页面上的最终键具有[相关的文档列表索引](#doclist_index_format)，则设置文档列表索引标志。该字段的值为：'
- en: The column value sizes are stored in a blob containing one packed varint for
    each column of the FTS5 table, from left to right. The varint contains, of course,
    the total number of tokens in the corresponding column value. Unindexed columns
    are included in this vector of varints; for them the value is always set to zero.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在一个包含每个FTS5表列的打包变长整数的blob中，从左到右。变长整数当然包含相应列值中的令牌总数。未索引的列也包括在这些变长整数的向量中；对于它们，值始终设置为零。
- en: This table is used by the [xColumnSize](#xColumnSize) API. It can be omitted
    altogether by specifying the [columnsize=0](#the_columnsize_option) option. In
    that case the xColumnSize API is still available to auxiliary functions, but runs
    much more slowly.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 该表由 [xColumnSize](#xColumnSize) API 使用。可以通过指定 [columnsize=0](#the_columnsize_option)
    选项来完全省略它。在这种情况下，xColumnSize API 仍然可用于辅助函数，但运行速度会慢得多。
- en: 9.4\. The Table Contents (%_content table)
  id: totrans-692
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4\. 表内容（%_content 表）
- en: '[PRE96]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The actual table content - the values inserted into the FTS5 table, is stored
    in the %_content table. This table is created with one "c*" column for each column
    of the FTS5 table, including any unindexed columns. The values for the leftmost
    FTS5 table column are stored in column "c0" of the %_content table, the values
    from the next FTS5 table column in column "c1", and so on.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 实际表内容 - 插入到 FTS5 表中的值，存储在 `%_content` 表中。该表创建时包含一个"c*"列，每个 FTS5 表的列都有，包括任何未索引的列。最左边的
    FTS5 表列的值存储在 `%_content` 表的 "c0" 列中，接下来的 FTS5 表列的值存储在 "c1" 列中，依此类推。
- en: This table is omitted completely for [external content or contentless](#external_content_and_contentless_tables)
    FTS5 tables. tables.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 对于外部内容或无内容的 FTS5 表，该表完全被省略。表格。
- en: 9.5\. Configuration Options (%_config table)
  id: totrans-696
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5\. 配置选项（%_config 表）
- en: '[PRE97]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'This table stores the values of any persistent configuration options. Column
    "k" stores the name of the option (text) and column "v" the value. Example contents:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 该表存储任何持久配置选项的值。列 "k" 存储选项的名称（文本），列 "v" 存储其值。示例内容：
- en: '[PRE98]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Appendix A: Comparison with FTS3/4'
  id: totrans-700
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 A：与 FTS3/4 的比较
- en: Also available is the similar but more mature [FTS3/4](fts3.html) module. FTS5
    is a new version of FTS4 that includes various fixes and solutions for problems
    that could not be fixed in FTS4 without sacrificing backwards compatibility. Some
    of these problems are [described below](fts5.html#_summary_of_technical_differences_).
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 还提供类似但更成熟的 [FTS3/4](fts3.html) 模块。FTS5 是 FTS4 的新版本，包括各种修复和解决方案，这些问题在不损害向后兼容性的情况下无法在
    FTS4 中修复。其中一些问题在下文中有所描述。
- en: Application Porting Guide
  id: totrans-702
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序迁移指南
- en: In order to use FTS5 instead of FTS3 or FTS4, applications usually require minimal
    modifications. Most of these fall into three categories - changes required to
    the CREATE VIRTUAL TABLE statement used to create the FTS table, changes required
    to SELECT queries used to execute queries against the table, and changes required
    to applications that use [FTS auxiliary functions](fts3.html#snippet).
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 FTS5 替代 FTS3 或 FTS4，应用程序通常需要进行最少的修改。这些修改大部分属于三类 - 修改用于创建 FTS 表的 CREATE VIRTUAL
    TABLE 语句所需的内容，修改用于执行针对表的 SELECT 查询的内容，以及修改使用 [FTS 辅助函数](fts3.html#snippet) 的应用程序。
- en: Changes to CREATE VIRTUAL TABLE statements
  id: totrans-704
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改 CREATE VIRTUAL TABLE 语句
- en: The module name must be changed from "fts3" or "fts4" to "fts5".
  id: totrans-705
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块名称必须从 "fts3" 或 "fts4" 更改为 "fts5"。
- en: All type information or constraint specifications must be removed from column
    definitions. FTS3/4 ignores everything following the column name in a column definition,
    FTS5 attempts to parse it (and will report an error if it fails to).
  id: totrans-706
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有类型信息或约束规范必须从列定义中移除。FTS3/4 忽略列定义中列名后的所有内容，FTS5 尝试解析它（如果解析失败则报错）。
- en: The "matchinfo=fts3" option is not available. The ["columnsize=0"](fts5.html#the_columnsize_option)
    option is equivalent.
  id: totrans-707
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '"matchinfo=fts3" 选项不可用。["columnsize=0"](fts5.html#the_columnsize_option) 选项是等效的。'
- en: The notindexed= option is not available. Adding [UNINDEXED](fts5.html#the_unindexed_column_option)
    to the column definition is equivalent.
  id: totrans-708
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: notindexed= 选项不可用。在列定义中添加 [UNINDEXED](fts5.html#the_unindexed_column_option)
    是等效的。
- en: The ICU tokenizer is not available.
  id: totrans-709
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ICU 分词器不可用。
- en: The compress=, uncompress= and languageid= options are not available. There
    is as of yet no equivalent for their functionality.
  id: totrans-710
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`compress=`, `uncompress=` 和 `languageid=` 选项不可用。目前还没有它们功能的等效替代方案。'
- en: '[PRE99]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Changes to SELECT statements
  id: totrans-712
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SELECT 语句的更改
- en: The "docid" alias does not exist. Applications must use "rowid" instead.
  id: totrans-713
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '"docid" 别名不存在。应用程序必须使用 "rowid" 代替。'
- en: 'The behaviour of queries when a column-filter is specified both as part of
    the FTS query and by using a column as the LHS of a MATCH operator is slightly
    different. For a table with columns "a" and "b" and a query similar to:'
  id: totrans-714
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 FTS 查询的一部分以及使用列作为 MATCH 运算符的 LHS 指定列过滤器时，查询行为稍有不同。对于具有列 "a" 和 "b" 的表和类似的查询：
- en: '[PRE100]'
  id: totrans-715
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: FTS3/4 searches for matches in column "b". However, FTS5 always returns zero
    rows, as results are first filtered for column "b", then for column "a", leaving
    no results. In other words, in FTS3/4 the inner filter overrides the outer, in
    FTS5 both filters are applied.
  id: totrans-716
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: FTS3/4 在列 "b" 中搜索匹配项。然而，FTS5 总是返回零行，因为首先对列 "b" 进行结果过滤，然后对列 "a" 进行过滤，导致无结果。换句话说，在
    FTS3/4 中，内部过滤器覆盖外部过滤器，而在 FTS5 中，两个过滤器都被应用。
- en: The FTS query syntax (right hand side of the MATCH operator) has changed in
    some ways. The FTS5 syntax is quite close to the FTS4 "enhanced syntax". The main
    difference is that FTS5 is fussier about unrecognized punctuation characters and
    similar within query strings. Most queries that work with FTS3/4 should also work
    with FTS5, and those that do not should return parse errors.
  id: totrans-717
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FTS 查询语法（MATCH 操作符的右侧）在某些方面发生了变化。FTS5 语法与 FTS4 的 "增强语法" 非常接近。主要区别在于 FTS5 对于未识别的标点符号和类似字符在查询字符串中更为挑剔。大多数在
    FTS3/4 中有效的查询也应该在 FTS5 中有效，不过无法的查询应返回解析错误。
- en: Auxiliary Function Changes
  id: totrans-718
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 辅助函数变更
- en: FTS5 has no matchinfo() or offsets() function, and the snippet() function is
    not as fully-featured as in FTS3/4\. However, since FTS5 does provide an API allowing
    applications to create [custom auxiliary functions](fts5.html#custom_auxiliary_functions_api_reference),
    any required functionality may be implemented within the application code.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: FTS5 没有 `matchinfo()` 或 `offsets()` 函数，而 `snippet()` 函数不如 FTS3/4 那样功能完善。但是，由于
    FTS5 提供了允许应用程序创建[自定义辅助函数](fts5.html#custom_auxiliary_functions_api_reference)的
    API，因此可以在应用程序代码中实现任何所需功能。
- en: The set of built-in auxiliary functions provided by FTS5 may be improved upon
    in the future.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: FTS5 提供的内置辅助函数集合可能会在将来得到改进。
- en: Other Issues
  id: totrans-721
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他问题
- en: The functionality provided by the fts4aux module is now provided by [fts5vocab](fts5.html#the_fts5vocab_virtual_table_module).
    The schema of these two tables is slightly different.
  id: totrans-722
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: fts4aux 模块提供的功能现在由[fts5vocab](fts5.html#the_fts5vocab_virtual_table_module)提供。这两个表的模式略有不同。
- en: The FTS3/4 "merge=X,Y" command has been replaced by the [FTS5 merge command](fts5.html#the_merge_command).
  id: totrans-723
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FTS3/4 中的 "merge=X,Y" 命令已被[FTS5 merge 命令](fts5.html#the_merge_command)替换。
- en: The FTS3/4 "automerge=X" command has been replaced by the [FTS5 automerge option](fts5.html#the_automerge_configuration_option).
  id: totrans-724
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FTS3/4 中的 "automerge=X" 命令已被[FTS5 automerge 选项](fts5.html#the_automerge_configuration_option)替换。
- en: Summary of Technical Differences
  id: totrans-725
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术差异总结
- en: 'FTS5 is similar to FTS3/4 in that the primary task of each is to maintain an
    index mapping from each unique token to a list of instances of that token within
    a set of documents, where each instance is identified by the document in which
    it appears and its position within that document. For example:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: FTS5 类似于 FTS3/4，每个的主要任务是维护一个索引映射，将每个唯一标记映射到文档集合中该标记的实例列表，其中每个实例由其出现的文档和其在该文档中的位置标识。例如：
- en: '[PRE101]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: In the example above, each triple identifies the location of a token instance
    by rowid, column number (columns are numbered sequentially starting at 0 from
    left to right) and position within the column value (the first token in a column
    value is 0, the second is 1, and so on). Using this index, FTS5 is able to provide
    timely answers to queries such as "the set of all documents that contain the token
    'A'", or "the set of all documents that contain the sequence 'Y Z'". The list
    of instances associated with a single token is called an "instance-list".
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，每个三元组通过 rowid、列号（列从左到右顺序编号，从0开始）和列值内位置（列值的第一个标记为0，第二个为1，依此类推）标识标记实例的位置。利用此索引，FTS5
    能够及时地回答诸如 "包含标记 'A' 的所有文档集合" 或 "包含序列 'Y Z' 的所有文档集合" 的查询。与单个标记关联的实例列表称为 "实例列表"。
- en: 'The principle difference between FTS3/4 and FTS5 is that in FTS3/4, each instance-list
    is stored as a single large database record, whereas in FTS5 large instance-lists
    are divided between multiple database records. This has the following implications
    for dealing with large databases that contain large lists:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: FTS3/4 和 FTS5 的主要区别在于，在 FTS3/4 中，每个实例列表存储为单个大型数据库记录，而在 FTS5 中，大型实例列表分为多个数据库记录。这对处理包含大型列表的大型数据库具有以下影响：
- en: FTS5 is able to load instance-lists into memory incrementally in order to reduce
    memory usage and peak allocation size. FTS3/4 very often loads entire instance-lists
    into memory.
  id: totrans-730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FTS5 能够逐步将实例列表加载到内存中，以减少内存使用和峰值分配大小。FTS3/4 往往会将整个实例列表加载到内存中。
- en: When processing queries that feature more than one token, FTS5 is sometimes
    able to determine that the query can be answered by inspecting a subset of a large
    instance-list. FTS3/4 almost always has to traverse entire instance-lists.
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理包含多个标记的查询时，FTS5有时能够确定可以通过检查大实例列表的子集来回答查询。FTS3/4几乎总是需要遍历整个实例列表。
- en: If an instance-list grows so large that it exceeds the [SQLITE_MAX_LENGTH](limits.html#max_length)
    limit, FTS3/4 is unable to handle it. FTS5 does not have this problem.
  id: totrans-732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个实例列表增长得太大以至超过[SQLITE_MAX_LENGTH](limits.html#max_length)限制，FTS3/4将无法处理。FTS5不会出现这个问题。
- en: For these reasons, many complex queries may use less memory and run faster using
    FTS5.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，许多复杂查询可能使用更少的内存，并且使用FTS5运行速度更快。
- en: 'Some other ways in which FTS5 differs from FTS3/4 are:'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: FTS5与FTS3/4的一些其他区别包括：
- en: FTS5 supports "ORDER BY rank" for returning results in order of decreasing relevancy.
  id: totrans-735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FTS5支持通过“ORDER BY rank”按减少相关性的顺序返回结果。
- en: FTS5 features an API allowing users to create custom auxiliary functions for
    advanced ranking and text processing applications. The special "rank" column may
    be mapped to a custom auxiliary function so that adding "ORDER BY rank" to a query
    works as expected.
  id: totrans-736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FTS5提供了一个API，允许用户为高级排名和文本处理应用程序创建自定义辅助函数。特殊的“rank”列可以映射到自定义辅助函数，以便在查询中添加“ORDER
    BY rank”时按预期工作。
- en: FTS5 recognizes unicode separator characters and case equivalence by default.
    This is also possible using FTS3/4, but must be explicitly enabled.
  id: totrans-737
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，FTS5识别Unicode分隔符和大小写等价性。这在FTS3/4中也是可能的，但必须显式启用。
- en: The query syntax has been revised where necessary to remove ambiguities and
    to make it possible to escape special characters in query terms.
  id: totrans-738
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询语法已经根据需要进行了修订，以消除歧义，并使得在查询术语中转义特殊字符成为可能。
- en: By default, FTS3/4 occasionally merges together two or more of the b-trees that
    make up its full-text index within an INSERT, UPDATE or DELETE statement executed
    by the user. This means that any operation on an FTS3/4 table may turn out to
    be surprisingly slow, as FTS3/4 may unpredictably choose to merge together two
    or more large b-trees within it. FTS5 uses incremental merging by default, which
    limits the amount of processing that may take place within any given INSERT, UPDATE
    or DELETE operation.
  id: totrans-739
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，FTS3/4偶尔会在用户执行的INSERT、UPDATE或DELETE语句中合并两个或多个组成其全文索引的b-tree。这意味着对FTS3/4表的任何操作可能会出奇地慢，因为FTS3/4可能会不可预测地选择在其中合并两个或多个大的b-tree。FTS5默认使用增量合并，限制了在任何给定的INSERT、UPDATE或DELETE操作中可能发生的处理量。
