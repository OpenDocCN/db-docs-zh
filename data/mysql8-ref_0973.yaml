- en: 15.2.20 WITH (Common Table Expressions)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.2.20 WITH（公共表达式）
- en: 原文：[https://dev.mysql.com/doc/refman/8.0/en/with.html](https://dev.mysql.com/doc/refman/8.0/en/with.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://dev.mysql.com/doc/refman/8.0/en/with.html](https://dev.mysql.com/doc/refman/8.0/en/with.html)
- en: A common table expression (CTE) is a named temporary result set that exists
    within the scope of a single statement and that can be referred to later within
    that statement, possibly multiple times. The following discussion describes how
    to write statements that use CTEs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 公共表达式（CTE）是存在于单个语句范围内的命名临时结果集，可以在该语句中稍后引用，可能多次。以下讨论描述了如何编写使用CTE的语句。
- en: '[Common Table Expressions](with.html#common-table-expressions "Common Table
    Expressions")'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[公共表达式](with.html#common-table-expressions "公共表达式")'
- en: '[Recursive Common Table Expressions](with.html#common-table-expressions-recursive
    "Recursive Common Table Expressions")'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[递归公共表达式](with.html#common-table-expressions-recursive "递归公共表达式")'
- en: '[Limiting Common Table Expression Recursion](with.html#common-table-expressions-recursion-limits
    "Limiting Common Table Expression Recursion")'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[限制公共表达式递归](with.html#common-table-expressions-recursion-limits "限制公共表达式递归")'
- en: '[Recursive Common Table Expression Examples](with.html#common-table-expressions-recursive-examples
    "Recursive Common Table Expression Examples")'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[递归公共表达式示例](with.html#common-table-expressions-recursive-examples "递归公共表达式示例")'
- en: '[Common Table Expressions Compared to Similar Constructs](with.html#common-table-expressions-similar-constructs
    "Common Table Expressions Compared to Similar Constructs")'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[与类似结构比较的公共表达式](with.html#common-table-expressions-similar-constructs "与类似结构比较的公共表达式")'
- en: For information about CTE optimization, see [Section 10.2.2.4, “Optimizing Derived
    Tables, View References, and Common Table Expressions with Merging or Materialization”](derived-table-optimization.html
    "10.2.2.4 Optimizing Derived Tables, View References, and Common Table Expressions
    with Merging or Materialization").
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有关CTE优化的信息，请参见[第10.2.2.4节，“使用合并或材料化优化派生表、视图引用和公共表达式”](derived-table-optimization.html
    "10.2.2.4 Optimizing Derived Tables, View References, and Common Table Expressions
    with Merging or Materialization")。
- en: Additional Resources
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 其他资源
- en: 'These articles contain additional information about using CTEs in MySQL, including
    many examples:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文章包含有关在MySQL中使用CTEs的其他信息，包括许多示例：
- en: '[MySQL 8.0 Labs: [Recursive] Common Table Expressions in MySQL (CTEs)](https://dev.mysql.com/blog-archive/mysql-8-0-labs-recursive-common-table-expressions-in-mysql-ctes/)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[MySQL 8.0实验室：MySQL中的[递归]公共表达式（CTEs）](https://dev.mysql.com/blog-archive/mysql-8-0-labs-recursive-common-table-expressions-in-mysql-ctes/)'
- en: '[MySQL 8.0 Labs: [Recursive] Common Table Expressions in MySQL (CTEs), Part
    Two – how to generate series](https://dev.mysql.com/blog-archive/mysql-8-0-labs-recursive-common-table-expressions-in-mysql-ctes-part-two-how-to-generate-series/)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[MySQL 8.0实验室：MySQL中的[递归]公共表达式（CTEs）第二部分 - 如何生成系列](https://dev.mysql.com/blog-archive/mysql-8-0-labs-recursive-common-table-expressions-in-mysql-ctes-part-two-how-to-generate-series/)'
- en: '[MySQL 8.0 Labs: [Recursive] Common Table Expressions in MySQL (CTEs), Part
    Three – hierarchies](https://dev.mysql.com/blog-archive/mysql-8-0-labs-recursive-common-table-expressions-in-mysql-ctes-part-three-hierarchies/)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[MySQL 8.0实验室：MySQL中的[递归]公共表达式（CTEs）第三部分 - 层次结构](https://dev.mysql.com/blog-archive/mysql-8-0-labs-recursive-common-table-expressions-in-mysql-ctes-part-three-hierarchies/)'
- en: '[MySQL 8.0.1: [Recursive] Common Table Expressions in MySQL (CTEs), Part Four
    – depth-first or breadth-first traversal, transitive closure, cycle avoidance](https://dev.mysql.com/blog-archive/mysql-8-0-1-recursive-common-table-expressions-in-mysql-ctes-part-four-depth-first-or-breadth-first-traversal-transitive-closure-cycle-avoidance/)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[MySQL 8.0.1：MySQL中的[递归]公共表达式（CTEs）第四部分 - 深度优先或广度优先遍历，传递闭包，循环避免](https://dev.mysql.com/blog-archive/mysql-8-0-1-recursive-common-table-expressions-in-mysql-ctes-part-four-depth-first-or-breadth-first-traversal-transitive-closure-cycle-avoidance/)'
- en: Common Table Expressions
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 公共表达式
- en: 'To specify common table expressions, use a [`WITH`](with.html "15.2.20 WITH
    (Common Table Expressions)") clause that has one or more comma-separated subclauses.
    Each subclause provides a subquery that produces a result set, and associates
    a name with the subquery. The following example defines CTEs named `cte1` and
    `cte2` in the [`WITH`](with.html "15.2.20 WITH (Common Table Expressions)") clause,
    and refers to them in the top-level [`SELECT`](select.html "15.2.13 SELECT Statement")
    that follows the [`WITH`](with.html "15.2.20 WITH (Common Table Expressions)")
    clause:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定公共表达式，请使用具有一个或多个逗号分隔子句的[`WITH`](with.html "15.2.20 WITH (Common Table Expressions)")子句。每个子句提供一个生成结果集的子查询，并将一个名称与子查询关联。以下示例在[`WITH`](with.html
    "15.2.20 WITH (Common Table Expressions)")子句中定义了名为`cte1`和`cte2`的CTE，并在跟随[`WITH`](with.html
    "15.2.20 WITH (Common Table Expressions)")子句的顶层[`SELECT`](select.html "15.2.13 SELECT
    Statement")中引用它们：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the statement containing the [`WITH`](with.html "15.2.20 WITH (Common Table
    Expressions)") clause, each CTE name can be referenced to access the corresponding
    CTE result set.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含[`WITH`](with.html "15.2.20 WITH (Common Table Expressions)")子句的语句中，每个CTE名称都可以被引用以访问相应的CTE结果集。
- en: A CTE name can be referenced in other CTEs, enabling CTEs to be defined based
    on other CTEs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: CTE名称可以在其他CTE中引用，使得CTE可以基于其他CTE定义。
- en: A CTE can refer to itself to define a recursive CTE. Common applications of
    recursive CTEs include series generation and traversal of hierarchical or tree-structured
    data.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: CTE可以引用自身来定义递归CTE。递归CTE的常见应用包括序列生成和遍历分层或树形数据。
- en: 'Common table expressions are an optional part of the syntax for DML statements.
    They are defined using a [`WITH`](with.html "15.2.20 WITH (Common Table Expressions)")
    clause:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 公共表达式是DML语句语法的可选部分。它们使用[`WITH`](with.html "15.2.20 WITH (Common Table Expressions)")子句定义：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*`cte_name`* names a single common table expression and can be used as a table
    reference in the statement containing the [`WITH`](with.html "15.2.20 WITH (Common
    Table Expressions)") clause.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*`cte_name`*指定一个单个公共表达式，并且可以在包含[`WITH`](with.html "15.2.20 WITH (Common Table
    Expressions)")子句的语句中作为表引用。'
- en: The *`subquery`* part of `AS (*`subquery`*)` is called the “subquery of the
    CTE” and is what produces the CTE result set. The parentheses following `AS` are
    required.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`AS (*`子查询`*)`部分中的*`子查询`*称为“CTE的子查询”，并生成CTE结果集。`AS`后面的括号是必需的。'
- en: A common table expression is recursive if its subquery refers to its own name.
    The `RECURSIVE` keyword must be included if any CTE in the [`WITH`](with.html
    "15.2.20 WITH (Common Table Expressions)") clause is recursive. For more information,
    see [Recursive Common Table Expressions](with.html#common-table-expressions-recursive
    "Recursive Common Table Expressions").
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果CTE的子查询引用其自身的名称，则该公共表达式是递归的。如果[`WITH`](with.html "15.2.20 WITH (Common Table
    Expressions)")子句中的任何CTE是递归的，则必须包含`RECURSIVE`关键字。有关更多信息，请参见[递归公共表达式](with.html#common-table-expressions-recursive
    "Recursive Common Table Expressions")。
- en: 'Determination of column names for a given CTE occurs as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 给定CTE的列名确定如下：
- en: 'If a parenthesized list of names follows the CTE name, those names are the
    column names:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果CTE名称后跟着一个括号括起的名称列表，则这些名称是列名：
- en: '[PRE2]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The number of names in the list must be the same as the number of columns in
    the result set.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 名称列表中的名称数量必须与结果集中的列数相同。
- en: 'Otherwise, the column names come from the select list of the first [`SELECT`](select.html
    "15.2.13 SELECT Statement") within the `AS (*`subquery`*)` part:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，列名来自`AS (*`子查询`*)`部分中第一个[`SELECT`](select.html "15.2.13 SELECT Statement")的选择列表：
- en: '[PRE3]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A [`WITH`](with.html "15.2.20 WITH (Common Table Expressions)") clause is permitted
    in these contexts:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下允许使用[`WITH`](with.html "15.2.20 WITH (Common Table Expressions)")子句：
- en: At the beginning of [`SELECT`](select.html "15.2.13 SELECT Statement"), [`UPDATE`](update.html
    "15.2.17 UPDATE Statement"), and [`DELETE`](delete.html "15.2.2 DELETE Statement")
    statements.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[`SELECT`](select.html "15.2.13 SELECT Statement")、[`UPDATE`](update.html "15.2.17 UPDATE
    Statement")和[`DELETE`](delete.html "15.2.2 DELETE Statement")语句的开头。
- en: '[PRE4]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'At the beginning of subqueries (including derived table subqueries):'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在子查询（包括派生表子查询）的开头：
- en: '[PRE5]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Immediately preceding [`SELECT`](select.html "15.2.13 SELECT Statement") for
    statements that include a [`SELECT`](select.html "15.2.13 SELECT Statement") statement:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在包含[`SELECT`](select.html "15.2.13 SELECT Statement")语句的语句之前：
- en: '[PRE6]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Only one [`WITH`](with.html "15.2.20 WITH (Common Table Expressions)") clause
    is permitted at the same level. [`WITH`](with.html "15.2.20 WITH (Common Table
    Expressions)") followed by [`WITH`](with.html "15.2.20 WITH (Common Table Expressions)")
    at the same level is not permitted, so this is illegal:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 同一级别只允许一个[`WITH`](with.html "15.2.20 WITH (Common Table Expressions)")子句。不允许在同一级别后跟[`WITH`](with.html
    "15.2.20 WITH (Common Table Expressions)")再跟[`WITH`](with.html "15.2.20 WITH (Common
    Table Expressions)")，因此这是不合法的：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To make the statement legal, use a single [`WITH`](with.html "15.2.20 WITH
    (Common Table Expressions)") clause that separates the subclauses by a comma:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要使语句合法，使用一个单独的[`WITH`](with.html "15.2.20 WITH (Common Table Expressions)")子句，通过逗号分隔子句：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'However, a statement can contain multiple [`WITH`](with.html "15.2.20 WITH
    (Common Table Expressions)") clauses if they occur at different levels:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果它们出现在不同级别，则语句可以包含多个[`WITH`](with.html "15.2.20 WITH (Common Table Expressions)")子句：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A [`WITH`](with.html "15.2.20 WITH (Common Table Expressions)") clause can
    define one or more common table expressions, but each CTE name must be unique
    to the clause. This is illegal:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[`WITH`](with.html "15.2.20 WITH (Common Table Expressions)")子句可以定义一个或多个公共表达式，但每个CTE名称必须对该子句唯一。这是不合法的：'
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To make the statement legal, define the CTEs with unique names:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要使语句合法，定义具有唯一名称的CTE：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A CTE can refer to itself or to other CTEs:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: CTE可以引用自身或其他CTE：
- en: A self-referencing CTE is recursive.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自引用CTE是递归的。
- en: A CTE can refer to CTEs defined earlier in the same [`WITH`](with.html "15.2.20 WITH
    (Common Table Expressions)") clause, but not those defined later.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CTE可以引用在同一[`WITH`](with.html "15.2.20 WITH (Common Table Expressions)")子句中较早定义的CTE，但不能引用稍后定义的CTE。
- en: This constraint rules out mutually-recursive CTEs, where `cte1` references `cte2`
    and `cte2` references `cte1`. One of those references must be to a CTE defined
    later, which is not permitted.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个约束排除了相互递归的CTE，其中`cte1`引用`cte2`，而`cte2`引用`cte1`。这些引用中的一个必须是对稍后定义的CTE的引用，这是不允许的。
- en: A CTE in a given query block can refer to CTEs defined in query blocks at a
    more outer level, but not CTEs defined in query blocks at a more inner level.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在给定查询块中，CTE可以引用更外层级别的查询块中定义的CTE，但不能引用更内层级别的查询块中定义的CTE。
- en: For resolving references to objects with the same names, derived tables hide
    CTEs; and CTEs hide base tables, `TEMPORARY` tables, and views. Name resolution
    occurs by searching for objects in the same query block, then proceeding to outer
    blocks in turn while no object with the name is found.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于解析具有相同名称的对象引用，派生表隐藏CTE；而CTE隐藏基本表、`TEMPORARY`表和视图。名称解析通过在同一查询块中搜索对象，然后依次在外部块中查找，直到找到具有该名称的对象为止。
- en: Like derived tables, a CTE cannot contain outer references prior to MySQL 8.0.14\.
    This is a MySQL restriction that is lifted in MySQL 8.0.14, not a restriction
    of the SQL standard. For additional syntax considerations specific to recursive
    CTEs, see [Recursive Common Table Expressions](with.html#common-table-expressions-recursive
    "Recursive Common Table Expressions").
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与派生表类似，在MySQL 8.0.14之前，CTE不能包含外部引用。这是MySQL在MySQL 8.0.14中解除的限制，而不是SQL标准的限制。有关递归CTE的特定语法考虑事项，请参见[递归公共表达式](with.html#common-table-expressions-recursive
    "递归公共表达式")。
- en: Recursive Common Table Expressions
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 递归公共表达式
- en: 'A recursive common table expression is one having a subquery that refers to
    its own name. For example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 递归公共表达式是具有引用其自身名称的子查询的表达式。例如：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When executed, the statement produces this result, a single column containing
    a simple linear sequence:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行时，该语句产生这样的结果，一个包含简单线性序列的单列：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A recursive CTE has this structure:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 递归CTE具有以下结构：
- en: The `WITH` clause must begin with `WITH RECURSIVE` if any CTE in the `WITH`
    clause refers to itself. (If no CTE refers to itself, `RECURSIVE` is permitted
    but not required.)
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`WITH`子句中的任何CTE引用自身，则`WITH`子句必须以`WITH RECURSIVE`开头。（如果没有CTE引用自身，则允许使用`RECURSIVE`但不是必需的。）
- en: 'If you forget `RECURSIVE` for a recursive CTE, this error is a likely result:'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果忘记为递归CTE添加`RECURSIVE`，则可能会出现以下错误：
- en: '[PRE14]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The recursive CTE subquery has two parts, separated by [`UNION ALL`](union.html
    "15.2.18 UNION Clause") or [`UNION [DISTINCT]`](union.html "15.2.18 UNION Clause"):'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归CTE子查询有两部分，由[`UNION ALL`](union.html "15.2.18 UNION Clause")或[`UNION [DISTINCT]`](union.html
    "15.2.18 UNION Clause")分隔：
- en: '[PRE15]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first [`SELECT`](select.html "15.2.13 SELECT Statement") produces the initial
    row or rows for the CTE and does not refer to the CTE name. The second [`SELECT`](select.html
    "15.2.13 SELECT Statement") produces additional rows and recurses by referring
    to the CTE name in its `FROM` clause. Recursion ends when this part produces no
    new rows. Thus, a recursive CTE consists of a nonrecursive [`SELECT`](select.html
    "15.2.13 SELECT Statement") part followed by a recursive [`SELECT`](select.html
    "15.2.13 SELECT Statement") part.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个 [`SELECT`](select.html "15.2.13 SELECT Statement") 生成 CTE 的初始行或行，并不引用 CTE
    名称。第二个 [`SELECT`](select.html "15.2.13 SELECT Statement") 生成额外的行并通过在其 `FROM` 子句中引用
    CTE 名称进行递归。当这部分不再生成新行时，递归结束。因此，递归 CTE 由一个非递归的 [`SELECT`](select.html "15.2.13 SELECT
    Statement") 部分后跟一个递归的 [`SELECT`](select.html "15.2.13 SELECT Statement") 部分组成。
- en: Each [`SELECT`](select.html "15.2.13 SELECT Statement") part can itself be a
    union of multiple [`SELECT`](select.html "15.2.13 SELECT Statement") statements.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个 [`SELECT`](select.html "15.2.13 SELECT Statement") 部分本身可以是多个 [`SELECT`](select.html
    "15.2.13 SELECT Statement") 语句的联合。
- en: The types of the CTE result columns are inferred from the column types of the
    nonrecursive [`SELECT`](select.html "15.2.13 SELECT Statement") part only, and
    the columns are all nullable. For type determination, the recursive [`SELECT`](select.html
    "15.2.13 SELECT Statement") part is ignored.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CTE 结果列的类型是从非递归 [`SELECT`](select.html "15.2.13 SELECT Statement") 部分的列类型推断出来的，所有列都是可空的。对于类型确定，递归
    [`SELECT`](select.html "15.2.13 SELECT Statement") 部分将被忽略。
- en: If the nonrecursive and recursive parts are separated by [`UNION DISTINCT`](union.html
    "15.2.18 UNION Clause"), duplicate rows are eliminated. This is useful for queries
    that perform transitive closures, to avoid infinite loops.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果非递归部分和递归部分由 [`UNION DISTINCT`](union.html "15.2.18 UNION Clause") 分隔，重复行将被消除。这对执行传递闭包的查询很有用，以避免无限循环。
- en: Each iteration of the recursive part operates only on the rows produced by the
    previous iteration. If the recursive part has multiple query blocks, iterations
    of each query block are scheduled in unspecified order, and each query block operates
    on rows that have been produced either by its previous iteration or by other query
    blocks since that previous iteration's end.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归部分的每次迭代仅在前一次迭代生成的行上操作。如果递归部分有多个查询块，每个查询块的迭代按照未指定的顺序进行安排，并且每个查询块操作的行是由其前一次迭代或自其前一次迭代结束以来其他查询块生成的行。
- en: 'The recursive CTE subquery shown earlier has this nonrecursive part that retrieves
    a single row to produce the initial row set:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 之前显示的递归 CTE 子查询有这个非递归部分，用于检索单行以生成初始行集合：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The CTE subquery also has this recursive part:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: CTE 子查询也有这个递归部分：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: At each iteration, that [`SELECT`](select.html "15.2.13 SELECT Statement") produces
    a row with a new value one greater than the value of `n` from the previous row
    set. The first iteration operates on the initial row set (`1`) and produces `1+1=2`;
    the second iteration operates on the first iteration's row set (`2`) and produces
    `2+1=3`; and so forth. This continues until recursion ends, which occurs when
    `n` is no longer less than 5.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代中，[`SELECT`](select.html "15.2.13 SELECT Statement") 会生成一个新值，比上一行集合中的 `n`
    的值大 `1`。第一次迭代操作初始行集合（`1`）并生成 `1+1=2`；第二次迭代操作第一次迭代的行集合（`2`）并生成 `2+1=3`；依此类推。直到递归结束，即当
    `n` 不再小于 `5` 时。
- en: 'If the recursive part of a CTE produces wider values for a column than the
    nonrecursive part, it may be necessary to widen the column in the nonrecursive
    part to avoid data truncation. Consider this statement:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 CTE 的递归部分为某列生成了比非递归部分更宽的值，可能需要扩展非递归部分中的列以避免数据截断。考虑以下语句：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In nonstrict SQL mode, the statement produces this output:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在非严格 SQL 模式下，该语句会产生如下输出：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `str` column values are all `'abc'` because the nonrecursive [`SELECT`](select.html
    "15.2.13 SELECT Statement") determines the column widths. Consequently, the wider
    `str` values produced by the recursive [`SELECT`](select.html "15.2.13 SELECT
    Statement") are truncated.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`str` 列的值都是 `''abc''`，因为非递归 [`SELECT`](select.html "15.2.13 SELECT Statement")
    确定了列宽度。因此，递归 [`SELECT`](select.html "15.2.13 SELECT Statement") 生成的更宽的 `str` 值会被截断。'
- en: 'In strict SQL mode, the statement produces an error:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格 SQL 模式下，该语句会产生错误：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To address this issue, so that the statement does not produce truncation or
    errors, use [`CAST()`](cast-functions.html#function_cast) in the nonrecursive
    [`SELECT`](select.html "15.2.13 SELECT Statement") to make the `str` column wider:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，使语句不产生截断或错误，可以在非递归的[`SELECT`](select.html "15.2.13 SELECT Statement")中使用[`CAST()`](cast-functions.html#function_cast)来使`str`列变宽：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now the statement produces this result, without truncation:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在该语句产生了这个结果，没有截断：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Columns are accessed by name, not position, which means that columns in the
    recursive part can access columns in the nonrecursive part that have a different
    position, as this CTE illustrates:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列通过名称访问，而不是位置，这意味着递归部分中的列可以访问非递归部分中位置不同的列，正如这个CTE所示：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Because `p` in one row is derived from `q` in the previous row, and vice versa,
    the positive and negative values swap positions in each successive row of the
    output:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因为一行中的`p`是从前一行中的`q`派生的，反之亦然，所以输出的每一行中正负值交换位置：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Some syntax constraints apply within recursive CTE subqueries:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语法约束适用于递归CTE子查询：
- en: 'The recursive [`SELECT`](select.html "15.2.13 SELECT Statement") part must
    not contain these constructs:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归[`SELECT`](select.html "15.2.13 SELECT Statement")部分不能包含以下结构：
- en: Aggregate functions such as `SUM()`
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合函数如`SUM()`
- en: Window functions
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 窗口函数
- en: '`GROUP BY`'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GROUP BY`'
- en: '`ORDER BY`'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ORDER BY`'
- en: '`DISTINCT`'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DISTINCT`'
- en: Prior to MySQL 8.0.19, the recursive [`SELECT`](select.html "15.2.13 SELECT
    Statement") part of a recursive CTE also could not use a `LIMIT` clause. This
    restriction is lifted in MySQL 8.0.19, and `LIMIT` is now supported in such cases,
    along with an optional `OFFSET` clause. The effect on the result set is the same
    as when using `LIMIT` in the outermost `SELECT`, but is also more efficient, since
    using it with the recursive `SELECT` stops the generation of rows as soon as the
    requested number of them has been produced.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在MySQL 8.0.19之前，递归CTE的递归[`SELECT`](select.html "15.2.13 SELECT Statement")部分也不能使用`LIMIT`子句。这个限制在MySQL
    8.0.19中被解除，现在在这种情况下支持`LIMIT`，还有一个可选的`OFFSET`子句。结果集的效果与在最外层`SELECT`中使用`LIMIT`时相同，但更有效，因为在递归`SELECT`中使用它会在生成请求的行数后立即停止生成行。
- en: These constraints do not apply to the nonrecursive [`SELECT`](select.html "15.2.13 SELECT
    Statement") part of a recursive CTE. The prohibition on `DISTINCT` applies only
    to [`UNION`](union.html "15.2.18 UNION Clause") members; `UNION DISTINCT` is permitted.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些约束不适用于递归CTE的非递归[`SELECT`](select.html "15.2.13 SELECT Statement")部分。对`DISTINCT`的禁止仅适用于[`UNION`](union.html
    "15.2.18 UNION Clause")成员；允许`UNION DISTINCT`。
- en: The recursive [`SELECT`](select.html "15.2.13 SELECT Statement") part must reference
    the CTE only once and only in its `FROM` clause, not in any subquery. It can reference
    tables other than the CTE and join them with the CTE. If used in a join like this,
    the CTE must not be on the right side of a `LEFT JOIN`.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归的[`SELECT`](select.html "15.2.13 SELECT Statement")部分必须仅在其`FROM`子句中引用CTE一次，而且不能在任何子查询中引用。它可以引用除CTE之外的其他表，并将它们与CTE连接起来。如果在这样的连接中使用，CTE不能位于`LEFT
    JOIN`的右侧。
- en: These constraints come from the SQL standard, other than the MySQL-specific
    exclusions of `ORDER BY`, `LIMIT` (MySQL 8.0.18 and earlier), and `DISTINCT`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这些约束来自SQL标准，除了MySQL特定的排除`ORDER BY`、`LIMIT`（MySQL 8.0.18及更早版本）和`DISTINCT`之外。
- en: For recursive CTEs, [`EXPLAIN`](explain.html "15.8.2 EXPLAIN Statement") output
    rows for recursive [`SELECT`](select.html "15.2.13 SELECT Statement") parts display
    `Recursive` in the `Extra` column.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于递归CTE，[`EXPLAIN`](explain.html "15.8.2 EXPLAIN Statement")输出的递归[`SELECT`](select.html
    "15.2.13 SELECT Statement")部分在`Extra`列中显示`Recursive`。
- en: Cost estimates displayed by [`EXPLAIN`](explain.html "15.8.2 EXPLAIN Statement")
    represent cost per iteration, which might differ considerably from total cost.
    The optimizer cannot predict the number of iterations because it cannot predict
    at what point the `WHERE` clause becomes false.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[`EXPLAIN`](explain.html "15.8.2 EXPLAIN Statement")显示的成本估计表示每次迭代的成本，这可能与总成本有很大差异。优化器无法预测迭代次数，因为它无法预测`WHERE`子句何时变为false。'
- en: CTE actual cost may also be affected by result set size. A CTE that produces
    many rows may require an internal temporary table large enough to be converted
    from in-memory to on-disk format and may suffer a performance penalty. If so,
    increasing the permitted in-memory temporary table size may improve performance;
    see [Section 10.4.4, “Internal Temporary Table Use in MySQL”](internal-temporary-tables.html
    "10.4.4 Internal Temporary Table Use in MySQL").
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: CTE的实际成本也可能受到结果集大小的影响。产生许多行的CTE可能需要一个足够大的内部临时表，以便从内存转换为磁盘格式，并可能遭受性能损失。如果是这样，增加允许的内存临时表大小可能会提高性能；参见[第10.4.4节，“MySQL中的内部临时表使用”](internal-temporary-tables.html
    "10.4.4 MySQL中的内部临时表使用")。
- en: Limiting Common Table Expression Recursion
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 限制公共表达式递归
- en: 'It is important for recursive CTEs that the recursive [`SELECT`](select.html
    "15.2.13 SELECT Statement") part include a condition to terminate recursion. As
    a development technique to guard against a runaway recursive CTE, you can force
    termination by placing a limit on execution time:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于递归CTE非常重要的是，递归的[`SELECT`](select.html "15.2.13 SELECT Statement")部分包含一个终止递归的条件。作为一种开发技术，防止递归CTE失控的方法是通过设置执行时间限制来强制终止：
- en: The [`cte_max_recursion_depth`](server-system-variables.html#sysvar_cte_max_recursion_depth)
    system variable enforces a limit on the number of recursion levels for CTEs. The
    server terminates execution of any CTE that recurses more levels than the value
    of this variable.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`cte_max_recursion_depth`](server-system-variables.html#sysvar_cte_max_recursion_depth)系统变量为CTE的递归级别数量设置了限制。服务器会终止任何递归超过此变量值的CTE的执行。'
- en: The [`max_execution_time`](server-system-variables.html#sysvar_max_execution_time)
    system variable enforces an execution timeout for [`SELECT`](select.html "15.2.13 SELECT
    Statement") statements executed within the current session.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`max_execution_time`](server-system-variables.html#sysvar_max_execution_time)系统变量强制执行当前会话中执行的[`SELECT`](select.html
    "15.2.13 SELECT Statement")语句的执行超时。'
- en: The [`MAX_EXECUTION_TIME`](optimizer-hints.html#optimizer-hints-execution-time
    "Statement Execution Time Optimizer Hints") optimizer hint enforces a per-query
    execution timeout for the [`SELECT`](select.html "15.2.13 SELECT Statement") statement
    in which it appears.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`MAX_EXECUTION_TIME`](optimizer-hints.html#optimizer-hints-execution-time
    "Statement Execution Time Optimizer Hints")优化提示为其中出现的[`SELECT`](select.html "15.2.13 SELECT
    Statement")语句强制执行每个查询的执行超时。'
- en: 'Suppose that a recursive CTE is mistakenly written with no recursion execution
    termination condition:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 假设递归CTE被错误地编写为没有递归执行终止条件：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'By default, [`cte_max_recursion_depth`](server-system-variables.html#sysvar_cte_max_recursion_depth)
    has a value of 1000, causing the CTE to terminate when it recurses past 1000 levels.
    Applications can change the session value to adjust for their requirements:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，[`cte_max_recursion_depth`](server-system-variables.html#sysvar_cte_max_recursion_depth)的值为1000，当递归超过1000级时，CTE会终止。应用程序可以更改会话值以满足其需求：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can also set the global [`cte_max_recursion_depth`](server-system-variables.html#sysvar_cte_max_recursion_depth)
    value to affect all sessions that begin subsequently.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以设置全局[`cte_max_recursion_depth`](server-system-variables.html#sysvar_cte_max_recursion_depth)值，以影响随后开始的所有会话。
- en: 'For queries that execute and thus recurse slowly or in contexts for which there
    is reason to set the [`cte_max_recursion_depth`](server-system-variables.html#sysvar_cte_max_recursion_depth)
    value very high, another way to guard against deep recursion is to set a per-session
    timeout. To do so, execute a statement like this prior to executing the CTE statement:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于执行缓慢且因此递归的查询，或者有理由将[`cte_max_recursion_depth`](server-system-variables.html#sysvar_cte_max_recursion_depth)值设置得非常高的情况，另一种防止深度递归的方法是设置每个会话的超时时间。为此，在执行CTE语句之前执行类似以下语句：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Alternatively, include an optimizer hint within the CTE statement itself:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在CTE语句本身中包含一个优化提示：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Beginning with MySQL 8.0.19, you can also use `LIMIT` within the recursive
    query to impose a maximum number of rows to be returned to the outermost [`SELECT`](select.html
    "15.2.13 SELECT Statement"), for example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 从MySQL 8.0.19开始，你也可以在递归查询中使用`LIMIT`来对最外层的[`SELECT`](select.html "15.2.13 SELECT
    Statement")返回的最大行数进行限制，例如：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can do this in addition to or instead of setting a time limit. Thus, the
    following CTE terminates after returning ten thousand rows or running for one
    second (1000 milliseconds), whichever occurs first:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在设置时间限制之外或代替设置时间限制。因此，以下CTE在返回一万行或运行一秒钟（1000毫秒）后终止：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If a recursive query without an execution time limit enters an infinite loop,
    you can terminate it from another session using [`KILL QUERY`](kill.html "15.7.8.4 KILL
    Statement"). Within the session itself, the client program used to run the query
    might provide a way to kill the query. For example, in [**mysql**](mysql.html
    "6.5.1 mysql — The MySQL Command-Line Client"), typing **Control+C** interrupts
    the current statement.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有执行时间限制的递归查询进入无限循环，您可以从另一个会话中使用[`KILL QUERY`](kill.html "15.7.8.4 KILL语句")终止它。在会话本身中，用于运行查询的客户端程序可能提供了终止查询的方法。例如，在[**mysql**](mysql.html
    "6.5.1 mysql — MySQL命令行客户端")中，键入**Control+C**会中断当前语句。
- en: Recursive Common Table Expression Examples
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 递归公共表达式示例
- en: As mentioned previously, recursive common table expressions (CTEs) are frequently
    used for series generation and traversing hierarchical or tree-structured data.
    This section shows some simple examples of these techniques.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，递归公共表达式（CTEs）经常用于生成系列和遍历分层或树形结构数据。本节展示了这些技术的一些简单示例。
- en: '[Fibonacci Series Generation](with.html#common-table-expressions-recursive-fibonacci-series
    "Fibonacci Series Generation")'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[斐波那契数列生成](with.html#common-table-expressions-recursive-fibonacci-series "斐波那契数列生成")'
- en: '[Date Series Generation](with.html#common-table-expressions-recursive-date-series
    "Date Series Generation")'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[日期系列生成](with.html#common-table-expressions-recursive-date-series "日期系列生成")'
- en: '[Hierarchical Data Traversal](with.html#common-table-expressions-recursive-hierarchy-traversal
    "Hierarchical Data Traversal")'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[分层数据遍历](with.html#common-table-expressions-recursive-hierarchy-traversal "分层数据遍历")'
- en: Fibonacci Series Generation
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 斐波那契数列生成
- en: 'A Fibonacci series begins with the two numbers 0 and 1 (or 1 and 1) and each
    number after that is the sum of the previous two numbers. A recursive common table
    expression can generate a Fibonacci series if each row produced by the recursive
    [`SELECT`](select.html "15.2.13 SELECT Statement") has access to the two previous
    numbers from the series. The following CTE generates a 10-number series using
    0 and 1 as the first two numbers:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契数列以数字0和1（或1和1）开始，之后每个数字都是前两个数字的和。如果递归[`SELECT`](select.html "15.2.13 SELECT语句")生成的每行都可以访问系列中前两个数字，则递归公共表达式可以生成斐波那契数列。以下CTE使用0和1作为前两个数字生成了一个包含10个数字的系列：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The CTE produces this result:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: CTE生成了这个结果：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'How the CTE works:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: CTE的工作原理如下：
- en: '`n` is a display column to indicate that the row contains the `n`-th Fibonacci
    number. For example, the 8th Fibonacci number is 13.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n`是一个显示列，表示该行包含第`n`个斐波那契数。例如，第8个斐波那契数是13。'
- en: The `fib_n` column displays Fibonacci number `n`.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fib_n`列显示斐波那契数`n`。'
- en: The `next_fib_n` column displays the next Fibonacci number after number `n`.
    This column provides the next series value to the next row, so that row can produce
    the sum of the two previous series values in its `fib_n` column.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next_fib_n`列显示数字`n`后面的下一个斐波那契数。该列为下一行提供了下一个系列值，以便该行可以在其`fib_n`列中生成前两个系列值的和。'
- en: Recursion ends when `n` reaches 10\. This is an arbitrary choice, to limit the
    output to a small set of rows.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`n`达到10时，递归结束。这是一个任意选择，以限制输出为一小组行。
- en: 'The preceding output shows the entire CTE result. To select just part of it,
    add an appropriate `WHERE` clause to the top-level [`SELECT`](select.html "15.2.13 SELECT
    Statement"). For example, to select the 8th Fibonacci number, do this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出显示了整个CTE结果。要仅选择其中的一部分，请在顶层[`SELECT`](select.html "15.2.13 SELECT语句")中添加适当的`WHERE`子句。例如，要选择第8个斐波那契数，执行以下操作：
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Date Series Generation
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 日期系列生成
- en: A common table expression can generate a series of successive dates, which is
    useful for generating summaries that include a row for all dates in the series,
    including dates not represented in the summarized data.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 公共表达式可以生成一系列连续的日期，这对于生成包含系列中所有日期的行的摘要非常有用，包括未在摘要数据中表示的日期。
- en: 'Suppose that a table of sales numbers contains these rows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 假设销售数字表包含以下行：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This query summarizes the sales per day:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询总结了每天的销售情况：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: However, that result contains “holes” for dates not represented in the range
    of dates spanned by the table. A result that represents all dates in the range
    can be produced using a recursive CTE to generate that set of dates, joined with
    a `LEFT JOIN` to the sales data.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，该结果对于表跨越的日期范围中未表示的日期存在“空洞”。可以使用递归CTE生成该日期集合，然后与销售数据进行`LEFT JOIN`连接以生成表示范围内所有日期的结果。
- en: 'Here is the CTE to generate the date range series:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是生成日期范围系列的CTE：
- en: '[PRE36]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The CTE produces this result:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: CTE生成此结果：
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'How the CTE works:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: CTE的工作原理：
- en: The nonrecursive [`SELECT`](select.html "15.2.13 SELECT Statement") produces
    the lowest date in the date range spanned by the `sales` table.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非递归[`SELECT`](select.html "15.2.13 SELECT Statement")生成`sales`表跨度日期范围内最早的日期。
- en: Each row produced by the recursive [`SELECT`](select.html "15.2.13 SELECT Statement")
    adds one day to the date produced by the previous row.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归[`SELECT`](select.html "15.2.13 SELECT Statement")生成的每行将日期增加一天到前一行生成的日期。
- en: Recursion ends after the dates reach the highest date in the date range spanned
    by the `sales` table.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当日期达到`sales`表跨度的日期范围内的最高日期时，递归结束。
- en: 'Joining the CTE with a `LEFT JOIN` against the `sales` table produces the sales
    summary with a row for each date in the range:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 将CTE与`sales`表进行`LEFT JOIN`连接，生成每个日期范围内的销售摘要：
- en: '[PRE38]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output looks like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Some points to note:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一些需要注意的要点：
- en: Are the queries inefficient, particularly the one with the [`MAX()`](aggregate-functions.html#function_max)
    subquery executed for each row in the recursive [`SELECT`](select.html "15.2.13 SELECT
    Statement")? [`EXPLAIN`](explain.html "15.8.2 EXPLAIN Statement") shows that the
    subquery containing [`MAX()`](aggregate-functions.html#function_max) is evaluated
    only once and the result is cached.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询是否低效，特别是对于递归[`SELECT`](select.html "15.2.13 SELECT Statement")中每行执行的包含[`MAX()`](aggregate-functions.html#function_max)子查询？[`EXPLAIN`](explain.html
    "15.8.2 EXPLAIN Statement")显示包含[`MAX()`](aggregate-functions.html#function_max)的子查询仅评估一次，并且结果被缓存。
- en: The use of [`COALESCE()`](comparison-operators.html#function_coalesce) avoids
    displaying `NULL` in the `sum_price` column on days for which no sales data occur
    in the `sales` table.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用[`COALESCE()`](comparison-operators.html#function_coalesce)避免在`sales`表中没有销售数据的日期中在`sum_price`列中显示`NULL`。
- en: Hierarchical Data Traversal
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 分层数据遍历
- en: Recursive common table expressions are useful for traversing data that forms
    a hierarchy. Consider these statements that create a small data set that shows,
    for each employee in a company, the employee name and ID number, and the ID of
    the employee's manager. The top-level employee (the CEO), has a manager ID of
    `NULL` (no manager).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 递归通用表达式对于遍历形成层次结构的数据非常有用。考虑以下创建一个小数据集的语句，该数据集显示公司中每个员工的员工姓名和ID号，以及员工的经理的ID。顶层员工（CEO）的经理ID为`NULL`（没有经理）。
- en: '[PRE40]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The resulting data set looks like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 结果数据集如下所示：
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To produce the organizational chart with the management chain for each employee
    (that is, the path from CEO to employee), use a recursive CTE:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要为每个员工生成组织结构图和每个员工的管理链（即从CEO到员工的路径），请使用递归CTE：
- en: '[PRE42]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The CTE produces this output:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: CTE生成此输出：
- en: '[PRE43]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'How the CTE works:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: CTE的工作原理：
- en: The nonrecursive [`SELECT`](select.html "15.2.13 SELECT Statement") produces
    the row for the CEO (the row with a `NULL` manager ID).
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非递归[`SELECT`](select.html "15.2.13 SELECT Statement")生成CEO的行（具有`NULL`管理者ID的行）。
- en: The `path` column is widened to `CHAR(200)` to ensure that there is room for
    the longer `path` values produced by the recursive [`SELECT`](select.html "15.2.13 SELECT
    Statement").
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`path`列扩展为`CHAR(200)`，以确保递归[`SELECT`](select.html "15.2.13 SELECT Statement")生成的较长`path`值有足够的空间。'
- en: Each row produced by the recursive [`SELECT`](select.html "15.2.13 SELECT Statement")
    finds all employees who report directly to an employee produced by a previous
    row. For each such employee, the row includes the employee ID and name, and the
    employee management chain. The chain is the manager's chain, with the employee
    ID added to the end.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归[`SELECT`](select.html "15.2.13 SELECT Statement")生成的每行找到所有直接向前一行生成的员工报告的员工。对于每个这样的员工，行包括员工ID和姓名，以及员工的管理链。链是经理的链，员工ID添加到末尾。
- en: Recursion ends when employees have no others who report to them.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当员工没有其他人向他们报告时，递归结束。
- en: 'To find the path for a specific employee or employees, add a `WHERE` clause
    to the top-level [`SELECT`](select.html "15.2.13 SELECT Statement"). For example,
    to display the results for Tarek and Sarah, modify that [`SELECT`](select.html
    "15.2.13 SELECT Statement") like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找特定员工或员工的路径，请在顶层[`SELECT`](select.html "15.2.13 SELECT Statement")添加`WHERE`子句。例如，要显示Tarek和Sarah的结果，请修改[`SELECT`](select.html
    "15.2.13 SELECT Statement")如下：
- en: '[PRE44]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Common Table Expressions Compared to Similar Constructs
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 与类似结构比较的通用表达式
- en: 'Common table expressions (CTEs) are similar to derived tables in some ways:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通用表达式（CTEs）在某些方面类似于派生表：
- en: Both constructs are named.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两种结构都有名称。
- en: Both constructs exist for the scope of a single statement.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两种结构存在于单个语句的范围内。
- en: 'Because of these similarities, CTEs and derived tables often can be used interchangeably.
    As a trivial example, these statements are equivalent:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些相似之处，CTE和派生表通常可以互换使用。作为一个简单的例子，以下语句是等价的：
- en: '[PRE45]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'However, CTEs have some advantages over derived tables:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，CTE相对于派生表有一些优势：
- en: A derived table can be referenced only a single time within a query. A CTE can
    be referenced multiple times. To use multiple instances of a derived table result,
    you must derive the result multiple times.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 派生表只能在查询中引用一次。而CTE可以被多次引用。要使用派生表结果的多个实例，必须多次派生结果。
- en: A CTE can be self-referencing (recursive).
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个CTE可以是自引用的（递归的）。
- en: One CTE can refer to another.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个CTE可以引用另一个CTE。
- en: A CTE may be easier to read when its definition appears at the beginning of
    the statement rather than embedded within it.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个CTE在语句中的定义出现在开头时可能更容易阅读，而不是嵌入其中。
- en: CTEs are similar to tables created with [`CREATE [TEMPORARY] TABLE`](create-table.html
    "15.1.20 CREATE TABLE Statement") but need not be defined or dropped explicitly.
    For a CTE, you need no privileges to create tables.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: CTE类似于使用[`CREATE [TEMPORARY] TABLE`](create-table.html "15.1.20 CREATE TABLE
    Statement")创建的表，但不需要显式定义或删除。对于CTE，您无需拥有创建表的权限。
