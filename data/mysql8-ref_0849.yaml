- en: 14.17.6 JSON Table Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14.17.6 JSON表函数
- en: 原文：[https://dev.mysql.com/doc/refman/8.0/en/json-table-functions.html](https://dev.mysql.com/doc/refman/8.0/en/json-table-functions.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 译文：[https://dev.mysql.com/doc/refman/8.0/en/json-table-functions.html](https://dev.mysql.com/doc/refman/8.0/en/json-table-functions.html)
- en: This section contains information about JSON functions that convert JSON data
    to tabular data. MySQL 8.0 supports one such function, `JSON_TABLE()`.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含将JSON数据转换为表格数据的JSON函数的信息。MySQL 8.0支持一种名为`JSON_TABLE()`的函数。
- en: '[`JSON_TABLE(*`expr`*, *`path`* COLUMNS (*`column_list`*) [AS] *`alias`*)`](json-table-functions.html#function_json-table)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[`JSON_TABLE(*`expr`*, *`path`* COLUMNS (*`column_list`*) [AS] *`alias`*)`](json-table-functions.html#function_json-table)'
- en: 'Extracts data from a JSON document and returns it as a relational table having
    the specified columns. The complete syntax for this function is shown here:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 从JSON文档中提取数据，并将其作为具有指定列的关系表返回。此函数的完整语法如下所示：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*`expr`*: This is an expression that returns JSON data. This can be a constant
    (`''{"a":1}''`), a column (`t1.json_data`, given table `t1` specified prior to
    `JSON_TABLE()` in the `FROM` clause), or a function call (`JSON_EXTRACT(t1.json_data,''$.post.comments'')`).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*`expr`*：这是返回JSON数据的表达式。这可以是一个常量（`''{"a":1}''`），一个列（`t1.json_data`，在`FROM`子句中在`JSON_TABLE()`之前指定了表`t1`），或一个函数调用（`JSON_EXTRACT(t1.json_data,''$.post.comments'')`）。'
- en: '*`path`*: A JSON path expression, which is applied to the data source. We refer
    to the JSON value matching the path as the *row source*; this is used to generate
    a row of relational data. The `COLUMNS` clause evaluates the row source, finds
    specific JSON values within the row source, and returns those JSON values as SQL
    values in individual columns of a row of relational data.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*`path`*：一个应用于数据源的JSON路径表达式。我们将匹配路径的JSON值称为*行源*；这用于生成关系数据的一行。`COLUMNS`子句评估行源，在行源中找到特定的JSON值，并将这些JSON值作为关系数据行的各个列中的SQL值返回。'
- en: The *`alias`* is required. The usual rules for table aliases apply (see [Section 11.2,
    “Schema Object Names”](identifiers.html "11.2 Schema Object Names")).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*`alias`*是必需的。适用于表别名的通常规则（参见[第11.2节，“模式对象名称”](identifiers.html "11.2 Schema
    Object Names")）。'
- en: Beginning with MySQL 8.0.27, this function compares column names in case-insensitive
    fashion.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 从MySQL 8.0.27开始，此函数以不区分大小写的方式比较列名。
- en: '`JSON_TABLE()` supports four types of columns, described in the following list:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSON_TABLE()`支持四种列类型，描述如下：'
- en: '`*`name`* FOR ORDINALITY`: This type enumerates rows in the `COLUMNS` clause;
    the column named *`name`* is a counter whose type is `UNSIGNED INT`, and whose
    initial value is 1. This is equivalent to specifying a column as `AUTO_INCREMENT`
    in a [`CREATE TABLE`](create-table.html "15.1.20 CREATE TABLE Statement") statement,
    and can be used to distinguish parent rows with the same value for multiple rows
    generated by a `NESTED [PATH]` clause.'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`*`name`* FOR ORDINALITY`：此类型在`COLUMNS`子句中枚举行；名为*`name`*的列是一个计数器，其类型为`UNSIGNED
    INT`，初始值为1。这相当于在[`CREATE TABLE`](create-table.html "15.1.20 CREATE TABLE Statement")语句中指定列为`AUTO_INCREMENT`，并可用于区分由`NESTED
    [PATH]`子句生成的多行中具有相同值的父行。'
- en: '`*`name`* *`type`* PATH *`string_path`* [*`on_empty`*] [*`on_error`*]`: Columns
    of this type are used to extract values specified by *`string_path`*. *`type`*
    is a MySQL scalar data type (that is, it cannot be an object or array). `JSON_TABLE()`
    extracts data as JSON then coerces it to the column type, using the regular automatic
    type conversion applying to JSON data in MySQL. A missing value triggers the *`on_empty`*
    clause. Saving an object or array triggers the optional *`on error`* clause; this
    also occurs when an error takes place during coercion from the value saved as
    JSON to the table column, such as trying to save the string `''asd''` to an integer
    column.'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`*`name`* *`type`* PATH *`string_path`* [*`on_empty`*] [*`on_error`*]`：此类型的列用于提取由*`string_path`*指定的值。*`type`*是MySQL标量数据类型（即，不能是对象或数组）。`JSON_TABLE()`将数据提取为JSON，然后将其强制转换为列类型，使用MySQL中适用于JSON数据的常规自动类型转换。缺少值会触发*`on_empty`*子句。保存对象或数组会触发可选的*`on_error`*子句；当在将保存为JSON的值从JSON转换为表列时发生错误时，例如尝试将字符串`''asd''`保存到整数列时，也会发生这种情况。'
- en: '`*`name`* *`type`* EXISTS PATH *`path`*`: This column returns 1 if any data
    is present at the location specified by *`path`*, and 0 otherwise. *`type`* can
    be any valid MySQL data type, but should normally be specified as some variety
    of [`INT`](integer-types.html "13.1.2 Integer Types (Exact Value) - INTEGER, INT,
    SMALLINT, TINYINT, MEDIUMINT, BIGINT").'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`*`name`* *`type`* EXISTS PATH *`path`*`：如果指定的 *`path`* 位置存在任何数据，则此列返回 1，否则返回
    0。*`type`* 可以是任何有效的 MySQL 数据类型，但通常应指定为某种类型的 [`INT`](integer-types.html "13.1.2 Integer
    Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT")。'
- en: '`NESTED [PATH] *`path`* COLUMNS (*`column_list`*)`: This flattens nested objects
    or arrays in JSON data into a single row along with the JSON values from the parent
    object or array. Using multiple `PATH` options allows projection of JSON values
    from multiple levels of nesting into a single row.'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`NESTED [PATH] *`path`* COLUMNS (*`column_list`*)`：这将 JSON 数据中嵌套的对象或数组展开为单行，并包括来自父对象或数组的
    JSON 值。使用多个 `PATH` 选项允许将多个嵌套级别的 JSON 值投影到单行中。'
- en: The *`path`* is relative to the parent path row path of `JSON_TABLE()`, or the
    path of the parent `NESTED [PATH]` clause in the event of nested paths.
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*`path`* 相对于 `JSON_TABLE()` 的父路径行路径，或者在嵌套路径的情况下，相对于父 `NESTED [PATH]` 子句的路径。'
- en: '*`on empty`*, if specified, determines what `JSON_TABLE()` does in the event
    that data is missing (depending on type). This clause is also triggered on a column
    in a `NESTED PATH` clause when the latter has no match and a `NULL` complemented
    row is produced for it. *`on empty`* takes one of the following values:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*`on empty`*，如果指定，确定 `JSON_TABLE()` 在数据缺失时（取决于类型）的操作。当 `NESTED PATH` 子句中的列没有匹配项并且为其生成了一个
    `NULL` 补充行时，此子句也会触发。*`on empty`* 可以采用以下值：'
- en: '`NULL ON EMPTY`: The column is set to `NULL`; this is the default behavior.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NULL ON EMPTY`：列被设置为 `NULL`；这是默认行为。'
- en: '`DEFAULT *`json_string`* ON EMPTY`: the provided *`json_string`* is parsed
    as JSON, as long as it is valid, and stored instead of the missing value. Column
    type rules also apply to the default value.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEFAULT *`json_string`* ON EMPTY`：提供的 *`json_string`* 被解析为 JSON，只要它是有效的，并且存储在缺失值的位置。列类型规则也适用于默认值。'
- en: '`ERROR ON EMPTY`: An error is thrown.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ERROR ON EMPTY`：抛出错误。'
- en: 'If used, *`on_error`* takes one of the following values with the corresponding
    result as shown here:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 *`on_error`*，则可以采用以下值，并显示相应的结果如下：
- en: '`NULL ON ERROR`: The column is set to `NULL`; this is the default behavior.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NULL ON ERROR`：列被设置为 `NULL`；这是默认行为。'
- en: '`DEFAULT *`json string`* ON ERROR`: The *`json_string`* is parsed as JSON (provided
    that it is valid) and stored instead of the object or array.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEFAULT *`json string`* ON ERROR`：*`json_string`* 被解析为 JSON（前提是它是有效的），并存储在对象或数组的位置。 '
- en: '`ERROR ON ERROR`: An error is thrown.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ERROR ON ERROR`：抛出错误。'
- en: 'Prior to MySQL 8.0.20, a warning was thrown if a type conversion error occurred
    with `NULL ON ERROR` or `DEFAULT ... ON ERROR` was specified or implied. In MySQL
    8.0.20 and later, this is no longer the case. (Bug #30628330)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '在 MySQL 8.0.20 之前，如果发生类型转换错误，并且指定或暗示了 `NULL ON ERROR` 或 `DEFAULT ... ON ERROR`，则会发出警告。在
    MySQL 8.0.20 及更高版本中，不再会出现这种情况。（Bug #30628330）'
- en: Previously, it was possible to specify `ON EMPTY` and `ON ERROR` clauses in
    either order. This runs counter to the SQL standard, which stipulates that `ON
    EMPTY`, if specified, must precede any `ON ERROR` clause. For this reason, beginning
    with MySQL 8.0.20, specifying `ON ERROR` before `ON EMPTY` is deprecated; trying
    to do so causes the server to issue a warning. Expect support for the nonstandard
    syntax to be removed in a future version of MySQL.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，可以以任何顺序指定 `ON EMPTY` 和 `ON ERROR` 子句。这与 SQL 标准相悖，后者规定，如果指定了 `ON EMPTY`，则必须在任何
    `ON ERROR` 子句之前。因此，从 MySQL 8.0.20 开始，指定 `ON ERROR` 在 `ON EMPTY` 之前已被弃用；尝试这样做会导致服务器发出警告。预计在未来的
    MySQL 版本中将删除对非标准语法的支持。
- en: When a value saved to a column is truncated, such as saving 3.14159 in a [`DECIMAL(10,1)`](fixed-point-types.html
    "13.1.3 Fixed-Point Types (Exact Value) - DECIMAL, NUMERIC") column, a warning
    is issued independently of any `ON ERROR` option. When multiple values are truncated
    in a single statement, the warning is issued only once.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当将一个值保存到列中时被截断，例如将 3.14159 保存在 [`DECIMAL(10,1)`](fixed-point-types.html "13.1.3 Fixed-Point
    Types (Exact Value) - DECIMAL, NUMERIC") 列中，将发出警告，与任何 `ON ERROR` 选项无关。当在单个语句中截断多个值时，只会发出一次警告。
- en: 'Prior to MySQL 8.0.21, when the expression and path passed to this function
    resolved to JSON null, `JSON_TABLE()` raised an error. In MySQL 8.0.21 and later,
    it returns SQL `NULL` in such cases, in accordance with the SQL standard, as shown
    here (Bug #31345503, Bug #99557):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '在MySQL 8.0.21之前，当传递给此函数的表达式和路径解析为JSON null时，`JSON_TABLE()`会引发错误。在MySQL 8.0.21及更高版本中，在这种情况下返回SQL
    `NULL`，符合SQL标准，如下所示（Bug #31345503，Bug #99557）：'
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The following query demonstrates the use of `ON EMPTY` and `ON ERROR`. The row
    corresponding to `{"b":1}` is empty for the path `"$.a"`, and attempting to save
    `[1,2]` as a scalar produces an error; these rows are highlighted in the output
    shown.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下查询演示了`ON EMPTY`和`ON ERROR`的使用。对应于`{"b":1}`的行在路径`"$.a"`上为空，并尝试将`[1,2]`保存为标量会产生错误；这些行在输出中被突出显示。
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Column names are subject to the usual rules and limitations governing table
    column names. See [Section 11.2, “Schema Object Names”](identifiers.html "11.2 Schema
    Object Names").
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 列名受表列名规则和限制的约束。请参见[第11.2节，“模式对象名称”](identifiers.html "11.2 Schema Object Names")。
- en: All JSON and JSON path expressions are checked for validity; an invalid expression
    of either type causes an error.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 所有JSON和JSON路径表达式都会被检查其有效性；任何一种类型的无效表达式都会导致错误。
- en: 'Each match for the *`path`* preceding the `COLUMNS` keyword maps to an individual
    row in the result table. For example, the following query gives the result shown
    here:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在`COLUMNS`关键字之前的*`path`*的每个匹配项映射到结果表中的一个单独行。例如，以下查询给出了这里显示的结果：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The expression `"$[*]"` matches each element of the array. You can filter the
    rows in the result by modifying the path. For example, using `"$[1]"` limits extraction
    to the second element of the JSON array used as the source, as shown here:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`"$[*]"`匹配数组的每个元素。您可以通过修改路径来过滤结果中的行。例如，使用`"$[1]"`将提取限制为用作源的JSON数组的第二个元素，如下所示：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Within a column definition, `"$"` passes the entire match to the column; `"$.x"`
    and `"$.y"` pass only the values corresponding to the keys `x` and `y`, respectively,
    within that match. For more information, see [JSON Path Syntax](json.html#json-path-syntax
    "JSON Path Syntax").
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在列定义中，`"$"`将整个匹配项传递给列；`"$.x"`和`"$.y"`分别仅传递与该匹配项中的键`x`和`y`对应的值。有关更多信息，请参见[JSON路径语法](json.html#json-path-syntax
    "JSON Path Syntax")。
- en: '`NESTED PATH` (or simply `NESTED`; `PATH` is optional) produces a set of records
    for each match in the `COLUMNS` clause to which it belongs. If there is no match,
    all columns of the nested path are set to `NULL`. This implements an outer join
    between the topmost clause and `NESTED [PATH]`. An inner join can be emulated
    by applying a suitable condition in the `WHERE` clause, as shown here:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`NESTED PATH`（或简称`NESTED`；`PATH`是可选的）为`COLUMNS`子句中的每个匹配项生成一组记录。如果没有匹配项，则嵌套路径的所有列都设置为`NULL`。这实现了顶层子句和`NESTED
    [PATH]`之间的外连接。可以通过在`WHERE`子句中应用适当条件来模拟内连接，如下所示：'
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Sibling nested paths—that is, two or more instances of `NESTED [PATH]` in the
    same `COLUMNS` clause—are processed one after another, one at a time. While one
    nested path is producing records, columns of any sibling nested path expressions
    are set to `NULL`. This means that the total number of records for a single match
    within a single containing `COLUMNS` clause is the sum and not the product of
    all records produced by `NESTED [PATH]` modifiers, as shown here:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 兄弟嵌套路径——即在同一`COLUMNS`子句中的两个或多个`NESTED [PATH]`实例——依次处理，一次处理一个。当一个嵌套路径生成记录时，任何兄弟嵌套路径表达式的列都设置为`NULL`。这意味着在单个包含`COLUMNS`子句中的单个匹配项的总记录数是由`NESTED
    [PATH]`修饰符生成的所有记录的总和，而不是乘积，如下所示：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A `FOR ORDINALITY` column enumerates records produced by the `COLUMNS` clause,
    and can be used to distinguish parent records of a nested path, especially if
    values in parent records are the same, as can be seen here:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`FOR ORDINALITY`列枚举由`COLUMNS`子句生成的记录，并可用于区分嵌套路径的父记录，特别是如果父记录中的值相同，则可以看到：'
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The source document contains an array of two elements; each of these elements
    produces two rows. The values of `apath` and `bpath` are the same over the entire
    result set; this means that they cannot be used to determine whether `lpath` values
    came from the same or different parents. The value of the `ord` column remains
    the same as the set of records having `top_ord` equal to 1, so these two values
    are from a single object. The remaining two values are from different objects,
    since they have different values in the `ord` column.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 源文档包含一个包含两个元素的数组；每个元素产生两行。 `apath` 和 `bpath` 的值在整个结果集中保持不变；这意味着它们不能用来确定 `lpath`
    值是来自相同还是不同的父级。 `ord` 列的值与具有 `top_ord` 等于1的记录集保持一致，因此这两个值来自单个对象。 剩下的两个值来自不同的对象，因为它们在
    `ord` 列中具有不同的值。
- en: Normally, you cannot join a derived table which depends on columns of preceding
    tables in the same `FROM` clause. MySQL, per the SQL standard, makes an exception
    for table functions; these are considered lateral derived tables, even in versions
    of MySQL that do not yet support the `LATERAL` keyword (8.0.13 and earlier). In
    versions where `LATERAL` is supported (8.0.14 and later), it is implicit, and
    for this reason is not allowed before `JSON_TABLE()`, also according to the standard.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，您不能在相同的 `FROM` 子句中连接依赖于前面表的列的派生表。 MySQL根据SQL标准对表函数做了一个例外；即使在尚未支持 `LATERAL`
    关键字的MySQL版本中（8.0.13及更早版本），这些被视为横向派生表。 在支持 `LATERAL` 的版本中（8.0.14及更高版本），它是隐式的，并且因此在
    `JSON_TABLE()` 之前不允许使用。
- en: 'Suppose you have a table `t1` created and populated using the statements shown
    here:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已经创建并使用以下语句填充了一个名为 `t1` 的表：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can then execute joins, such as this one, in which `JSON_TABLE()` acts
    as a derived table while at the same time it refers to a column in a previously
    referenced table:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以执行诸如这样的连接，其中 `JSON_TABLE()` 充当派生表，同时引用先前引用表中的列：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Attempting to use the `LATERAL` keyword with this query raises [`ER_PARSE_ERROR`](/doc/mysql-errors/8.0/en/server-error-reference.html#error_er_parse_error).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在此查询中使用 `LATERAL` 关键字会引发 [`ER_PARSE_ERROR`](/doc/mysql-errors/8.0/en/server-error-reference.html#error_er_parse_error)。
