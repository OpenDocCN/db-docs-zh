- en: The C language interface to SQLite Version 2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQLite Version 2的C语言接口
- en: 原文：[https://sqlite.com/c_interface.html](https://sqlite.com/c_interface.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://sqlite.com/c_interface.html](https://sqlite.com/c_interface.html)
- en: '| **Editorial Note:** This document describes SQLite version 2, which was deprecated
    and replaced by SQLite3 in 2004. This document is retained as part of the historical
    record of SQLite. Modern programmers should refer to more up-to-date documentation
    on SQLite is available elsewhere on this website. |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '| **编者按：** 本文档描述的是已于2004年被弃用并由SQLite3取代的SQLite版本2。这份文档作为SQLite历史记录的一部分被保留下来。现代程序员应参考本网站其他地方的更为更新的SQLite文档。'
- en: The SQLite library is designed to be very easy to use from a C or C++ program.
    This document gives an overview of the C/C++ programming interface.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite库设计得非常易于从C或C++程序中使用。本文档概述了C/C++编程接口。
- en: 1.0 The Core API
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.0 核心API
- en: 'The interface to the SQLite library consists of three core functions, one opaque
    data structure, and some constants used as return values. The core interface is
    as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite库的接口由三个核心函数、一个不透明数据结构和一些用作返回值的常量组成。核心接口如下：
- en: '[PRE0]'
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The above is all you really need to know in order to use SQLite in your C or
    C++ programs. There are other interface functions available (and described below)
    but we will begin by describing the core functions shown above.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 以上内容是您在C或C++程序中使用SQLite所需了解的全部。还有其他可用的接口函数（如下所述），但我们将从上面描述的核心函数开始。
- en: 1.1 Opening a database
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1 打开数据库
- en: Use the **sqlite_open** function to open an existing SQLite database or to create
    a new SQLite database. The first argument is the database name. The second argument
    is intended to signal whether the database is going to be used for reading and
    writing or just for reading. But in the current implementation, the second argument
    to **sqlite_open** is ignored. The third argument is a pointer to a string pointer.
    If the third argument is not NULL and an error occurs while trying to open the
    database, then an error message will be written to memory obtained from malloc()
    and *errmsg will be made to point to this error message. The calling function
    is responsible for freeing the memory when it has finished with it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**sqlite_open**函数打开一个现有的SQLite数据库或创建一个新的SQLite数据库。第一个参数是数据库名称。第二个参数意图是表明数据库是用于读写还是仅用于读取。但在当前实现中，**sqlite_open**的第二个参数被忽略。第三个参数是一个指向字符串指针的指针。如果第三个参数不为NULL并且在尝试打开数据库时发生错误，则会将错误消息写入从malloc()获取的内存中，并且*errmsg将指向这条错误消息。调用函数在完成后负责释放内存。
- en: The name of an SQLite database is the name of a file that will contain the database.
    If the file does not exist, SQLite attempts to create and initialize it. If the
    file is read-only (due to permission bits or because it is located on read-only
    media like a CD-ROM) then SQLite opens the database for reading only. The entire
    SQL database is stored in a single file on the disk. But additional temporary
    files may be created during the execution of an SQL command in order to store
    the database rollback journal or temporary and intermediate results of a query.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite数据库的名称是将包含数据库的文件的名称。如果文件不存在，SQLite将尝试创建并初始化它。如果文件是只读的（由于权限位或因为它位于只读介质如CD-ROM上），那么SQLite仅打开数据库以供读取。整个SQL数据库存储在磁盘上的单个文件中。但在执行SQL命令期间可能会创建额外的临时文件，用于存储数据库回滚日志或查询的临时和中间结果。
- en: The return value of the **sqlite_open** function is a pointer to an opaque **sqlite**
    structure. This pointer will be the first argument to all subsequent SQLite function
    calls that deal with the same database. NULL is returned if the open fails for
    any reason.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**sqlite_open** 函数的返回值是一个指向不透明**sqlite**结构的指针。该指针将成为处理相同数据库的所有后续SQLite函数调用的第一个参数。如果由于任何原因打开失败，则返回NULL。'
- en: 1.2 Closing the database
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2 关闭数据库
- en: To close an SQLite database, call the **sqlite_close** function passing it the
    sqlite structure pointer that was obtained from a prior call to **sqlite_open**.
    If a transaction is active when the database is closed, the transaction is rolled
    back.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭SQLite数据库，请调用**sqlite_close**函数，并将先前从**sqlite_open**调用中获得的sqlite结构指针传递给它。如果数据库关闭时有事务处于活动状态，则事务将被回滚。
- en: 1.3 Executing SQL statements
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3 执行SQL语句
- en: 'The **sqlite_exec** function is used to process SQL statements and queries.
    This function requires 5 parameters as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**sqlite_exec** 函数用于处理SQL语句和查询。该函数需要以下5个参数：'
- en: A pointer to the sqlite structure obtained from a prior call to **sqlite_open**.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个指向先前从**sqlite_open**调用中获取的sqlite结构的指针。
- en: A zero-terminated string containing the text of one or more SQL statements and/or
    queries to be processed.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含一个或多个SQL语句和/或查询文本的以零结尾的字符串。
- en: A pointer to a callback function which is invoked once for each row in the result
    of a query. This argument may be NULL, in which case no callbacks will ever be
    invoked.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个指向回调函数的指针，该函数在查询结果的每一行中调用一次。此参数可以为NULL，如果为NULL，则永远不会调用回调函数。
- en: A pointer that is forwarded to become the first argument to the callback function.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个指针，将作为回调函数的第一个参数传递。
- en: A pointer to an error string. Error messages are written to space obtained from
    malloc() and the error string is made to point to the malloced space. The calling
    function is responsible for freeing this space when it has finished with it. This
    argument may be NULL, in which case error messages are not reported back to the
    calling function.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指向错误字符串的指针。错误消息被写入从 malloc() 获得的空间，并且错误字符串指向了 malloc 分配的空间。调用函数在使用完后负责释放此空间。此参数可能为空，在这种情况下，错误消息不会被报告回调用函数。
- en: 'The callback function is used to receive the results of a query. A prototype
    for the callback function is as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数用于接收查询结果。回调函数的原型如下所示：
- en: '[PRE1]'
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The first argument to the callback is just a copy of the fourth argument to
    **sqlite_exec** This parameter can be used to pass arbitrary information through
    to the callback function from client code. The second argument is the number of
    columns in the query result. The third argument is an array of pointers to strings
    where each string is a single column of the result for that record. Note that
    the callback function reports a NULL value in the database as a NULL pointer,
    which is very different from an empty string. If the i-th parameter is an empty
    string, we will get:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 回调的第一个参数只是 **sqlite_exec** 的第四个参数的一个副本。此参数可用于通过客户端代码将任意信息传递给回调函数。第二个参数是查询结果中的列数。第三个参数是一个指向字符串指针数组的指针，其中每个字符串是该记录结果的单个列。请注意，回调函数将数据库中的
    NULL 值报告为 NULL 指针，这与空字符串非常不同。如果第 i 个参数是空字符串，我们会得到：
- en: '[PRE2]'
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'But if the i-th parameter is NULL we will get:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果第 i 个参数为空，我们会得到：
- en: '[PRE3]'
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The names of the columns are contained in first *argc* entries of the fourth
    argument. If the [SHOW_DATATYPES](pragma.html) pragma is on (it is off by default)
    then the second *argc* entries in the 4th argument are the datatypes for the corresponding
    columns.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 列的名称包含在第 *argc* 个参数的第四个参数的前几个条目中。如果 [SHOW_DATATYPES](pragma.html) pragma 打开（默认关闭），则第四个参数的第二
    *argc* 个条目是相应列的数据类型。
- en: If the [EMPTY_RESULT_CALLBACKS](pragma.html#pragma_empty_result_callbacks) pragma
    is set to ON and the result of a query is an empty set, then the callback is invoked
    once with the third parameter (argv) set to 0\. In other words
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 [EMPTY_RESULT_CALLBACKS](pragma.html#pragma_empty_result_callbacks) pragma
    设置为 ON 并且查询的结果是空集，则回调将使用第三个参数 (argv) 设置为 0。换句话说，
- en: '[PRE4]'
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The second parameter (argc) and the fourth parameter (columnNames) are still
    valid and can be used to determine the number and names of the result columns
    if there had been a result. The default behavior is not to invoke the callback
    at all if the result set is empty.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数 (argc) 和第四个参数 (columnNames) 仍然有效，并且可以用于确定结果列的数量和名称（如果有结果）。默认行为是如果结果集为空，则根本不调用回调函数。
- en: The callback function should normally return 0\. If the callback function returns
    non-zero, the query is immediately aborted and **sqlite_exec** will return SQLITE_ABORT.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数通常应返回 0。如果回调函数返回非零值，则立即中止查询，**sqlite_exec** 将返回 SQLITE_ABORT。
- en: 1.4 Error Codes
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4 错误代码
- en: 'The **sqlite_exec** function normally returns SQLITE_OK. But if something goes
    wrong it can return a different value to indicate the type of error. Here is a
    complete list of the return codes:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**sqlite_exec** 函数通常返回 SQLITE_OK。但如果出现问题，它可以返回不同的值以指示错误类型。以下是返回代码的完整列表：'
- en: '[PRE5]'
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The meanings of these various return values are as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不同返回值的含义如下：
- en: SQLITE_OK
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQLITE_OK
- en: ''
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This value is returned if everything worked and there were no errors.
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果一切正常且没有错误，则返回此值。
- en: ''
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SQLITE_INTERNAL
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQLITE_INTERNAL
- en: ''
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This value indicates that an internal consistency check within the SQLite library
    failed. This can only happen if there is a bug in the SQLite library. If you ever
    get an SQLITE_INTERNAL reply from an **sqlite_exec** call, please report the problem
    on the SQLite mailing list.
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此值表示 SQLite 库内部一致性检查失败。这只会在 SQLite 库中存在错误时发生。如果您从 **sqlite_exec** 调用中获得 SQLITE_INTERNAL
    回复，请在 SQLite 邮件列表上报告此问题。
- en: ''
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SQLITE_ERROR
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQLITE_ERROR
- en: ''
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This return value indicates that there was an error in the SQL that was passed
    into the **sqlite_exec**.
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此返回值表明传递给 **sqlite_exec** 的 SQL 中存在错误。
- en: ''
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SQLITE_PERM
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQLITE_PERM
- en: ''
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This return value says that the access permissions on the database file are
    such that the file cannot be opened.
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此返回值表示数据库文件的访问权限使得无法打开该文件。
- en: ''
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SQLITE_ABORT
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQLITE_ABORT
- en: ''
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This value is returned if the callback function returns non-zero.
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果回调函数返回非零，则返回此值。
- en: ''
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SQLITE_BUSY
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQLITE_BUSY
- en: ''
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This return code indicates that another program or thread has the database locked.
    SQLite allows two or more threads to read the database at the same time, but only
    one thread can have the database open for writing at the same time. Locking in
    SQLite is on the entire database.
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此返回代码表示另一个程序或线程已锁定数据库。SQLite 允许两个或更多线程同时读取数据库，但同一时间只能有一个线程可以写入数据库。在 SQLite 中，锁定是对整个数据库的。
- en: ''
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SQLITE_LOCKED
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQLITE_LOCKED
- en: ''
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This return code is similar to SQLITE_BUSY in that it indicates that the database
    is locked. But the source of the lock is a recursive call to **sqlite_exec**.
    This return can only occur if you attempt to invoke sqlite_exec from within a
    callback routine of a query from a prior invocation of sqlite_exec. Recursive
    calls to sqlite_exec are allowed as long as they do not attempt to write the same
    table.
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此返回代码与 SQLITE_BUSY 类似，表明数据库已锁定。但锁定的来源是对 **sqlite_exec** 的递归调用。此返回仅在您尝试从先前调用
    **sqlite_exec** 的查询的回调函数中调用 sqlite_exec 时才会发生。允许递归调用 **sqlite_exec**，只要它们不尝试写入相同的表。
- en: ''
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SQLITE_NOMEM
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQLITE_NOMEM
- en: ''
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This value is returned if a call to **malloc** fails.
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果调用 **malloc** 失败，则返回此值。
- en: ''
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SQLITE_READONLY
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQLITE_READONLY
- en: ''
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This return code indicates that an attempt was made to write to a database file
    that is opened for reading only.
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此返回代码指示尝试向仅供读取的数据库文件写入时返回。
- en: ''
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SQLITE_INTERRUPT
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQLITE_INTERRUPT
- en: ''
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This value is returned if a call to **sqlite_interrupt** interrupts a database
    operation in progress.
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果调用**sqlite_interrupt**中断正在进行的数据库操作，将返回此值。
- en: ''
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SQLITE_IOERR
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQLITE_IOERR
- en: ''
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This value is returned if the operating system informs SQLite that it is unable
    to perform some disk I/O operation. This could mean that there is no more space
    left on the disk.
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果操作系统通知SQLite无法执行某些磁盘I/O操作，将返回此值。这可能意味着磁盘上没有剩余空间了。
- en: ''
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SQLITE_CORRUPT
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQLITE_CORRUPT
- en: ''
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This value is returned if SQLite detects that the database it is working on
    has become corrupted. Corruption might occur due to a rogue process writing to
    the database file or it might happen due to a previously undetected logic error
    in of SQLite. This value is also returned if a disk I/O error occurs in such a
    way that SQLite is forced to leave the database file in a corrupted state. The
    latter should only happen due to a hardware or operating system malfunction.
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果SQLite检测到它正在处理的数据库已损坏，则返回此值。损坏可能是由于恶意进程向数据库文件写入，也可能是由于SQLite先前未检测到的逻辑错误引起的。如果发生这种情况，SQLite被迫以损坏的状态离开数据库文件时，也将返回此值。后者只应该由硬件或操作系统故障引起。
- en: ''
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SQLITE_FULL
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQLITE_FULL
- en: ''
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This value is returned if an insertion failed because there is no space left
    on the disk, or the database is too big to hold any more information. The latter
    case should only occur for databases that are larger than 2GB in size.
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果插入失败，因为磁盘上没有剩余空间，或者数据库太大而无法容纳更多信息，则返回此值。后一种情况应仅发生在大于2GB大小的数据库中。
- en: ''
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SQLITE_CANTOPEN
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQLITE_CANTOPEN
- en: ''
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This value is returned if the database file could not be opened for some reason.
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果由于某些原因无法打开数据库文件，将返回此值。
- en: ''
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SQLITE_PROTOCOL
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQLITE_PROTOCOL
- en: ''
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This value is returned if some other process is messing with file locks and
    has violated the file locking protocol that SQLite uses on its rollback journal
    files.
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果其他进程正在干扰文件锁，并且违反了SQLite在其回滚日志文件上使用的文件锁定协议，将返回此值。
- en: ''
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SQLITE_SCHEMA
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQLITE_SCHEMA
- en: ''
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When the database first opened, SQLite reads the database schema into memory
    and uses that schema to parse new SQL statements. If another process changes the
    schema, the command currently being processed will abort because the virtual machine
    code generated assumed the old schema. This is the return code for such cases.
    Retrying the command usually will clear the problem.
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当数据库首次打开时，SQLite将数据库架构读入内存，并使用该架构解析新的SQL语句。如果另一个进程更改了架构，则当前正在处理的命令将中止，因为生成的虚拟机代码假定旧的架构。这是这种情况的返回代码。通常重新尝试命令可以解决问题。
- en: ''
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SQLITE_TOOBIG
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQLITE_TOOBIG
- en: ''
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SQLite will not store more than about 1 megabyte of data in a single row of
    a single table. If you attempt to store more than 1 megabyte in a single row,
    this is the return code you get.
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQLite不会在单个表的单行中存储超过约1兆字节的数据。如果尝试在单行中存储超过1兆字节的数据，这将是您收到的返回代码。
- en: ''
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SQLITE_CONSTRAINT
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQLITE_CONSTRAINT
- en: ''
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This constant is returned if the SQL statement would have violated a database
    constraint.
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果SQL语句违反了数据库约束，则返回此常量。
- en: ''
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SQLITE_MISMATCH
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQLITE_MISMATCH
- en: ''
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This error occurs when there is an attempt to insert non-integer data into a
    column labeled INTEGER PRIMARY KEY. For most columns, SQLite ignores the data
    type and allows any kind of data to be stored. But an INTEGER PRIMARY KEY column
    is only allowed to store integer data.
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当试图将非整数数据插入标记为INTEGER PRIMARY KEY的列时，会发生此错误。对于大多数列，SQLite会忽略数据类型并允许存储任何类型的数据。但是INTEGER
    PRIMARY KEY列只允许存储整数数据。
- en: ''
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SQLITE_MISUSE
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQLITE_MISUSE
- en: ''
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This error might occur if one or more of the SQLite API routines is used incorrectly.
    Examples of incorrect usage include calling **sqlite_exec** after the database
    has been closed using **sqlite_close** or calling **sqlite_exec** with the same
    database pointer simultaneously from two separate threads.
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果有一个或多个SQLite API例程使用不正确，可能会发生此错误。不正确的用法包括在使用**sqlite_close**关闭数据库后调用**sqlite_exec**，或者同时从两个独立的线程中的相同数据库指针调用**sqlite_exec**。
- en: ''
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SQLITE_NOLFS
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQLITE_NOLFS
- en: ''
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This error means that you have attempts to create or access a file database
    file that is larger that 2GB on a legacy Unix machine that lacks large file support.
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个错误表示您尝试在不支持大文件的旧版Unix机器上创建或访问大于2GB的文件数据库文件。
- en: ''
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SQLITE_AUTH
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQLITE_AUTH
- en: ''
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This error indicates that the authorizer callback has disallowed the SQL you
    are attempting to execute.
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个错误表明授权回调已经禁止了您尝试执行的SQL。
- en: ''
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SQLITE_ROW
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQLITE_ROW
- en: ''
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is one of the return codes from the **sqlite_step** routine which is part
    of the non-callback API. It indicates that another row of result data is available.
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这是**sqlite_step**例程的返回代码之一，它是非回调API的一部分。它表示另一行结果数据可用。
- en: ''
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SQLITE_DONE
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQLITE_DONE
- en: ''
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is one of the return codes from the **sqlite_step** routine which is part
    of the non-callback API. It indicates that the SQL statement has been completely
    executed and the **sqlite_finalize** routine is ready to be called.
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这是**sqlite_step**例程的返回代码之一，它是非回调API的一部分。它表示SQL语句已完全执行，并且**sqlite_finalize**例程已准备就绪可以调用。
- en: 2.0 Accessing Data Without Using A Callback Function
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.0 Accessing Data Without Using A Callback Function
- en: The **sqlite_exec** routine described above used to be the only way to retrieve
    data from an SQLite database. But many programmers found it inconvenient to use
    a callback function to obtain results. So beginning with SQLite version 2.7.7,
    a second access interface is available that does not use callbacks.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 上面描述的**sqlite_exec**例程曾经是从SQLite数据库中检索数据的唯一方式。但是许多程序员发现使用回调函数获取结果很不方便。因此，从SQLite版本2.7.7开始，提供了第二个不使用回调函数的访问接口。
- en: The new interface uses three separate functions to replace the single **sqlite_exec**
    function.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 新接口使用三个独立的函数来替换单一的**sqlite_exec**函数。
- en: '[PRE6]'
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The strategy is to compile a single SQL statement using **sqlite_compile** then
    invoke **sqlite_step** multiple times, once for each row of output, and finally
    call **sqlite_finalize** to clean up after the SQL has finished execution.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是使用**sqlite_compile**编译一条单独的SQL语句，然后针对每行输出多次调用**sqlite_step**，最后调用**sqlite_finalize**来清理SQL执行完成后的状态。
- en: 2.1 Compiling An SQL Statement Into A Virtual Machine
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1 编译SQL语句成虚拟机
- en: The **sqlite_compile** "compiles" a single SQL statement (specified by the second
    parameter) and generates a virtual machine that is able to execute that statement.
    As with must interface routines, the first parameter must be a pointer to an sqlite
    structure that was obtained from a prior call to **sqlite_open**.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**sqlite_compile** "编译"一条单独的SQL语句（由第二个参数指定），并生成一个能执行该语句的虚拟机。与大多数接口例程一样，第一个参数必须是来自对**sqlite_open**的先前调用的sqlite结构的指针。'
- en: A pointer to the virtual machine is stored in a pointer which is passed in as
    the 4th parameter. Space to hold the virtual machine is dynamically allocated.
    To avoid a memory leak, the calling function must invoke **sqlite_finalize** on
    the virtual machine after it has finished with it. The 4th parameter may be set
    to NULL if an error is encountered during compilation.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机的指针存储在作为第四个参数传入的指针中。用于存储虚拟机的空间是动态分配的。为避免内存泄漏，调用函数在使用完虚拟机后必须调用**sqlite_finalize**。如果在编译过程中遇到错误，第四个参数可能会设置为NULL。
- en: If any errors are encountered during compilation, an error message is written
    into memory obtained from **malloc** and the 5th parameter is made to point to
    that memory. If the 5th parameter is NULL, then no error message is generated.
    If the 5th parameter is not NULL, then the calling function should dispose of
    the memory containing the error message by calling **sqlite_freemem**.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在编译过程中遇到任何错误，错误消息将被写入从**malloc**获取的内存中，第五个参数将指向该内存。如果第五个参数为NULL，则不会生成错误消息。如果第五个参数不为NULL，则调用函数应通过调用**sqlite_freemem**来释放包含错误消息的内存。
- en: If the 2nd parameter actually contains two or more statements of SQL, only the
    first statement is compiled. (This is different from the behavior of **sqlite_exec**
    which executes all SQL statements in its input string.) The 3rd parameter to **sqlite_compile**
    is made to point to the first character beyond the end of the first statement
    of SQL in the input. If the 2nd parameter contains only a single SQL statement,
    then the 3rd parameter will be made to point to the '\000' terminator at the end
    of the 2nd parameter.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第二个参数实际上包含两个或更多条SQL语句，那么只有第一条语句被编译。（这与**sqlite_exec**的行为不同，后者会执行其输入字符串中的所有SQL语句。）**sqlite_compile**的第三个参数指向输入中第一条SQL语句结束后的第一个字符。如果第二个参数只包含一条SQL语句，那么第三个参数将指向第二个参数结尾处的'\000'终结符。
- en: On success, **sqlite_compile** returns SQLITE_OK. Otherwise and error code is
    returned.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，**sqlite_compile** 返回 SQLITE_OK。否则，返回错误代码。
- en: 2.2 Step-By-Step Execution Of An SQL Statement
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2 SQL 语句逐步执行
- en: After a virtual machine has been generated using **sqlite_compile** it is executed
    by one or more calls to **sqlite_step**. Each invocation of **sqlite_step**, except
    the last one, returns a single row of the result. The number of columns in the
    result is stored in the integer that the 2nd parameter points to. The pointer
    specified by the 3rd parameter is made to point to an array of pointers to column
    values. The pointer in the 4th parameter is made to point to an array of pointers
    to column names and datatypes. The 2nd through 4th parameters to **sqlite_step**
    convey the same information as the 2nd through 4th parameters of the **callback**
    routine when using the **sqlite_exec** interface. Except, with **sqlite_step**
    the column datatype information is always included in the in the 4th parameter
    regardless of whether or not the [SHOW_DATATYPES](pragma.html) pragma is on or
    off.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **sqlite_compile** 生成虚拟机后，通过一个或多个调用 **sqlite_step** 来执行它。每次调用 **sqlite_step**（除了最后一次）返回一个结果的单行。结果中的列数存储在第二个参数指向的整数中。第三个参数指定的指针被设置为指向一个指向列值的指针数组。第四个参数指针被设置为指向一个指向列名和数据类型的指针数组。**sqlite_step**
    的第二至第四个参数传递的信息与使用 **sqlite_exec** 接口时 **callback** 例程的第二至第四个参数相同。不同的是，使用 **sqlite_step**
    时，无论是否打开了 [SHOW_DATATYPES](pragma.html) pragma，列数据类型信息始终包含在第四个参数中。
- en: Each invocation of **sqlite_step** returns an integer code that indicates what
    happened during that step. This code may be SQLITE_BUSY, SQLITE_ROW, SQLITE_DONE,
    SQLITE_ERROR, or SQLITE_MISUSE.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用 **sqlite_step** 返回一个整数代码，指示该步骤期间发生的情况。此代码可能是 SQLITE_BUSY、SQLITE_ROW、SQLITE_DONE、SQLITE_ERROR
    或 SQLITE_MISUSE。
- en: If the virtual machine is unable to open the database file because it is locked
    by another thread or process, **sqlite_step** will return SQLITE_BUSY. The calling
    function should do some other activity, or sleep, for a short amount of time to
    give the lock a chance to clear, then invoke **sqlite_step** again. This can be
    repeated as many times as desired.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果虚拟机无法打开数据库文件，因为它被另一个线程或进程锁定，**sqlite_step** 将返回 SQLITE_BUSY。调用函数应该做一些其他活动，或者短暂地休眠，以便让锁有机会清除，然后再次调用
    **sqlite_step**。这可以重复多次。
- en: Whenever another row of result data is available, **sqlite_step** will return
    SQLITE_ROW. The row data is stored in an array of pointers to strings and the
    2nd parameter is made to point to this array.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 每当有另一行结果数据可用时，**sqlite_step** 将返回 SQLITE_ROW。行数据存储在一个指向字符串的指针数组中，第二个参数指向这个数组。
- en: When all processing is complete, **sqlite_step** will return either SQLITE_DONE
    or SQLITE_ERROR. SQLITE_DONE indicates that the statement completed successfully
    and SQLITE_ERROR indicates that there was a run-time error. (The details of the
    error are obtained from **sqlite_finalize**.) It is a misuse of the library to
    attempt to call **sqlite_step** again after it has returned SQLITE_DONE or SQLITE_ERROR.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有处理完成时，**sqlite_step**将返回SQLITE_DONE或SQLITE_ERROR。SQLITE_DONE表示语句成功完成，SQLITE_ERROR表示发生运行时错误。（错误的详细信息来自**sqlite_finalize**。）试图在**sqlite_step**返回SQLITE_DONE或SQLITE_ERROR后再次调用它是对库的误用。
- en: When **sqlite_step** returns SQLITE_DONE or SQLITE_ERROR, the *pN and *pazColName
    values are set to the number of columns in the result set and to the names of
    the columns, just as they are for an SQLITE_ROW return. This allows the calling
    code to find the number of result columns and the column names and datatypes even
    if the result set is empty. The *pazValue parameter is always set to NULL when
    the return codes is SQLITE_DONE or SQLITE_ERROR. If the SQL being executed is
    a statement that does not return a result (such as an INSERT or an UPDATE) then
    *pN will be set to zero and *pazColName will be set to NULL.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当**sqlite_step**返回SQLITE_DONE或SQLITE_ERROR时，*pN和*pazColName的值将设置为结果集中的列数和列的名称，就像对于SQLITE_ROW返回一样。这允许调用代码在结果集为空的情况下找到结果列数和列名及数据类型。当返回代码为SQLITE_DONE或SQLITE_ERROR时，*pazValue参数始终设置为NULL。如果正在执行的SQL是不返回结果的语句（如INSERT或UPDATE），那么*pN将设置为零，*pazColName将设置为NULL。
- en: If you abuse the library by trying to call **sqlite_step** inappropriately it
    will attempt return SQLITE_MISUSE. This can happen if you call sqlite_step() on
    the same virtual machine at the same time from two or more threads or if you call
    sqlite_step() again after it returned SQLITE_DONE or SQLITE_ERROR or if you pass
    in an invalid virtual machine pointer to sqlite_step(). You should not depend
    on the SQLITE_MISUSE return code to indicate an error. It is possible that a misuse
    of the interface will go undetected and result in a program crash. The SQLITE_MISUSE
    is intended as a debugging aid only - to help you detect incorrect usage prior
    to a mishap. The misuse detection logic is not guaranteed to work in every case.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果滥用库试图不当调用**sqlite_step**，它将尝试返回SQLITE_MISUSE。如果您在两个或多个线程中同时调用同一个虚拟机上的sqlite_step()，或者在它返回SQLITE_DONE或SQLITE_ERROR后再次调用sqlite_step()，或者向sqlite_step()传递无效的虚拟机指针，则可能发生这种情况。您不应依赖SQLITE_MISUSE返回代码来指示错误。界面的误用可能不会被检测到，并导致程序崩溃。SQLITE_MISUSE仅用作调试辅助工具
    - 以帮助您在事故发生之前检测到不正确的使用。误用检测逻辑不能保证在每种情况下都能正常工作。
- en: 2.3 Deleting A Virtual Machine
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3 删除虚拟机
- en: Every virtual machine that **sqlite_compile** creates should eventually be handed
    to **sqlite_finalize**. The sqlite_finalize() procedure deallocates the memory
    and other resources that the virtual machine uses. Failure to call sqlite_finalize()
    will result in resource leaks in your program.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 每个**sqlite_compile**创建的虚拟机最终都应该交给**sqlite_finalize**。sqlite_finalize()过程释放虚拟机使用的内存和其他资源。如果不调用sqlite_finalize()，程序中会出现资源泄漏。
- en: The **sqlite_finalize** routine also returns the result code that indicates
    success or failure of the SQL operation that the virtual machine carried out.
    The value returned by sqlite_finalize() will be the same as would have been returned
    had the same SQL been executed by **sqlite_exec**. The error message returned
    will also be the same.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**sqlite_finalize**例程还返回指示虚拟机执行的SQL操作成功或失败的结果代码。sqlite_finalize()返回的值将与通过**sqlite_exec**执行相同SQL时返回的值相同。返回的错误消息也将相同。'
- en: It is acceptable to call **sqlite_finalize** on a virtual machine before **sqlite_step**
    has returned SQLITE_DONE. Doing so has the effect of interrupting the operation
    in progress. Partially completed changes will be rolled back and the database
    will be restored to its original state (unless an alternative recovery algorithm
    is selected using an ON CONFLICT clause in the SQL being executed.) The effect
    is the same as if a callback function of **sqlite_exec** had returned non-zero.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在**sqlite_step**返回SQLITE_DONE之前对虚拟机调用**sqlite_finalize**也是可以接受的。这样做会中断正在进行的操作。部分完成的更改将被回滚，并且数据库将恢复到其原始状态（除非使用SQL中的ON
    CONFLICT子句选择了替代恢复算法）。其效果等同于**sqlite_exec**的回调函数返回非零值的情况。
- en: It is also acceptable to call **sqlite_finalize** on a virtual machine that
    has never been passed to **sqlite_step** even once.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个从未传递给**sqlite_step**的虚拟机上调用**sqlite_finalize**也是可以接受的。
- en: 3.0 The Extended API
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.0 扩展API
- en: 'Only the three core routines described in section 1.0 are required to use SQLite.
    But there are many other functions that provide useful interfaces. These extended
    routines are as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 只有1.0节中描述的三个核心例程是使用SQLite所必需的。但是还有许多其他提供有用接口的函数。这些扩展例程如下：
- en: '[PRE7]'
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE7]'
- en: All of the above definitions are included in the "sqlite.h" header file that
    comes in the source tree.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 所有上述定义都包含在源代码树中的"sqlite.h"头文件中。
- en: 3.1 The ROWID of the most recent insert
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1 最近插入的ROWID
- en: Every row of an SQLite table has a unique integer key. If the table has a column
    labeled INTEGER PRIMARY KEY, then that column serves as the key. If there is no
    INTEGER PRIMARY KEY column then the key is a unique integer. The key for a row
    can be accessed in a SELECT statement or used in a WHERE or ORDER BY clause using
    any of the names "ROWID", "OID", or "_ROWID_".
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 每个SQLite表的每一行都有一个唯一的整数键。如果表有一个标记为INTEGER PRIMARY KEY的列，那么该列将作为键。如果没有INTEGER
    PRIMARY KEY列，则键是一个唯一的整数。可以在SELECT语句中访问行的键，或者在WHERE或ORDER BY子句中使用以下任何一个名称："ROWID"、"OID"或"_ROWID_"。
- en: When you do an insert into a table that does not have an INTEGER PRIMARY KEY
    column, or if the table does have an INTEGER PRIMARY KEY but the value for that
    column is not specified in the VALUES clause of the insert, then the key is automatically
    generated. You can find the value of the key for the most recent INSERT statement
    using the **sqlite_last_insert_rowid** API function.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当向没有INTEGER PRIMARY KEY列的表插入数据时，或者如果表有INTEGER PRIMARY KEY列但在INSERT语句的VALUES子句中没有指定该列的值，则会自动生成该键值。可以使用**sqlite_last_insert_rowid**
    API函数找到最近一次INSERT语句的键值。
- en: 3.2 The number of rows that changed
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2 修改的行数
- en: The **sqlite_changes** API function returns the number of rows that have been
    inserted, deleted, or modified since the database was last quiescent. A "quiescent"
    database is one in which there are no outstanding calls to **sqlite_exec** and
    no VMs created by **sqlite_compile** that have not been finalized by **sqlite_finalize**.
    In common usage, **sqlite_changes** returns the number of rows inserted, deleted,
    or modified by the most recent **sqlite_exec** call or since the most recent **sqlite_compile**.
    But if you have nested calls to **sqlite_exec** (that is, if the callback routine
    of one **sqlite_exec** invokes another **sqlite_exec**) or if you invoke **sqlite_compile**
    to create a new VM while there is still another VM in existence, then the meaning
    of the number returned by **sqlite_changes** is more complex. The number reported
    includes any changes that were later undone by a ROLLBACK or ABORT. But rows that
    are deleted because of a DROP TABLE are *not* counted.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**sqlite_changes** API函数返回自数据库上次静止以来插入、删除或修改的行数。"静止"数据库是指没有未完成的**sqlite_exec**调用，也没有由**sqlite_compile**创建但未由**sqlite_finalize**最终化的VM。通常情况下，**sqlite_changes**返回最近一次**sqlite_exec**调用或自最近一次**sqlite_compile**以来插入、删除或修改的行数。但如果有嵌套调用**sqlite_exec**（即一个**sqlite_exec**的回调例程调用另一个**sqlite_exec**），或者在仍存在另一个VM的情况下调用**sqlite_compile**创建新VM，则**sqlite_changes**返回的数字的含义更为复杂。报告的数字包括后来由ROLLBACK或ABORT撤消的任何更改。但因为DROP
    TABLE而删除的行数*不*计入其中。'
- en: SQLite implements the command "**DELETE FROM table**" (without a WHERE clause)
    by dropping the table then recreating it. This is much faster than deleting the
    elements of the table individually. But it also means that the value returned
    from **sqlite_changes** will be zero regardless of the number of elements that
    were originally in the table. If an accurate count of the number of elements deleted
    is necessary, use "**DELETE FROM table WHERE 1**" instead.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite通过删除表然后重新创建来实现不带WHERE子句的命令"**DELETE FROM table**"。这比逐个删除表中元素要快得多。但这也意味着，无论原表中有多少元素，从**sqlite_changes**返回的值都将是零。如果需要准确计算删除的元素数量，请改用"**DELETE
    FROM table WHERE 1**"。
- en: 3.3 Querying into memory obtained from malloc()
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3 从malloc()获取的内存中进行查询
- en: The **sqlite_get_table** function is a wrapper around **sqlite_exec** that collects
    all the information from successive callbacks and writes it into memory obtained
    from malloc(). This is a convenience function that allows the application to get
    the entire result of a database query with a single function call.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**sqlite_get_table**函数是**sqlite_exec**的一个包装器，它收集连续回调中的所有信息，并将其写入从malloc()获得的内存中。这是一个便利函数，允许应用程序通过单个函数调用获取数据库查询的整个结果。'
- en: The main result from **sqlite_get_table** is an array of pointers to strings.
    There is one element in this array for each column of each row in the result.
    NULL results are represented by a NULL pointer. In addition to the regular data,
    there is an added row at the beginning of the array that contains the name of
    each column of the result.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**sqlite_get_table**的主要结果是一个指向字符串指针的数组。这个数组中的每个元素对应于结果中每行每列的一个元素。NULL结果由NULL指针表示。除了常规数据外，数组的开头还有一个额外的行，其中包含结果每列的名称。'
- en: 'As an example, consider the following query:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下查询：
- en: SELECT employee_name, login, host FROM users WHERE login LIKE 'd%';
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SELECT employee_name, login, host FROM users WHERE login LIKE 'd%';
- en: 'This query will return the name, login and host computer name for every employee
    whose login begins with the letter "d". If this query is submitted to **sqlite_get_table**
    the result might look like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询将返回以字母"d"开头的每位员工的姓名、登录名和主机名。如果将此查询提交给**sqlite_get_table**，结果可能如下所示：
- en: nrow = 2
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: nrow = 2
- en: ncolumn = 3
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ncolumn = 3
- en: result[0] = "employee_name"
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: result[0] = "employee_name"
- en: result[1] = "login"
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: result[1] = "login"
- en: result[2] = "host"
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: result[2] = "host"
- en: result[3] = "dummy"
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: result[3] = "dummy"
- en: result[4] = "No such user"
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: result[4] = "No such user"
- en: result[5] = 0
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: result[5] = 0
- en: result[6] = "D. Richard Hipp"
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: result[6] = "D. Richard Hipp"
- en: result[7] = "drh"
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: result[7] = "drh"
- en: result[8] = "zadok"
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: result[8] = "zadok"
- en: Notice that the "host" value for the "dummy" record is NULL so the result[]
    array contains a NULL pointer at that slot.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，“dummy”记录的“host”值为NULL，因此result[]数组在该位置包含一个NULL指针。
- en: 'If the result set of a query is empty, then by default **sqlite_get_table**
    will set nrow to 0 and leave its result parameter is set to NULL. But if the EMPTY_RESULT_CALLBACKS
    pragma is ON then the result parameter is initialized to the names of the columns
    only. For example, consider this query which has an empty result set:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果查询的结果集为空，默认情况下**sqlite_get_table**会将nrow设置为0，并将其结果参数设置为NULL。但是如果打开了EMPTY_RESULT_CALLBACKS
    pragma，则结果参数初始化为仅列名。例如，考虑以下结果集为空的查询：
- en: SELECT employee_name, login, host FROM users WHERE employee_name IS NULL;
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SELECT employee_name, login, host FROM users WHERE employee_name IS NULL;
- en: 'The default behavior gives this results:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 默认行为提供如下结果：
- en: nrow = 0
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: nrow = 0
- en: ncolumn = 0
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ncolumn = 0
- en: result = 0
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: result = 0
- en: 'But if the EMPTY_RESULT_CALLBACKS pragma is ON, then the following is returned:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果打开了EMPTY_RESULT_CALLBACKS pragma，则返回如下结果：
- en: nrow = 0
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: nrow = 0
- en: ncolumn = 3
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ncolumn = 3
- en: result[0] = "employee_name"
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: result[0] = "employee_name"
- en: result[1] = "login"
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: result[1] = "login"
- en: result[2] = "host"
  id: totrans-194
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: result[2] = "host"
- en: Memory to hold the information returned by **sqlite_get_table** is obtained
    from malloc(). But the calling function should not try to free this information
    directly. Instead, pass the complete table to **sqlite_free_table** when the table
    is no longer needed. It is safe to call **sqlite_free_table** with a NULL pointer
    such as would be returned if the result set is empty.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 用于存储**sqlite_get_table**返回信息的内存是从malloc()获取的。但调用函数不应直接尝试释放此信息。而是在不再需要表时将完整表传递给**sqlite_free_table**。可以安全地使用空指针调用**sqlite_free_table**，例如，如果结果集为空，则会返回空指针。
- en: The **sqlite_get_table** routine returns the same integer result code as **sqlite_exec**.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**sqlite_get_table**例程返回与**sqlite_exec**相同的整数结果代码。'
- en: 3.4 Interrupting an SQLite operation
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4 中断SQLite操作
- en: The **sqlite_interrupt** function can be called from a different thread or from
    a signal handler to cause the current database operation to exit at its first
    opportunity. When this happens, the **sqlite_exec** routine (or the equivalent)
    that started the database operation will return SQLITE_INTERRUPT.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**sqlite_interrupt**函数可以从不同的线程或信号处理程序中调用，以使当前数据库操作在第一次机会时退出。当发生这种情况时，启动数据库操作的**sqlite_exec**例程（或等效例程）将返回SQLITE_INTERRUPT。'
- en: 3.5 Testing for a complete SQL statement
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5 测试完整的SQL语句
- en: The next interface routine to SQLite is a convenience function used to test
    whether or not a string forms a complete SQL statement. If the **sqlite_complete**
    function returns true when its input is a string, then the argument forms a complete
    SQL statement. There are no guarantees that the syntax of that statement is correct,
    but we at least know the statement is complete. If **sqlite_complete** returns
    false, then more text is required to complete the SQL statement.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite的下一个接口例程是一个方便函数，用于测试一个字符串是否构成完整的SQL语句。如果**sqlite_complete**函数在其输入为字符串时返回true，则该参数形成完整的SQL语句。不能保证该语句的语法是否正确，但至少我们知道该语句是完整的。如果**sqlite_complete**返回false，则需要更多文本来完成SQL语句。
- en: For the purpose of the **sqlite_complete** function, an SQL statement is complete
    if it ends in a semicolon.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**sqlite_complete**函数的目的，如果SQL语句以分号结束，则该SQL语句是完整的。
- en: The **sqlite** command-line utility uses the **sqlite_complete** function to
    know when it needs to call **sqlite_exec**. After each line of input is received,
    **sqlite** calls **sqlite_complete** on all input in its buffer. If **sqlite_complete**
    returns true, then **sqlite_exec** is called and the input buffer is reset. If
    **sqlite_complete** returns false, then the prompt is changed to the continuation
    prompt and another line of text is read and added to the input buffer.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**sqlite**命令行实用程序使用**sqlite_complete**函数来确定何时需要调用**sqlite_exec**。在接收到每行输入后，**sqlite**在其缓冲区上调用**sqlite_complete**。如果**sqlite_complete**返回true，则调用**sqlite_exec**并重置输入缓冲区。如果**sqlite_complete**返回false，则将提示更改为继续提示，并读取另一行文本并添加到输入缓冲区中。'
- en: 3.6 Library version string
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.6 库版本字符串
- en: The SQLite library exports the string constant named **sqlite_version** which
    contains the version number of the library. The header file contains a macro SQLITE_VERSION
    with the same information. If desired, a program can compare the SQLITE_VERSION
    macro against the **sqlite_version** string constant to verify that the version
    number of the header file and the library match.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 库导出名为 **sqlite_version** 的字符串常量，其中包含库的版本号。头文件包含一个名为 SQLITE_VERSION 的宏，具有相同的信息。如果需要，程序可以将
    SQLITE_VERSION 宏与 **sqlite_version** 字符串常量进行比较，以验证头文件的版本号与库的版本号是否匹配。
- en: 3.7 Library character encoding
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.7 库字符编码
- en: By default, SQLite assumes that all data uses a fixed-size 8-bit character (iso8859).
    But if you give the --enable-utf8 option to the configure script, then the library
    assumes UTF-8 variable sized characters. This makes a difference for the LIKE
    and GLOB operators and the LENGTH() and SUBSTR() functions. The static string
    **sqlite_encoding** will be set to either "UTF-8" or "iso8859" to indicate how
    the library was compiled. In addition, the **sqlite.h** header file will define
    one of the macros **SQLITE_UTF8** or **SQLITE_ISO8859**, as appropriate.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，SQLite 假定所有数据使用固定大小的 8 位字符（iso8859）。但是，如果在配置脚本中给出了 --enable-utf8 选项，则库将假定使用
    UTF-8 可变大小字符。这会影响 LIKE 和 GLOB 运算符以及 LENGTH() 和 SUBSTR() 函数。静态字符串 **sqlite_encoding**
    将设置为 "UTF-8" 或 "iso8859"，以指示库的编译方式。此外，**sqlite.h** 头文件将根据需要定义 **SQLITE_UTF8**
    或 **SQLITE_ISO8859** 中的一个宏。
- en: Note that the character encoding mechanism used by SQLite cannot be changed
    at run-time. This is a compile-time option only. The **sqlite_encoding** character
    string just tells you how the library was compiled.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，SQLite 使用的字符编码机制不能在运行时更改。这只是一个编译时选项。**sqlite_encoding** 字符串仅告诉您库是如何编译的。
- en: 3.8 Changing the library's response to locked files
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.8 更改库对锁定文件的响应
- en: The **sqlite_busy_handler** procedure can be used to register a busy callback
    with an open SQLite database. The busy callback will be invoked whenever SQLite
    tries to access a database that is locked. The callback will typically do some
    other useful work, or perhaps sleep, in order to give the lock a chance to clear.
    If the callback returns non-zero, then SQLite tries again to access the database
    and the cycle repeats. If the callback returns zero, then SQLite aborts the current
    operation and returns SQLITE_BUSY.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**sqlite_busy_handler** 过程可用于向打开的 SQLite 数据库注册一个忙碌回调。每当 SQLite 尝试访问一个已锁定的数据库时，将调用忙碌回调。回调通常会执行一些其他有用的工作，或者可能休眠，以便让锁有机会释放。如果回调返回非零值，则
    SQLite 再次尝试访问数据库，循环重复。如果回调返回零，则 SQLite 中止当前操作并返回 SQLITE_BUSY。'
- en: 'The arguments to **sqlite_busy_handler** are the opaque structure returned
    from **sqlite_open**, a pointer to the busy callback function, and a generic pointer
    that will be passed as the first argument to the busy callback. When SQLite invokes
    the busy callback, it sends it three arguments: the generic pointer that was passed
    in as the third argument to **sqlite_busy_handler**, the name of the database
    table or index that the library is trying to access, and the number of times that
    the library has attempted to access the database table or index.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**sqlite_busy_handler** 的参数包括从 **sqlite_open** 返回的不透明结构体指针，一个指向繁忙回调函数的指针，以及一个通用指针，将作为繁忙回调的第一个参数传递。当
    SQLite 调用繁忙回调时，它会传递三个参数给它：作为 **sqlite_busy_handler** 第三个参数传入的通用指针，SQLite 正在尝试访问的数据库表或索引的名称，以及库试图访问数据库表或索引的次数。'
- en: For the common case where we want the busy callback to sleep, the SQLite library
    provides a convenience routine **sqlite_busy_timeout**. The first argument to
    **sqlite_busy_timeout** is a pointer to an open SQLite database and the second
    argument is a number of milliseconds. After **sqlite_busy_timeout** has been executed,
    the SQLite library will wait for the lock to clear for at least the number of
    milliseconds specified before it returns SQLITE_BUSY. Specifying zero milliseconds
    for the timeout restores the default behavior.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 对于常见情况，我们希望繁忙回调休眠，SQLite 库提供了一个便利函数 **sqlite_busy_timeout**。**sqlite_busy_timeout**
    的第一个参数是指向打开的 SQLite 数据库的指针，第二个参数是毫秒数。在执行完 **sqlite_busy_timeout** 后，SQLite 库将等待锁至少指定的毫秒数，然后返回
    SQLITE_BUSY。将超时设置为零毫秒将恢复默认行为。
- en: 3.9 Using the `_printf()` wrapper functions
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.9 使用 `_printf()` 封装函数
- en: The four utility functions
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个实用函数
- en: '**sqlite_exec_printf()**'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sqlite_exec_printf()**'
- en: '**sqlite_exec_vprintf()**'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sqlite_exec_vprintf()**'
- en: '**sqlite_get_table_printf()**'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sqlite_get_table_printf()**'
- en: '**sqlite_get_table_vprintf()**'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sqlite_get_table_vprintf()**'
- en: implement the same query functionality as **sqlite_exec** and **sqlite_get_table**.
    But instead of taking a complete SQL statement as their second argument, the four
    **_printf** routines take a printf-style format string. The SQL statement to be
    executed is generated from this format string and from whatever additional arguments
    are attached to the end of the function call.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 实现了与 **sqlite_exec** 和 **sqlite_get_table** 相同的查询功能。但是，这四个 **_printf** 程序不接受完整的
    SQL 语句作为它们的第二个参数，而是接受一个类似于 printf 的格式字符串。要执行的 SQL 语句是从此格式字符串生成的，并根据附加到函数调用末尾的任何其他参数生成。
- en: There are two advantages to using the SQLite printf functions instead of **sprintf**.
    First of all, with the SQLite printf routines, there is never a danger of overflowing
    a static buffer as there is with **sprintf**. The SQLite printf routines automatically
    allocate (and later frees) as much memory as is necessary to hold the SQL statements
    generated.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SQLite printf 函数而不是 **sprintf** 有两个优点。首先，使用 SQLite printf 函数，不会像使用 **sprintf**
    那样存在溢出静态缓冲区的危险。SQLite printf 函数会自动分配（和稍后释放）足够容纳生成的 SQL 语句所需的内存。
- en: The second advantage the SQLite printf routines have over **sprintf** are two
    new formatting options specifically designed to support string literals in SQL.
    Within the format string, the %q formatting option works very much like %s in
    that it reads a null-terminated string from the argument list and inserts it into
    the result. But %q translates the inserted string by making two copies of every
    single-quote (') character in the substituted string. This has the effect of escaping
    the end-of-string meaning of single-quote within a string literal. The %Q formatting
    option works similar; it translates the single-quotes like %q and additionally
    encloses the resulting string in single-quotes. If the argument for the %Q formatting
    options is a NULL pointer, the resulting string is NULL without single quotes.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite printf 例程相对于 **sprintf** 的第二个优点是具有两个新的格式选项，专门设计用于支持 SQL 中的字符串字面值。在格式字符串内部，%q
    格式选项的工作方式与 %s 非常相似，它从参数列表中读取以 null 结尾的字符串，并将其插入结果中。但是 %q 通过制作被替换字符串中每个单引号（'）字符的两个副本来翻译插入的字符串。这样做的效果是转义字符串字面值中的单引号的字符串字面值的字符串末尾含义。%Q
    格式选项类似工作；它像 %q 一样翻译单引号，并额外用单引号括起生成的字符串。如果 %Q 格式选项的参数是 NULL 指针，则生成的字符串是没有单引号的 NULL。
- en: 'Consider an example. Suppose you are trying to insert a string value into a
    database table where the string value was obtained from user input. Suppose the
    string to be inserted is stored in a variable named zString. The code to do the
    insertion might look like this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个例子。假设您试图将一个字符串值插入到数据库表中，该字符串值是从用户输入获取的。假设要插入的字符串存储在名为 zString 的变量中。执行插入操作的代码可能如下所示：
- en: '[PRE8]'
  id: totrans-222
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If the zString variable holds text like "Hello", then this statement will work
    just fine. But suppose the user enters a string like "Hi y''all!". The SQL statement
    generated reads as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 zString 变量保存的文本类似于 "Hello"，那么这个语句将正常工作。但是假设用户输入了类似于 "Hi y'all!" 的字符串。生成的
    SQL 语句如下所示：
- en: '[PRE9]'
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is not valid SQL because of the apostrophe in the word "y''all". But if
    the %q formatting option is used instead of %s, like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是有效的 SQL，因为单词 "y'all" 中有撇号。但是如果使用 %q 格式选项而不是 %s，如下所示：
- en: '[PRE10]'
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then the generated SQL will look like the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 那么生成的 SQL 将如下所示：
- en: '[PRE11]'
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here the apostrophe has been escaped and the SQL statement is well-formed. When
    generating SQL on-the-fly from data that might contain a single-quote character
    ('), it is always a good idea to use the SQLite printf routines and the %q formatting
    option instead of **sprintf**.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这里撇号已经转义，SQL 语句形式良好。当从可能包含单引号字符（'）的数据中动态生成 SQL 时，建议始终使用 SQLite printf 例程和 %q
    格式选项，而不是 **sprintf**。
- en: 'If the %Q formatting option is used instead of %q, like this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 %Q 格式选项而不是 %q，如下所示：
- en: '[PRE12]'
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then the generated SQL will look like the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 那么生成的 SQL 将如下所示：
- en: '[PRE13]'
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If the value of the zString variable is NULL, the generated SQL will look like
    the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 zString 变量的值为 NULL，生成的 SQL 将如下所示：
- en: '[PRE14]'
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'All of the _printf() routines above are built around the following two functions:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 所有上述 _printf() 例程都围绕以下两个函数构建：
- en: '[PRE15]'
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The **sqlite_mprintf()** routine works like the standard library **sprintf()**
    except that it writes its results into memory obtained from malloc() and returns
    a pointer to the malloced buffer. **sqlite_mprintf()** also understands the %q
    and %Q extensions described above. The **sqlite_vmprintf()** is a varargs version
    of the same routine. The string pointer that these routines return should be freed
    by passing it to **sqlite_freemem()**.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**sqlite_mprintf()** 例程的工作方式类似于标准库 **sprintf()**，不同之处在于它将结果写入从 malloc() 获得的内存中，并返回指向
    malloc 缓冲区的指针。 **sqlite_mprintf()** 也理解上述的 %q 和 %Q 扩展。 **sqlite_vmprintf()** 是相同例程的可变参数版本。
    这些例程返回的字符串指针应通过将其传递给 **sqlite_freemem()** 来释放。'
- en: 3.10 Performing background jobs during large queries
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.10 在大查询期间执行后台作业
- en: The **sqlite_progress_handler()** routine can be used to register a callback
    routine with an SQLite database to be invoked periodically during long running
    calls to **sqlite_exec()**, **sqlite_step()** and the various wrapper functions.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**sqlite_progress_handler()** 例程可用于向 SQLite 数据库注册回调例程，在对 **sqlite_exec()**、**sqlite_step()**
    和各种包装函数进行长时间调用期间定期调用。'
- en: The callback is invoked every N virtual machine operations, where N is supplied
    as the second argument to **sqlite_progress_handler()**. The third and fourth
    arguments to **sqlite_progress_handler()** are a pointer to the routine to be
    invoked and a void pointer to be passed as the first argument to it.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数在每个 N 虚拟机操作时调用，其中 N 作为第二个参数提供给 **sqlite_progress_handler()**。 **sqlite_progress_handler()**
    的第三个和第四个参数分别是要调用的例程的指针以及作为其第一个参数传递的 void 指针。
- en: The time taken to execute each virtual machine operation can vary based on many
    factors. A typical value for a 1 GHz PC is between half and three million per
    second but may be much higher or lower, depending on the query. As such it is
    difficult to schedule background operations based on virtual machine operations.
    Instead, it is recommended that a callback be scheduled relatively frequently
    (say every 1000 instructions) and external timer routines used to determine whether
    or not background jobs need to be run.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 执行每个虚拟机操作所需的时间可以根据许多因素而变化。 对于 1 GHz PC，每秒的典型值在半秒和三百万之间，但可能会更高或更低，具体取决于查询。 因此，很难根据虚拟机操作安排后台操作。
    相反，建议相对频繁地安排回调（例如每 1000 条指令），并使用外部定时器例程确定是否需要运行后台作业。
- en: 4.0 Adding New SQL Functions
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.0 添加新的 SQL 函数
- en: 'Beginning with version 2.4.0, SQLite allows the SQL language to be extended
    with new functions implemented as C code. The following interface is used:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 2.4.0 开始，SQLite 允许使用 C 代码扩展 SQL 语言。 使用以下接口：
- en: '[PRE16]'
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The **sqlite_create_function()** interface is used to create regular functions
    and **sqlite_create_aggregate()** is used to create new aggregate functions. In
    both cases, the **db** parameter is an open SQLite database on which the functions
    should be registered, **zName** is the name of the new function, **nArg** is the
    number of arguments, and **pUserData** is a pointer which is passed through unchanged
    to the C implementation of the function. Both routines return 0 on success and
    non-zero if there are any errors.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**sqlite_create_function()**接口用于创建常规函数，**sqlite_create_aggregate()**用于创建新的聚合函数。在两种情况下，**db**参数是一个打开的SQLite数据库，这些函数将在其上注册，**zName**是新函数的名称，**nArg**是参数数量，**pUserData**是一个指针，将无变化地传递给函数的C实现。这两个例程在成功时返回0，如果有任何错误则返回非零值。'
- en: The length of a function name may not exceed 255 characters. Any attempt to
    create a function whose name exceeds 255 characters in length will result in an
    error.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 函数名的长度不能超过255个字符。任何尝试创建长度超过255个字符的函数都会导致错误。
- en: For regular functions, the **xFunc** callback is invoked once for each function
    call. The implementation of xFunc should call one of the **sqlite_set_result_...**
    interfaces to return its result. The **sqlite_user_data()** routine can be used
    to retrieve the **pUserData** pointer that was passed in when the function was
    registered.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 对于常规函数，每次函数调用都会调用**xFunc**回调函数。实现**xFunc**的时候应调用其中一个**sqlite_set_result_...**接口来返回其结果。**sqlite_user_data()**例程可用于检索在注册函数时传递的**pUserData**指针。
- en: For aggregate functions, the **xStep** callback is invoked once for each row
    in the result and then **xFinalize** is invoked at the end to compute a final
    answer. The xStep routine can use the **sqlite_aggregate_context()** interface
    to allocate memory that will be unique to that particular instance of the SQL
    function. This memory will be automatically deleted after xFinalize is called.
    The **sqlite_aggregate_count()** routine can be used to find out how many rows
    of data were passed to the aggregate. The xFinalize callback should invoke one
    of the **sqlite_set_result_...** interfaces to set the final result of the aggregate.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 对于聚合函数，**xStep**回调在结果的每一行上调用一次，然后在结束时调用**xFinalize**来计算最终答案。**xStep**例程可以使用**sqlite_aggregate_context()**接口来分配内存，该内存将是特定SQL函数实例的唯一。此内存在调用**xFinalize**后将自动删除。**sqlite_aggregate_count()**例程可用于查找传递给聚合函数的数据行数。**xFinalize**回调应调用其中一个**sqlite_set_result_...**接口来设置聚合的最终结果。
- en: SQLite now implements all of its built-in functions using this interface. For
    additional information and examples on how to create new SQL functions, review
    the SQLite source code in the file **func.c**.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite现在使用这个接口实现其所有内置函数。有关如何创建新SQL函数的更多信息和示例，请查看文件**func.c**中的SQLite源代码。
- en: 5.0 Multi-Threading And SQLite
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.0 多线程与SQLite
- en: If SQLite is compiled with the THREADSAFE preprocessor macro set to 1, then
    it is safe to use SQLite from two or more threads of the same process at the same
    time. But each thread should have its own **sqlite*** pointer returned from **sqlite_open**.
    It is never safe for two or more threads to access the same **sqlite*** pointer
    at the same time.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 SQLite 是用 THREADSAFE 预处理宏设置为 1 编译的，则可以安全地在同一进程的两个或更多线程中同时使用 SQLite。但是每个线程应该有自己从
    **sqlite_open** 返回的 **sqlite*** 指针。不允许两个或更多线程同时访问同一个 **sqlite*** 指针。
- en: In precompiled SQLite libraries available on the website, the Unix versions
    are compiled with THREADSAFE turned off but the Windows versions are compiled
    with THREADSAFE turned on. If you need something different that this you will
    have to recompile.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在网站上提供的预编译 SQLite 库中，Unix 版本被编译为关闭 THREADSAFE，而 Windows 版本被编译为开启 THREADSAFE。如果你需要不同的设置，你需要重新编译。
- en: Under Unix, an **sqlite*** pointer should not be carried across a **fork()**
    system call into the child process. The child process should open its own copy
    of the database after the **fork()**.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unix 系统下，**sqlite*** 指针不应该在 **fork()** 系统调用中传递到子进程中。子进程应该在 **fork()** 之后打开自己的数据库副本。
- en: 6.0 Usage Examples
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.0 使用示例
- en: For examples of how the SQLite C/C++ interface can be used, refer to the source
    code for the **sqlite** program in the file [src/shell.c](https://sqlite.org/src/file/src/shell.c.in)
    of the source tree. Additional information about sqlite is available at [cli.html](cli.html).
    See also the sources to the Tcl interface for SQLite in the source file [src/tclsqlite.c](https://sqlite.org/src/file/src/tclsqlite.c).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 SQLite C/C++ 接口的使用示例，请参考源码中的 **sqlite** 程序文件 [src/shell.c](https://sqlite.org/src/file/src/shell.c.in)。关于
    SQLite 的其他信息请参考 [cli.html](cli.html)。另请参考 SQLite 的 Tcl 接口源文件 [src/tclsqlite.c](https://sqlite.org/src/file/src/tclsqlite.c)。
