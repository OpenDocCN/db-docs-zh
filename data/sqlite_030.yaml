- en: 1\. Overview
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1\. 概述
- en: 原文：[https://sqlite.com/rtree.html](https://sqlite.com/rtree.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://sqlite.com/rtree.html](https://sqlite.com/rtree.html)
- en: An [R-Tree](http://en.wikipedia.org/wiki/R-tree) is a special index that is
    designed for doing range queries. R-Trees are most commonly used in geospatial
    systems where each entry is a rectangle with minimum and maximum X and Y coordinates.
    Given a query rectangle, an R-Tree is able to quickly find all entries that are
    contained within the query rectangle or which overlap the query rectangle. This
    idea is easily extended to three dimensions for use in CAD systems. R-Trees also
    find use in time-domain range look-ups. For example, suppose a database records
    the starting and ending times for a large number of events. A R-Tree is able to
    quickly find all events that were active at any time during a given time interval,
    or all events that started during a particular time interval, or all events that
    both started and ended within a given time interval. And so forth.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[R-Tree](http://en.wikipedia.org/wiki/R-tree) 是一种专门设计用于执行范围查询的特殊索引。R-Trees
    最常用于地理空间系统，其中每个条目都是具有最小和最大 X 和 Y 坐标的矩形。给定一个查询矩形，R-Tree 能够快速找到所有包含在查询矩形内或与查询矩形重叠的条目。这个想法可以很容易地扩展到三维，用于
    CAD 系统。R-Trees 也用于时间域范围查找。例如，假设一个数据库记录了大量事件的开始和结束时间。R-Tree 能够快速找到在给定时间间隔内任何时间处于活动状态的所有事件，或者在特定时间间隔内开始的所有事件，或者在给定时间间隔内既开始又结束的所有事件，依此类推。'
- en: 'The R-Tree concept originated with [Toni Guttman](https://link.springer.com/referenceworkentry/10.1007/978-0-387-35973-1_1151):
    *R-Trees: A Dynamic Index Structure for Spatial Searching*, Proc. 1984 ACM SIGMOD
    International Conference on Management of Data, pp. 47-57. The implementation
    found in SQLite is a refinement of Guttman''s original idea, commonly called "R*Trees",
    that was described by Norbert Beckmann, Hans-Peter Kriegel, Ralf Schneider, Bernhard
    Seeger: *The R*-Tree: An Efficient and Robust Access Method for Points and Rectangles.*
    SIGMOD Conference 1990: 322-331.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 'R-Tree 的概念源于[Toni Guttman](https://link.springer.com/referenceworkentry/10.1007/978-0-387-35973-1_1151)：*R-Trees:
    A Dynamic Index Structure for Spatial Searching*，1984 年 ACM SIGMOD 国际数据管理会议，第47-57页。在
    SQLite 中找到的实现是 Guttman 原始想法的一个改进，通常称为“R*Trees”，由 Norbert Beckmann, Hans-Peter
    Kriegel, Ralf Schneider, Bernhard Seeger 描述：*The R*-Tree: An Efficient and Robust
    Access Method for Points and Rectangles.* SIGMOD Conference 1990: 322-331.'
- en: 2\. Compiling The R*Tree Module
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2\. 编译 R*Tree 模块
- en: The source code to the SQLite R*Tree module is included as part of the [amalgamation](amalgamation.html).
    However, depending on configuration options and the particular version of SQLite
    you are using, it may or may not be enabled by default. To ensure that the R*Tree
    module is enabled, simply compile with the [SQLITE_ENABLE_RTREE](compile.html#enable_rtree)
    C-preprocessor macro defined. With many compilers, this is accomplished by adding
    the option "-DSQLITE_ENABLE_RTREE=1" to the compiler command-line.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite R*Tree 模块的源代码包含在[amalgamation](amalgamation.html)中。但是，具体取决于配置选项和您使用的
    SQLite 版本，它可能已启用或未启用。要确保 R*Tree 模块已启用，只需在编译时定义[SQLITE_ENABLE_RTREE](compile.html#enable_rtree)
    C 预处理宏。使用许多编译器，可以通过将选项“-DSQLITE_ENABLE_RTREE=1”添加到编译器命令行来实现此目的。
- en: 3\. Using the R*Tree Module
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3\. 使用 R*Tree 模块
- en: The SQLite R*Tree module is implemented as a [virtual table](c3ref/create_module.html).
    Each R*Tree index is a virtual table with an odd number of columns between 3 and
    11. The first column is always a 64-bit signed integer primary key. The other
    columns are pairs, one pair per dimension, containing the minimum and maximum
    values for that dimension, respectively. A 1-dimensional R*Tree thus has 3 columns.
    A 2-dimensional R*Tree has 5 columns. A 3-dimensional R*Tree has 7 columns. A
    4-dimensional R*Tree has 9 columns. And a 5-dimensional R*Tree has 11 columns.
    The SQLite R*Tree implementation does not support R*Trees wider than 5 dimensions.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 的 R*Tree 模块被实现为一个[virtual table](c3ref/create_module.html)。每个 R*Tree
    索引都是一个虚拟表，具有3到11个奇数列。第一列始终是一个64位有符号整数主键。其他列是成对出现的，每个维度包含该维度的最小和最大值。因此，一个一维的 R*Tree
    有3列，一个二维的有5列，一个三维的有7列，一个四维的有9列，一个五维的有11列。SQLite 的 R*Tree 实现不支持超过5维的 R*Trees。
- en: The first column of an SQLite R*Tree is similar to an integer primary key column
    of a normal SQLite table. It may only store a 64-bit signed integer value. Inserting
    a NULL value into this column causes SQLite to automatically generate a new unique
    primary key value. If an attempt is made to insert any other non-integer value
    into this column, the r-tree module silently converts it to an integer before
    writing it into the database.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一个SQLite R*Tree的第一列类似于普通SQLite表的整数主键列。它只能存储64位有符号整数值。向这一列插入NULL值会导致SQLite自动生成一个新的唯一主键值。如果尝试将任何其他非整数值插入此列，r-tree模块会在将其写入数据库之前将其静默转换为整数。
- en: The min/max-value pair columns are stored as 32-bit floating point values for
    "rtree" virtual tables or as 32-bit signed integers in "rtree_i32" virtual tables.
    Unlike regular SQLite tables which can store data in a variety of datatypes and
    formats, the R*Tree rigidly enforce these storage types. If any other type of
    value is inserted into such a column, the r-tree module silently converts it to
    the required type before writing the new record to the database.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于"rtree"虚拟表，min/max-value对列存储为32位浮点值，对于"rtree_i32"虚拟表，则存储为32位有符号整数。与可以存储各种数据类型和格式的常规SQLite表不同，R*Tree严格执行这些存储类型。如果向这样的列插入任何其他类型的值，r-tree模块会静默地将其转换为所需的类型，然后将新记录写入数据库。
- en: 3.1\. Creating An R*Tree Index
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1\. 创建R*Tree索引
- en: 'A new R*Tree index is created as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 新的R*Tree索引的创建如下所示：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The *<name>* is the name your application chooses for the R*Tree index and
    *<column-names>* is a comma separated list of between 3 and 11 columns. The virtual
    <name> table creates three [shadow tables](vtab.html#xshadowname) to actually
    store its content. The names of these shadow tables are:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*<name>*是你的应用为R*Tree索引选择的名称，*<column-names>*是一个由3到11列之间的逗号分隔的列表。虚拟的<name>表创建了三个[阴影表](vtab.html#xshadowname)来实际存储其内容。这些阴影表的名称分别是：'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The shadow tables are ordinary SQLite data tables. You can query them directly
    if you like, though this unlikely to reveal anything particularly useful. And
    you can [UPDATE](lang_update.html), [DELETE](lang_delete.html), [INSERT](lang_insert.html)
    or even [DROP](lang_droptable.html) the shadow tables, though doing so will corrupt
    your R*Tree index. So it is best to simply ignore the shadow tables. Recognize
    that they hold your R*Tree index information and let it go as that.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影表是普通的SQLite数据表。你可以直接查询它们，但这不太可能会显示出特别有用的内容。你可以[UPDATE](lang_update.html)、[DELETE](lang_delete.html)、[INSERT](lang_insert.html)甚至[DROP](lang_droptable.html)这些阴影表，但这样做会损坏你的R*Tree索引。因此最好是简单地忽略阴影表。要认识到它们保存着你的R*Tree索引信息，然后就让它们消失。
- en: 'As an example, consider creating a two-dimensional R*Tree index for use in
    spatial queries:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑创建一个用于空间查询的二维R*Tree索引：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 3.1.1\. Column naming details
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.1\. 列命名细节
- en: In the argments to "rtree" in the CREATE VIRTUAL TABLE statement, the names
    of the columns are taken from the first token of each argument. All subsequent
    tokens within each argument are silently ignored. This means, for example, that
    if you try to give a column a [type affinity](datatype3.html#affinity) or add
    a constraint such as UNIQUE or NOT NULL or DEFAULT to a column, those extra tokens
    are accepted as valid, but they do not change the behavior of the rtree. In an
    RTREE virtual table, the first column always has a [type affinity](datatype3.html#affinity)
    of INTEGER and all other data columns have a [type affinity](datatype3.html#affinity)
    of REAL. In an RTREE_I32 virtual table, all columns have type affinity of INTEGER.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在CREATE VIRTUAL TABLE语句中"rtree"的参数中，列的名称取自每个参数的第一个标记。每个参数中的所有后续标记都被静默地忽略。这意味着，例如，如果您尝试给列指定[类型亲和性](datatype3.html#affinity)或添加唯一或非NULL或默认约束等，这些额外的标记都被视为有效，但它们不会改变rtree的行为。在RTREE虚拟表中，第一列总是具有整数的[类型亲和性](datatype3.html#affinity)，而所有其他数据列都具有实数的[类型亲和性](datatype3.html#affinity)。在RTREE_I32虚拟表中，所有列都具有整数的[类型亲和性](datatype3.html#affinity)。
- en: Recommended practice is to omit any extra tokens in the rtree specification.
    Let each argument to "rtree" be a single ordinary label that is the name of the
    corresponding column, and omit all other tokens from the argument list.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐的做法是在rtree规范中省略任何额外的标记。让"rtree"的每个参数都是一个单一的普通标签，即对应列的名称，并删除参数列表中的所有其他标记。
- en: 3.2\. Populating An R*Tree Index
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2\. 填充R*Tree索引
- en: 'The usual [INSERT](lang_insert.html), [UPDATE](lang_update.html), and [DELETE](lang_delete.html)
    commands work on an R*Tree index just like on regular tables. So to insert some
    data into our sample R*Tree index, we can do something like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通常的 [插入](lang_insert.html)，[更新](lang_update.html)，和 [删除](lang_delete.html) 命令在
    R*树 索引上的工作方式与常规表格相同。因此，要将一些数据插入到我们的示例 R*树 索引中，我们可以像这样做：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The entries above are bounding boxes (longitude and latitude) for 14 zipcodes
    near Charlotte, NC. A real database would have many thousands, millions, or billions
    of such entries, but this small 14-row sample will be sufficient to illustrate
    the ideas.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 上述条目是夏洛特附近 14 个邮政编码的边界框（经度和纬度）。真实的数据库可能会有成千上万、百万甚至十亿这样的条目，但这个小样本的 14 行足以说明这些概念。
- en: 3.3\. Querying An R*Tree Index
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3\. 查询 R*树 索引
- en: 'Any valid query will work against an R*Tree index. The R*Tree implementation
    just makes some kinds of queries especially efficient. Queries against the primary
    key are efficient:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 任何有效的查询都可以针对 R*树 索引工作。R*树的实现使某些类型的查询特别高效。对主键的查询是高效的：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Of course, an ordinary SQLite table will also do a query against its integer
    primary key efficiently, so the previous is not important. The big reason for
    using an R*Tree is so that you can efficiently do range queries against the coordinate
    ranges. For example, the main office of the SQLite project is located at 35.37785,
    -80.77470. To find which zipcodes might service that office, one could right:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，普通的 SQLite 表格也可以有效地对其整数主键进行查询，因此前述内容并不重要。使用 R*树 的主要原因是可以有效地对坐标范围进行范围查询。例如，SQLite
    项目的主办公室位于 35.37785, -80.77470。要找出可能为该办公室提供服务的邮政编码，可以这样做：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The query above will quickly locate all zipcodes that contain the SQLite main
    office in their bounding box, even if the R*Tree contains many entries. The previous
    is an example of a "contained-within" query. The R*Tree also supports "overlapping"
    queries. For example, to find all zipcode bounding boxes that overlap with the
    28269 zipcode:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询将快速定位所有包含 SQLite 主办公室在其边界框内的邮政编码，即使 R*树 包含许多条目。上述是一个“包含”查询的示例。R*树 还支持“重叠”查询。例如，要找出与
    28269 邮政编码重叠的所有邮政编码边界框：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This second query will find both 28269 entry (since every bounding box overlaps
    with itself) and also other zipcode that is close enough to 28269 that their bounding
    boxes overlap.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此第二个查询将找到 28269 条目（因为每个边界框与自身重叠），还会找到其他与 28269 足够接近的邮政编码，它们的边界框也会重叠。
- en: 'Note that it is not necessary for all coordinates in an R*Tree index to be
    constrained in order for the index search to be efficient. One might, for example,
    want to query all objects that overlap with the 35th parallel:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，并不需要 R*树 索引中的所有坐标都受到限制，以便使索引搜索高效。例如，可以查询与北纬 35 度重叠的所有对象：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: But, generally speaking, the more constraints that the R*Tree module has to
    work with, and the smaller the bounding box, the faster the results will come
    back.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，一般来说，R*树 模块需要处理的约束越多，边界框越小，结果返回得越快。
- en: 3.4\. Roundoff Error
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4\. 精度误差
- en: By default, coordinates are stored in an R*Tree using 32-bit floating point
    values. When a coordinate cannot be exactly represented by a 32-bit floating point
    number, the lower-bound coordinates are rounded down and the upper-bound coordinates
    are rounded up. Thus, bounding boxes might be slightly larger than specified,
    but will never be any smaller. This is exactly what is desired for doing the more
    common "overlapping" queries where the application wants to find every entry in
    the R*Tree that overlaps a query bounding box. Rounding the entry bounding boxes
    outward might cause a few extra entries to appears in an overlapping query if
    the edge of the entry bounding box corresponds to an edge of the query bounding
    box. But the overlapping query will never miss a valid table entry.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，R*树 中使用 32 位浮点值存储坐标。当一个坐标不能被 32 位浮点数精确表示时，下限坐标会向下舍入，上限坐标会向上舍入。因此，边界框可能会比指定的稍大，但永远不会更小。这正是进行更常见的“重叠”查询所需要的。如果将条目边界框向外舍入，可能会在重叠查询中导致额外的几个条目出现，如果条目边界框的边缘对应于查询边界框的边缘。但重叠查询永远不会漏掉有效的表条目。
- en: However, for a "contained-within" style query, rounding the bounding boxes outward
    might cause some entries to be excluded from the result set if the edge of the
    entry bounding box corresponds to the edge of the query bounding box. To guard
    against this, applications should expand their contained-within query boxes slightly
    (by 0.000012%) by rounding down the lower coordinates and rounding up the top
    coordinates, in each dimension.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，对于“包含在内”风格的查询，将边界框向外舍入可能导致某些条目被排除在结果集之外，如果条目边界框的边缘对应于查询边界框的边缘。为了防止这种情况，应用程序应该在每个维度上稍微扩展其“包含在内”查询框（增加
    0.000012%），即通过向下舍入较低坐标和向上舍入顶部坐标。
- en: 3.5\. Reading And Writing At The Same Time
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5\. 同时读取和写入
- en: It is the nature of the Guttman R-Tree algorithm that any write might radically
    restructure the tree, and in the process change the scan order of the nodes. For
    this reason, it is not generally possible to modify the R-Tree in the middle of
    a query of the R-Tree. Attempts to do so will fail with a [SQLITE_LOCKED](rescode.html#locked)
    "database table is locked" error.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Guttman R-Tree 算法的特性是，任何写操作可能会彻底重构树，并在此过程中改变节点的扫描顺序。因此，在查询 R-Tree 进行中通常不可能修改
    R-Tree。试图这样做将导致一个 [SQLITE_LOCKED](rescode.html#locked) "数据库表被锁定" 错误。
- en: 'So, for example, suppose an application runs one query against an R-Tree like
    this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，假设一个应用程序像这样针对 R-Tree 运行一个查询：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then for each "id" value returned, suppose the application creates an UPDATE
    statement like the following and binds the "id" value returned against the "?1"
    parameter:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于返回的每个“id”值，假设应用程序创建如下 UPDATE 语句，并将返回的“id”值绑定到“?1”参数：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Then the UPDATE might fail with an SQLITE_LOCKED error. The reason is that the
    initial query has not run to completion. It is remembering its place in the middle
    of a scan of the R-Tree. So an update to the R-Tree cannot be tolerated as this
    would disrupt the scan.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 那么更新可能会因 SQLITE_LOCKED 错误而失败。原因是初始查询尚未完成。它记住了在扫描 R-Tree 中间的位置。因此，不能容忍对 R-Tree
    的更新，因为这会破坏扫描。
- en: This is a limitation of the R-Tree extension only. Ordinary tables in SQLite
    are able to read and write at the same time. Other virtual tables might (or might
    not) also that capability. And R-Tree can appear to read and write at the same
    time in some circumstances, if it can figure out how to reliably run the query
    to completion before starting the update. But you shouldn't count on that for
    every query. Generally speaking, it is best to avoid running queries and updates
    to the same R-Tree at the same time.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是 R-Tree 扩展的一个限制。SQLite 中的普通表能够同时读取和写入。其他虚拟表可能（或可能不会）具有这种能力。在某些情况下，如果可以在开始更新之前可靠地完成查询，则
    R-Tree 看起来可以同时读取和写入。但是你不应该期望每个查询都能这样。一般来说，最好避免同时对同一个 R-Tree 运行查询和更新。
- en: If you really need to update an R-Tree based on complex queries against the
    same R-Tree, it is best to run the complex queries first and store the results
    in a temporary table, then update the R-Tree based on the values stored in the
    temporary table.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果确实需要根据相同的 R-Tree 的复杂查询更新 R-Tree，最好先运行复杂查询，并将结果存储在临时表中，然后基于存储在临时表中的值更新 R-Tree。
- en: 4\. Using R*Trees Effectively
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4\. 有效使用 R*Trees
- en: 'For SQLite versions prior to 3.24.0 (2018-06-04), the only information that
    an R*Tree index stores about an object is its integer ID and its bounding box.
    Additional information needs to be stored in separate tables and related to the
    R*Tree index using the primary key. For the example above, one might create an
    auxiliary table as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 SQLite 版本在 3.24.0 之前（2018-06-04），R*Tree 索引存储的关于对象的唯一信息是其整数 ID 和其边界框。额外的信息需要存储在单独的表中，并使用主键与
    R*Tree 索引关联。例如，可以创建一个辅助表如下：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, the demo_data.boundary field is intended to hold some kind
    of binary representation of the precise boundaries of the object. The R*Tree index
    only holds an axis-aligned rectangular boundary for the object. The R*Tree boundary
    is just an approximation of the true object boundary. So what typically happens
    is that the R*Tree index is used to narrow a search down to a list of candidate
    objects and then more detailed and expensive computations are done on each candidate
    to find if the candidate truly meets the search criteria.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，demo_data.boundary 字段旨在保存对象精确边界的某种二进制表示。R*Tree 索引仅保存对象的轴对齐矩形边界。R*Tree
    边界只是真实对象边界的近似。因此，通常的情况是使用 R*Tree 索引缩小搜索范围到候选对象列表，然后对每个候选对象进行更详细和昂贵的计算，以确定候选对象是否真正符合搜索条件。
- en: '**Key Point:** An R*Tree index does not normally provide the exact answer but
    merely reduces the set of potential answers from millions to dozens.'
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**关键点：** R*Tree 索引通常不能提供确切答案，只能将潜在答案集从数百万减少到几十个。'
- en: 'Suppose the demo_data.boundary field holds some proprietary data description
    of a complex two-dimensional boundary for a zipcode and suppose that the application
    has used the [sqlite3_create_function()](c3ref/create_function.html) interface
    to created an application-defined function "contained_in(boundary,lat,long)" that
    accepts the demo_data.boundary object and a latitute and longitude and returns
    return true or false if the lat/long is contained within the boundary. One may
    assume that "contained_in()" is a relatively slow functions that we do not want
    to invoke too frequently. Then an efficient way to find the specific ZIP code
    for the main SQLite office would be to run a query like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 demo_data.boundary 字段保存邮政编码复杂二维边界的某种专有数据描述，并假设应用程序已使用 [sqlite3_create_function()](c3ref/create_function.html)
    接口创建了一个应用程序定义函数 "contained_in(boundary,lat,long)"，该函数接受 demo_data.boundary 对象以及纬度和经度，并根据边界判断是否返回
    true 或 false。可以假设 "contained_in()" 是一个相对较慢的函数，我们不希望频繁调用它。那么，找到主 SQLite 办公室特定邮政编码的有效方法是运行类似于以下的查询：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Notice how the query above works: The R*Tree index runs in the outer loop to
    find entries that contain the SQLite main office in their boundary box. For each
    row found, SQLite looks up the corresponding entry in the demo_data table. It
    then uses the boundary field from the demo_data table as a parameter to the contained_in()
    function and if that function returns true, then we know the sought after coordinate
    is in that ZIP code boundary.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意上述查询的工作方式：R*Tree 索引在外循环中运行，以查找其边界框中包含 SQLite 主办公室的条目。对于每个找到的行，SQLite 查找 demo_data
    表中对应的条目。然后，它使用 demo_data 表中的 boundary 字段作为 contained_in() 函数的参数，如果该函数返回 true，则我们知道所寻找的坐标在该邮政编码边界内。
- en: 'One would get the same answer without the use of the R*Tree index using the
    following simpler query:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下更简单的查询，即使没有使用 R*Tree 索引，也能得到相同的答案：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The problem with this latter query is that it must apply the contained_in()
    function to all entries in the demo_data table. The use of the R*Tree in the penultimate
    query reduces the number of calls to contained_in() function to a small subset
    of the entire table. The R*Tree index did not find the exact answer itself, it
    merely limited the search space.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 后一个查询的问题在于必须对 demo_data 表中的所有条目应用 contained_in() 函数。在倒数第二个查询中使用 R*Tree 可将对 contained_in()
    函数的调用次数减少到整个表的一个小子集。R*Tree 索引本身并没有找到确切答案，它只是限制了搜索空间。
- en: 4.1\. Auxiliary Columns
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1\. 辅助列
- en: Beginning with SQLite version 3.24.0 (2018-06-04), r-tree tables can have auxiliary
    columns that store arbitrary data. Auxiliary columns can be used in place of secondary
    tables such as "demo_data".
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从 SQLite 版本 3.24.0（2018-06-04）开始，r-tree 表可以具有存储任意数据的辅助列。辅助列可以代替 "demo_data"
    等二级表。
- en: 'Auxiliary columns are marked with a "+" symbol before the column name. Auxiliary
    columns must come after all of the coordinate boundary columns. An RTREE table
    can have no more than 100 columns total. In other words, the count of columns
    including the integer primary key column, the coordinate boundary columns, and
    all auxiliary columns must be 100 or less. The following example shows an r-tree
    table with auxiliary columns that is equivalent to the two tables "demo_index"
    and "demo_data" above:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助列在列名前标有“+”符号。辅助列必须位于所有坐标边界列之后。一个 RTREE 表最多可以有 100 列。换句话说，包括整数主键列、坐标边界列和所有辅助列在内的列数必须小于或等于
    100。下面的示例显示了一个带有辅助列的 r-tree 表，该表相当于上述两个表 "demo_index" 和 "demo_data"：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'By combining location data and related information into the same table, auxiliary
    columns can provide a cleaner model and reduce the need to joins. For example,
    the earlier [join between demo_index and demo_data](#diquery) can now be written
    as a simple query, like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 将位置数据和相关信息合并到同一表中，辅助列可以提供更清晰的模型并减少连接的需求。例如，之前在 [demo_index 和 demo_data 之间的连接](#diquery)
    现在可以写成一个简单的查询，如下所示：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 4.1.1\. Limitations
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1\. 限制
- en: For auxiliary columns, only the name of the column matters. The [type affinity](datatype3.html#affinity)
    is ignored. Constraints such as NOT NULL, UNIQUE, REFERENCES, or CHECK are also
    ignored. However, future versions of SQLite might start paying attention to the
    type affinity and constraints, so users of auxiliary columns are advised to leave
    both blank, to avoid future compatibility problems.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于辅助列，只有列名是重要的。类型亲和性被忽略。诸如 NOT NULL、UNIQUE、REFERENCES 或 CHECK 的约束也被忽略。然而，SQLite
    的未来版本可能会开始关注类型亲和性和约束，因此建议辅助列的用户将其留空，以避免未来的兼容性问题。
- en: 5\. Integer-Valued R-Trees
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5\. 整数值 R-Trees
- en: 'The default virtual table ("rtree") stores coordinates as single-precision
    (4-byte) floating point numbers. If integer coordinates are desired, declare the
    table using "rtree_i32" instead:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的虚拟表（"rtree"）将坐标存储为单精度（4 字节）浮点数。如果需要整数坐标，请使用 "rtree_i32" 声明表：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: An rtree_i32 stores coordinates as 32-bit signed integers. Even though it stores
    values using integer, the rtree_i32 virtual table still uses floating point computations
    internally as part of the r-tree algorithm.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 rtree_i32 将坐标存储为 32 位带符号整数。尽管它使用整数存储值，但 rtree_i32 虚拟表仍然在 r-tree 算法的内部使用浮点计算。
- en: 6\. Custom R-Tree Queries
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6\. 自定义 R-Tree 查询
- en: By using standard SQL expressions in the WHERE clause of a SELECT query, a programmer
    can query for all R*Tree entries that intersect with or are contained within a
    particular bounding-box. Custom R*Tree queries, using the MATCH operator in the
    WHERE clause of a SELECT, allow the programmer to query for the set of R*Tree
    entries that intersect any arbitrary region or shape, not just a box. This capability
    is useful, for example, in computing the subset of objects in the R*Tree that
    are visible from a camera positioned in 3-D space.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 SELECT 查询的 WHERE 子句中使用标准 SQL 表达式，程序员可以查询与特定边界框相交或包含的所有 R*Tree 条目。使用 MATCH
    操作符在 SELECT 的 WHERE 子句中进行自定义 R*Tree 查询，允许程序员查询与任意区域或形状相交的 R*Tree 条目集合，而不仅仅是一个框。例如，在计算从位于
    3D 空间中的摄像机位置可见的 R*Tree 对象子集时，这种功能非常有用。
- en: 'Regions for custom R*Tree queries are defined by R*Tree geometry callbacks
    implemented by the application and registered with SQLite via a call to one of
    the following two APIs:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义 R*Tree 查询的区域由应用程序实现的 R*Tree 几何回调定义，并通过调用以下两个 API 之一向 SQLite 注册：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The sqlite3_rtree_query_callback() became available with SQLite [version 3.8.5](releaselog/3_8_5.html)
    (2014-06-04) and is the preferred interface. The sqlite3_rtree_geometry_callback()
    is an older and less flexible interface that is supported for backwards compatibility.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: sqlite3_rtree_query_callback() 在 SQLite [版本 3.8.5](releaselog/3_8_5.html)（2014-06-04）中可用，是首选接口。sqlite3_rtree_geometry_callback()
    是一个较旧且灵活性较差的接口，仅供向后兼容支持。
- en: A call to one of the above APIs creates a new SQL function named by the second
    parameter (zQueryFunc or zGeom). When that SQL function appears on the right-hand
    side of the MATCH operator and the left-hand side of the MATCH operator is any
    column in the R*Tree virtual table, then the callback defined by the third argument
    (xQueryFunc or xGeom) is invoked to determine if a particular object or subtree
    overlaps the desired region.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 API 的调用会创建一个以第二个参数（zQueryFunc 或 zGeom）命名的新 SQL 函数。当该 SQL 函数出现在 MATCH 运算符的右侧，并且
    MATCH 运算符的左侧是 R*Tree 虚拟表中的任意列时，将调用由第三个参数（xQueryFunc 或 xGeom）定义的回调函数，以确定特定对象或子树是否与所需区域重叠。
- en: 'For example, a query like the following might be used to find all R*Tree entries
    that overlap with a circle centered a 45.3,22.9 with a radius of 5.0:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，像下面这样的查询可能用于查找与圆心位于 (45.3, 22.9)，半径为 5.0 的圆重叠的所有 R*Tree 条目：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The SQL syntax for custom queries is the same regardless of which interface,
    sqlite3_rtree_geometry_callback() or sqlite3_rtree_query_callback(), is used to
    register the SQL function. However, the newer query-style callbacks give the application
    greater control over how the query proceeds.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 无论使用 sqlite3_rtree_geometry_callback() 还是 sqlite3_rtree_query_callback() 接口注册
    SQL 函数，自定义查询的 SQL 语法都是相同的。但是，新的查询样式回调允许应用程序更好地控制查询的执行过程。
- en: 6.1\. The Legacy xGeom Callback
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1\. 旧版 xGeom 回调
- en: The legacy xGeom callback is invoked with four arguments. The first argument
    is a pointer to an sqlite3_rtree_geometry structure which provides information
    about how the SQL function was invoked. The second argument is the number of coordinates
    in each r-tree entry, and is always the same for any given R*Tree. The number
    of coordinates is 2 for a 1-dimensional R*Tree, 4 for a 2-dimensional R*Tree,
    6 for a 3-dimensional R*Tree, and so forth. The third argument, aCoord[], is an
    array of nCoord coordinates that defines a bounding box to be tested. The last
    argument is a pointer into which the callback result should be written. The result
    is zero if the bounding-box defined by aCoord[] is completely outside the region
    defined by the xGeom callback and the result is non-zero if the bounding-box is
    inside or overlaps with the xGeom region. The xGeom callback should normally return
    SQLITE_OK. If xGeom returns anything other than SQLITE_OK, then the r-tree query
    will abort with an error.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 旧版 xGeom 回调使用四个参数调用。第一个参数是指向 sqlite3_rtree_geometry 结构体的指针，提供了有关 SQL 函数调用方式的信息。第二个参数是每个
    R*Tree 条目中坐标的数量，对于给定的 R*Tree 总是相同。对于一维 R*Tree，坐标数为 2；对于二维 R*Tree，坐标数为 4；对于三维 R*Tree，坐标数为
    6，依此类推。第三个参数 aCoord[] 是一个包含 nCoord 个坐标的数组，定义要测试的边界框。最后一个参数是一个指针，用于写入回调结果。如果由 aCoord[]
    定义的边界框完全位于由 xGeom 回调定义的区域外，则结果为零；如果边界框在 xGeom 区域内或重叠，则结果为非零。xGeom 回调通常应返回 SQLITE_OK。如果
    xGeom 返回除 SQLITE_OK 之外的任何内容，则 R*Tree 查询将以错误中止。
- en: The sqlite3_rtree_geometry structure that the first argument to the xGeom callback
    points to has a structure shown below. The exact same sqlite3_rtree_geometry structure
    is used for every callback for same MATCH operator in the same query. The contents
    of the sqlite3_rtree_geometry structure are initialized by SQLite but are not
    subsequently modified. The callback is free to make changes to the pUser and xDelUser
    elements of the structure if desired.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: sqlite3_rtree_geometry 结构体指针作为 xGeom 回调的第一个参数，具体结构如下所示。在同一查询中，对于相同的 MATCH 运算符，每个回调都使用完全相同的
    sqlite3_rtree_geometry 结构体。SQLite 初始化了 sqlite3_rtree_geometry 结构体的内容，但后续不再修改。如果需要，回调函数可以自由地更改结构体中的
    pUser 和 xDelUser 元素。
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The pContext member of the sqlite3_rtree_geometry structure is always set to
    a copy of the pContext argument passed to sqlite3_rtree_geometry_callback() when
    the callback is registered. The aParam[] array (size nParam) contains the parameter
    values passed to the SQL function on the right-hand side of the MATCH operator.
    In the example "circle" query above, nParam would be set to 3 and the aParam[]
    array would contain the three values 45.3, 22.9 and 5.0.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当注册回调时，sqlite3_rtree_geometry_callback() 中传递的 pContext 参数的副本始终设置为 sqlite3_rtree_geometry
    结构体的 pContext 成员。aParam[] 数组（大小为 nParam）包含传递给 MATCH 运算符右侧的 SQL 函数的参数值。在上面的 "circle"
    查询示例中，nParam 将设置为 3，并且 aParam[] 数组将包含三个值 45.3, 22.9 和 5.0。
- en: The pUser and xDelUser members of the sqlite3_rtree_geometry structure are initially
    set to NULL. The pUser variable may be set by the callback implementation to any
    arbitrary value that may be useful to subsequent invocations of the callback within
    the same query (for example, a pointer to a complicated data structure used to
    test for region intersection). If the xDelUser variable is set to a non-NULL value,
    then after the query has finished running SQLite automatically invokes it with
    the value of the pUser variable as the only argument. In other words, xDelUser
    may be set to a destructor function for the pUser value.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: sqlite3_rtree_geometry结构体的pUser和xDelUser成员最初被设置为NULL。回调实现可以将pUser变量设置为任何在同一查询中后续调用的回调中有用的任意值（例如，指向用于测试区域交集的复杂数据结构的指针）。如果xDelUser变量被设置为非NULL值，则在查询运行完毕后SQLite会自动以pUser变量的值作为唯一参数调用它。换句话说，xDelUser可以设置为pUser值的析构函数。
- en: The xGeom callback always does a depth-first search of the r-tree.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: xGeom回调总是对r-tree执行深度优先搜索。
- en: 6.2\. The New xQueryFunc Callback
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2\. 新的xQueryFunc回调
- en: 'The newer xQueryFunc callback receives more information from the r-tree query
    engine on each call, and it sends more information back to the query engine before
    it returns. To help keep the interface manageable, the xQueryFunc callback sends
    and receives information from the query engine as fields in the sqlite3_rtree_query_info
    structure:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 新的xQueryFunc回调从r-tree查询引擎在每次调用时接收更多信息，并在返回之前向查询引擎发送更多信息。为了帮助保持接口的可管理性，xQueryFunc回调作为sqlite3_rtree_query_info结构体中的字段从查询引擎发送和接收信息：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first five fields of the sqlite3_rtree_query_info structure are identical
    to the sqlite3_rtree_geometry structure, and have exactly the same meaning. The
    sqlite3_rtree_query_info structure also contains nCoord and aCoord fields which
    have the same meaning as the parameter of the same name in the xGeom callback.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: sqlite3_rtree_query_info结构体的前五个字段与sqlite3_rtree_geometry结构体相同，并具有完全相同的含义。sqlite3_rtree_query_info结构体还包含nCoord和aCoord字段，它们具有与xGeom回调中同名参数完全相同的含义。
- en: The xQueryFunc must set the eWithin field of sqlite3_rtree_query_info to one
    of the values NOT_WITHIN, PARTLY_WITHIN, or FULLY_WITHIN depending on whether
    or not the bounding box defined by aCoord[] is completely outside the region,
    overlaps the region, or is completely inside the region, respectively. In addition,
    the xQueryFunc must set the rScore field to a non-negative value that indicates
    the order in which subtrees and entries of the query should be analyzed and returned.
    Smaller scores are processed first.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: xQueryFunc必须将sqlite3_rtree_query_info的eWithin字段设置为NOT_WITHIN、PARTLY_WITHIN或FULLY_WITHIN值之一，具体取决于aCoord[]定义的边界框是完全在区域外、与区域重叠还是完全在区域内。此外，xQueryFunc必须将rScore字段设置为非负值，指示查询中应分析和返回子树和条目的顺序。较小的分数首先处理。
- en: As its name implies, an R*Tree is organized as a tree. Each node of the tree
    is a bounding box. The root of the tree is a bounding box that encapsulates all
    elements of the tree. Beneath the root are a number of subtrees (typically 20
    or more) each with their own smaller bounding boxes and each containing some subset
    of the R*Tree entries. The subtrees may have sub-subtrees, and so forth until
    finally one reaches the leaves of the tree which are the actual R*Tree entries.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名，R*树被组织成一棵树。树的每个节点都是一个边界框。树的根是一个边界框，它封装了树的所有元素。在根节点下面有若干个子树（通常是20个或更多），每个子树都有自己的较小边界框，并且每个子树包含R*树条目的某个子集。子树可能还有子子树，以此类推，直到最后到达树的叶子节点，这些叶子节点就是实际的R*树条目。
- en: An R*Tree query is initialized by making the root node the only entry in a priority
    queue sorted by rScore. The query proceeds by extracting the entry from the priority
    queue that has the lowest score. If that entry is a leaf (meaning that it is an
    actual R*Tree entry and not a subtree) then that entry is returned as one row
    of the query result. If the extracted priority queue entry is a node (a subtree),
    then the next child of that node is passed to the xQueryFunc callback. If the
    node has more children then it is returned to the priority queue. Otherwise it
    is discarded. Those subelements for which the xQueryFunc callback sets eWithin
    to PARTLY_WITHIN or FULLY_WITHIN are added to the priority queue using the score
    supplied by the callback. Subelements that return NOT_WITHIN are discarded. The
    query runs until the priority queue is empty.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: R*Tree查询通过将根节点作为按rScore排序的优先队列中的唯一条目来初始化。查询通过提取优先队列中具有最低分数的条目来进行。如果该条目是叶子节点（表示它是实际的R*Tree条目而不是子树），则将该条目作为查询结果的一行返回。如果提取的优先队列条目是一个节点（一个子树），则将该节点的下一个子节点传递给xQueryFunc回调。如果节点有更多子节点，则将其返回到优先队列。否则将其丢弃。xQueryFunc回调设置eWithin为PARTLY_WITHIN或FULLY_WITHIN的子元素将使用回调提供的分数添加到优先队列中。返回NOT_WITHIN的子元素将被丢弃。查询在优先队列为空时结束。
- en: Every leaf entry and node (subtree) within the R*Tree has an integer "level".
    The leaves have a level of 0\. The first containing subtree of the leaves has
    a level of 1\. The root of the R*Tree has the largest level value. The mxLevel
    entry in the sqlite3_rtree_query_info structure is the level value for the root
    of the R*Tree. The iLevel entry in sqlite3_rtree_query_info gives the level for
    the object being interrogated.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: R*Tree中的每个叶子条目和节点（子树）都有一个整数“级别”。叶子的级别为0。叶子的第一个包含子树的级别为1。R*Tree的根具有最大的级别值。sqlite3_rtree_query_info结构中的mxLevel条目是R*Tree根的级别值。sqlite3_rtree_query_info中的iLevel条目给出了正在查询的对象的级别。
- en: Most R*Tree queries use a depth-first search. This is accomplished by setting
    the rScore equal to iLevel. A depth-first search is usually preferred since it
    minimizes the number of elements in the priority queue, which reduces memory requirements
    and speeds processing. However, some application may prefer a breadth-first search,
    which can be accomplished by setting rScore to mxLevel-iLevel. By creating more
    complex formulas for rScore, applications can exercise detailed control over the
    order in which subtree are searched and leaf R*Tree entries are returned. For
    example, in an application with many millions of R*Tree entries, the rScore might
    be arranged so that the largest or most significant entries are returned first,
    allowing the application to display the most important information quickly, and
    filling in smaller and less important details as they become available.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数R*Tree查询使用深度优先搜索。通过将rScore设置为iLevel来实现此操作。通常偏爱深度优先搜索，因为它可以最小化优先队列中的元素数量，从而降低内存需求并加快处理速度。然而，某些应用程序可能更喜欢广度优先搜索，可以通过将rScore设置为mxLevel-iLevel来实现。通过为rScore创建更复杂的公式，应用程序可以详细控制搜索子树和返回叶R*Tree条目的顺序。例如，在具有数百万R*Tree条目的应用程序中，可以安排rScore，以便首先返回最大或最重要的条目，从而使应用程序能够快速显示最重要的信息，并在可用时填充更小和不太重要的细节。
- en: Other information fields of the sqlite3_rtree_query_info structure are available
    for use by the xQueryFunc callback, if desired. The iRowid field is the rowid
    (the first of the 3 to 11 columns in the R*Tree) for the element being considered.
    iRowid is only valid for leaves. The eParentWithin and rParentScore values are
    copies of the eWithin and rScore values from the containing subtree of the current
    row. The anQueue field is an array of mxLevel+1 unsigned integers that tell the
    current number of elements in the priority queue at each level.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，sqlite3_rtree_query_info结构的其他信息字段可以由xQueryFunc回调使用。iRowid字段是正在考虑的元素的行号（R*Tree中的3到11列中的第一个）。iRowid仅对叶子有效。eParentWithin和rParentScore值是当前行所在子树的eWithin和rScore值的副本。anQueue字段是一个mxLevel+1个无符号整数的数组，告知当前每个级别优先队列中的元素数量。
- en: 6.3\. Additional Considerations for Custom Queries
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3\. 自定义查询的其他注意事项
- en: The MATCH operator of a custom R*Tree query function must be a top-level AND-connected
    term of the WHERE clause, or else it will not be usable by the R*Tree query optimizer
    and the query will not be runnable. If the MATCH operator is connected to other
    terms of the WHERE clause via an OR operator, for example, the query will fail
    with an error.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义R*Tree查询函数的MATCH运算符必须是WHERE子句的顶级AND连接术语，否则将无法由R*Tree查询优化器使用，查询将无法运行。例如，如果MATCH运算符通过OR运算符连接到WHERE子句的其他术语，则查询将失败并显示错误。
- en: Two or more MATCH operators are allowed in the same WHERE clause, as long as
    they are connected by AND operators. However, the R*Tree query engine only contains
    a single priority queue. The priority assigned to each node in the search is the
    lowest priority returned by any of the MATCH operators.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 同一WHERE子句中允许使用两个或多个MATCH运算符，只要它们通过AND运算符连接即可。但是，R*Tree查询引擎仅包含单个优先级队列。在搜索中分配给每个节点的优先级是由任何MATCH运算符返回的最低优先级。
- en: 7\. Implementation Details
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现细节。
- en: The following sections describe some low-level details of the R*Tree implementation,
    that might be useful for trouble-shooting or performance analysis.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的部分描述了R*Tree实现的一些低级细节，这对故障排除或性能分析可能有用。
- en: 7.1\. Shadow Tables
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1\. 影子表
- en: 'The content of an R*Tree index is actually stored in three ordinary SQLite
    tables with names derived from the name of the R*Tree. These three tables are
    called "[shadow tables](vtab.html#xshadowname)". This is their schema:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: R*Tree索引的内容实际上存储在三个普通的SQLite表中，这些表的名称源自R*Tree的名称。这三个表称为"[影子表](vtab.html#xshadowname)"。它们的架构如下：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The "%" in the name of each shadow table is replaced by the name of the R*Tree
    virtual table. So, if the name of the R*Tree table is "xyz" then the three shadow
    tables would be "xyz_node", "xyz_parent", and "xyz_rowid".
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 每个影子表的名称中的"%"被替换为R*Tree虚拟表的名称。因此，如果R*Tree表的名称是"xyz"，那么这三个影子表将是"xyz_node"，"xyz_parent"和"xyz_rowid"。
- en: There is one entry in the %_node table for each R*Tree node. An R*Tree node
    consists of one or more entries that are proximate to one another. The nodes of
    an R*Tree for a tree. All nodes other than the root have an entry in the %_parent
    shadow table that identifies the parent node. Each entry in an R*Tree has a rowid.
    The %_rowid shadow table maps entry rowids to the node that contains that entry.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '%_node表中每个R*Tree节点都有一个条目。R*Tree节点由互相接近的一个或多个条目组成。对于树的R*Tree，除了根节点之外的所有节点在%_parent影子表中都有一个条目，用于标识父节点。R*Tree的每个条目都有一个rowid。%_rowid影子表将条目rowid映射到包含该条目的节点。'
- en: Extra columns appended to the %_rowid table hold the content of [auxiliary columns](rtree.html#auxcol).
    The names of these extra %_rowid columns are probably not the same as the actual
    auxiliary column names.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 附加到%_rowid表的额外列保存[辅助列](rtree.html#auxcol)的内容。这些额外的%_rowid列的名称可能与实际的辅助列名称不同。
- en: 7.2\. Integrity Check using the rtreecheck() SQL function
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用rtreecheck() SQL函数进行完整性检查。
- en: The scalar SQL function rtreecheck(R) or rtreecheck(S,R) runs an integrity check
    on the rtree table named R contained within database S. The function returns a
    human-language description of any problems found, or the string 'ok' if everything
    is ok. Running rtreecheck() on an R*Tree virtual table is similar to running [PRAGMA
    integrity_check](pragma.html#pragma_integrity_check) on a database.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 标量SQL函数rtreecheck(R)或rtreecheck(S,R)对数据库S中包含的名为R的rtree表运行完整性检查。该函数返回发现的任何问题的人类语言描述，或者如果一切正常，则返回字符串'ok'。在R*Tree虚拟表上运行rtreecheck()类似于在数据库上运行[PRAGMA
    integrity_check](pragma.html#pragma_integrity_check)。
- en: 'Example: To verify that an R*Tree named "demo_index" is well-formed and internally
    consistent, run:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：要验证名为"demo_index"的R*Tree是否形成良好且内部一致，请运行：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The rtreecheck() function performs the following checks:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: rtreecheck()函数执行以下检查：
- en: 'For each cell in the r-tree structure (%_node table), that:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于rtree结构（%_node表）中的每个单元格：
- en: for each dimension, (coord1 <= coord2).
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个维度，（coord1 <= coord2）。
- en: unless the cell is on the root node, that the cell is bounded by the parent
    cell on the parent node.
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除非单元格位于根节点上，否则该单元格由父节点上的父单元格限定。
- en: for leaf nodes, that there is an entry in the %_rowid table corresponding to
    the cell's rowid value that points to the correct node.
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于叶节点，%_rowid表中有一个条目，其对应于指向正确节点的单元格的rowid值。
- en: for cells on non-leaf nodes, that there is an entry in the %_parent table mapping
    from the cell's child node to the node that it resides on.
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于非叶子节点上的单元格，%_parent表中有一个条目，将单元格的子节点映射到其所在的节点。
- en: That there are the same number of entries in the %_rowid table as there are
    leaf cells in the r-tree structure, and that there is a leaf cell that corresponds
    to each entry in the %_rowid table.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 %_rowid 表中的条目数与 r 树结构中的叶子单元格数相同，并且每个 %_rowid 表条目对应一个叶子单元格。
- en: That there are the same number of entries in the %_parent table as there are
    non-leaf cells in the r-tree structure, and that there is a non-leaf cell that
    corresponds to each entry in the %_parent table.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 %_parent 表中的条目数与 r 树结构中的非叶子单元格数相同，并且每个 %_parent 表条目对应一个非叶子单元格。
