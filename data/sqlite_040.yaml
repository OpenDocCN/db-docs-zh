- en: 1\. Introduction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1\. 引言
- en: 原文：[https://sqlite.com/vtab.html#tabfunc2](https://sqlite.com/vtab.html#tabfunc2)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://sqlite.com/vtab.html#tabfunc2](https://sqlite.com/vtab.html#tabfunc2)
- en: A virtual table is an object that is registered with an open SQLite [database
    connection](c3ref/sqlite3.html). From the perspective of an SQL statement, the
    virtual table object looks like any other table or view. But behind the scenes,
    queries and updates on a virtual table invoke callback methods of the virtual
    table object instead of reading and writing on the database file.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟表是一个注册到开放SQLite [数据库连接](c3ref/sqlite3.html)的对象。从SQL语句的角度看，虚拟表对象看起来像任何其他表或视图。但在幕后，对虚拟表的查询和更新会调用虚拟表对象的回调方法，而不是直接读取和写入数据库文件。
- en: 'The virtual table mechanism allows an application to publish interfaces that
    are accessible from SQL statements as if they were tables. SQL statements can
    do almost anything to a virtual table that they can do to a real table, with the
    following exceptions:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟表机制允许应用程序发布可以从SQL语句访问的接口，就像它们是表一样。SQL语句可以对虚拟表做几乎任何与真实表相同的操作，但以下操作除外：
- en: One cannot create a trigger on a virtual table.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不能在虚拟表上创建触发器。
- en: One cannot create additional indices on a virtual table. (Virtual tables can
    have indices but that must be built into the virtual table implementation. Indices
    cannot be added separately using [CREATE INDEX](lang_createindex.html) statements.)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不能在虚拟表上创建额外的索引。（虚拟表可以有索引，但必须内建到虚拟表的实现中。不能通过[CREATE INDEX](lang_createindex.html)语句单独添加索引。）
- en: One cannot run [ALTER TABLE ... ADD COLUMN](lang_altertable.html) commands against
    a virtual table.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不能对虚拟表运行[ALTER TABLE ... ADD COLUMN](lang_altertable.html)命令。
- en: Individual virtual table implementations might impose additional constraints.
    For example, some virtual implementations might provide read-only tables. Or some
    virtual table implementations might allow [INSERT](lang_insert.html) or [DELETE](lang_delete.html)
    but not [UPDATE](lang_update.html). Or some virtual table implementations might
    limit the kinds of UPDATEs that can be made.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 各个虚拟表实现可能施加额外的约束。例如，一些虚拟实现可能提供只读表。或者一些虚拟表实现可能允许[INSERT](lang_insert.html)或[DELETE](lang_delete.html)，但不允许[UPDATE](lang_update.html)。或者一些虚拟表实现可能限制可以进行的UPDATE类型。
- en: A virtual table might represent an in-memory data structures. Or it might represent
    a view of data on disk that is not in the SQLite format. Or the application might
    compute the content of the virtual table on demand.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟表可以代表内存中的数据结构。或者它可以表示磁盘上不在SQLite格式中的数据的视图。或者应用程序可能按需计算虚拟表的内容。
- en: 'Here are some existing and postulated uses for virtual tables:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些现有和假设的虚拟表用途：
- en: A [full-text search](fts3.html) interface
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[全文搜索](fts3.html)接口'
- en: Spatial indices using [R-Trees](rtree.html)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用[R-Tree](rtree.html)进行空间索引
- en: Introspect the disk content of an SQLite database file (the [dbstat virtual
    table](dbstat.html))
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查SQLite数据库文件的磁盘内容（[dbstat虚拟表](dbstat.html)）
- en: Read and/or write the content of a comma-separated value (CSV) file
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取和/或写入逗号分隔值（CSV）文件的内容
- en: Access the filesystem of the host computer as if it were a database table
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问主机计算机的文件系统，就像它是一个数据库表一样。
- en: Enabling SQL manipulation of data in statistics packages like R
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用SQL在统计软件包如R中对数据的操作
- en: See the [list of virtual tables](vtablist.html) page for a longer list of actual
    virtual table implementations.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[虚拟表列表](vtablist.html)页面，了解更多实际虚拟表实现的列表。
- en: 1.1\. Usage
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1\. 使用方法
- en: A virtual table is created using a [CREATE VIRTUAL TABLE](lang_createvtab.html)
    statement.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[CREATE VIRTUAL TABLE](lang_createvtab.html)语句创建虚拟表。
- en: '**[create-virtual-table-stmt:](syntax/create-virtual-table-stmt.html)**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**[create-virtual-table-stmt:](syntax/create-virtual-table-stmt.html)**'
- en: <svg class="pikchr" viewBox="0 0 624.096 259.848"><text x="74" y="17" text-anchor="middle"
    fill="rgb(0,0,0)" dominant-baseline="central">CREATE</text> <text x="183" y="17"
    text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">VIRTUAL</text>
    <text x="286" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">TABLE</text>
    <text x="372" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">IF</text>
    <text x="435" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">NOT</text>
    <text x="521" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">EXISTS</text>
    <text x="95" y="92" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">schema-name</text>
    <text x="197" y="92" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)"
    dominant-baseline="central">.</text> <text x="300" y="92" text-anchor="middle"
    fill="rgb(0,0,0)" dominant-baseline="central">table-name</text> <text x="67" y="204"
    text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">USING</text>
    <text x="187" y="204" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">module-name</text>
    <text x="300" y="204" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)"
    dominant-baseline="central">(</text> <text x="432" y="204" text-anchor="middle"
    fill="rgb(0,0,0)" dominant-baseline="central">module-argument</text> <text x="563"
    y="204" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)" dominant-baseline="central">)</text>
    <text x="432" y="242" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)"
    dominant-baseline="central">,</text></svg>
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="pikchr" viewBox="0 0 624.096 259.848"><text x="74" y="17" text-anchor="middle"
    fill="rgb(0,0,0)" dominant-baseline="central">CREATE</text> <text x="183" y="17"
    text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">VIRTUAL</text>
    <text x="286" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">TABLE</text>
    <text x="372" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">IF</text>
    <text x="435" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">NOT</text>
    <text x="521" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">EXISTS</text>
    <text x="95" y="92" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">schema-name</text>
    <text x="197" y="92" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)"
    dominant-baseline="central">.</text> <text x="300" y="92" text-anchor="middle"
    fill="rgb(0,0,0)" dominant-baseline="central">table-name</text> <text x="67" y="204"
    text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">USING</text>
    <text x="187" y="204" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">module-name</text>
    <text x="300" y="204" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)"
    dominant-baseline="central">(</text> <text x="432" y="204" text-anchor="middle"
    fill="rgb(0,0,0)" dominant-baseline="central">module-argument</text> <text x="563"
    y="204" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)" dominant-baseline="central">)</text>
    <text x="432" y="242" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)"
    dominant-baseline="central">,</text></svg>
- en: The CREATE VIRTUAL TABLE statement creates a new table called table-name derived
    from the class module-name. The module-name is the name that is registered for
    the virtual table by the [sqlite3_create_module()](c3ref/create_module.html) interface.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: CREATE VIRTUAL TABLE 语句创建一个名为 table-name 的新表，其来源于类 module-name。module-name 是通过
    [sqlite3_create_module()](c3ref/create_module.html) 接口为虚拟表注册的名称。
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'One can also provide comma-separated arguments to the module following the
    module name:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的名称后面还可以提供逗号分隔的参数。
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The format of the arguments to the module is very general. Each module-argument
    may contain keywords, string literals, identifiers, numbers, and punctuation.
    Each module-argument is passed as written (as text) into the [constructor method](vtab.html#xcreate)
    of the virtual table implementation when the virtual table is created and that
    constructor is responsible for parsing and interpreting the arguments. The argument
    syntax is sufficiently general that a virtual table implementation can, if it
    wants to, interpret its arguments as [column definitions](lang_createtable.html#tablecoldef)
    in an ordinary [CREATE TABLE](lang_createtable.html) statement. The implementation
    could also impose some other interpretation on the arguments.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 模块参数的格式非常通用。每个模块参数可以包含关键字、字符串字面值、标识符、数字和标点符号。在创建虚拟表时，每个模块参数将按照原文（作为文本）传递给虚拟表实现的
    [构造方法](vtab.html#xcreate)，该构造方法负责解析和解释这些参数。参数的语法足够通用，以至于虚拟表实现如果希望的话，可以将其参数解释为普通
    [CREATE TABLE](lang_createtable.html) 语句中的 [列定义](lang_createtable.html#tablecoldef)。实现也可以对参数施加其他解释。
- en: Once a virtual table has been created, it can be used like any other table with
    the exceptions noted above and imposed by specific virtual table implementations.
    A virtual table is destroyed using the ordinary [DROP TABLE](lang_droptable.html)
    syntax.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了虚拟表，它可以像任何其他表一样使用，但具体虚拟表实现所规定的例外情况除外。销毁虚拟表时，需使用普通的 [DROP TABLE](lang_droptable.html)
    语法。
- en: 1.1.1\. Temporary virtual tables
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.1\. 临时虚拟表
- en: There is no "CREATE TEMP VIRTUAL TABLE" statement. To create a temporary virtual
    table, add the "temp" schema before the virtual table name.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 没有 "CREATE TEMP VIRTUAL TABLE" 语句。要创建临时虚拟表，请在虚拟表名称前添加 "temp" 模式。
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 1.1.2\. Eponymous virtual tables
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.2\. 同名虚拟表
- en: Some virtual tables exist automatically in the "main" schema of every database
    connection in which their module is registered, even without a [CREATE VIRTUAL
    TABLE](lang_createvtab.html) statement. Such virtual tables are called "eponymous
    virtual tables". To use an eponymous virtual table, simply use the module name
    as if it were a table. Eponymous virtual tables exist in the "main" schema only,
    so they will not work if prefixed with a different schema name.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 某些虚拟表会自动存在于每个数据库连接的 "main" 模式中，即使没有 [CREATE VIRTUAL TABLE](lang_createvtab.html)
    语句。此类虚拟表称为 "同名虚拟表"。要使用同名虚拟表，只需将模块名称用作普通表即可。同名虚拟表仅存在于 "main" 模式中，因此如果使用不同模式名称前缀，它们将无法工作。
- en: An example of an eponymous virtual table is the [dbstat virtual table](dbstat.html).
    To use the dbstat virtual table as an eponymous virtual table, simply query against
    the "dbstat" module name, as if it were an ordinary table. (Note that SQLite must
    be compiled with the [SQLITE_ENABLE_DBSTAT_VTAB](compile.html#enable_dbstat_vtab)
    option to include the dbstat virtual table in the build.)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是 [dbstat 虚拟表](dbstat.html)。要将 dbstat 虚拟表用作同名虚拟表，只需针对 "dbstat" 模块名称进行查询，就像它是普通表一样。（请注意，SQLite
    必须使用 [SQLITE_ENABLE_DBSTAT_VTAB](compile.html#enable_dbstat_vtab) 选项编译，以在构建中包含
    dbstat 虚拟表。）
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A virtual table is eponymous if its [xCreate](vtab.html#xcreate) method is the
    exact same function as the [xConnect](vtab.html#xconnect) method, or if the [xCreate](vtab.html#xcreate)
    method is NULL. The [xCreate](vtab.html#xcreate) method is called when a virtual
    table is first created using the [CREATE VIRTUAL TABLE](lang_createvtab.html)
    statement. The [xConnect](vtab.html#xconnect) method is invoked whenever a database
    connection attaches to or reparses a schema. When these two methods are the same,
    that indicates that the virtual table has no persistent state that needs to be
    created and destroyed.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其 [xCreate](vtab.html#xcreate) 方法与 [xConnect](vtab.html#xconnect) 方法完全相同，或者
    [xCreate](vtab.html#xcreate) 方法为 NULL，则虚拟表称为同名的。当使用 [CREATE VIRTUAL TABLE](lang_createvtab.html)
    语句首次创建虚拟表时，将调用 [xCreate](vtab.html#xcreate) 方法。当数据库连接附加到或重新解析模式时，将调用 [xConnect](vtab.html#xconnect)
    方法。当这两个方法相同时，表示虚拟表没有需要创建和销毁的持久状态。
- en: 1.1.3\. Eponymous-only virtual tables
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.3\. 仅同名虚拟表
- en: If the [xCreate](vtab.html#xcreate) method is NULL, then [CREATE VIRTUAL TABLE](lang_createvtab.html)
    statements are prohibited for that virtual table, and the virtual table is an
    "eponymous-only virtual table". Eponymous-only virtual tables are useful as [table-valued
    functions](vtab.html#tabfunc2).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 [xCreate](vtab.html#xcreate) 方法为 NULL，则禁止为该虚拟表使用 [CREATE VIRTUAL TABLE](lang_createvtab.html)
    语句，该虚拟表称为 "仅同名虚拟表"。仅同名虚拟表可用作表值函数。
- en: Note that prior to [version 3.9.0](releaselog/3_9_0.html) (2015-10-14), SQLite
    did not check the xCreate method for NULL before invoking it. So if an eponymous-only
    virtual table is registered with SQLite [version 3.8.11.1](releaselog/3_8_11_1.html)
    (2015-07-29) or earlier and a [CREATE VIRTUAL TABLE](lang_createvtab.html) command
    is attempted against that virtual table module, a jump to a NULL pointer will
    occur, resulting in a crash.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 [version 3.9.0](releaselog/3_9_0.html) (2015-10-14) 之前，SQLite 在调用 xCreate
    方法之前不会检查其是否为 NULL。因此，如果仅具有同名的虚拟表，并且尝试对该虚拟表模块使用 [CREATE VIRTUAL TABLE](lang_createvtab.html)
    命令，则会发生跳转到 NULL 指针，导致崩溃。
- en: 1.2\. Implementation
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2\. 实现
- en: 'Several new C-level objects are used by the virtual table implementation:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟表实现使用了几个新的 C 级对象：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The [sqlite3_module](c3ref/module.html) structure defines a module object used
    to implement a virtual table. Think of a module as a class from which one can
    construct multiple virtual tables having similar properties. For example, one
    might have a module that provides read-only access to comma-separated-value (CSV)
    files on disk. That one module can then be used to create several virtual tables
    where each virtual table refers to a different CSV file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[sqlite3_module](c3ref/module.html)结构定义了一个模块对象，用于实现虚拟表。可以将模块想象为可以构建具有类似属性的多个虚拟表的类。例如，可以有一个模块提供对磁盘上逗号分隔值（CSV）文件的只读访问。然后可以使用该单个模块创建多个虚拟表，其中每个虚拟表引用不同的CSV文件。'
- en: The module structure contains methods that are invoked by SQLite to perform
    various actions on the virtual table such as creating new instances of a virtual
    table or destroying old ones, reading and writing data, searching for and deleting,
    updating, or inserting rows. The module structure is explained in more detail
    below.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 模块结构包含由SQLite调用的方法，执行虚拟表的各种操作，如创建新实例、销毁旧实例、读取和写入数据、搜索和删除、更新或插入行。模块结构将在下文详细解释。
- en: 'Each virtual table instance is represented by an [sqlite3_vtab](c3ref/vtab.html)
    structure. The sqlite3_vtab structure looks like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每个虚拟表实例都由一个[sqlite3_vtab](c3ref/vtab.html)结构表示。sqlite3_vtab结构如下所示：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Virtual table implementations will normally subclass this structure to add additional
    private and implementation-specific fields. The nRef field is used internally
    by the SQLite core and should not be altered by the virtual table implementation.
    The virtual table implementation may pass error message text to the core by putting
    an error message string in zErrMsg. Space to hold this error message string must
    be obtained from an SQLite memory allocation function such as [sqlite3_mprintf()](c3ref/mprintf.html)
    or [sqlite3_malloc()](c3ref/free.html). Prior to assigning a new value to zErrMsg,
    the virtual table implementation must free any preexisting content of zErrMsg
    using [sqlite3_free()](c3ref/free.html). Failure to do this will result in a memory
    leak. The SQLite core will free and zero the content of zErrMsg when it delivers
    the error message text to the client application or when it destroys the virtual
    table. The virtual table implementation only needs to worry about freeing the
    zErrMsg content when it overwrites the content with a new, different error message.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟表实现通常会子类化这个结构以添加额外的私有和特定于实现的字段。nRef字段由SQLite核心内部使用，不应该被虚拟表实现修改。虚拟表实现可以通过在zErrMsg中放置错误消息字符串来向核心传递错误消息文本，这是从SQLite内存分配函数（如[sqlite3_mprintf()](c3ref/mprintf.html)或[sqlite3_malloc()](c3ref/free.html)）中获取空间来存储该错误消息字符串。在给zErrMsg分配新值之前，虚拟表实现必须使用[sqlite3_free()](c3ref/free.html)释放zErrMsg的任何现有内容。如果未能执行此操作，将导致内存泄漏。当核心向客户端应用程序交付错误消息文本或销毁虚拟表时，核心将释放并清零zErrMsg的内容。虚拟表实现只需要在将内容覆盖为新的不同错误消息时担心释放zErrMsg的内容。
- en: 'The [sqlite3_vtab_cursor](c3ref/vtab_cursor.html) structure represents a pointer
    to a specific row of a virtual table. This is what an sqlite3_vtab_cursor looks
    like:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[sqlite3_vtab_cursor](c3ref/vtab_cursor.html)结构表示虚拟表特定行的指针。sqlite3_vtab_cursor的结构如下所示：'
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once again, practical implementations will likely subclass this structure to
    add additional private fields.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，实际实现很可能会子类化这个结构以添加额外的私有字段。
- en: The [sqlite3_index_info](c3ref/index_info.html) structure is used to pass information
    into and out of the xBestIndex method of the module that implements a virtual
    table.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[sqlite3_index_info](c3ref/index_info.html)结构用于在实现虚拟表的模块的xBestIndex方法中传入和传出信息。'
- en: 'Before a [CREATE VIRTUAL TABLE](lang_createvtab.html) statement can be run,
    the module specified in that statement must be registered with the database connection.
    This is accomplished using either of the [sqlite3_create_module()](c3ref/create_module.html)
    or [sqlite3_create_module_v2()](c3ref/create_module.html) interfaces:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行[CREATE VIRTUAL TABLE](lang_createvtab.html)语句之前，必须注册该语句中指定的模块到数据库连接。可以使用[sqlite3_create_module()](c3ref/create_module.html)或[sqlite3_create_module_v2()](c3ref/create_module.html)接口来完成这一操作：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The [sqlite3_create_module()](c3ref/create_module.html) and [sqlite3_create_module_v2()](c3ref/create_module.html)
    routines associates a module name with an [sqlite3_module](c3ref/module.html)
    structure and a separate client data that is specific to each module. The only
    difference between the two create_module methods is that the _v2 method includes
    an extra parameter that specifies a destructor for client data pointer. The module
    structure is what defines the behavior of a virtual table. The module structure
    looks like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[sqlite3_create_module()](c3ref/create_module.html) 和 [sqlite3_create_module_v2()](c3ref/create_module.html)
    程序将模块名称与一个[sqlite3_module](c3ref/module.html) 结构及一个特定于每个模块的客户端数据关联起来。这两种 create_module
    方法的唯一区别是 _v2 方法包含一个额外参数，指定客户端数据指针的析构函数。模块结构定义了虚拟表的行为。模块结构看起来像这样：'
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The module structure defines all of the methods for each virtual table object.
    The module structure also contains the iVersion field which defines the particular
    edition of the module table structure. Currently, iVersion is always 4 or less,
    but in future releases of SQLite the module structure definition might be extended
    with additional methods and in that case the maximum iVersion value will be increased.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 模块结构定义了每个虚拟表对象的所有方法。模块结构还包含 iVersion 字段，该字段定义了模块表结构的特定版本。目前，iVersion 总是 4 或更低，但在SQLite的未来版本中，模块结构定义可能会扩展以包含额外的方法，届时最大的
    iVersion 值将会增加。
- en: The rest of the module structure consists of methods used to implement various
    features of the virtual table. Details on what each of these methods do are provided
    in the sequel.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 模块结构的其余部分由用于实现虚拟表各种功能的方法组成。关于每个方法的详细信息在下文中提供。
- en: 1.3\. Virtual Tables And Shared Cache
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3\. 虚拟表与共享缓存
- en: Prior to SQLite [version 3.6.17](releaselog/3_6_17.html) (2009-08-10), the virtual
    table mechanism assumes that each [database connection](c3ref/sqlite3.html) kept
    its own copy of the database schema. Hence, the virtual table mechanism could
    not be used in a database that has [shared cache mode](sharedcache.html) enabled.
    The [sqlite3_create_module()](c3ref/create_module.html) interface would return
    an error if [shared cache mode](sharedcache.html) is enabled. That restriction
    was relaxed beginning with SQLite [version 3.6.17](releaselog/3_6_17.html).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQLite [版本 3.6.17](releaselog/3_6_17.html)（2009-08-10）之前，虚拟表机制假设每个[数据库连接](c3ref/sqlite3.html)保留自己的数据库模式副本。因此，在启用了[共享缓存模式](sharedcache.html)的数据库中无法使用虚拟表机制。如果启用了[共享缓存模式](sharedcache.html)，[sqlite3_create_module()](c3ref/create_module.html)接口会返回错误。从SQLite
    [版本 3.6.17](releaselog/3_6_17.html)开始放宽了该限制。
- en: 1.4\. Creating New Virtual Table Implementations
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4\. 创建新的虚拟表实现
- en: 'Follow these steps to create your own virtual table:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建您自己的虚拟表：
- en: Write all necessary methods.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写所有必要的方法。
- en: Create an instance of the [sqlite3_module](c3ref/module.html) structure containing
    pointers to all the methods from step 1.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含步骤 1 所有方法指针的[sqlite3_module](c3ref/module.html) 结构的实例。
- en: Register your [sqlite3_module](c3ref/module.html) structure using one of the
    [sqlite3_create_module()](c3ref/create_module.html) or [sqlite3_create_module_v2()](c3ref/create_module.html)
    interfaces.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用其中一个[sqlite3_create_module()](c3ref/create_module.html) 或 [sqlite3_create_module_v2()](c3ref/create_module.html)
    接口注册您的[sqlite3_module](c3ref/module.html) 结构。
- en: Run a [CREATE VIRTUAL TABLE](lang_createvtab.html) command that specifies the
    new module in the USING clause.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行一个[创建虚拟表](lang_createvtab.html)的命令，在`USING`子句中指定新模块。
- en: 'The only really hard part is step 1\. You might want to start with an existing
    virtual table implementation and modify it to suit your needs. The [SQLite source
    tree](https://sqlite.org/src/dir?ci=trunk&type=tree) contains many virtual table
    implementations that are suitable for copying, including:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一真正困难的部分是步骤 1。你可能希望从现有的虚拟表实现开始，并根据需要进行修改。[SQLite 源代码树](https://sqlite.org/src/dir?ci=trunk&type=tree)包含许多适合复制的虚拟表实现，包括：
- en: '**[templatevtab.c](https://sqlite.org/src/file/ext/misc/templatevtab.c)** →
    A virtual table created specifically to serve as a template for other custom virtual
    tables.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[templatevtab.c](https://sqlite.org/src/file/ext/misc/templatevtab.c)** →
    专门创建的虚拟表，作为其他自定义虚拟表的模板。'
- en: '**[series.c](https://sqlite.org/src/file/ext/misc/series.c)** → Implementation
    of the generate_series() table-valued function.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[series.c](https://sqlite.org/src/file/ext/misc/series.c)** → 生成 generate_series()
    表值函数的实现。'
- en: '**[json.c](https://sqlite.org/src/file/src/json.c)** → Contains the sources
    for the [json_each()](json1.html#jeach) and [json_tree()](json1.html#jtree) table-valued
    functions.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[json.c](https://sqlite.org/src/file/src/json.c)** → 包含了 [json_each()](json1.html#jeach)
    和 [json_tree()](json1.html#jtree) 表值函数的源代码。'
- en: '**[csv.c](https://sqlite.org/src/file/ext/misc/csv.c)** → A virtual table that
    reads CSV files.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[csv.c](https://sqlite.org/src/file/ext/misc/csv.c)** → 一个读取 CSV 文件的虚拟表。'
- en: There are [many other virtual table implementations](vtablist.html) in the SQLite
    source tree that can be used as examples. Locate these other virtual table implementations
    by searching for "sqlite3_create_module".
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLite 源树中有 [许多其他虚拟表实现](vtablist.html)，可用作示例。通过搜索 "sqlite3_create_module"
    可找到这些其他虚拟表实现。
- en: You might also want to implement your new virtual table as a [loadable extension](loadext.html).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还希望将新的虚拟表实现为一个 [可加载扩展](loadext.html)。
- en: 2\. Virtual Table Methods
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2\. 虚拟表方法
- en: 2.1\. The xCreate Method
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1\. xCreate 方法
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The xCreate method is called to create a new instance of a virtual table in
    response to a [CREATE VIRTUAL TABLE](lang_createvtab.html) statement. If the xCreate
    method is the same pointer as the [xConnect](vtab.html#xconnect) method, then
    the virtual table is an [eponymous virtual table](vtab.html#epovtab). If the xCreate
    method is omitted (if it is a NULL pointer) then the virtual table is an [eponymous-only
    virtual table](vtab.html#epoonlyvtab).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: xCreate 方法是在响应 [CREATE VIRTUAL TABLE](lang_createvtab.html) 语句时调用的，用于创建虚拟表的新实例。如果
    xCreate 方法与 [xConnect](vtab.html#xconnect) 方法相同，则该虚拟表是一个 [同名虚拟表](vtab.html#epovtab)。如果省略了
    xCreate 方法（如果它是一个空指针），那么该虚拟表是一个 [仅同名虚拟表](vtab.html#epoonlyvtab)。
- en: The db parameter is a pointer to the SQLite [database connection](c3ref/sqlite3.html)
    that is executing the [CREATE VIRTUAL TABLE](lang_createvtab.html) statement.
    The pAux argument is the copy of the client data pointer that was the fourth argument
    to the [sqlite3_create_module()](c3ref/create_module.html) or [sqlite3_create_module_v2()](c3ref/create_module.html)
    call that registered the [virtual table module](c3ref/module.html). The argv parameter
    is an array of argc pointers to null terminated strings. The first string, argv[0],
    is the name of the module being invoked. The module name is the name provided
    as the second argument to [sqlite3_create_module()](c3ref/create_module.html)
    and as the argument to the USING clause of the [CREATE VIRTUAL TABLE](lang_createvtab.html)
    statement that is running. The second, argv[1], is the name of the database in
    which the new virtual table is being created. The database name is "main" for
    the primary database, or "temp" for TEMP database, or the name given at the end
    of the [ATTACH](lang_attach.html) statement for attached databases. The third
    element of the array, argv[2], is the name of the new virtual table, as specified
    following the TABLE keyword in the [CREATE VIRTUAL TABLE](lang_createvtab.html)
    statement. If present, the fourth and subsequent strings in the argv[] array report
    the arguments to the module name in the [CREATE VIRTUAL TABLE](lang_createvtab.html)
    statement.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: db 参数是指向执行 [CREATE VIRTUAL TABLE](lang_createvtab.html) 语句的 SQLite [数据库连接](c3ref/sqlite3.html)
    的指针。pAux 参数是在注册 [虚拟表模块](c3ref/module.html) 时作为第四个参数传递给 [sqlite3_create_module()](c3ref/create_module.html)
    或 [sqlite3_create_module_v2()](c3ref/create_module.html) 调用的客户端数据指针的副本。argv 参数是一个包含
    argc 个指向空终止字符串的指针数组。数组的第一个字符串，argv[0]，是被调用模块的名称。模块名称是作为 [sqlite3_create_module()](c3ref/create_module.html)
    的第二个参数提供的名称，也是 [CREATE VIRTUAL TABLE](lang_createvtab.html) 语句的 USING 子句中提供的参数。数组的第二个字符串，argv[1]，是正在创建新虚拟表的数据库的名称。对于主数据库，数据库名称是
    "main"，对于 TEMP 数据库，名称是 "temp"，对于附加数据库，名称是在 [ATTACH](lang_attach.html) 语句的末尾指定的名称。数组的第三个元素，argv[2]，是在
    [CREATE VIRTUAL TABLE](lang_createvtab.html) 语句中的 TABLE 关键字后指定的新虚拟表的名称。如果存在，argv[]
    中的第四个及其后的字符串报告了 [CREATE VIRTUAL TABLE](lang_createvtab.html) 语句中模块名称的参数。
- en: The job of this method is to construct the new virtual table object (an [sqlite3_vtab](c3ref/vtab.html)
    object) and return a pointer to it in *ppVTab.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的作用是构造新的虚拟表对象（一个 [sqlite3_vtab](c3ref/vtab.html) 对象），并在 *ppVTab 中返回指向该对象的指针。
- en: 'As part of the task of creating a new [sqlite3_vtab](c3ref/vtab.html) structure,
    this method must invoke [sqlite3_declare_vtab()](c3ref/declare_vtab.html) to tell
    the SQLite core about the columns and datatypes in the virtual table. The [sqlite3_declare_vtab()](c3ref/declare_vtab.html)
    API has the following prototype:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 作为创建新的 [sqlite3_vtab](c3ref/vtab.html) 结构的任务的一部分，该方法必须调用 [sqlite3_declare_vtab()](c3ref/declare_vtab.html)
    来告知 SQLite 核心虚拟表中的列和数据类型。[sqlite3_declare_vtab()](c3ref/declare_vtab.html) API
    具有以下原型：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first argument to [sqlite3_declare_vtab()](c3ref/declare_vtab.html) must
    be the same [database connection](c3ref/sqlite3.html) pointer as the first parameter
    to this method. The second argument to [sqlite3_declare_vtab()](c3ref/declare_vtab.html)
    must a zero-terminated UTF-8 string that contains a well-formed [CREATE TABLE](lang_createtable.html)
    statement that defines the columns in the virtual table and their data types.
    The name of the table in this CREATE TABLE statement is ignored, as are all constraints.
    Only the column names and datatypes matter. The CREATE TABLE statement string
    need not to be held in persistent memory. The string can be deallocated and/or
    reused as soon as the [sqlite3_declare_vtab()](c3ref/declare_vtab.html) routine
    returns.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 [sqlite3_declare_vtab()](c3ref/declare_vtab.html) 的第一个参数必须与此方法的第一个参数相同，即
    [数据库连接](c3ref/sqlite3.html) 指针。调用 [sqlite3_declare_vtab()](c3ref/declare_vtab.html)
    的第二个参数必须是以零结尾的 UTF-8 字符串，包含一个形式良好的 [CREATE TABLE](lang_createtable.html) 语句，定义虚拟表中的列和它们的数据类型。在此
    CREATE TABLE 语句中表的名称被忽略，以及所有约束。只有列名和数据类型才重要。CREATE TABLE 语句的字符串不需要持久内存。一旦 [sqlite3_declare_vtab()](c3ref/declare_vtab.html)
    程序返回，该字符串就可以被释放和/或重用。
- en: 'The xConnect method can also optionally request special features for the virtual
    table by making one or more calls to the [sqlite3_vtab_config()](c3ref/vtab_config.html)
    interface:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 [sqlite3_vtab_config()](c3ref/vtab_config.html) 接口，xConnect 方法还可以选择性地为虚拟表请求特殊功能：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Calls to sqlite3_vtab_config() are optional. But for maximum security, it is
    recommended that virtual table implementations invoke "[sqlite3_vtab_config](c3ref/vtab_config.html)(db,
    [SQLITE_VTAB_DIRECTONLY](c3ref/c_vtab_constraint_support.html#sqlitevtabdirectonly))"
    if the virtual table will not be used from inside of triggers or views.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对 [sqlite3_vtab_config()](c3ref/vtab_config.html) 的调用是可选的。但为了最大的安全性，建议虚拟表实现在虚拟表不会从触发器或视图内部使用时调用
    "[sqlite3_vtab_config](c3ref/vtab_config.html)(db, [SQLITE_VTAB_DIRECTONLY](c3ref/c_vtab_constraint_support.html#sqlitevtabdirectonly))"。
- en: The xCreate method need not initialize the pModule, nRef, and zErrMsg fields
    of the [sqlite3_vtab](c3ref/vtab.html) object. The SQLite core will take care
    of that chore.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: xCreate 方法不需要初始化 [sqlite3_vtab](c3ref/vtab.html) 对象的 pModule、nRef 和 zErrMsg
    字段。SQLite 核心将负责处理此任务。
- en: The xCreate should return [SQLITE_OK](rescode.html#ok) if it is successful in
    creating the new virtual table, or [SQLITE_ERROR](rescode.html#error) if it is
    not successful. If not successful, the [sqlite3_vtab](c3ref/vtab.html) structure
    must not be allocated. An error message may optionally be returned in *pzErr if
    unsuccessful. Space to hold the error message string must be allocated using an
    SQLite memory allocation function like [sqlite3_malloc()](c3ref/free.html) or
    [sqlite3_mprintf()](c3ref/mprintf.html) as the SQLite core will attempt to free
    the space using [sqlite3_free()](c3ref/free.html) after the error has been reported
    up to the application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功创建新的虚拟表，xCreate 应返回 [SQLITE_OK](rescode.html#ok)，否则返回 [SQLITE_ERROR](rescode.html#error)。如果失败，必须不分配
    [sqlite3_vtab](c3ref/vtab.html) 结构。如果失败，可以选择在 *pzErr 中返回错误消息。用于存储错误消息字符串的空间必须使用
    SQLite 内存分配函数（如 [sqlite3_malloc()](c3ref/free.html) 或 [sqlite3_mprintf()](c3ref/mprintf.html)）分配，因为
    SQLite 核心将尝试在向应用程序报告错误后使用 [sqlite3_free()](c3ref/free.html) 释放该空间。
- en: If the xCreate method is omitted (left as a NULL pointer) then the virtual table
    is an [eponymous-only virtual table](vtab.html#epoonlyvtab). New instances of
    the virtual table cannot be created using [CREATE VIRTUAL TABLE](lang_createvtab.html)
    and the virtual table can only be used via its module name. Note that SQLite versions
    prior to 3.9.0 (2015-10-14) do not understand eponymous-only virtual tables and
    will segfault if an attempt is made to [CREATE VIRTUAL TABLE](lang_createvtab.html)
    on an eponymous-only virtual table because the xCreate method was not checked
    for null.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略 xCreate 方法（作为 NULL 指针），那么该虚拟表就是一个 [仅同名虚拟表](vtab.html#epoonlyvtab)。不能使用
    [CREATE VIRTUAL TABLE](lang_createvtab.html) 创建虚拟表的新实例，虚拟表只能通过其模块名称使用。请注意，SQLite
    3.9.0（2015-10-14）之前的版本不理解仅同名虚拟表，如果尝试在仅同名虚拟表上使用 [CREATE VIRTUAL TABLE](lang_createvtab.html)
    会导致 segfault，因为未检查 xCreate 方法是否为 null。
- en: If the xCreate method is the exact same pointer as the [xConnect](vtab.html#xconnect)
    method, that indicates that the virtual table does not need to initialize backing
    store. Such a virtual table can be used as an [eponymous virtual table](vtab.html#epovtab)
    or as a named virtual table using [CREATE VIRTUAL TABLE](lang_createvtab.html)
    or both.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果xCreate方法与[xConnect](vtab.html#xconnect)方法的确切指针相同，则表明虚拟表不需要初始化后备存储。这样的虚拟表可以用作[eponymous
    virtual table](vtab.html#epovtab)，或者使用[CREATE VIRTUAL TABLE](lang_createvtab.html)命名虚拟表，或者两者都可以。
- en: 2.1.1\. Hidden columns in virtual tables
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1\. 虚拟表中的隐藏列
- en: 'If a column datatype contains the special keyword "HIDDEN" (in any combination
    of upper and lower case letters) then that keyword it is omitted from the column
    datatype name and the column is marked as a hidden column internally. A hidden
    column differs from a normal column in three respects:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列数据类型包含特殊关键字"HIDDEN"（无论大小写组合如何），则该关键字将从列数据类型名称中省略，并且该列在内部标记为隐藏列。隐藏列与普通列有三个不同之处：
- en: Hidden columns are not listed in the dataset returned by "[PRAGMA table_info](pragma.html#pragma_table_info)",
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏列不在由"[PRAGMA table_info](pragma.html#pragma_table_info)"返回的数据集中列出，
- en: Hidden columns are not included in the expansion of a "*" expression in the
    result set of a [SELECT](lang_select.html), and
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏列不包括在[SELECT](lang_select.html)结果集中"*"表达式的展开中，
- en: Hidden columns are not included in the implicit column-list used by an [INSERT](lang_insert.html)
    statement that lacks an explicit column-list.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏列不包括在[INSERT](lang_insert.html)语句的隐式列列表中，该语句缺乏显式列列表。
- en: 'For example, if the following SQL is passed to [sqlite3_declare_vtab()](c3ref/declare_vtab.html):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果将以下SQL传递给[sqlite3_declare_vtab()](c3ref/declare_vtab.html)：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Then the virtual table would be created with two hidden columns, and with datatypes
    of "VARCHAR(12)" and "INTEGER".
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 那么虚拟表将创建两个隐藏列，并且数据类型分别为"VARCHAR(12)"和"INTEGER"。
- en: An example use of hidden columns can be seen in the [FTS3](fts3.html) virtual
    table implementation, where every FTS virtual table contains an [FTS hidden column](fts3.html#hiddencol)
    that is used to pass information from the virtual table into [FTS auxiliary functions](fts3.html#snippet)
    and to the [FTS MATCH](fts3.html#full_text_index_queries) operator.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏列的一个示例用法可以在[FTS3](fts3.html)虚拟表实现中看到，其中每个FTS虚拟表包含一个[FTS隐藏列](fts3.html#hiddencol)，用于将信息从虚拟表传递到[FTS辅助函数](fts3.html#snippet)和[FTS
    MATCH](fts3.html#full_text_index_queries)操作符。
- en: 2.1.2\. Table-valued functions
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.2\. 表值函数
- en: A [virtual table](vtab.html) that contains [hidden columns](vtab.html#hiddencol)
    can be used like a table-valued function in the FROM clause of a [SELECT](lang_select.html)
    statement. The arguments to the table-valued function become constraints on the
    HIDDEN columns of the virtual table.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包含[隐藏列](vtab.html#hiddencol)的[虚拟表](vtab.html)，可以像在[SELECT](lang_select.html)语句的FROM子句中使用表值函数一样使用。表值函数的参数成为虚拟表的隐藏列的约束条件。
- en: 'For example, the "generate_series" extension (located in the [ext/misc/series.c](https://www.sqlite.org/src/artifact?ci=trunk&filename=ext/misc/series.c)
    file in the [source tree](https://www.sqlite.org/src/tree?ci=trunk)) implements
    an [eponymous virtual table](vtab.html#epovtab) with the following schema:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，"generate_series"扩展（位于[ext/misc/series.c](https://www.sqlite.org/src/artifact?ci=trunk&filename=ext/misc/series.c)文件中的[source
    tree](https://www.sqlite.org/src/tree?ci=trunk)）实现了一个[eponymous virtual table](vtab.html#epovtab)，其架构如下：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The [sqlite3_module.xBestIndex](vtab.html#xbestindex) method in the implementation
    of this table checks for equality constraints against the HIDDEN columns, and
    uses those as input parameters to determine the range of integer "value" outputs
    to generate. Reasonable defaults are used for any unconstrained columns. For example,
    to list all integers between 5 and 50:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在此表的实现中，[sqlite3_module.xBestIndex](vtab.html#xbestindex)方法检查对隐藏列的等式约束，并将其作为输入参数，以确定生成的整数"value"输出的范围。对于任何未约束的列，使用合理的默认值。例如，要列出介于5和50之间的所有整数：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The previous query is equivalent to the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的查询等效于以下内容：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Arguments on the virtual table name are matched to [hidden columns](vtab.html#hiddencol)
    in order. The number of arguments can be less than the number of hidden columns,
    in which case the latter hidden columns are unconstrained. However, an error results
    if there are more arguments than there are hidden columns in the virtual table.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟表名称上的参数与 [hidden columns](vtab.html#hiddencol) 中的隐藏列按顺序匹配。参数数量可以少于虚拟表中隐藏列的数量，此时后面的隐藏列是无约束的。但如果参数比虚拟表中的隐藏列更多，则会导致错误。
- en: 2.1.3\. WITHOUT ROWID Virtual Tables
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.3\. WITHOUT ROWID 虚拟表
- en: Beginning with SQLite [version 3.14.0](releaselog/3_14.html) (2016-08-08), the
    CREATE TABLE statement that is passed into [sqlite3_declare_vtab()](c3ref/declare_vtab.html)
    may contain a [WITHOUT ROWID](withoutrowid.html) clause. This is useful for cases
    where the virtual table rows cannot easily be mapped into unique integers. A CREATE
    TABLE statement that includes WITHOUT ROWID must define one or more columns as
    the PRIMARY KEY. Every column of the PRIMARY KEY must individually be NOT NULL
    and all columns for each row must be collectively unique.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 从 SQLite [version 3.14.0](releaselog/3_14.html)（2016-08-08）开始，传递给 [sqlite3_declare_vtab()](c3ref/declare_vtab.html)
    的 CREATE TABLE 语句可以包含 [WITHOUT ROWID](withoutrowid.html) 子句。在虚拟表行不能轻松映射到唯一整数的情况下，这非常有用。包含
    WITHOUT ROWID 的 CREATE TABLE 语句必须将一个或多个列定义为主键。主键的每一列都必须单独为 NOT NULL，并且每行的所有列必须集体唯一。
- en: Note that SQLite does not enforce the PRIMARY KEY for a WITHOUT ROWID virtual
    table. Enforcement is the responsibility of the underlying virtual table implementation.
    But SQLite does assume that the PRIMARY KEY constraint is valid - that the identified
    columns really are UNIQUE and NOT NULL - and it uses that assumption to optimize
    queries against the virtual table.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，SQLite 不会强制执行 WITHOUT ROWID 虚拟表的主键。强制执行是底层虚拟表实现的责任。但 SQLite 确实假定主键约束有效 -
    即已识别的列确实是唯一的和非 NULL 的 - 并且它使用该假设来优化针对虚拟表的查询。
- en: The rowid column is not accessible on a WITHOUT ROWID virtual table (of course).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WITHOUT ROWID 虚拟表上不可访问 rowid 列（当然）。
- en: The [xUpdate](vtab.html#xupdate) method was originally designed around having
    a [ROWID](lang_createtable.html#rowid) as a single value. The [xUpdate](vtab.html#xupdate)
    method has been expanded to accommodate an arbitrary PRIMARY KEY in place of the
    ROWID, but the PRIMARY KEY must still be only one column. For this reason, SQLite
    will reject any WITHOUT ROWID virtual table that has more than one PRIMARY KEY
    column and a non-NULL xUpdate method.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[xUpdate](vtab.html#xupdate) 方法最初设计时围绕一个 [ROWID](lang_createtable.html#rowid)
    作为单个值。[xUpdate](vtab.html#xupdate) 方法已扩展以适应任意主键替代 ROWID，但主键仍然必须仅为一列。因此，SQLite
    将拒绝具有多于一个主键列和非 NULL xUpdate 方法的 WITHOUT ROWID 虚拟表。'
- en: 2.2\. The xConnect Method
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2\. xConnect 方法
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The xConnect method is very similar to [xCreate](vtab.html#xcreate). It has
    the same parameters and constructs a new [sqlite3_vtab](c3ref/vtab.html) structure
    just like xCreate. And it must also call [sqlite3_declare_vtab()](c3ref/declare_vtab.html)
    like xCreate. It should also make all of the same [sqlite3_vtab_config()](c3ref/vtab_config.html)
    calls as xCreate.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: xConnect 方法与 [xCreate](vtab.html#xcreate) 非常相似。它具有相同的参数，并像 xCreate 一样构造一个新的
    [sqlite3_vtab](c3ref/vtab.html) 结构。它还必须像 xCreate 一样调用 [sqlite3_declare_vtab()](c3ref/declare_vtab.html)。它还应该像
    xCreate 一样进行所有相同的 [sqlite3_vtab_config()](c3ref/vtab_config.html) 调用。
- en: The difference is that xConnect is called to establish a new connection to an
    existing virtual table whereas xCreate is called to create a new virtual table
    from scratch.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 区别在于 xConnect 被调用以建立对现有虚拟表的新连接，而 xCreate 被调用以从头创建一个新的虚拟表。
- en: The xCreate and xConnect methods are only different when the virtual table has
    some kind of backing store that must be initialized the first time the virtual
    table is created. The xCreate method creates and initializes the backing store.
    The xConnect method just connects to an existing backing store. When xCreate and
    xConnect are the same, the table is an [eponymous virtual table](vtab.html#epovtab).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当虚拟表具有必须在创建虚拟表时初始化的某种后备存储时，xCreate 和 xConnect 方法才会有所不同。xCreate 方法创建和初始化后备存储。xConnect
    方法只是连接到现有的后备存储。当 xCreate 和 xConnect 相同时，表是一个 [eponymous virtual table](vtab.html#epovtab)。
- en: As an example, consider a virtual table implementation that provides read-only
    access to existing comma-separated-value (CSV) files on disk. There is no backing
    store that needs to be created or initialized for such a virtual table (since
    the CSV files already exist on disk) so the xCreate and xConnect methods will
    be identical for that module.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个虚拟表实现，该实现提供对磁盘上现有的逗号分隔值（CSV）文件的只读访问。对于这样一个虚拟表，不需要创建或初始化后备存储（因为 CSV 文件已经存在于磁盘上），因此对于该模块，xCreate
    和 xConnect 方法将是相同的。
- en: Another example is a virtual table that implements a full-text index. The xCreate
    method must create and initialize data structures to hold the dictionary and posting
    lists for that index. The xConnect method, on the other hand, only has to locate
    and use an existing dictionary and posting lists that were created by a prior
    xCreate call.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是实现全文索引的虚拟表。xCreate 方法必须创建和初始化用于保存该索引的词典和 posting lists 的数据结构。另一方面，xConnect
    方法只需查找并使用之前由 xCreate 调用创建的现有词典和 posting lists。
- en: The xConnect method must return [SQLITE_OK](rescode.html#ok) if it is successful
    in creating the new virtual table, or [SQLITE_ERROR](rescode.html#error) if it
    is not successful. If not successful, the [sqlite3_vtab](c3ref/vtab.html) structure
    must not be allocated. An error message may optionally be returned in *pzErr if
    unsuccessful. Space to hold the error message string must be allocated using an
    SQLite memory allocation function like [sqlite3_malloc()](c3ref/free.html) or
    [sqlite3_mprintf()](c3ref/mprintf.html) as the SQLite core will attempt to free
    the space using [sqlite3_free()](c3ref/free.html) after the error has been reported
    up to the application.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 xConnect 方法成功创建新的虚拟表，则必须返回 [SQLITE_OK](rescode.html#ok)，如果不成功，则返回 [SQLITE_ERROR](rescode.html#error)。如果不成功，则不得分配
    [sqlite3_vtab](c3ref/vtab.html) 结构。如果不成功，可以选择在 *pzErr 中返回错误消息。必须使用 SQLite 内存分配函数（如
    [sqlite3_malloc()](c3ref/free.html) 或 [sqlite3_mprintf()](c3ref/mprintf.html)）分配用于保存错误消息字符串的空间，因为
    SQLite 核心将尝试使用 [sqlite3_free()](c3ref/free.html) 释放该空间，在将错误报告到应用程序后。
- en: The xConnect method is required for every virtual table implementation, though
    the [xCreate](vtab.html#xcreate) and xConnect pointers of the [sqlite3_module](c3ref/module.html)
    object may point to the same function if the virtual table does not need to initialize
    backing store.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: xConnect 方法对于每个虚拟表实现都是必需的，尽管 [xCreate](vtab.html#xcreate) 和 [sqlite3_module](c3ref/module.html)
    对象的 xConnect 指针可能指向同一个函数，如果虚拟表不需要初始化后备存储。
- en: 2.3\. The xBestIndex Method
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3\. xBestIndex 方法
- en: 'SQLite uses the xBestIndex method of a virtual table module to determine the
    best way to access the virtual table. The xBestIndex method has a prototype like
    this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 使用虚拟表模块的 xBestIndex 方法来确定访问虚拟表的最佳方式。xBestIndex 方法的原型如下：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The SQLite core communicates with the xBestIndex method by filling in certain
    fields of the [sqlite3_index_info](c3ref/index_info.html) structure and passing
    a pointer to that structure into xBestIndex as the second parameter. The xBestIndex
    method fills out other fields of this structure which forms the reply. The [sqlite3_index_info](c3ref/index_info.html)
    structure looks like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 核心通过填充 [sqlite3_index_info](c3ref/index_info.html) 结构的某些字段并将指向该结构的指针作为第二个参数传递给
    xBestIndex 方法，与 xBestIndex 方法进行通信。xBestIndex 方法填写此结构的其他字段，形成回复。
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note the warnings on the "estimatedRows", "idxFlags", and colUsed fields. These
    fields were added with SQLite versions 3.8.2, 3.9.0, and 3.10.0, respectively.
    Any extension that reads or writes these fields must first check that the version
    of the SQLite library in use is greater than or equal to appropriate version -
    perhaps comparing the value returned from [sqlite3_libversion_number()](c3ref/libversion.html)
    against constants 3008002, 3009000, and/or 3010000\. The result of attempting
    to access these fields in an sqlite3_index_info structure created by an older
    version of SQLite are undefined.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 "estimatedRows"、"idxFlags" 和 colUsed 字段上的警告。这些字段分别在 SQLite 版本 3.8.2、3.9.0
    和 3.10.0 中添加。任何读取或写入这些字段的扩展必须首先检查正在使用的 SQLite 库版本是否大于或等于适当的版本 — 可能将从 [sqlite3_libversion_number()](c3ref/libversion.html)
    返回的值与常量 3008002、3009000 和/或 3010000 进行比较。在由旧版本 SQLite 创建的 sqlite3_index_info 结构中尝试访问这些字段的结果是未定义的。
- en: 'In addition, there are some defined constants:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，还有一些定义的常量：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Use the [sqlite3_vtab_collation()](c3ref/vtab_collation.html) interface to
    find the name of the [collating sequence](datatype3.html#collation) that should
    be used when evaluating the i-th constraint:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[sqlite3_vtab_collation()](c3ref/vtab_collation.html)接口来查找在评估第i个约束时应该使用的排序序列的名称：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The SQLite core calls the xBestIndex method when it is compiling a query that
    involves a virtual table. In other words, SQLite calls this method when it is
    running [sqlite3_prepare()](c3ref/prepare.html) or the equivalent. By calling
    this method, the SQLite core is saying to the virtual table that it needs to access
    some subset of the rows in the virtual table and it wants to know the most efficient
    way to do that access. The xBestIndex method replies with information that the
    SQLite core can then use to conduct an efficient search of the virtual table.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译涉及虚拟表的SQL查询时，SQLite核心调用xBestIndex方法。换句话说，SQLite在运行[sqlite3_prepare()](c3ref/prepare.html)或等效方法时调用此方法。通过调用此方法，SQLite核心告诉虚拟表它需要访问虚拟表中的某些行的子集，并且想要知道最有效的访问方式。xBestIndex方法会回复一些信息，SQLite核心随后可以用来执行对虚拟表的高效搜索。
- en: While compiling a single SQL query, the SQLite core might call xBestIndex multiple
    times with different settings in [sqlite3_index_info](c3ref/index_info.html).
    The SQLite core will then select the combination that appears to give the best
    performance.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译单个SQL查询时，SQLite核心可能会以不同的设置多次调用xBestIndex方法，来处理[sqlite3_index_info](c3ref/index_info.html)中的组合。然后SQLite核心将选择看起来性能最佳的组合。
- en: Before calling this method, the SQLite core initializes an instance of the [sqlite3_index_info](c3ref/index_info.html)
    structure with information about the query that it is currently trying to process.
    This information derives mainly from the WHERE clause and ORDER BY or GROUP BY
    clauses of the query, but also from any ON or USING clauses if the query is a
    join. The information that the SQLite core provides to the xBestIndex method is
    held in the part of the structure that is marked as "Inputs". The "Outputs" section
    is initialized to zero.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用此方法之前，SQLite核心会初始化一个[sqlite3_index_info](c3ref/index_info.html)结构的实例，其中包含关于当前正在处理的查询的信息。这些信息主要来源于查询的WHERE子句以及ORDER
    BY或GROUP BY子句，如果查询是一个连接，则还来自任何ON或USING子句。SQLite核心提供给xBestIndex方法的信息保存在标记为“Inputs”的结构的部分中。“Outputs”部分被初始化为零。
- en: The information in the [sqlite3_index_info](c3ref/index_info.html) structure
    is ephemeral and may be overwritten or deallocated as soon as the xBestIndex method
    returns. If the xBestIndex method needs to remember any part of the [sqlite3_index_info](c3ref/index_info.html)
    structure, it should make a copy. Care must be take to store the copy in a place
    where it will be deallocated, such as in the idxStr field with needToFreeIdxStr
    set to 1.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[sqlite3_index_info](c3ref/index_info.html)结构中的信息是短暂的，并且可能在xBestIndex方法返回后被覆盖或释放。如果xBestIndex方法需要记住[sqlite3_index_info](c3ref/index_info.html)结构的任何部分，它应该创建一个副本。必须小心地将副本存储在会被释放的地方，例如将needToFreeIdxStr设置为1的idxStr字段中。'
- en: Note that xBestIndex will always be called before [xFilter](vtab.html#xfilter),
    since the idxNum and idxStr outputs from xBestIndex are required inputs to xFilter.
    However, there is no guarantee that xFilter will be called following a successful
    xBestIndex.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意xBestIndex总是会在[xFilter](vtab.html#xfilter)之前调用，因为xBestIndex的idxNum和idxStr输出是xFilter所需的输入。但是，并不保证xBestIndex成功后一定会调用xFilter。
- en: The xBestIndex method is required for every virtual table implementation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个虚拟表实现，xBestIndex方法都是必需的。
- en: 2.3.1\. Inputs
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1\. 输入
- en: The main thing that the SQLite core is trying to communicate to the virtual
    table is the constraints that are available to limit the number of rows that need
    to be searched. The aConstraint[] array contains one entry for each constraint.
    There will be exactly nConstraint entries in that array.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite核心试图传达给虚拟表的主要内容是可用于限制需要搜索的行数的约束。aConstraint[]数组包含每个约束的一个条目。在该数组中会有确切的nConstraint条目。
- en: Each constraint will usually correspond to a term in the WHERE clause or in
    a USING or ON clause that is of the form
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 每个约束通常对应于WHERE子句中的一个术语，或者形式为USING或ON子句中的术语
- en: column OP EXPR
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: column OP EXPR
- en: 'Where "column" is a column in the virtual table, OP is an operator like "="
    or "<", and EXPR is an arbitrary expression. So, for example, if the WHERE clause
    contained a term like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 其中"column"是虚拟表中的一列，OP是像"="或"<"这样的操作符，EXPR是任意表达式。例如，如果WHERE子句包含以下术语：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then one of the constraints would be on the "a" column with operator "=" and
    an expression of "5". Constraints need not have a literal representation of the
    WHERE clause. The query optimizer might make transformations to the WHERE clause
    in order to extract as many constraints as it can. So, for example, if the WHERE
    clause contained something like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，“a”列的一个约束条件是用运算符“=”和表达式“5”定义的。约束条件不需要字面上的WHERE子句表示。查询优化器可能会对WHERE子句进行转换，以提取尽可能多的约束条件。例如，如果WHERE子句包含类似以下内容：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The query optimizer might translate this into three separate constraints:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 查询优化器可能会将此转换为三个单独的约束条件：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: For each such constraint, the aConstraint[].iColumn field indicates which column
    appears on the left-hand side of the constraint. The first column of the virtual
    table is column 0\. The rowid of the virtual table is column -1\. The aConstraint[].op
    field indicates which operator is used. The SQLITE_INDEX_CONSTRAINT_* constants
    map integer constants into operator values. Columns occur in the order they were
    defined by the call to [sqlite3_declare_vtab()](c3ref/declare_vtab.html) in the
    [xCreate](vtab.html#xcreate) or [xConnect](vtab.html#xconnect) method. Hidden
    columns are counted when determining the column index.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个这样的约束条件，aConstraint[]中的iColumn字段指示约束条件左侧出现的列。虚拟表的第一列是列0。虚拟表的rowid是列-1。aConstraint[].op字段指示使用的操作符。SQLITE_INDEX_CONSTRAINT_*常量将整数常量映射到操作符值。列按照在[xCreate](vtab.html#xcreate)或[xConnect](vtab.html#xconnect)方法中对[sqlite3_declare_vtab()](c3ref/declare_vtab.html)的调用定义的顺序出现。在确定列索引时，隐藏列也要计算在内。
- en: 'If the [xFindFunction()](vtab.html#xfindfunction) method for the virtual table
    is defined, and if xFindFunction() sometimes returns [SQLITE_INDEX_CONSTRAINT_FUNCTION](c3ref/c_index_constraint_eq.html)
    or larger, then the constraints might also be of the form:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果虚拟表的[xFindFunction()](vtab.html#xfindfunction)方法已定义，并且如果xFindFunction()有时返回[SQLITE_INDEX_CONSTRAINT_FUNCTION](c3ref/c_index_constraint_eq.html)或更大的值，则约束条件也可能采用以下形式：
- en: FUNCTION( column, EXPR)
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: FUNCTION( column, EXPR)
- en: In this case the aConstraint[].op value is the same as the value returned by
    [xFindFunction()](vtab.html#xfindfunction) for FUNCTION.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，aConstraint[].op值与[xFindFunction()](vtab.html#xfindfunction)方法返回的FUNCTION相同。
- en: The aConstraint[] array contains information about all constraints that apply
    to the virtual table. But some of the constraints might not be usable because
    of the way tables are ordered in a join. The xBestIndex method must therefore
    only consider constraints that have an aConstraint[].usable flag which is true.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: aConstraint[]数组包含有关适用于虚拟表的所有约束条件的信息。但是由于表在连接中的排序方式，某些约束条件可能无法使用。因此，xBestIndex方法必须仅考虑aConstraint[].usable标志为true的约束条件。
- en: In addition to WHERE clause constraints, the SQLite core also tells the xBestIndex
    method about the ORDER BY clause. (In an aggregate query, the SQLite core might
    put in GROUP BY clause information in place of the ORDER BY clause information,
    but this fact should not make any difference to the xBestIndex method.) If all
    terms of the ORDER BY clause are columns in the virtual table, then nOrderBy will
    be the number of terms in the ORDER BY clause and the aOrderBy[] array will identify
    the column for each term in the order by clause and whether or not that column
    is ASC or DESC.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 除了WHERE子句约束条件外，SQLite核心还告诉xBestIndex方法关于ORDER BY子句的信息。（在聚合查询中，SQLite核心可能会放入GROUP
    BY子句信息以替换ORDER BY子句信息，但这个事实不应影响xBestIndex方法。）如果ORDER BY子句的所有术语都是虚拟表中的列，则nOrderBy将是ORDER
    BY子句中术语的数量，并且aOrderBy[]数组将标识ORDER BY子句中每个术语的列以及该列是否为ASC或DESC。
- en: In SQLite [version 3.10.0](releaselog/3_10_0.html) (2016-01-06) and later, the
    colUsed field is available to indicate which fields of the virtual table are actually
    used by the statement being prepared. If the lowest bit of colUsed is set, that
    means that the first column is used. The second lowest bit corresponds to the
    second column. And so forth. If the most significant bit of colUsed is set, that
    means that one or more columns other than the first 63 columns are used. If column
    usage information is needed by the [xFilter](vtab.html#xfilter) method, then the
    required bits must be encoded into either the output idxNum field or idxStr content.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQLite [3.10.0版](releaselog/3_10_0.html)（2016-01-06）及以后，colUsed字段可用于指示被正在准备的语句实际使用的虚拟表的字段。如果colUsed的最低位被设置，这意味着使用了第一列。次低位对应第二列。以此类推。如果colUsed的最高位被设置，这意味着使用了除了前63列之外的一列或多列。如果[xFilter](vtab.html#xfilter)方法需要使用列使用信息，则必须将必需的位编码为输出idxNum字段或idxStr内容中的哪些位。
- en: 2.3.1.1\. LIKE, GLOB, REGEXP, and MATCH functions
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.1.1\. LIKE、GLOB、REGEXP和MATCH函数
- en: 'For the LIKE, GLOB, REGEXP, and MATCH operators, the aConstraint[].iColumn
    value is the virtual table column that is the left operand of the operator. However,
    if these operators are expressed as function calls instead of operators, then
    the aConstraint[].iColumn value references the virtual table column that is the
    second argument to that function:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于LIKE、GLOB、REGEXP和MATCH运算符，aConstraint[].iColumn值是运算符的左操作数的虚拟表列。然而，如果这些运算符被表达为函数调用而不是运算符，那么aConstraint[].iColumn值引用的是该函数的第二个参数的虚拟表列：
- en: LIKE(*EXPR*, *column*)
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: LIKE(*EXPR*, *column*)
- en: GLOB(*EXPR*, *column*)
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: GLOB(*EXPR*, *column*)
- en: REGEXP(*EXPR*, *column*)
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: REGEXP(*EXPR*, *column*)
- en: MATCH(*EXPR*, *column*)
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: MATCH(*EXPR*, *column*)
- en: 'Hence, as far as the xBestIndex() method is concerned, the following two forms
    are equivalent:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于xBestIndex()方法来说，以下两种形式是等效的：
- en: '*column* LIKE *EXPR*'
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*column* 像 *EXPR*'
- en: LIKE(*EXPR*,*column*)
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: LIKE(*EXPR*,*column*)
- en: This special behavior of looking at the second argument of a function only occurs
    for the LIKE, GLOB, REGEXP, and MATCH functions. For all other functions, the
    aConstraint[].iColumn value references the first argument of the function.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '查看函数的第二个参数的这种特殊行为仅适用于LIKE、GLOB、REGEXP和MATCH函数。对于所有其他函数，aConstraint[].iColumn值引用的是函数的第一个参数。 '
- en: This special feature of LIKE, GLOB, REGEXP, and MATCH does not apply to the
    [xFindFunction()](vtab.html#xfindfunction) method, however. The [xFindFunction()](vtab.html#xfindfunction)
    method always keys off of the left operand of an LIKE, GLOB, REGEXP, or MATCH
    operator but off of the first argument to function-call equivalents of those operators.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这种对LIKE、GLOB、REGEXP和MATCH的特殊特性并不适用于[xFindFunction()](vtab.html#xfindfunction)方法。然而，[xFindFunction()](vtab.html#xfindfunction)方法始终基于LIKE、GLOB、REGEXP或MATCH运算符的左操作数，而不是基于这些运算符的函数调用等效的第一个参数。
- en: 2.3.1.2\. LIMIT and OFFSET
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.1.2\. LIMIT和OFFSET
- en: When aConstraint[].op is one of SQLITE_INDEX_CONSTRAINT_LIMIT or SQLITE_INDEX_CONSTRAINT_OFFSET,
    that indicates that there is a LIMIT or OFFSET clause on the SQL query statement
    that is using the virtual table. The LIMIT and OFFSET operators have no left operand,
    and so when aConstraint[].op is one of SQLITE_INDEX_CONSTRAINT_LIMIT or SQLITE_INDEX_CONSTRAINT_OFFSET
    then the aConstraint[].iColumn value is meaningless and should not be used.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当aConstraint[].op是SQLITE_INDEX_CONSTRAINT_LIMIT或SQLITE_INDEX_CONSTRAINT_OFFSET之一时，表示SQL查询语句使用了虚拟表的LIMIT或OFFSET子句。LIMIT和OFFSET运算符没有左操作数，因此当aConstraint[].op是SQLITE_INDEX_CONSTRAINT_LIMIT或SQLITE_INDEX_CONSTRAINT_OFFSET之一时，aConstraint[].iColumn的值是无意义的，不应该使用。
- en: 2.3.1.3\. Right-hand side values of constraints
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.1.3\. 约束的右操作数值
- en: The [sqlite3_vtab_rhs_value()](c3ref/vtab_rhs_value.html) interface can be used
    to try to access the right-hand operand of a constraint. However, the value of
    a right-hand operator might not be known at the time that the xBestIndex method
    is run, so the sqlite3_vtab_rhs_value() call might not be successful. Usually
    the right operand of a constraint is only available to xBestIndex if it is coded
    as a literal value in the input SQL. If the right operand is coded as an expression
    or a [host parameter](c3ref/bind_blob.html), it probably will not be accessible
    to xBestIndex. Some operators, such as [SQLITE_INDEX_CONSTRAINT_ISNULL](c3ref/c_index_constraint_eq.html)
    and [SQLITE_INDEX_CONSTRAINT_ISNOTNULL](c3ref/c_index_constraint_eq.html) have
    no right-hand operand. The sqlite3_vtab_rhs_value() interface always returns [SQLITE_NOTFOUND](rescode.html#notfound)
    for such operators.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[sqlite3_vtab_rhs_value()](c3ref/vtab_rhs_value.html)接口可用于尝试访问约束的右操作数。但是，在执行xBestIndex方法时，右操作数的值可能尚不可知，因此sqlite3_vtab_rhs_value()调用可能不会成功。通常，如果右操作数在输入SQL中以文字值编码，则xBestIndex仅能访问约束的右操作数。如果右操作数编码为表达式或[主机参数](c3ref/bind_blob.html)，它可能对xBestIndex不可用。一些操作符，如[SQLITE_INDEX_CONSTRAINT_ISNULL](c3ref/c_index_constraint_eq.html)和[SQLITE_INDEX_CONSTRAINT_ISNOTNULL](c3ref/c_index_constraint_eq.html)，没有右操作数。对于这类操作符，sqlite3_vtab_rhs_value()接口总是返回[SQLITE_NOTFOUND](rescode.html#notfound)。'
- en: 2.3.2\. Outputs
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2\. 输出
- en: Given all of the information above, the job of the xBestIndex method it to figure
    out the best way to search the virtual table.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 综合以上所有信息，xBestIndex方法的工作是找出搜索虚拟表的最佳方式。
- en: The xBestIndex method conveys an indexing strategy to the [xFilter](vtab.html#xfilter)
    method through the idxNum and idxStr fields. The idxNum value and idxStr string
    content are arbitrary as far as the SQLite core is concerned and can have any
    meaning as long as xBestIndex and xFilter agree on what that meaning is. The SQLite
    core just copies the information from xBestIndex through to the [xFilter](vtab.html#xfilter)
    method, assuming only that the char sequence referenced via idxStr is NUL terminated.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: xBestIndex方法通过idxNum和idxStr字段向[xFilter](vtab.html#xfilter)方法传达索引策略。就SQLite核心而言，idxNum值和idxStr字符串内容可以是任意的，并且只要xBestIndex和xFilter就它们的含义达成一致即可。SQLite核心只是将信息从xBestIndex复制到[xFilter](vtab.html#xfilter)方法，假设idxStr引用的字符序列以NUL结尾。
- en: The idxStr value may be a string obtained from an SQLite memory allocation function
    such as [sqlite3_mprintf()](c3ref/mprintf.html). If this is the case, then the
    needToFreeIdxStr flag must be set to true so that the SQLite core will know to
    call [sqlite3_free()](c3ref/free.html) on that string when it has finished with
    it, and thus avoid a memory leak. The idxStr value may also be a static constant
    string, in which case the needToFreeIdxStr boolean should remain false.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: idxStr值可以是从SQLite内存分配函数（如[sqlite3_mprintf()](c3ref/mprintf.html)）获得的字符串。如果是这种情况，则必须将needToFreeIdxStr标志设置为true，以便SQLite核心在完成使用后调用[sqlite3_free()](c3ref/free.html)释放该字符串，从而避免内存泄漏。idxStr值也可能是静态常量字符串，此时needToFreeIdxStr布尔值应保持false。
- en: The estimatedCost field should be set to the estimated number of disk access
    operations required to execute this query against the virtual table. The SQLite
    core will often call xBestIndex multiple times with different constraints, obtain
    multiple cost estimates, then choose the query plan that gives the lowest estimate.
    The SQLite core initializes estimatedCost to a very large value prior to invoking
    xBestIndex, so if xBestIndex determines that the current combination of parameters
    is undesirable, it can leave the estimatedCost field unchanged to discourage its
    use.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: estimatedCost字段应设置为执行该查询对虚拟表所需的估计磁盘访问操作数。SQLite核心通常会多次调用xBestIndex，使用不同的约束获取多个成本估计值，然后选择提供最低估计的查询计划。SQLite核心在调用xBestIndex之前将estimatedCost初始化为一个非常大的值，因此如果xBestIndex确定当前参数组合不理想，它可以保持estimatedCost字段不变以阻止其使用。
- en: If the current version of SQLite is 3.8.2 or greater, the estimatedRows field
    may be set to an estimate of the number of rows returned by the proposed query
    plan. If this value is not explicitly set, the default estimate of 25 rows is
    used.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前版本的SQLite是3.8.2或更高，则estimatedRows字段可以设置为拟议查询计划返回的行数估计值。如果没有显式设置此值，则使用默认的25行估计值。
- en: If the current version of SQLite is 3.9.0 or greater, the idxFlags field may
    be set to SQLITE_INDEX_SCAN_UNIQUE to indicate that the virtual table will return
    only zero or one rows given the input constraints. Additional bits of the idxFlags
    field might be understood in later versions of SQLite.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前的 SQLite 版本是 3.9.0 或更高，则可以将 idxFlags 字段设置为 SQLITE_INDEX_SCAN_UNIQUE，以指示虚拟表在给定输入约束条件时仅返回零行或一行。在
    SQLite 的后续版本中可能会理解 idxFlags 字段的其他位。
- en: The aConstraintUsage[] array contains one element for each of the nConstraint
    constraints in the inputs section of the [sqlite3_index_info](c3ref/index_info.html)
    structure. The aConstraintUsage[] array is used by xBestIndex to tell the core
    how it is using the constraints.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: aConstraintUsage[] 数组包含输入部分的 nConstraint 约束的每个元素。aConstraintUsage[] 数组由 xBestIndex
    使用，告诉核心它如何使用这些约束。
- en: The xBestIndex method may set aConstraintUsage[].argvIndex entries to values
    greater than zero. Exactly one entry should be set to 1, another to 2, another
    to 3, and so forth up to as many or as few as the xBestIndex method wants. The
    EXPR of the corresponding constraints will then be passed in as the argv[] parameters
    to xFilter.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: xBestIndex 方法可以将 aConstraintUsage[].argvIndex 条目设置为大于零的值。应该将精确地一个条目设置为 1，另一个设置为
    2，另一个设置为 3，以此类推，直到 xBestIndex 方法想要的条目数。相应约束的 EXPR 将作为 argv[] 参数传递给 xFilter。
- en: For example, if the aConstraint[3].argvIndex is set to 1, then when xFilter
    is called, the argv[0] passed to xFilter will have the EXPR value of the aConstraint[3]
    constraint.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果 aConstraint[3].argvIndex 设置为 1，则在调用 xFilter 时，传递给 xFilter 的 argv[0] 将具有
    aConstraint[3] 约束的 EXPR 值。
- en: 2.3.2.1\. Omit constraint checking in bytecode
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.2.1\. 在字节码中省略约束检查
- en: 'By default, the SQLite generates [bytecode](opcode.html) that will double checks
    all constraints on each row of the virtual table to verify that they are satisfied.
    If the virtual table can guarantee that a constraint will always be satisfied,
    it can try to suppress that double-check by setting aConstraintUsage[].omit. However,
    with some exceptions, this is only a hint and there is no guarantee that the redundant
    check of the constraint will be suppressed. Key points:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，SQLite 生成的字节码将在虚拟表的每一行上双重检查所有约束，以验证它们是否满足。如果虚拟表能够保证约束始终满足，它可以尝试通过设置 aConstraintUsage[].omit
    来抑制该冗余检查。然而，除了一些例外情况外，这只是一个提示，不能保证冗余约束检查将被抑制。关键点：
- en: The omit flag is only honored if the argvIndex value for the constraint is greater
    than 0 and less than or equal to 16\. Constraint checking is never suppressed
    for constraints that do not pass their right operand into the xFilter method.
    The current implementation is only able to suppress redundant constraint checking
    for the first 16 values passed to xFilter, though that limitation might be increased
    in future releases.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有在约束的 argvIndex 值大于 0 且小于或等于 16 时，才会遵循 omit 标志。对于不将其右操作数传递到 xFilter 方法的约束，永远不会抑制约束检查。当前实现只能抑制传递给
    xFilter 的前 16 个值的冗余约束检查，尽管该限制可能会在未来的版本中增加。
- en: The omit flag is always honored for [SQLITE_INDEX_CONSTRAINT_OFFSET](c3ref/c_index_constraint_eq.html)
    constraints as long as argvIndex is greater than 0\. Setting the omit flag on
    an SQLITE_INDEX_CONSTRAINT_OFFSET constraint indicates to SQLite that the virtual
    table will itself suppress the first N rows of output, where N is the right operand
    of the OFFSET operator. If the virtual table implementation sets omit on an SQLITE_INDEX_CONSTRAINT_OFFSET
    constraint but then fails to suppress the first N rows of output, an incorrect
    answer will result from the overall query.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只要 argvIndex 大于 0，对于 SQLITE_INDEX_CONSTRAINT_OFFSET 约束，始终会遵循 omit 标志。在 SQLITE_INDEX_CONSTRAINT_OFFSET
    约束上设置 omit 标志表示虚拟表本身将抑制输出的前 N 行，其中 N 是 OFFSET 运算符的右操作数。如果虚拟表实现在 SQLITE_INDEX_CONSTRAINT_OFFSET
    约束上设置了 omit，但未能抑制输出的前 N 行，则整体查询将得到错误的答案。
- en: 2.3.2.2\. ORDER BY and orderByConsumed
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.2.2\. ORDER BY 和 orderByConsumed
- en: If the virtual table will output rows in the order specified by the ORDER BY
    clause, then the orderByConsumed flag may be set to true. If the output is not
    automatically in the correct order then orderByConsumed must be left in its default
    false setting. This will indicate to the SQLite core that it will need to do a
    separate sorting pass over the data after it comes out of the virtual table. Setting
    orderByConsumed is an optimization. A query will always get the correct answer
    if orderByConsumed is left at its default value (0). Unnecessary sort operations
    might be avoided resulting in a faster query if orderByConsumed is set, but setting
    orderByConsumed incorrectly can result in an incorrect answer. It is suggested
    that new virtual table implementations leave the orderByConsumed value unset initially,
    and then after everything else is known to be working correctly, go back and attempt
    to optimize by setting orderByConsumed where appropriate.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果虚拟表将按照 ORDER BY 子句指定的顺序输出行，则 orderByConsumed 标志可以设置为 true。如果输出不自动按正确顺序，则 orderByConsumed
    必须保持其默认 false 设置。这将告知 SQLite 核心在虚拟表输出后需要对数据进行单独的排序传递。设置 orderByConsumed 是一种优化。如果
    orderByConsumed 保持其默认值 (0)，则查询将始终获得正确答案。如果设置了 orderByConsumed，可能可以避免不必要的排序操作，从而加快查询速度，但如果错误地设置
    orderByConsumed 可能导致错误答案。建议新的虚拟表实现在初始状态下不设置 orderByConsumed 值，然后在确保其他一切正常工作后，返回并尝试通过适当设置
    orderByConsumed 来进行优化。
- en: Sometimes the orderByConsumed flag can be safely set even if the outputs from
    the virtual table are not strictly in the order specified by nOrderBy and aOrderBy.
    If the [sqlite3_vtab_distinct()](c3ref/vtab_distinct.html) interface returns 1
    or 2, that indicates that the ordering can be relaxed. See the documentation on
    [sqlite3_vtab_distinct()](c3ref/vtab_distinct.html) for further information.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，即使虚拟表的输出不严格按照 nOrderBy 和 aOrderBy 指定的顺序，orderByConsumed 标志也可以安全地设置。如果 [sqlite3_vtab_distinct()](c3ref/vtab_distinct.html)
    接口返回 1 或 2，则表示可以放宽排序要求。有关详细信息，请参阅 [sqlite3_vtab_distinct()](c3ref/vtab_distinct.html)
    的文档。
- en: 2.3.3\. Return Value
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.3\. 返回值
- en: 'The xBestIndex method should return SQLITE_OK on success. If any kind of fatal
    error occurs, an appropriate error code (ex: [SQLITE_NOMEM](rescode.html#nomem))
    should be returned instead.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: xBestIndex 方法在成功时应返回 SQLITE_OK。如果发生任何致命错误，则应返回适当的错误代码（例如 [SQLITE_NOMEM](rescode.html#nomem)）。
- en: If xBestIndex returns [SQLITE_CONSTRAINT](rescode.html#constraint), that does
    not indicate an error. Rather, SQLITE_CONSTRAINT indicates that the particular
    combination of input parameters specified is insufficient for the virtual table
    to do its job. This is logically the same as setting the estimatedCost to infinity.
    If every call to xBestIndex for a particular query plan returns SQLITE_CONSTRAINT,
    that means there is no way for the virtual table to be safely used, and the [sqlite3_prepare()](c3ref/prepare.html)
    call will fail with a "no query solution" error.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 xBestIndex 返回 [SQLITE_CONSTRAINT](rescode.html#constraint)，这并不表示错误。相反，SQLITE_CONSTRAINT
    表示指定的输入参数组合对于虚拟表执行其工作是不足够的。逻辑上，这与将 estimatedCost 设置为无穷大是相同的。如果对于特定查询计划的每次 xBestIndex
    调用都返回 SQLITE_CONSTRAINT，这意味着虚拟表无法安全使用，而且 [sqlite3_prepare()](c3ref/prepare.html)
    调用将因“无查询解决方案”错误而失败。
- en: 2.3.4\. Enforcing Required Parameters On Table-Valued Functions
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.4\. 强制表值函数上的必需参数
- en: 'The SQLITE_CONSTRAINT return from xBestIndex is useful for [table-valued functions](vtab.html#tabfunc2)
    that have required parameters. If the aConstraint[].usable field is false for
    one of the required parameter, then the xBestIndex method should return SQLITE_CONSTRAINT.
    If a required field does not appear in the aConstraint[] array at all, that means
    that the corresponding parameter is omitted from the input SQL. In that case,
    xBestIndex should set an error message in pVTab->zErrMsg and return SQLITE_ERROR.
    To summarize:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 xBestIndex 的 SQLITE_CONSTRAINT 返回对于具有必需参数的 [表值函数](vtab.html#tabfunc2) 是有用的。如果对于所需参数之一，aConstraint[].usable
    字段为 false，则 xBestIndex 方法应返回 SQLITE_CONSTRAINT。如果一个必需字段在 aConstraint[] 数组中根本不出现，则表示相应参数在输入
    SQL 中被省略。在这种情况下，xBestIndex 应在 pVTab->zErrMsg 中设置错误消息，并返回 SQLITE_ERROR。总结如下：
- en: The aConstraint[].usable value for a required parameter is false → return SQLITE_CONSTRAINT.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于所需参数，aConstraint[] 中的 usable 值为 false → 返回 SQLITE_CONSTRAINT。
- en: A required parameter does not appears anywhere in the aConstraint[] array →
    Set an error message in pVTab->zErrMsg and return SQLITE_ERROR
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于在 aConstraint[] 数组中根本未出现的必需参数 → 在 pVTab->zErrMsg 中设置错误消息，并返回 SQLITE_ERROR。
- en: 'The following example will better illustrate the use of SQLITE_CONSTRAINT as
    a return value from xBestIndex:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例将更好地说明了在xBestIndex中使用SQLITE_CONSTRAINT作为返回值的情况：
- en: '[PRE24]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Assuming that the first hidden column of "tablevaluedfunc" is "param1", the
    query above is semantically equivalent to this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 假设"tablevaluedfunc"的第一个隐藏列是"param1"，上述查询在语义上等同于此查询：
- en: '[PRE25]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The query planner must decide between many possible implementations of this
    query, but two plans in particular are of note:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 查询规划器必须在此查询的许多可能实现之间做出决策，但特别值得注意的是两个计划：
- en: Scan all rows of realtab and for each row, find rows in tablevaluedfunc where
    param1 is equal to realtab.x
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扫描realtab的所有行，并且对于每一行，在tablevaluedfunc中查找param1等于realtab.x的行。
- en: Scan all rows of tablevalued func and for each row find rows in realtab where
    x is equal to tablevaluedfunc.param1.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扫描tablevaluedfunc的所有行，并且对于每一行，在realtab中查找x等于tablevaluedfunc.param1的行。
- en: The xBestIndex method will be invoked once for each of the potential plans above.
    For plan 1, the aConstraint[].usable flag for the SQLITE_CONSTRAINT_EQ constraint
    on the param1 column will be true because the right-hand side value for the "param1
    = ?" constraint will be known, since it is determined by the outer realtab loop.
    But for plan 2, the aConstraint[].usable flag for "param1 = ?" will be false because
    the right-hand side value is determined by an inner loop and is thus an unknown
    quantity. Because param1 is a required input to the table-valued functions, the
    xBestIndex method should return SQLITE_CONSTRAINT when presented with plan 2,
    indicating that a required input is missing. This forces the query planner to
    select plan 1.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述每个潜在的计划，xBestIndex方法将被调用一次。对于计划1，因为"param1 = ?"约束条件的右侧值是已知的，所以aConstraint[].usable标志为SQLITE_CONSTRAINT_EQ约束在param1列上为true，因为它由外部的realtab循环确定。但是对于计划2，"param1
    = ?"的aConstraint[].usable标志为false，因为右侧值由内部循环确定，因此是一个未知量。由于param1是表值函数的必需输入，所以当xBestIndex方法接收到计划2时，应返回SQLITE_CONSTRAINT，表示缺少必需的输入。这迫使查询规划器选择计划1。
- en: 2.4\. The xDisconnect Method
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4\. xDisconnect 方法
- en: '[PRE26]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This method releases a connection to a virtual table. Only the [sqlite3_vtab](c3ref/vtab.html)
    object is destroyed. The virtual table is not destroyed and any backing store
    associated with the virtual table persists. This method undoes the work of [xConnect](vtab.html#xconnect).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法释放对虚拟表的连接。只销毁[sqlite3_vtab](c3ref/vtab.html)对象。虚拟表不会被销毁，并且与虚拟表关联的任何后备存储都将保持。此方法撤消了[xConnect](vtab.html#xconnect)的工作。
- en: This method is a destructor for a connection to the virtual table. Contrast
    this method with [xDestroy](vtab.html#sqlite3_module.xDestroy). The xDestroy is
    a destructor for the entire virtual table.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法是连接到虚拟表的析构函数。将此方法与[xDestroy](vtab.html#sqlite3_module.xDestroy)进行对比。xDestroy是整个虚拟表的析构函数。
- en: The xDisconnect method is required for every virtual table implementation, though
    it is acceptable for the xDisconnect and [xDestroy](vtab.html#sqlite3_module.xDestroy)
    methods to be the same function if that makes sense for the particular virtual
    table.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个虚拟表实现，都需要xDisconnect方法，尽管xDisconnect和[xDestroy](vtab.html#sqlite3_module.xDestroy)方法可以是同一个函数，如果对于特定的虚拟表而言是有意义的。
- en: 2.5\. The xDestroy Method
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5\. xDestroy 方法
- en: '[PRE27]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This method releases a connection to a virtual table, just like the [xDisconnect](vtab.html#xdisconnect)
    method, and it also destroys the underlying table implementation. This method
    undoes the work of [xCreate](vtab.html#xcreate).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法释放对虚拟表的连接，就像[xDisconnect](vtab.html#xdisconnect)方法一样，并且还销毁底层表实现。此方法撤消了[xCreate](vtab.html#xcreate)的工作。
- en: The [xDisconnect](vtab.html#xdisconnect) method is called whenever a database
    connection that uses a virtual table is closed. The xDestroy method is only called
    when a [DROP TABLE](lang_droptable.html) statement is executed against the virtual
    table.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 每当使用虚拟表的数据库连接关闭时，将调用[xDisconnect](vtab.html#xdisconnect)方法。仅在执行[DROP TABLE](lang_droptable.html)语句针对虚拟表时，才会调用xDestroy方法。
- en: The xDestroy method is required for every virtual table implementation, though
    it is acceptable for the [xDisconnect](vtab.html#xdisconnect) and xDestroy methods
    to be the same function if that makes sense for the particular virtual table.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个虚拟表实现，都需要xDestroy方法，尽管[xDisconnect](vtab.html#xdisconnect)和xDestroy方法可以是同一个函数，如果对于特定的虚拟表而言是有意义的。
- en: 2.6\. The xOpen Method
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.6\. xOpen 方法
- en: '[PRE28]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The xOpen method creates a new cursor used for accessing (read and/or writing)
    a virtual table. A successful invocation of this method will allocate the memory
    for the [sqlite3_vtab_cursor](c3ref/vtab_cursor.html) (or a subclass), initialize
    the new object, and make *ppCursor point to the new object. The successful call
    then returns [SQLITE_OK](rescode.html#ok).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: xOpen 方法创建用于访问（读取和/或写入）虚拟表的新游标。成功调用此方法将为 [sqlite3_vtab_cursor](c3ref/vtab_cursor.html)（或其子类）分配内存，初始化新对象，并使
    *ppCursor 指向新对象。成功调用将返回 [SQLITE_OK](rescode.html#ok)。
- en: For every successful call to this method, the SQLite core will later invoke
    the [xClose](vtab.html#xclose) method to destroy the allocated cursor.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 每次成功调用此方法后，SQLite 核心稍后将调用 [xClose](vtab.html#xclose) 方法来销毁分配的游标。
- en: The xOpen method need not initialize the pVtab field of the [sqlite3_vtab_cursor](c3ref/vtab_cursor.html)
    structure. The SQLite core will take care of that chore automatically.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: xOpen 方法不需要初始化 [sqlite3_vtab_cursor](c3ref/vtab_cursor.html) 结构的 pVtab 字段。SQLite
    核心将自动处理这一步骤。
- en: A virtual table implementation must be able to support an arbitrary number of
    simultaneously open cursors.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟表实现必须能够支持任意数量的同时打开游标。
- en: When initially opened, the cursor is in an undefined state. The SQLite core
    will invoke the [xFilter](vtab.html#xfilter) method on the cursor prior to any
    attempt to position or read from the cursor.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 初始打开时，游标处于未定义状态。SQLite 核心将在尝试定位或读取游标之前调用游标上的 [xFilter](vtab.html#xfilter) 方法。
- en: The xOpen method is required for every virtual table implementation.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 每个虚拟表实现都需要 xOpen 方法。
- en: 2.7\. The xClose Method
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.7\. xClose 方法
- en: '[PRE29]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The xClose method closes a cursor previously opened by [xOpen](vtab.html#xopen).
    The SQLite core will always call xClose once for each cursor opened using xOpen.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: xClose 方法关闭由 [xOpen](vtab.html#xopen) 打开的游标。SQLite 核心将始终为每个使用 xOpen 打开的游标调用一次
    xClose。
- en: This method must release all resources allocated by the corresponding xOpen
    call. The routine will not be called again even if it returns an error. The SQLite
    core will not use the [sqlite3_vtab_cursor](c3ref/vtab_cursor.html) again after
    it has been closed.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法必须释放由相应 xOpen 调用分配的所有资源。即使返回错误，该例程也不会再次被调用。SQLite 核心在关闭后不会再使用 [sqlite3_vtab_cursor](c3ref/vtab_cursor.html)。
- en: The xClose method is required for every virtual table implementation.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 每个虚拟表实现都需要 xClose 方法。
- en: 2.8\. The xEof Method
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.8\. xEof 方法
- en: '[PRE30]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The xEof method must return false (zero) if the specified cursor currently points
    to a valid row of data, or true (non-zero) otherwise. This method is called by
    the SQL engine immediately after each [xFilter](vtab.html#xfilter) and [xNext](vtab.html#xnext)
    invocation.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定的游标当前指向有效数据行，则 xEof 方法必须返回 false（零），否则返回 true（非零）。SQL 引擎在每次 [xFilter](vtab.html#xfilter)
    和 [xNext](vtab.html#xnext) 调用之后立即调用此方法。
- en: The xEof method is required for every virtual table implementation.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 每个虚拟表实现都需要 xEof 方法。
- en: 2.9\. The xFilter Method
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.9\. xFilter 方法
- en: '[PRE31]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This method begins a search of a virtual table. The first argument is a cursor
    opened by [xOpen](vtab.html#xopen). The next two arguments define a particular
    search index previously chosen by [xBestIndex](vtab.html#xbestindex). The specific
    meanings of idxNum and idxStr are unimportant as long as xFilter and xBestIndex
    agree on what that meaning is.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法开始对虚拟表进行搜索。第一个参数是由 [xOpen](vtab.html#xopen) 打开的游标。接下来的两个参数定义了先前由 [xBestIndex](vtab.html#xbestindex)
    选择的特定搜索索引。idxNum 和 idxStr 的具体含义并不重要，只要 xFilter 和 xBestIndex 对其含义达成一致即可。
- en: The xBestIndex function may have requested the values of certain expressions
    using the aConstraintUsage[].argvIndex values of the [sqlite3_index_info](c3ref/index_info.html)
    structure. Those values are passed to xFilter using the argc and argv parameters.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 xBestIndex 可能已经使用了 [sqlite3_index_info](c3ref/index_info.html) 结构中的 aConstraintUsage[].argvIndex
    值来请求某些表达式的值。这些值将通过 argc 和 argv 参数传递给 xFilter 方法。
- en: If the virtual table contains one or more rows that match the search criteria,
    then the cursor must be left point at the first row. Subsequent calls to [xEof](vtab.html#xeof)
    must return false (zero). If there are no rows match, then the cursor must be
    left in a state that will cause the [xEof](vtab.html#xeof) to return true (non-zero).
    The SQLite engine will use the [xColumn](vtab.html#xcolumn) and [xRowid](vtab.html#xrowid)
    methods to access that row content. The [xNext](vtab.html#xnext) method will be
    used to advance to the next row.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果虚拟表包含与搜索条件匹配的一个或多个行，则游标必须停在第一行。后续对[xEof](vtab.html#xeof)的调用必须返回false（零）。如果没有匹配的行，则游标必须处于导致[xEof](vtab.html#xeof)返回true（非零）的状态。SQLite引擎将使用[xColumn](vtab.html#xcolumn)和[xRowid](vtab.html#xrowid)方法访问该行内容。将使用[xNext](vtab.html#xnext)方法前进到下一行。
- en: This method must return [SQLITE_OK](rescode.html#ok) if successful, or an sqlite
    [error code](rescode.html) if an error occurs.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，此方法必须返回[SQLITE_OK](rescode.html#ok)，否则返回一个sqlite [错误码](rescode.html)。
- en: The xFilter method is required for every virtual table implementation.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 每个虚拟表实现都需要xFilter方法。
- en: 2.10\. The xNext Method
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.10\. The xNext Method
- en: '[PRE32]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The xNext method advances a [virtual table cursor](c3ref/vtab_cursor.html) to
    the next row of a result set initiated by [xFilter](vtab.html#xfilter). If the
    cursor is already pointing at the last row when this routine is called, then the
    cursor no longer points to valid data and a subsequent call to the [xEof](vtab.html#xeof)
    method must return true (non-zero). If the cursor is successfully advanced to
    another row of content, then subsequent calls to [xEof](vtab.html#xeof) must return
    false (zero).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: xNext方法将虚拟表游标前进到由[xFilter](vtab.html#xfilter)启动的结果集的下一行。如果此例程调用时游标已指向最后一行，则游标不再指向有效数据，后续对[xEof](vtab.html#xeof)方法的调用必须返回true（非零）。如果成功将游标前进到另一行内容，则后续对[xEof](vtab.html#xeof)的调用必须返回false（零）。
- en: This method must return [SQLITE_OK](rescode.html#ok) if successful, or an sqlite
    [error code](rescode.html) if an error occurs.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，此方法必须返回[SQLITE_OK](rescode.html#ok)，否则返回一个sqlite [错误码](rescode.html)。
- en: The xNext method is required for every virtual table implementation.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 每个虚拟表实现都需要xNext方法。
- en: 2.11\. The xColumn Method
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.11\. The xColumn Method
- en: '[PRE33]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The SQLite core invokes this method in order to find the value for the N-th
    column of the current row. N is zero-based so the first column is numbered 0\.
    The xColumn method may return its result back to SQLite using one of the following
    interface:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite核心调用此方法以查找当前行的第N列的值。N从零开始，因此第一列编号为0。xColumn方法可以使用以下接口将其结果返回给SQLite：
- en: '[sqlite3_result_blob()](c3ref/result_blob.html)'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[sqlite3_result_blob()](c3ref/result_blob.html)'
- en: '[sqlite3_result_double()](c3ref/result_blob.html)'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[sqlite3_result_double()](c3ref/result_blob.html)'
- en: '[sqlite3_result_int()](c3ref/result_blob.html)'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[sqlite3_result_int()](c3ref/result_blob.html)'
- en: '[sqlite3_result_int64()](c3ref/result_blob.html)'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[sqlite3_result_int64()](c3ref/result_blob.html)'
- en: '[sqlite3_result_null()](c3ref/result_blob.html)'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[sqlite3_result_null()](c3ref/result_blob.html)'
- en: '[sqlite3_result_text()](c3ref/result_blob.html)'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[sqlite3_result_text()](c3ref/result_blob.html)'
- en: '[sqlite3_result_text16()](c3ref/result_blob.html)'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[sqlite3_result_text16()](c3ref/result_blob.html)'
- en: '[sqlite3_result_text16le()](c3ref/result_blob.html)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[sqlite3_result_text16le()](c3ref/result_blob.html)'
- en: '[sqlite3_result_text16be()](c3ref/result_blob.html)'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[sqlite3_result_text16be()](c3ref/result_blob.html)'
- en: '[sqlite3_result_zeroblob()](c3ref/result_blob.html)'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[sqlite3_result_zeroblob()](c3ref/result_blob.html)'
- en: If the xColumn method implementation calls none of the functions above, then
    the value of the column defaults to an SQL NULL.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果xColumn方法的实现不调用上述任何函数，则列的值默认为SQL NULL。
- en: To raise an error, the xColumn method should use one of the result_text() methods
    to set the error message text, then return an appropriate [error code](rescode.html).
    The xColumn method must return [SQLITE_OK](rescode.html#ok) on success.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要引发错误，xColumn方法应使用result_text()方法之一设置错误消息文本，然后返回适当的[错误码](rescode.html)。xColumn方法在成功时必须返回[SQLITE_OK](rescode.html#ok)。
- en: The xColumn method is required for every virtual table implementation.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 每个虚拟表实现都需要xColumn方法。
- en: 2.12\. The xRowid Method
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.12\. The xRowid Method
- en: '[PRE34]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: A successful invocation of this method will cause *pRowid to be filled with
    the [rowid](lang_createtable.html#rowid) of row that the [virtual table cursor](c3ref/vtab_cursor.html)
    pCur is currently pointing at. This method returns [SQLITE_OK](rescode.html#ok)
    on success. It returns an appropriate [error code](rescode.html) on failure.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的成功调用将导致 *pRowid 填充为虚拟表光标 pCur 当前指向的行的 [rowid](lang_createtable.html#rowid)。此方法在成功时返回
    [SQLITE_OK](rescode.html#ok)。在失败时返回适当的 [错误代码](rescode.html)。
- en: The xRowid method is required for every virtual table implementation.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 每个虚拟表实现都需要 xRowid 方法。
- en: 2.13\. The xUpdate Method
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.13\. xUpdate 方法
- en: '[PRE35]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: All changes to a virtual table are made using the xUpdate method. This one method
    can be used to insert, delete, or update.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 所有对虚拟表的更改都使用 xUpdate 方法进行。这一方法可用于插入、删除或更新。
- en: The argc parameter specifies the number of entries in the argv array. The value
    of argc will be 1 for a pure delete operation or N+2 for an insert or replace
    or update where N is the number of columns in the table. In the previous sentence,
    N includes any hidden columns.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: argc 参数指定 argv 数组中的条目数。对于纯删除操作，argc 的值为 1；对于插入、替换或更新操作，argc 的值为 N+2，其中 N 是表中的列数。在前述句子中，N
    包括任何隐藏列。
- en: Every argv entry will have a non-NULL value in C but may contain the SQL value
    NULL. In other words, it is always true that `argv[i]!=0` for **i** between 0
    and `argc-1`. However, it might be the case that `sqlite3_value_type(argv[i])==SQLITE_NULL`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 argv 条目在 C 中都有非 NULL 值，但可能包含 SQL 值 NULL。换句话说，对于 **i** 在 0 到 `argc-1` 之间，始终成立
    `argv[i]!=0`。但可能存在 `sqlite3_value_type(argv[i])==SQLITE_NULL` 的情况。
- en: The argv[0] parameter is the [rowid](lang_createtable.html#rowid) of a row in
    the virtual table to be deleted. If argv[0] is an SQL NULL, then no deletion occurs.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: argv[0] 参数是要删除的虚拟表中的一行的 [rowid](lang_createtable.html#rowid)。如果 argv[0] 是 SQL
    NULL，则不进行删除。
- en: The argv[1] parameter is the rowid of a new row to be inserted into the virtual
    table. If argv[1] is an SQL NULL, then the implementation must choose a rowid
    for the newly inserted row. Subsequent argv[] entries contain values of the columns
    of the virtual table, in the order that the columns were declared. The number
    of columns will match the table declaration that the [xConnect](vtab.html#xconnect)
    or [xCreate](vtab.html#xcreate) method made using the [sqlite3_declare_vtab()](c3ref/declare_vtab.html)
    call. All hidden columns are included.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: argv[1] 参数是要插入到虚拟表中的新行的 rowid。如果 argv[1] 是 SQL NULL，则实现必须为新插入的行选择一个 rowid。随后的
    argv[] 条目按照声明列的顺序包含虚拟表的列的值。列数将与 [xConnect](vtab.html#xconnect) 或 [xCreate](vtab.html#xcreate)
    方法使用的 [sqlite3_declare_vtab()](c3ref/declare_vtab.html) 调用声明的表声明匹配。所有隐藏列都包括在内。
- en: When doing an insert without a rowid (argc>1, argv[1] is an SQL NULL), on a
    virtual table that uses ROWID (but not on a [WITHOUT ROWID virtual table](vtab.html#worid)),
    the implementation must set *pRowid to the rowid of the newly inserted row; this
    will become the value returned by the [sqlite3_last_insert_rowid()](c3ref/last_insert_rowid.html)
    function. Setting this value in all the other cases is a harmless no-op; the SQLite
    engine ignores the *pRowid return value if argc==1 or argv[1] is not an SQL NULL.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行没有行id的插入操作（argc>1 且 argv[1] 是 SQL NULL）时，在使用 ROWID 的虚拟表上（但不适用于 [WITHOUT ROWID
    虚拟表](vtab.html#worid)），实现必须将 *pRowid 设置为新插入行的行id；这将成为 [sqlite3_last_insert_rowid()](c3ref/last_insert_rowid.html)
    函数返回的值。在其他情况下设置此值是无害的空操作；如果 argc==1 或 argv[1] 不是 SQL NULL，则 SQLite 引擎会忽略 *pRowid
    返回值。
- en: Each call to xUpdate will fall into one of cases shown below. Not that references
    to **argv[i]** mean the SQL value held within the argv[i] object, not the argv[i]
    object itself.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用 xUpdate 都会落入下面显示的一个情况中。注意，对 **argv[i]** 的引用指的是 argv[i] 对象中保存的 SQL 值，而不是
    argv[i] 对象本身。
- en: '**argc = 1'
  id: totrans-267
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**argc = 1'
- en: argv[0] ≠ NULL**
  id: totrans-268
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: argv[0] ≠ NULL**
- en: ''
  id: totrans-269
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'DELETE: The single row with rowid or PRIMARY KEY equal to argv[0] is deleted.
    No insert occurs.'
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: DELETE：删除具有与 argv[0] 相等的 rowid 或主键的单行。不进行插入操作。
- en: ''
  id: totrans-271
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**argc > 1'
  id: totrans-272
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**argc > 1'
- en: argv[0] = NULL**
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: argv[0] = NULL**
- en: ''
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'INSERT: A new row is inserted with column values taken from argv[2] and following.
    In a rowid virtual table, if argv[1] is an SQL NULL, then a new unique rowid is
    generated automatically. The argv[1] will be NULL for a [WITHOUT ROWID virtual
    table](vtab.html#worid), in which case the implementation should take the PRIMARY
    KEY value from the appropriate column in argv[2] and following.'
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 插入：将从argv[2]和后续参数中获取的列值插入新行。在rowid虚拟表中，如果argv[1]是SQL NULL，则会自动生成一个新的唯一rowid。对于[WITHOUT
    ROWID虚拟表](vtab.html#worid)，argv[1]将为空，此时实现应该从argv[2]和后续参数中的适当列获取主键值。
- en: ''
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**argc > 1'
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**argc > 1'
- en: argv[0] ≠ NULL
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: argv[0] ≠ NULL
- en: argv[0] = argv[1]**
  id: totrans-279
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: argv[0] = argv[1]**
- en: ''
  id: totrans-280
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'UPDATE: The row with rowid or PRIMARY KEY argv[0] is updated with new values
    in argv[2] and following parameters.'
  id: totrans-281
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 更新：带有rowid或主键argv[0]的行使用argv[2]和后续参数中的新值进行更新。
- en: ''
  id: totrans-282
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**argc > 1'
  id: totrans-283
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**argc > 1'
- en: argv[0] ≠ NULL
  id: totrans-284
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: argv[0] ≠ NULL
- en: argv[0] ≠ argv[1]**
  id: totrans-285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: argv[0] ≠ argv[1]**
- en: ''
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'UPDATE with rowid or PRIMARY KEY change: The row with rowid or PRIMARY KEY
    argv[0] is updated with the rowid or PRIMARY KEY in argv[1] and new values in
    argv[2] and following parameters. This will occur when an SQL statement updates
    a rowid, as in the statement:'
  id: totrans-287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 更新行id或主键更新：带有rowid或主键argv[0]的行将使用argv[1]中的rowid或主键以及argv[2]和后续参数中的新值进行更新。当SQL语句更新rowid，如下SQL语句：
- en: ''
  id: totrans-288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[UPDATE](lang_update.html) table SET rowid=rowid+1 WHERE ...;'
  id: totrans-289
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[更新](lang_update.html) 表设置 rowid=rowid+1 WHERE ...;'
- en: The xUpdate method must return [SQLITE_OK](rescode.html#ok) if and only if it
    is successful. If a failure occurs, the xUpdate must return an appropriate [error
    code](rescode.html). On a failure, the pVTab->zErrMsg element may optionally be
    replaced with error message text stored in memory allocated from SQLite using
    functions such as [sqlite3_mprintf()](c3ref/mprintf.html) or [sqlite3_malloc()](c3ref/free.html).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 xUpdate 方法成功，则必须返回 [SQLITE_OK](rescode.html#ok)。如果发生失败，xUpdate 必须返回适当的 [错误代码](rescode.html)。失败时，pVTab->zErrMsg
    元素可以选择性地替换为从 SQLite 使用 [sqlite3_mprintf()](c3ref/mprintf.html) 或 [sqlite3_malloc()](c3ref/free.html)
    分配的内存中存储的错误消息文本。
- en: If the xUpdate method violates some constraint of the virtual table (including,
    but not limited to, attempting to store a value of the wrong datatype, attempting
    to store a value that is too large or too small, or attempting to change a read-only
    value) then the xUpdate must fail with an appropriate [error code](rescode.html).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果xUpdate方法违反了虚拟表的某些约束（包括但不限于尝试存储错误数据类型的值，尝试存储太大或太小的值，或尝试更改只读值），那么xUpdate必须以适当的[错误代码](rescode.html)失败。
- en: If the xUpdate method is performing an UPDATE, then [sqlite3_value_nochange(X)](c3ref/value_blob.html)
    can be used to discover which columns of the virtual table were actually modified
    by the UPDATE statement. The [sqlite3_value_nochange(X)](c3ref/value_blob.html)
    interface returns true for columns that do not change. On every UPDATE, SQLite
    will first invoke [xColumn](vtab.html#xcolumn) separately for each unchanging
    column in the table to obtain the value for that column. The [xColumn](vtab.html#xcolumn)
    method can check to see if the column is unchanged at the SQL level by invoking
    [sqlite3_vtab_nochange()](c3ref/vtab_nochange.html). If [xColumn](vtab.html#xcolumn)
    sees that the column is not being modified, it should return without setting a
    result using one of the [sqlite3_result_xxxxx()](c3ref/result_blob.html) interfaces.
    Only in that case [sqlite3_value_nochange()](c3ref/value_blob.html) will be true
    within the xUpdate method. If [xColumn](vtab.html#xcolumn) does invoke one or
    more [sqlite3_result_xxxxx()](c3ref/result_blob.html) interfaces, then SQLite
    understands that as a change in the value of the column and the [sqlite3_value_nochange()](c3ref/value_blob.html)
    call for that column within xUpdate will return false.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 xUpdate 方法执行 UPDATE，那么可以使用 [sqlite3_value_nochange(X)](c3ref/value_blob.html)
    来发现虚拟表的哪些列实际上被 UPDATE 语句修改。[sqlite3_value_nochange(X)](c3ref/value_blob.html)
    接口返回对于没有改变的列为真。在每次 UPDATE 时，SQLite 首先会分别为表中每个未改变的列调用 [xColumn](vtab.html#xcolumn)
    方法以获取该列的值。[xColumn](vtab.html#xcolumn) 方法可以通过调用 [sqlite3_vtab_nochange()](c3ref/vtab_nochange.html)
    来检查该列在 SQL 级别上是否未改变。如果 [xColumn](vtab.html#xcolumn) 看到列没有被修改，它应该在不使用 [sqlite3_result_xxxxx()](c3ref/result_blob.html)
    接口设置结果的情况下返回。只有在这种情况下，xUpdate 方法内的 [sqlite3_value_nochange()](c3ref/value_blob.html)
    才会为真。如果 [xColumn](vtab.html#xcolumn) 调用一个或多个 [sqlite3_result_xxxxx()](c3ref/result_blob.html)
    接口，则 SQLite 会将其视为列值的更改，xUpdate 内的 [sqlite3_value_nochange()](c3ref/value_blob.html)
    对该列的调用将返回假。
- en: There might be one or more [sqlite3_vtab_cursor](c3ref/vtab_cursor.html) objects
    open and in use on the virtual table instance and perhaps even on the row of the
    virtual table when the xUpdate method is invoked. The implementation of xUpdate
    must be prepared for attempts to delete or modify rows of the table out from other
    existing cursors. If the virtual table cannot accommodate such changes, the xUpdate
    method must return an [error code](rescode.html).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当 xUpdate 方法被调用时，虚拟表实例上可能有一个或多个正在使用的[sqlite3_vtab_cursor](c3ref/vtab_cursor.html)对象，甚至可能是虚拟表行上的行。xUpdate
    的实现必须准备好处理试图从其他现有游标删除或修改表行的尝试。如果虚拟表无法容纳此类更改，则xUpdate 方法必须返回一个[错误代码](rescode.html)。
- en: The xUpdate method is optional. If the xUpdate pointer in the [sqlite3_module](c3ref/module.html)
    for a virtual table is a NULL pointer, then the virtual table is read-only.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: xUpdate 方法是可选的。如果虚拟表的[sqlite3_module](c3ref/module.html)中的xUpdate指针是空指针，则该虚拟表是只读的。
- en: 2.14\. The xFindFunction Method
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.14\. xFindFunction 方法
- en: '[PRE36]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This method is called during [sqlite3_prepare()](c3ref/prepare.html) to give
    the virtual table implementation an opportunity to overload functions. This method
    may be set to NULL in which case no overloading occurs.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法在[sqlite3_prepare()](c3ref/prepare.html)期间调用，以便虚拟表实现有机会重载函数。如果此方法被设置为NULL，则不进行重载操作。
- en: 'When a function uses a column from a virtual table as its first argument, this
    method is called to see if the virtual table would like to overload the function.
    The first three parameters are inputs: the virtual table, the number of arguments
    to the function, and the name of the function. If no overloading is desired, this
    method returns 0\. To overload the function, this method writes the new function
    implementation into *pxFunc and writes user data into *ppArg and returns either
    1 or a number between [SQLITE_INDEX_CONSTRAINT_FUNCTION](c3ref/c_index_constraint_eq.html)
    and 255.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数使用虚拟表的列作为其第一个参数时，将调用此方法以查看虚拟表是否希望重载该函数。前三个参数是输入：虚拟表、函数的参数数量以及函数的名称。如果不希望进行重载，则此方法返回0。要重载函数，此方法将新的函数实现写入*pxFunc，并将用户数据写入*ppArg，并返回1或介于[SQLITE_INDEX_CONSTRAINT_FUNCTION](c3ref/c_index_constraint_eq.html)和255之间的数字。
- en: Historically, the return value from xFindFunction() was either zero or one.
    Zero means that the function is not overloaded and one means that it is overload.
    The ability to return values of [SQLITE_INDEX_CONSTRAINT_FUNCTION](c3ref/c_index_constraint_eq.html)
    or greater was added in version 3.25.0 (2018-09-15). If xFindFunction returns
    [SQLITE_INDEX_CONSTRAINT_FUNCTION](c3ref/c_index_constraint_eq.html) or greater,
    than means that the function takes two arguments and the function can be used
    as a boolean in the WHERE clause of a query and that the virtual table is able
    to exploit that function to speed up the query result. When xFindFunction returns
    [SQLITE_INDEX_CONSTRAINT_FUNCTION](c3ref/c_index_constraint_eq.html) or larger,
    the value returned becomes the [sqlite3_index_info](c3ref/index_info.html).aConstraint.op
    value for one of the constraints passed into [xBestIndex()](vtab.html#xbestindex).
    The first argument to the function is the column identified by aConstraint[].iColumn
    field of the constraint and the second argument to the function is the value that
    will be passed into [xFilter()](vtab.html#xfilter) (if the aConstraintUsage[].argvIndex
    value is set) or the value returned from [sqlite3_vtab_rhs_value()](c3ref/vtab_rhs_value.html).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，xFindFunction() 的返回值通常是零或一。零表示函数未重载，而一表示函数已重载。在 3.25.0 版本（2018-09-15）中，新增了返回值可以是[SQLITE_INDEX_CONSTRAINT_FUNCTION](c3ref/c_index_constraint_eq.html)或更大的能力。如果
    xFindFunction 返回[SQLITE_INDEX_CONSTRAINT_FUNCTION](c3ref/c_index_constraint_eq.html)或更大的值，则表示该函数接受两个参数，并且可以在查询的WHERE子句中作为布尔值使用，虚拟表能够利用该函数来加速查询结果。当
    xFindFunction 返回[SQLITE_INDEX_CONSTRAINT_FUNCTION](c3ref/c_index_constraint_eq.html)或更大时，返回的值将成为传递给[xBestIndex()](vtab.html#xbestindex)的一个约束的[sqlite3_index_info](c3ref/index_info.html).aConstraint.op
    值。函数的第一个参数是约束的aConstraint[].iColumn字段标识的列，第二个参数是将传递给[xFilter()](vtab.html#xfilter)（如果aConstraintUsage[].argvIndex
    值已设置）或从[sqlite3_vtab_rhs_value()](c3ref/vtab_rhs_value.html)返回的值。
- en: 'The [Geopoly module](geopoly.html) is an example of a virtual table that makes
    use of [SQLITE_INDEX_CONSTRAINT_FUNCTION](c3ref/c_index_constraint_eq.html) to
    improve performance. The xFindFunction() method for Geopoly returns SQLITE_INDEX_CONSTRAINT_FUNCTION
    for the [geopoly_overlap()](geopoly.html#goverlap) SQL function and it returns
    SQLITE_INDEX_CONSTRAINT_FUNCTION+1 for the [geopoly_within()](geopoly.html#gwithin)
    SQL function. This permits search optimizations for queries such as:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '[Geopoly 模块](geopoly.html) 是一个使用 [SQLITE_INDEX_CONSTRAINT_FUNCTION](c3ref/c_index_constraint_eq.html)
    来提高性能的虚拟表的示例。Geopoly 的 xFindFunction() 方法返回 SQLITE_INDEX_CONSTRAINT_FUNCTION，用于
    [geopoly_overlap()](geopoly.html#goverlap) SQL 函数，并为 [geopoly_within()](geopoly.html#gwithin)
    SQL 函数返回 SQLITE_INDEX_CONSTRAINT_FUNCTION+1。这允许针对如下查询进行搜索优化：'
- en: '[PRE37]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that infix functions ([LIKE](lang_expr.html#like), [GLOB](lang_expr.html#glob),
    [REGEXP](lang_expr.html#regexp), and [MATCH](lang_expr.html#match)) reverse the
    order of their arguments. So "like(A,B)" would normally work the same as "B like
    A". However, xFindFunction() always looks a the left-most argument, not the first
    logical argument. Hence, for the form "B like A", SQLite looks at the left operand
    "B" and if that operand is a virtual table column it invokes the xFindFunction()
    method on that virtual table. But if the form "like(A,B)" is used instead, then
    SQLite checks the A term to see if it is column of a virtual table and if so it
    invokes the xFindFunction() method for the virtual table of column A.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 注意中缀函数（[LIKE](lang_expr.html#like)、[GLOB](lang_expr.html#glob)、[REGEXP](lang_expr.html#regexp)
    和 [MATCH](lang_expr.html#match)）颠倒了参数的顺序。因此，“like(A,B)”通常与“B like A”相同。但是，xFindFunction()
    总是查看最左边的参数，而不是第一个逻辑参数。因此，对于形式“B like A”，SQLite 查看左操作数“B”，如果该操作数是虚拟表列，则在该虚拟表上调用
    xFindFunction() 方法。但如果使用的是形式“like(A,B)”，那么SQLite将检查 A 项，看看它是否是虚拟表的列，并在是的情况下为列
    A 的虚拟表调用 xFindFunction() 方法。
- en: The function pointer returned by this routine must be valid for the lifetime
    of the [sqlite3_vtab](c3ref/vtab.html) object given in the first parameter.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 该例程返回的函数指针必须对给定的 [sqlite3_vtab](c3ref/vtab.html) 对象的生命周期有效。
- en: 2.15\. The xBegin Method
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.15\. **xBegin** 方法
- en: '[PRE38]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This method begins a transaction on a virtual table. This is method is optional.
    The xBegin pointer of [sqlite3_module](c3ref/module.html) may be NULL.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法在虚拟表上开始一个事务。此方法是可选的。[sqlite3_module](c3ref/module.html) 的 xBegin 指针可能为 NULL。
- en: This method is always followed by one call to either the [xCommit](vtab.html#xcommit)
    or [xRollback](vtab.html#xrollback) method. Virtual table transactions do not
    nest, so the xBegin method will not be invoked more than once on a single virtual
    table without an intervening call to either [xCommit](vtab.html#xcommit) or [xRollback](vtab.html#xrollback).
    Multiple calls to other methods can and likely will occur in between the xBegin
    and the corresponding [xCommit](vtab.html#xcommit) or [xRollback](vtab.html#xrollback).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法始终在调用 [xCommit](vtab.html#xcommit) 或 [xRollback](vtab.html#xrollback) 方法之一后紧随其后。虚拟表事务不嵌套，因此在单个虚拟表上不会多次调用
    xBegin 方法，除非在 [xCommit](vtab.html#xcommit) 或 [xRollback](vtab.html#xrollback)
    之间进行了调用。可能会在 xBegin 和相应的 [xCommit](vtab.html#xcommit) 或 [xRollback](vtab.html#xrollback)
    之间发生多次对其他方法的调用。
- en: 2.16\. The xSync Method
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.16\. **xSync** 方法
- en: '[PRE39]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This method signals the start of a two-phase commit on a virtual table. This
    is method is optional. The xSync pointer of [sqlite3_module](c3ref/module.html)
    may be NULL.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法标志着在虚拟表上进行两阶段提交的开始。此方法是可选的。[sqlite3_module](c3ref/module.html) 的 xSync 指针可能为
    NULL。
- en: This method is only invoked after call to the [xBegin](vtab.html#xBegin) method
    and prior to an [xCommit](vtab.html#xcommit) or [xRollback](vtab.html#xrollback).
    In order to implement two-phase commit, the xSync method on all virtual tables
    is invoked prior to invoking the [xCommit](vtab.html#xcommit) method on any virtual
    table. If any of the xSync methods fail, the entire transaction is rolled back.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法仅在调用 [xBegin](vtab.html#xBegin) 方法后，并在 [xCommit](vtab.html#xcommit) 或 [xRollback](vtab.html#xrollback)
    之前调用。为了实现两阶段提交，将在调用任何虚拟表的 [xCommit](vtab.html#xcommit) 方法之前调用所有虚拟表的 xSync 方法。如果任何
    xSync 方法失败，则整个事务将被回滚。
- en: 2.17\. The xCommit Method
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.17\. **xCommit** 方法
- en: '[PRE40]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This method causes a virtual table transaction to commit. This is method is
    optional. The xCommit pointer of [sqlite3_module](c3ref/module.html) may be NULL.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法导致虚拟表事务提交。此方法是可选的。[sqlite3_module](c3ref/module.html) 的 xCommit 指针可能为 NULL。
- en: A call to this method always follows a prior call to [xBegin](vtab.html#xBegin)
    and [xSync](vtab.html#xsync).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 对该方法的调用始终在之前调用 [xBegin](vtab.html#xBegin) 和 [xSync](vtab.html#xsync) 方法之后。
- en: 2.18\. The xRollback Method
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.18\. **xRollback** 方法
- en: '[PRE41]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This method causes a virtual table transaction to rollback. This is method is
    optional. The xRollback pointer of [sqlite3_module](c3ref/module.html) may be
    NULL.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法导致虚拟表事务回滚。这种方法是可选的。[sqlite3_module](c3ref/module.html)的xRollback指针可能为NULL。
- en: A call to this method always follows a prior call to [xBegin](vtab.html#xBegin).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 对这种方法的调用总是在先前调用[xBegin](vtab.html#xBegin)之后进行。
- en: 2.19\. The xRename Method
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.19\. xRename 方法
- en: '[PRE42]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This method provides notification that the virtual table implementation that
    the virtual table will be given a new name. If this method returns [SQLITE_OK](rescode.html#ok)
    then SQLite renames the table. If this method returns an [error code](rescode.html)
    then the renaming is prevented.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法提供了通知虚拟表实现虚拟表将获得新名称的功能。如果此方法返回[SQLITE_OK](rescode.html#ok)，则SQLite将重命名表。如果此方法返回错误代码，则将阻止重命名。
- en: The xRename method is optional. If omitted, then the virtual table may not be
    renamed using the ALTER TABLE RENAME command.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: xRename 方法是可选的。如果省略，则无法使用ALTER TABLE RENAME命令重命名虚拟表。
- en: The [PRAGMA legacy_alter_table](pragma.html#pragma_legacy_alter_table) setting
    is enabled prior to invoking this method, and the value for legacy_alter_table
    is restored after this method finishes. This is necessary for the correct operation
    of virtual tables that make use of [shadow tables](vtab.html#xshadowname) where
    the shadow tables must be renamed to match the new virtual table name. If the
    legacy_alter_format is off, then the xConnect method will be invoked for the virtual
    table every time the xRename method tries to change the name of the shadow table.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用此方法之前启用了[PRAGMA legacy_alter_table](pragma.html#pragma_legacy_alter_table)设置，并在此方法完成后恢复了legacy_alter_table的值。这对于那些使用[影子表](vtab.html#xshadowname)的虚拟表的正确操作是必要的，其中影子表必须被重命名以匹配新的虚拟表名称。如果legacy_alter_format关闭，则每次xRename方法尝试更改影子表名称时都会调用xConnect方法来为虚拟表建立连接。
- en: 2.20\. The xSavepoint, xRelease, and xRollbackTo Methods
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.20\. xSavepoint, xRelease 和 xRollbackTo 方法
- en: '[PRE43]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: These methods provide the virtual table implementation an opportunity to implement
    nested transactions. They are always optional and will only be called in SQLite
    [version 3.7.7](releaselog/3_7_7.html) (2011-06-23) and later.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法为虚拟表实现提供了实现嵌套事务的机会。它们始终是可选的，并且只会在SQLite [版本3.7.7](releaselog/3_7_7.html)（2011-06-23）及更高版本中调用。
- en: When xSavepoint(X,N) is invoked, that is a signal to the virtual table X that
    it should save its current state as savepoint N. A subsequent call to xRollbackTo(X,R)
    means that the state of the virtual table should return to what it was when xSavepoint(X,R)
    was last called. The call to xRollbackTo(X,R) will invalidate all savepoints with
    N>R; none of the invalided savepoints will be rolled back or released without
    first being reinitialized by a call to xSavepoint(). A call to xRelease(X,M) invalidates
    all savepoints where N>=M.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用xSavepoint(X,N)时，这是一个信号，告诉虚拟表X应将其当前状态保存为保存点N。随后对xRollbackTo(X,R)的调用意味着虚拟表的状态应返回到上次调用xSavepoint(X,R)时的状态。对xRollbackTo(X,R)的调用将使所有N>R的保存点无效；没有无效的保存点会在首先通过调用xSavepoint()重新初始化之前回滚或释放。对xRelease(X,M)的调用使所有N>=M的保存点无效。
- en: None of the xSavepoint(), xRelease(), or xRollbackTo() methods will ever be
    called except in between calls to xBegin() and either xCommit() or xRollback().
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: xSavepoint()，xRelease()，或xRollbackTo()方法不会在调用xBegin()和xCommit()或xRollback()之间以外的任何时候调用。
- en: 2.21\. The xShadowName Method
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.21\. xShadowName 方法
- en: 'Some virtual table implementations (ex: [FTS3](fts3.html), [FTS5](fts5.html),
    and [RTREE](rtree.html)) make use of real (non-virtual) database tables to store
    content. For example, when content is inserted into the FTS3 virtual table, the
    data is ultimately stored in real tables named "%_content", "%_segdir", "%_segments",
    "%_stat", and "%_docsize" where "%" is the name of the original virtual table.
    This auxiliary real tables that store content for a virtual table are called "shadow
    tables". See ([1](fts3.html#*shadowtab)), ([2](fts5.html#fts5shadowtables)), and
    ([3](rtree.html#xshadow)) for additional information.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 一些虚拟表实现（例如：[FTS3](fts3.html)，[FTS5](fts5.html)，和[RTREE](rtree.html)）利用真实（非虚拟）数据库表来存储内容。例如，当内容插入到FTS3虚拟表时，数据最终存储在名为"%_content"，"%_segdir"，"%_segments"，"%_stat"和"%_docsize"的真实表中，其中"%"是原始虚拟表的名称。存储虚拟表内容的这些辅助真实表被称为"影子表"。参见（[1](fts3.html#*shadowtab)），（[2](fts5.html#fts5shadowtables)），和（[3](rtree.html#xshadow)）以获取更多信息。
- en: The xShadowName method exists to allow SQLite to determine whether a certain
    real table is in fact a shadow table for a virtual table.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: xShadowName方法存在的目的是允许SQLite确定某个真实表是否确实是虚拟表的阴影表。
- en: 'SQLite understands a real table to be a shadow table if all of the following
    are true:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以下所有条件都满足，SQLite将理解真实表为阴影表：
- en: The name of the table contains one or more "_" characters.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表的名称中包含一个或多个"_"字符。
- en: The part of the name prior to the last "_" exactly matches the name of a virtual
    table that was created using [CREATE VIRTUAL TABLE](lang_createvtab.html). (Shadow
    tables are not recognized for [eponymous virtual tables](vtab.html#epovtab) and
    [table-valued functions](vtab.html#tabfunc2).)
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称中最后一个"_"字符之前的部分与使用[CREATE VIRTUAL TABLE](lang_createvtab.html)创建的虚拟表的名称完全匹配。（对于[eponymous
    virtual tables](vtab.html#epovtab)和[table-valued functions](vtab.html#tabfunc2)，不会识别阴影表。）
- en: The virtual table contains an xShadowName method.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟表包含xShadowName方法。
- en: The xShadowName method returns true when its input is the part of the table
    name past the last "_" character.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当xShadowName方法的输入为表名称最后一个"_"字符之后的部分时，xShadowName方法返回true。
- en: If SQLite recognizes a table as a shadow table, and if the [SQLITE_DBCONFIG_DEFENSIVE](c3ref/c_dbconfig_defensive.html#sqlitedbconfigdefensive)
    flag is set, then the shadow table is read-only for ordinary SQL statements. The
    shadow table can still be written, but only by SQL that is invoked from within
    one of the methods of some virtual table implementation.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果SQLite识别某个表为阴影表，并且设置了[SQLITE_DBCONFIG_DEFENSIVE](c3ref/c_dbconfig_defensive.html#sqlitedbconfigdefensive)标志，那么该阴影表对普通SQL语句而言是只读的。阴影表仍然可以被写入，但只能由某个虚拟表实现的方法中调用的SQL进行。
- en: The whole point of the xShadowName method is to protect the content of shadow
    tables from being corrupted by hostile SQL. Every virtual table implementation
    that uses shadow tables should be able to detect and cope with corrupted shadow
    table content. However, bugs in particular virtual table implementation might
    allow a deliberately corrupted shadow table to cause a crash or other malfunction.
    The xShadowName mechanism seeks to avoid zero-day exploits by preventing ordinary
    SQL statements from deliberately corrupting shadow tables.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: xShadowName方法的主要目的是防止敌对SQL损坏阴影表的内容。每个使用阴影表的虚拟表实现都应能够检测和处理已损坏的阴影表内容。然而，特定虚拟表实现中的错误可能允许有意损坏的阴影表导致崩溃或其他故障。xShadowName机制旨在通过防止普通SQL语句有意损坏阴影表来避免零日漏洞利用。
- en: Shadow tables are read/write by default. Shadow tables only become read-only
    when the [SQLITE_DBCONFIG_DEFENSIVE](c3ref/c_dbconfig_defensive.html#sqlitedbconfigdefensive)
    flag is set using [sqlite3_db_config()](c3ref/db_config.html). Shadow tables need
    to be read/write by default in order to maintain backwards compatibility. For
    example, the SQL text generated by the [.dump](cli.html#dump) command of the [CLI](cli.html)
    writes directly into shadow tables.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影表默认为读/写模式。只有在使用[sqlite3_db_config()](c3ref/db_config.html)设置了[SQLITE_DBCONFIG_DEFENSIVE](c3ref/c_dbconfig_defensive.html#sqlitedbconfigdefensive)标志后，阴影表才会变为只读。为了保持向后兼容性，阴影表需要默认为读/写模式。例如，[CLI](cli.html)的.dump命令生成的SQL文本直接写入阴影表。
- en: 2.22\. The xIntegrity Method
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.22\. xIntegrity方法
- en: If the iVersion for an sqlite3_module is 4 or more and the xIntegrity method
    is not NULL, then the [PRAGMA integrity_check](pragma.html#pragma_integrity_check)
    and [PRAGMA quick_check](pragma.html#pragma_quick_check) commands will invoke
    xIntegrity as part of its processing. If the xIntegrity method writes an error
    message string into the fifth parameter, then PRAGMA integrity_check will report
    that error as part of its output. So, in other words, the xIntegrity method allows
    the [PRAGMA integrity_check](pragma.html#pragma_integrity_check) command to verify
    the integrity of content stored in a virtual table.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个sqlite3_module的iVersion为4或更高，并且xIntegrity方法不为NULL，则[PRAGMA integrity_check](pragma.html#pragma_integrity_check)和[PRAGMA
    quick_check](pragma.html#pragma_quick_check)命令将在处理过程中调用xIntegrity。如果xIntegrity方法将错误消息字符串写入第五个参数，则PRAGMA
    integrity_check将将该错误作为其输出的一部分报告。换句话说，xIntegrity方法允许[PRAGMA integrity_check](pragma.html#pragma_integrity_check)命令验证存储在虚拟表中的内容的完整性。
- en: 'The xIntegrity method is called with five parameters:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: xIntegrity方法被调用时带有五个参数：
- en: '**pVTab** → A pointer to the [sqlite3_vtab](c3ref/vtab.html) object that is
    the virtual table being checked.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pVTab** → 指向被检查的虚拟表对象[sqlite3_vtab](c3ref/vtab.html)的指针。'
- en: '**zSchema** → The name of the schema ("main", "temp", etc.) in which the virtual
    table is defined.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**zSchema** → 定义虚拟表的模式的名称（"main"、"temp"等）。'
- en: '**zTabName** → The name of the virtual table.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**zTabName** → 虚拟表的名称。'
- en: '**mFlags** → A flag to indicate whether this is an "integrity_check" or a "quick_check".
    Currently, this parameter will always be either 0 or 1, though future versions
    of SQLite might use other bits of the integer to indicate additional processing
    options.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**mFlags** → 一个标志，指示这是一个 "integrity_check" 还是 "quick_check"。当前，该参数始终是 0 或 1，尽管
    SQLite 的未来版本可能会使用整数的其他位来指示额外的处理选项。'
- en: '**pzErr** → This parameter points to a "char*" that is initialized to NULL.
    The xIntegrity() implementation should make *pzErr point to an error string obtained
    from sqlite3_malloc() or equivalent if it finds any problems.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pzErr** → 此参数指向一个初始化为 NULL 的 "char*"。如果 xIntegrity() 发现任何问题，则实现应使 *pzErr
    指向从 sqlite3_malloc() 或其等效函数获取的错误字符串。'
- en: The xIntegrity method should normally return SQLITE_OK - even if it finds problems
    in the content of the virtual table. Any other error code means that the xIntegrity
    method itself encountered problems while trying to evaluate the virtual table
    content. So, for example, if the inverted index for [FTS5](fts5.html) is found
    to be internally inconsistent, then the xIntegrity method should write an appropriate
    error message into the pzErr parameter and return SQLITE_OK. But if the xIntegrity
    method is unable to complete its evaluation of the virtual table content due to
    running out of memory, then it should return SQLITE_NOMEM.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: xIntegrity 方法通常应返回 SQLITE_OK — 即使它在虚拟表内容中发现问题。任何其他错误代码意味着 xIntegrity 方法本身在尝试评估虚拟表内容时遇到问题。例如，如果发现[FTS5](fts5.html)的倒排索引内部不一致，则
    xIntegrity 方法应向 pzErr 参数写入适当的错误消息并返回 SQLITE_OK。但是，如果 xIntegrity 方法由于内存耗尽而无法完成对虚拟表内容的评估，则应返回
    SQLITE_NOMEM。
- en: If an error message is generated, space to hold the error message string should
    be obtained from [sqlite3_malloc64()](c3ref/free.html) or the equivalent. Ownership
    of the error message string will pass to the SQLite core when xIntegrity returns.
    The core will make sure that [sqlite3_free()](c3ref/free.html) is invoked to reclaim
    the memory which it has finished with the error message. The PRAGMA integrity_check
    command that invokes the xIntegrity method does not change the returned error
    message. The xIntegrity method itself should include the name of the virtual table
    as part of the message. The zSchema and zName parameters are provided to make
    that easier.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 如果生成错误消息，则应从[sqlite3_malloc64()](c3ref/free.html)或其等效函数获取空间以保存错误消息字符串。当 xIntegrity
    返回时，错误消息字符串的所有权将传递给 SQLite 核心。核心会确保在完成对错误消息的使用后调用[sqlite3_free()](c3ref/free.html)以回收内存。调用
    xIntegrity 方法的 PRAGMA integrity_check 命令不会改变返回的错误消息。xIntegrity 方法本身应该将虚拟表的名称作为消息的一部分。为了更容易做到这一点，提供了
    zSchema 和 zName 参数。
- en: The mFlags parameter is currently a boolean value (either 0 or 1) that indicates
    if the xIntegrity method was called due to [PRAGMA integrity_check](pragma.html#pragma_integrity_check)
    (mFlags==0) or due to [PRAGMA quick_check](pragma.html#pragma_quick_check) (mFlags==1).
    Generally speaking, the xIntegrity method should do whatever validity checking
    it can accomplish in linear time regardless, but only do checking that requires
    superlinear time if `(mFlags&1)==0`. Future versions of SQLite might use higher-order
    bits of the mFlags parameter to indicate additional processing options.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: mFlags 参数当前是一个布尔值（0 或 1），指示 xIntegrity 方法是由于[PRAGMA integrity_check](pragma.html#pragma_integrity_check)（mFlags==0）还是由于[PRAGMA
    quick_check](pragma.html#pragma_quick_check)（mFlags==1）而被调用。一般来说，xIntegrity 方法应尽可能在线性时间内完成所有有效性检查，但仅在
    `(mFlags&1)==0` 时才执行需要超线性时间的检查。SQLite 的未来版本可能会使用 mFlags 参数的高阶位来指示额外的处理选项。
- en: Support for the xIntegrity method was added in SQLite version 3.44.0 (2023-11-01).
    In that same release, the xIntegrity method was added to many built-in virtual
    tables, such as [FTS3](fts3.html), [FTS5](fts5.html), and [RTREE](rtree.html)
    so that the content of those tables will henceforth be automatically checked for
    consistency when [PRAGMA integrity_check](pragma.html#pragma_integrity_check)
    is run.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLite 版本 3.44.0 (2023-11-01) 中添加了对 xIntegrity 方法的支持。在同一版本中，xIntegrity 方法还添加到了许多内置虚拟表中，如[FTS3](fts3.html)，[FTS5](fts5.html)和[RTREE](rtree.html)，因此从现在开始，在运行[PRAGMA
    integrity_check](pragma.html#pragma_integrity_check)时将自动检查这些表的内容是否一致。
