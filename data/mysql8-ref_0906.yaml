- en: 15.1.20 CREATE TABLE Statement
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.1.20 CREATE TABLE 语句
- en: 原文：[https://dev.mysql.com/doc/refman/8.0/en/create-table.html](https://dev.mysql.com/doc/refman/8.0/en/create-table.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://dev.mysql.com/doc/refman/8.0/en/create-table.html](https://dev.mysql.com/doc/refman/8.0/en/create-table.html)
- en: '[15.1.20.1 Files Created by CREATE TABLE](create-table-files.html)'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[15.1.20.1 CREATE TABLE 创建的文件](create-table-files.html)'
- en: '[15.1.20.2 CREATE TEMPORARY TABLE Statement](create-temporary-table.html)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[15.1.20.2 CREATE TEMPORARY TABLE 语句](create-temporary-table.html)'
- en: '[15.1.20.3 CREATE TABLE ... LIKE Statement](create-table-like.html)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[15.1.20.3 CREATE TABLE ... LIKE 语句](create-table-like.html)'
- en: '[15.1.20.4 CREATE TABLE ... SELECT Statement](create-table-select.html)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[15.1.20.4 CREATE TABLE ... SELECT 语句](create-table-select.html)'
- en: '[15.1.20.5 FOREIGN KEY Constraints](create-table-foreign-keys.html)'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '[15.1.20.5 外键约束](create-table-foreign-keys.html)'
- en: '[15.1.20.6 CHECK Constraints](create-table-check-constraints.html)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[15.1.20.6 CHECK 约束](create-table-check-constraints.html)'
- en: '[15.1.20.7 Silent Column Specification Changes](silent-column-changes.html)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[15.1.20.7 隐式列规范更改](silent-column-changes.html)'
- en: '[15.1.20.8 CREATE TABLE and Generated Columns](create-table-generated-columns.html)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[15.1.20.8 CREATE TABLE 和生成列](create-table-generated-columns.html)'
- en: '[15.1.20.9 Secondary Indexes and Generated Columns](create-table-secondary-indexes.html)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[15.1.20.9 二级索引和生成列](create-table-secondary-indexes.html)'
- en: '[15.1.20.10 Invisible Columns](invisible-columns.html)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[15.1.20.10 隐式列](invisible-columns.html)'
- en: '[15.1.20.11 Generated Invisible Primary Keys](create-table-gipks.html)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[15.1.20.11 生成的隐式主键](create-table-gipks.html)'
- en: '[15.1.20.12 Setting NDB Comment Options](create-table-ndb-comment-options.html)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[15.1.20.12 设置 NDB 注释选项](create-table-ndb-comment-options.html)'
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[`CREATE TABLE`](create-table.html "15.1.20 CREATE TABLE Statement") creates
    a table with the given name. You must have the [`CREATE`](privileges-provided.html#priv_create)
    privilege for the table.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[`CREATE TABLE`](create-table.html "15.1.20 CREATE TABLE 语句") 创建具有给定名称的表。您必须对表具有
    [`CREATE`](privileges-provided.html#priv_create) 权限。'
- en: By default, tables are created in the default database, using the [`InnoDB`](innodb-storage-engine.html
    "Chapter 17 The InnoDB Storage Engine") storage engine. An error occurs if the
    table exists, if there is no default database, or if the database does not exist.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，表在默认数据库中使用 [`InnoDB`](innodb-storage-engine.html "第 17 章 InnoDB 存储引擎")
    存储引擎创建。如果表已存在、没有默认数据库或数据库不存在，则会出现错误。
- en: MySQL has no limit on the number of tables. The underlying file system may have
    a limit on the number of files that represent tables. Individual storage engines
    may impose engine-specific constraints. `InnoDB` permits up to 4 billion tables.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 对表的数量没有限制。底层文件系统可能对代表表的文件数量有限制。各个存储引擎可能会施加特定于引擎的约束。`InnoDB` 允许最多 40 亿个表。
- en: For information about the physical representation of a table, see [Section 15.1.20.1,
    “Files Created by CREATE TABLE”](create-table-files.html "15.1.20.1 Files Created
    by CREATE TABLE").
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有关表的物理表示信息，请参阅 [第 15.1.20.1 节“CREATE TABLE 创建的文件”](create-table-files.html "15.1.20.1 CREATE
    TABLE 创建的文件").
- en: 'There are several aspects to the [`CREATE TABLE`](create-table.html "15.1.20 CREATE
    TABLE Statement") statement, described under the following topics in this section:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[`CREATE TABLE`](create-table.html "15.1.20 CREATE TABLE 语句") 语句有几个方面，在本节的以下主题中描述：'
- en: '[Table Name](create-table.html#create-table-name "Table Name")'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[表名](create-table.html#create-table-name "表名")'
- en: '[Temporary Tables](create-table.html#create-table-temporary-tables "Temporary
    Tables")'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[临时表](create-table.html#create-table-temporary-tables "临时表")'
- en: '[Table Cloning and Copying](create-table.html#create-table-clone-copy "Table
    Cloning and Copying")'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[表克隆和复制](create-table.html#create-table-clone-copy "表克隆和复制")'
- en: '[Column Data Types and Attributes](create-table.html#create-table-types-attributes
    "Column Data Types and Attributes")'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[列数据类型和属性](create-table.html#create-table-types-attributes "列数据类型和属性")'
- en: '[Indexes, Foreign Keys, and CHECK Constraints](create-table.html#create-table-indexes-keys
    "Indexes, Foreign Keys, and CHECK Constraints")'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[索引、外键和 CHECK 约束](create-table.html#create-table-indexes-keys "索引、外键和 CHECK
    约束")'
- en: '[Table Options](create-table.html#create-table-options "Table Options")'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[表选项](create-table.html#create-table-options "表选项")'
- en: '[Table Partitioning](create-table.html#create-table-partitioning "Table Partitioning")'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[表分区](create-table.html#create-table-partitioning "表分区")'
- en: Table Name
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 表名
- en: '`*`tbl_name`*`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`tbl_name`*`'
- en: The table name can be specified as *`db_name.tbl_name`* to create the table
    in a specific database. This works regardless of whether there is a default database,
    assuming that the database exists. If you use quoted identifiers, quote the database
    and table names separately. For example, write ``mydb`.`mytbl``, not ``mydb.mytbl``.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表名可以指定为*`db_name.tbl_name`*，以在特定数据库中创建表。无论是否存在默认数据库，都可以使用此方法，假设数据库存在。如果使用带引号的标识符，请分别引用数据库和表名。例如，写成``mydb`.`mytbl``，而不是``mydb.mytbl``。
- en: Rules for permissible table names are given in [Section 11.2, “Schema Object
    Names”](identifiers.html "11.2 Schema Object Names").
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可接受的表名规则在[第11.2节，“模式对象名称”](identifiers.html "11.2 模式对象名称")中给出。
- en: '`IF NOT EXISTS`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IF NOT EXISTS`'
- en: Prevents an error from occurring if the table exists. However, there is no verification
    that the existing table has a structure identical to that indicated by the [`CREATE
    TABLE`](create-table.html "15.1.20 CREATE TABLE Statement") statement.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果表存在，则防止出现错误。但是，并没有验证现有表的结构是否与 [`CREATE TABLE`](create-table.html "15.1.20
    CREATE TABLE 语句") 语句指示的结构完全相同。
- en: Temporary Tables
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 临时表
- en: You can use the `TEMPORARY` keyword when creating a table. A `TEMPORARY` table
    is visible only within the current session, and is dropped automatically when
    the session is closed. For more information, see [Section 15.1.20.2, “CREATE TEMPORARY
    TABLE Statement”](create-temporary-table.html "15.1.20.2 CREATE TEMPORARY TABLE
    Statement").
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建表时，可以使用 `TEMPORARY` 关键字。`TEMPORARY` 表仅在当前会话中可见，并在会话关闭时自动删除。有关更多信息，请参见[第15.1.20.2节，“CREATE
    TEMPORARY TABLE 语句”](create-temporary-table.html "15.1.20.2 CREATE TEMPORARY TABLE
    语句")。
- en: Table Cloning and Copying
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 表克隆和复制
- en: '`LIKE`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LIKE`'
- en: 'Use `CREATE TABLE ... LIKE` to create an empty table based on the definition
    of another table, including any column attributes and indexes defined in the original
    table:'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `CREATE TABLE ... LIKE` 根据另一个表的定义创建一个空表，包括原始表中定义的任何列属性和索引：
- en: '[PRE1]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For more information, see [Section 15.1.20.3, “CREATE TABLE ... LIKE Statement”](create-table-like.html
    "15.1.20.3 CREATE TABLE ... LIKE Statement").
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更多信息，请参见[第15.1.20.3节，“CREATE TABLE ... LIKE 语句”](create-table-like.html "15.1.20.3
    CREATE TABLE ... LIKE 语句")。
- en: '`[AS] *`query_expression`*`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[AS] *`query_expression`*`'
- en: 'To create one table from another, add a [`SELECT`](select.html "15.2.13 SELECT
    Statement") statement at the end of the [`CREATE TABLE`](create-table.html "15.1.20 CREATE
    TABLE Statement") statement:'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要从一个表创建另一个表，请在 [`CREATE TABLE`](create-table.html "15.1.20 CREATE TABLE 语句")
    语句末尾添加一个 [`SELECT`](select.html "15.2.13 SELECT 语句") 语句：
- en: '[PRE2]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For more information, see [Section 15.1.20.4, “CREATE TABLE ... SELECT Statement”](create-table-select.html
    "15.1.20.4 CREATE TABLE ... SELECT Statement").
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更多信息，请参见[第15.1.20.4节，“CREATE TABLE ... SELECT 语句”](create-table-select.html
    "15.1.20.4 CREATE TABLE ... SELECT 语句")。
- en: '`IGNORE | REPLACE`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IGNORE | REPLACE`'
- en: The `IGNORE` and `REPLACE` options indicate how to handle rows that duplicate
    unique key values when copying a table using a [`SELECT`](select.html "15.2.13 SELECT
    Statement") statement.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`IGNORE` 和 `REPLACE` 选项指示在使用 [`SELECT`](select.html "15.2.13 SELECT 语句") 语句复制表时如何处理重复唯一键值的行。'
- en: For more information, see [Section 15.1.20.4, “CREATE TABLE ... SELECT Statement”](create-table-select.html
    "15.1.20.4 CREATE TABLE ... SELECT Statement").
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更多信息，请参见[第15.1.20.4节，“CREATE TABLE ... SELECT 语句”](create-table-select.html
    "15.1.20.4 CREATE TABLE ... SELECT 语句")。
- en: Column Data Types and Attributes
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 列数据类型和属性
- en: There is a hard limit of 4096 columns per table, but the effective maximum may
    be less for a given table and depends on the factors discussed in [Section 10.4.7,
    “Limits on Table Column Count and Row Size”](column-count-limit.html "10.4.7 Limits
    on Table Column Count and Row Size").
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每个表的列有一个硬限制为4096列，但对于给定表，有效最大值可能会更少，并取决于[第10.4.7节，“表列计数和行大小限制”](column-count-limit.html
    "10.4.7 表列计数和行大小限制")中讨论的因素。
- en: '`*`data_type`*`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`data_type`*`'
- en: '*`data_type`* represents the data type in a column definition. For a full description
    of the syntax available for specifying column data types, as well as information
    about the properties of each type, see [Chapter 13, *Data Types*](data-types.html
    "Chapter 13 Data Types").'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*`data_type`* 代表列定义中的数据类型。有关指定列数据类型的语法以及每种类型属性的详细描述，请参见[第13章，*数据类型*](data-types.html
    "第13章 数据类型")。'
- en: Some attributes do not apply to all data types. `AUTO_INCREMENT` applies only
    to integer and floating-point types. Using `AUTO_INCREMENT` with [`FLOAT`](floating-point-types.html
    "13.1.4 Floating-Point Types (Approximate Value) - FLOAT, DOUBLE") or [`DOUBLE`](floating-point-types.html
    "13.1.4 Floating-Point Types (Approximate Value) - FLOAT, DOUBLE") columns is
    deprecated as of MySQL 8.0.17; expect support for it to be removed in a future
    version of MySQL.
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些属性不适用于所有数据类型。`AUTO_INCREMENT` 仅适用于整数和浮点类型。在 MySQL 8.0.17 中，使用 `AUTO_INCREMENT`
    与 [`FLOAT`](floating-point-types.html "13.1.4 浮点类型（近似值）- FLOAT, DOUBLE") 或 [`DOUBLE`](floating-point-types.html
    "13.1.4 浮点类型（近似值）- FLOAT, DOUBLE") 列已被弃用；预计在未来的 MySQL 版本中将删除对其的支持。
- en: Prior to MySQL 8.0.13, `DEFAULT` does not apply to the [`BLOB`](blob.html "13.3.4 The
    BLOB and TEXT Types"), [`TEXT`](blob.html "13.3.4 The BLOB and TEXT Types"), `GEOMETRY`,
    and [`JSON`](json.html "13.5 The JSON Data Type") types.
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 MySQL 8.0.13 之前，`DEFAULT` 不适用于 [`BLOB`](blob.html "13.3.4 BLOB 和 TEXT 类型"),
    [`TEXT`](blob.html "13.3.4 BLOB 和 TEXT 类型"), `GEOMETRY` 和 [`JSON`](json.html "13.5 JSON
    数据类型") 类型。
- en: 'Character data types ([`CHAR`](char.html "13.3.2 The CHAR and VARCHAR Types"),
    [`VARCHAR`](char.html "13.3.2 The CHAR and VARCHAR Types"), the [`TEXT`](blob.html
    "13.3.4 The BLOB and TEXT Types") types, [`ENUM`](enum.html "13.3.5 The ENUM Type"),
    [`SET`](set.html "13.3.6 The SET Type"), and any synonyms) can include `CHARACTER
    SET` to specify the character set for the column. `CHARSET` is a synonym for `CHARACTER
    SET`. A collation for the character set can be specified with the `COLLATE` attribute,
    along with any other attributes. For details, see [Chapter 12, *Character Sets,
    Collations, Unicode*](charset.html "Chapter 12 Character Sets, Collations, Unicode").
    Example:'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符数据类型（[`CHAR`](char.html "13.3.2 CHAR 和 VARCHAR 类型"), [`VARCHAR`](char.html
    "13.3.2 CHAR 和 VARCHAR 类型"), [`TEXT`](blob.html "13.3.4 BLOB 和 TEXT 类型"), [`ENUM`](enum.html
    "13.3.5 ENUM 类型"), [`SET`](set.html "13.3.6 SET 类型") 和任何同义词）可以包括 `CHARACTER SET`
    来指定列的字符集。`CHARSET` 是 `CHARACTER SET` 的同义词。可以使用 `COLLATE` 属性指定字符集的排序规则，以及其他任何属性。有关详细信息，请参见
    [第 12 章，*字符集、排序规则、Unicode*](charset.html "第 12 章 字符集、排序规则、Unicode")。示例：
- en: '[PRE3]'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: MySQL 8.0 interprets length specifications in character column definitions in
    characters. Lengths for [`BINARY`](binary-varbinary.html "13.3.3 The BINARY and
    VARBINARY Types") and [`VARBINARY`](binary-varbinary.html "13.3.3 The BINARY and
    VARBINARY Types") are in bytes.
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: MySQL 8.0 解释字符列定义中的长度规范为字符。[`BINARY`](binary-varbinary.html "13.3.3 BINARY 和
    VARBINARY 类型") 和 [`VARBINARY`](binary-varbinary.html "13.3.3 BINARY 和 VARBINARY
    类型") 的长度以字节为单位。
- en: For [`CHAR`](char.html "13.3.2 The CHAR and VARCHAR Types"), [`VARCHAR`](char.html
    "13.3.2 The CHAR and VARCHAR Types"), [`BINARY`](binary-varbinary.html "13.3.3 The
    BINARY and VARBINARY Types"), and [`VARBINARY`](binary-varbinary.html "13.3.3 The
    BINARY and VARBINARY Types") columns, indexes can be created that use only the
    leading part of column values, using `*`col_name`*(*`length`*)` syntax to specify
    an index prefix length. [`BLOB`](blob.html "13.3.4 The BLOB and TEXT Types") and
    [`TEXT`](blob.html "13.3.4 The BLOB and TEXT Types") columns also can be indexed,
    but a prefix length *must* be given. Prefix lengths are given in characters for
    nonbinary string types and in bytes for binary string types. That is, index entries
    consist of the first *`length`* characters of each column value for [`CHAR`](char.html
    "13.3.2 The CHAR and VARCHAR Types"), [`VARCHAR`](char.html "13.3.2 The CHAR and
    VARCHAR Types"), and [`TEXT`](blob.html "13.3.4 The BLOB and TEXT Types") columns,
    and the first *`length`* bytes of each column value for [`BINARY`](binary-varbinary.html
    "13.3.3 The BINARY and VARBINARY Types"), [`VARBINARY`](binary-varbinary.html
    "13.3.3 The BINARY and VARBINARY Types"), and [`BLOB`](blob.html "13.3.4 The BLOB
    and TEXT Types") columns. Indexing only a prefix of column values like this can
    make the index file much smaller. For additional information about index prefixes,
    see [Section 15.1.15, “CREATE INDEX Statement”](create-index.html "15.1.15 CREATE
    INDEX Statement").
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 [`CHAR`](char.html "13.3.2 CHAR 和 VARCHAR 类型")、[`VARCHAR`](char.html "13.3.2 CHAR
    和 VARCHAR 类型")、[`BINARY`](binary-varbinary.html "13.3.3 BINARY 和 VARBINARY 类型")
    和 [`VARBINARY`](binary-varbinary.html "13.3.3 BINARY 和 VARBINARY 类型") 列，可以创建仅使用列值前导部分的索引，使用
    `*`col_name`*(*`length`*)` 语法指定索引前缀长度。[`BLOB`](blob.html "13.3.4 BLOB 和 TEXT 类型")
    和 [`TEXT`](blob.html "13.3.4 BLOB 和 TEXT 类型") 列也可以被索引，但必须给出前缀长度。对于非二进制字符串类型，前缀长度以字符为单位，对于二进制字符串类型，前缀长度以字节为单位。也就是说，对于
    [`CHAR`](char.html "13.3.2 CHAR 和 VARCHAR 类型")、[`VARCHAR`](char.html "13.3.2 CHAR
    和 VARCHAR 类型") 和 [`TEXT`](blob.html "13.3.4 BLOB 和 TEXT 类型") 列，索引条目由每个列值的前 *`length`*
    个字符组成，对于 [`BINARY`](binary-varbinary.html "13.3.3 BINARY 和 VARBINARY 类型")、[`VARBINARY`](binary-varbinary.html
    "13.3.3 BINARY 和 VARBINARY 类型") 和 [`BLOB`](blob.html "13.3.4 BLOB 和 TEXT 类型")
    列，索引条目由每个列值的前 *`length`* 个字节组成。像这样仅对列值前缀进行索引可以使索引文件变得更小。有关索引前缀的更多信息，请参见 [第 15.1.15
    节，“CREATE INDEX 语句”](create-index.html "15.1.15 CREATE INDEX 语句")。
- en: 'Only the `InnoDB` and `MyISAM` storage engines support indexing on [`BLOB`](blob.html
    "13.3.4 The BLOB and TEXT Types") and [`TEXT`](blob.html "13.3.4 The BLOB and
    TEXT Types") columns. For example:'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 仅 `InnoDB` 和 `MyISAM` 存储引擎支持对 [`BLOB`](blob.html "13.3.4 BLOB 和 TEXT 类型") 和
    [`TEXT`](blob.html "13.3.4 BLOB 和 TEXT 类型") 列进行索引。例如：
- en: '[PRE4]'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If a specified index prefix exceeds the maximum column data type size, [`CREATE
    TABLE`](create-table.html "15.1.20 CREATE TABLE Statement") handles the index
    as follows:'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果指定的索引前缀超过最大列数据类型大小，[`CREATE TABLE`](create-table.html "15.1.20 CREATE TABLE
    语句") 将处理索引如下：
- en: For a nonunique index, either an error occurs (if strict SQL mode is enabled),
    or the index length is reduced to lie within the maximum column data type size
    and a warning is produced (if strict SQL mode is not enabled).
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于非唯一索引，如果启用了严格的 SQL 模式，则会发生错误，或者索引长度会减小以符合最大列数据类型大小，并产生警告（如果未启用严格的 SQL 模��）。
- en: For a unique index, an error occurs regardless of SQL mode because reducing
    the index length might enable insertion of nonunique entries that do not meet
    the specified uniqueness requirement.
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于唯一索引，无论 SQL 模式如何，都会发生错误，因为减少索引长度可能会导致插入不符合指定唯一性要求的非唯一条目。
- en: '[`JSON`](json.html "13.5 The JSON Data Type") columns cannot be indexed. You
    can work around this restriction by creating an index on a generated column that
    extracts a scalar value from the `JSON` column. See [Indexing a Generated Column
    to Provide a JSON Column Index](create-table-secondary-indexes.html#json-column-indirect-index
    "Indexing a Generated Column to Provide a JSON Column Index"), for a detailed
    example.'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`JSON`](json.html "13.5 JSON 数据类型") 列无法被索引。您可以通过在生成的列上创建索引来绕过此限制，该生成的列从 `JSON`
    列中提取标量值。详细示例请参见 [在生成的列上创建索引以提供 JSON 列索引](create-table-secondary-indexes.html#json-column-indirect-index
    "在生成的列上创建索引以提供 JSON 列索引")。'
- en: '`NOT NULL | NULL`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NOT NULL | NULL`'
- en: If neither `NULL` nor `NOT NULL` is specified, the column is treated as though
    `NULL` had been specified.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果未指定 `NULL` 或 `NOT NULL`，则该列被视为已指定 `NULL`。
- en: In MySQL 8.0, only the `InnoDB`, `MyISAM`, and `MEMORY` storage engines support
    indexes on columns that can have `NULL` values. In other cases, you must declare
    indexed columns as `NOT NULL` or an error results.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 MySQL 8.0 中，只有`InnoDB`、`MyISAM`和`MEMORY`存储引擎支持可以具有`NULL`值的列上的索引。在其他情况下，必须将索引列声明为`NOT
    NULL`，否则会产生错误。
- en: '`DEFAULT`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEFAULT`'
- en: Specifies a default value for a column. For more information about default value
    handling, including the case that a column definition includes no explicit `DEFAULT`
    value, see [Section 13.6, “Data Type Default Values”](data-type-defaults.html
    "13.6 Data Type Default Values").
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为列指定默认值。有关默认值处理的更多信息，包括列定义不包含显式`DEFAULT`值的情况，请参见[第 13.6 节，“数据类型默认值”](data-type-defaults.html
    "13.6 数据类型默认值")。
- en: If the [`NO_ZERO_DATE`](sql-mode.html#sqlmode_no_zero_date) or [`NO_ZERO_IN_DATE`](sql-mode.html#sqlmode_no_zero_in_date)
    SQL mode is enabled and a date-valued default is not correct according to that
    mode, [`CREATE TABLE`](create-table.html "15.1.20 CREATE TABLE Statement") produces
    a warning if strict SQL mode is not enabled and an error if strict mode is enabled.
    For example, with [`NO_ZERO_IN_DATE`](sql-mode.html#sqlmode_no_zero_in_date) enabled,
    `c1 DATE DEFAULT '2010-00-00'` produces a warning.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果启用了[`NO_ZERO_DATE`](sql-mode.html#sqlmode_no_zero_date)或[`NO_ZERO_IN_DATE`](sql-mode.html#sqlmode_no_zero_in_date)
    SQL 模式，并且日期值默认值不符合该模式，则[`CREATE TABLE`](create-table.html "15.1.20 CREATE TABLE
    Statement")在严格 SQL 模式未启用时会产生警告，在启用严格模式时会产生错误。例如，启用[`NO_ZERO_IN_DATE`](sql-mode.html#sqlmode_no_zero_in_date)，`c1
    DATE DEFAULT '2010-00-00'`会产生警告。
- en: '`VISIBLE`, `INVISIBLE`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VISIBLE`、`INVISIBLE`'
- en: Specify column visibility. The default is `VISIBLE` if neither keyword is present.
    A table must have at least one visible column. Attempting to make all columns
    invisible produces an error. For more information, see [Section 15.1.20.10, “Invisible
    Columns”](invisible-columns.html "15.1.20.10 Invisible Columns").
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 指定列的可见性。如果两个关键字都不存在，则默认为`VISIBLE`。表必须至少有一列可见。尝试使所有列不可见会产生错误。有关更多信息，请参见[第 15.1.20.10
    节，“不可见列”](invisible-columns.html "15.1.20.10 不可见列")。
- en: The `VISIBLE` and `INVISIBLE` keywords are available as of MySQL 8.0.23\. Prior
    to MySQL 8.0.23, all columns are visible.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`VISIBLE` 和 `INVISIBLE` 关键字从 MySQL 8.0.23 开始可用。在 MySQL 8.0.23 之前，所有列都是可见的。'
- en: '`AUTO_INCREMENT`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AUTO_INCREMENT`'
- en: An integer or floating-point column can have the additional attribute `AUTO_INCREMENT`.
    When you insert a value of `NULL` (recommended) or `0` into an indexed `AUTO_INCREMENT`
    column, the column is set to the next sequence value. Typically this is `*`value`*+1`,
    where *`value`* is the largest value for the column currently in the table. `AUTO_INCREMENT`
    sequences begin with `1`.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 整数或浮点列可以具有附加属性`AUTO_INCREMENT`。当您将`NULL`（推荐）或`0`值插入到索引的`AUTO_INCREMENT`列中时，该列将设置为下一个序列值。通常这是`*`value`*+1`，其中*`value`*是当前表中列的最大值。`AUTO_INCREMENT`序列从`1`开始。
- en: To retrieve an `AUTO_INCREMENT` value after inserting a row, use the [`LAST_INSERT_ID()`](information-functions.html#function_last-insert-id)
    SQL function or the [`mysql_insert_id()`](/doc/c-api/8.0/en/mysql-insert-id.html)
    C API function. See [Section 14.15, “Information Functions”](information-functions.html
    "14.15 Information Functions"), and [mysql_insert_id()](/doc/c-api/8.0/en/mysql-insert-id.html).
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在插入行后检索`AUTO_INCREMENT`值，请使用[`LAST_INSERT_ID()`](information-functions.html#function_last-insert-id)
    SQL 函数或[`mysql_insert_id()`](/doc/c-api/8.0/en/mysql-insert-id.html) C API 函数。请参见[第
    14.15 节，“信息函数”](information-functions.html "14.15 信息函数")，以及[mysql_insert_id()](/doc/c-api/8.0/en/mysql-insert-id.html)。
- en: If the [`NO_AUTO_VALUE_ON_ZERO`](sql-mode.html#sqlmode_no_auto_value_on_zero)
    SQL mode is enabled, you can store `0` in `AUTO_INCREMENT` columns as `0` without
    generating a new sequence value. See [Section 7.1.11, “Server SQL Modes”](sql-mode.html
    "7.1.11 Server SQL Modes").
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果启用了[`NO_AUTO_VALUE_ON_ZERO`](sql-mode.html#sqlmode_no_auto_value_on_zero)
    SQL 模式，则可以将`0`存储在`AUTO_INCREMENT`列中，而不生成新的序列值。参见[第 7.1.11 节，“服务器 SQL 模式”](sql-mode.html
    "7.1.11 服务器 SQL 模式")。
- en: There can be only one `AUTO_INCREMENT` column per table, it must be indexed,
    and it cannot have a `DEFAULT` value. An `AUTO_INCREMENT` column works properly
    only if it contains only positive values. Inserting a negative number is regarded
    as inserting a very large positive number. This is done to avoid precision problems
    when numbers “wrap” over from positive to negative and also to ensure that you
    do not accidentally get an `AUTO_INCREMENT` column that contains `0`.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个表只能有一个`AUTO_INCREMENT`列，它必须被索引，并且不能有默认值。`AUTO_INCREMENT`列只有在包含正值时才能正常工作。插入负数被视为插入一个非常大的正数。这样做是为了避免当数字从正数“环绕”到负数时出现精度问题，并确保您不会意外地获得一个包含`0`的`AUTO_INCREMENT`列。
- en: For `MyISAM` tables, you can specify an `AUTO_INCREMENT` secondary column in
    a multiple-column key. See [Section 5.6.9, “Using AUTO_INCREMENT”](example-auto-increment.html
    "5.6.9 Using AUTO_INCREMENT").
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于`MyISAM`表，您可以在多列键中指定一个`AUTO_INCREMENT`次要列。参见[Section 5.6.9, “Using AUTO_INCREMENT”](example-auto-increment.html
    "5.6.9 Using AUTO_INCREMENT")。
- en: 'To make MySQL compatible with some ODBC applications, you can find the `AUTO_INCREMENT`
    value for the last inserted row with the following query:'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要使MySQL与某些ODBC应用程序兼容，您可以使用以下查询找到最后插入行的`AUTO_INCREMENT`值：
- en: '[PRE5]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This method requires that [`sql_auto_is_null`](server-system-variables.html#sysvar_sql_auto_is_null)
    variable is not set to 0\. See [Section 7.1.8, “Server System Variables”](server-system-variables.html
    "7.1.8 Server System Variables").
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法要求[`sql_auto_is_null`](server-system-variables.html#sysvar_sql_auto_is_null)变量未设置为0。请参见[Section 7.1.8,
    “Server System Variables”](server-system-variables.html "7.1.8 Server System Variables")。
- en: For information about `InnoDB` and `AUTO_INCREMENT`, see [Section 17.6.1.6,
    “AUTO_INCREMENT Handling in InnoDB”](innodb-auto-increment-handling.html "17.6.1.6 AUTO_INCREMENT
    Handling in InnoDB"). For information about `AUTO_INCREMENT` and MySQL Replication,
    see [Section 19.5.1.1, “Replication and AUTO_INCREMENT”](replication-features-auto-increment.html
    "19.5.1.1 Replication and AUTO_INCREMENT").
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有关`InnoDB`和`AUTO_INCREMENT`的信息，请参见[Section 17.6.1.6, “AUTO_INCREMENT Handling
    in InnoDB”](innodb-auto-increment-handling.html "17.6.1.6 AUTO_INCREMENT Handling
    in InnoDB")。有关`AUTO_INCREMENT`和MySQL复制的信息，请参见[Section 19.5.1.1, “Replication and
    AUTO_INCREMENT”](replication-features-auto-increment.html "19.5.1.1 Replication
    and AUTO_INCREMENT")。
- en: '`COMMENT`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COMMENT`'
- en: A comment for a column can be specified with the `COMMENT` option, up to 1024
    characters long. The comment is displayed by the [`SHOW CREATE TABLE`](show-create-table.html
    "15.7.7.10 SHOW CREATE TABLE Statement") and [`SHOW FULL COLUMNS`](show-columns.html
    "15.7.7.5 SHOW COLUMNS Statement") statements. It is also shown in the `COLUMN_COMMENT`
    column of the Information Schema [`COLUMNS`](information-schema-columns-table.html
    "28.3.8 The INFORMATION_SCHEMA COLUMNS Table") table.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以使用`COMMENT`选项为列指定长达1024个字符的注释。该注释将显示在[`SHOW CREATE TABLE`](show-create-table.html
    "15.7.7.10 SHOW CREATE TABLE Statement")和[`SHOW FULL COLUMNS`](show-columns.html
    "15.7.7.5 SHOW COLUMNS Statement")语句中。它还显示在信息模式[`COLUMNS`](information-schema-columns-table.html
    "28.3.8 The INFORMATION_SCHEMA COLUMNS Table")表的`COLUMN_COMMENT`列中。
- en: '`COLUMN_FORMAT`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COLUMN_FORMAT`'
- en: In NDB Cluster, it is also possible to specify a data storage format for individual
    columns of [`NDB`](mysql-cluster.html "Chapter 25 MySQL NDB Cluster 8.0") tables
    using `COLUMN_FORMAT`. Permissible column formats are `FIXED`, `DYNAMIC`, and
    `DEFAULT`. `FIXED` is used to specify fixed-width storage, `DYNAMIC` permits the
    column to be variable-width, and `DEFAULT` causes the column to use fixed-width
    or variable-width storage as determined by the column's data type (possibly overridden
    by a `ROW_FORMAT` specifier).
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在NDB Cluster中，还可以使用`COLUMN_FORMAT`为[`NDB`](mysql-cluster.html "Chapter 25 MySQL
    NDB Cluster 8.0")表的各个列指定数据存储格式。可接受的列格式包括`FIXED`、`DYNAMIC`和`DEFAULT`。`FIXED`用于指定固定宽度存储，`DYNAMIC`允许列为可变宽度，`DEFAULT`使列使用由列的数据类型确定的固定宽度或可变宽度存储（可能被`ROW_FORMAT`修饰符覆盖）。
- en: For [`NDB`](mysql-cluster.html "Chapter 25 MySQL NDB Cluster 8.0") tables, the
    default value for `COLUMN_FORMAT` is `FIXED`.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于[`NDB`](mysql-cluster.html "Chapter 25 MySQL NDB Cluster 8.0")表，`COLUMN_FORMAT`的默认值为`FIXED`。
- en: In NDB Cluster, the maximum possible offset for a column defined with `COLUMN_FORMAT=FIXED`
    is 8188 bytes. For more information and possible workarounds, see [Section 25.2.7.5,
    “Limits Associated with Database Objects in NDB Cluster”](mysql-cluster-limitations-database-objects.html
    "25.2.7.5 Limits Associated with Database Objects in NDB Cluster").
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在NDB Cluster中，使用`COLUMN_FORMAT=FIXED`定义的列的最大可能偏移量为8188字节。有关更多信息和可能的解决方法，请参见[Section 25.2.7.5,
    “Limits Associated with Database Objects in NDB Cluster”](mysql-cluster-limitations-database-objects.html
    "25.2.7.5 Limits Associated with Database Objects in NDB Cluster")。
- en: '`COLUMN_FORMAT` currently has no effect on columns of tables using storage
    engines other than [`NDB`](mysql-cluster.html "Chapter 25 MySQL NDB Cluster 8.0").
    MySQL 8.0 silently ignores `COLUMN_FORMAT`.'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`COLUMN_FORMAT` 目前对使用除 [`NDB`](mysql-cluster.html "第 25 章 MySQL NDB Cluster
    8.0") 之外的存储引擎的表的列没有影响。MySQL 8.0 会默默忽略 `COLUMN_FORMAT`。'
- en: '`ENGINE_ATTRIBUTE` and `SECONDARY_ENGINE_ATTRIBUTE` options (available as of
    MySQL 8.0.21) are used to specify column attributes for primary and secondary
    storage engines. The options are reserved for future use.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENGINE_ATTRIBUTE` 和 `SECONDARY_ENGINE_ATTRIBUTE` 选项（自 MySQL 8.0.21 起可用）用于指定主存储引擎和辅助存储引擎的列属性。这些选项保留供将来使用。'
- en: Permitted values are a string literal containing a valid `JSON` document or
    an empty string (''). Invalid `JSON` is rejected.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 允许的值是包含有效 `JSON` 文档或空字符串（''）的字符串文字。无效的 `JSON` 将被拒绝。
- en: '[PRE6]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`ENGINE_ATTRIBUTE` and `SECONDARY_ENGINE_ATTRIBUTE` values can be repeated
    without error. In this case, the last specified value is used.'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ENGINE_ATTRIBUTE` 和 `SECONDARY_ENGINE_ATTRIBUTE` 的值可以重复使用而不会出错。在这种情况下，将使用最后指定的值。'
- en: '`ENGINE_ATTRIBUTE` and `SECONDARY_ENGINE_ATTRIBUTE` values are not checked
    by the server, nor are they cleared when the table''s storage engine is changed.'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ENGINE_ATTRIBUTE` 和 `SECONDARY_ENGINE_ATTRIBUTE` 的值不会被服务器检查，也不会在表的存储引擎更改时被清除。'
- en: '`STORAGE`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STORAGE`'
- en: 'For [`NDB`](mysql-cluster.html "Chapter 25 MySQL NDB Cluster 8.0") tables,
    it is possible to specify whether the column is stored on disk or in memory by
    using a `STORAGE` clause. `STORAGE DISK` causes the column to be stored on disk,
    and `STORAGE MEMORY` causes in-memory storage to be used. The [`CREATE TABLE`](create-table.html
    "15.1.20 CREATE TABLE Statement") statement used must still include a `TABLESPACE`
    clause:'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于 [`NDB`](mysql-cluster.html "第 25 章 MySQL NDB Cluster 8.0") 表，可以通过使用 `STORAGE`
    子句来指定列是存储在磁盘上还是内存中。`STORAGE DISK` 导致列存储在磁盘上，而 `STORAGE MEMORY` 导致使用内存存储。仍然必须在使用的
    [`CREATE TABLE`](create-table.html "15.1.20 CREATE TABLE Statement") 语句中包含 `TABLESPACE`
    子句：
- en: '[PRE7]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For [`NDB`](mysql-cluster.html "Chapter 25 MySQL NDB Cluster 8.0") tables, `STORAGE
    DEFAULT` is equivalent to `STORAGE MEMORY`.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于 [`NDB`](mysql-cluster.html "第 25 章 MySQL NDB Cluster 8.0") 表，`STORAGE DEFAULT`
    等同于 `STORAGE MEMORY`。
- en: The `STORAGE` clause has no effect on tables using storage engines other than
    [`NDB`](mysql-cluster.html "Chapter 25 MySQL NDB Cluster 8.0"). The `STORAGE`
    keyword is supported only in the build of [**mysqld**](mysqld.html "6.3.1 mysqld
    — The MySQL Server") that is supplied with NDB Cluster; it is not recognized in
    any other version of MySQL, where any attempt to use the `STORAGE` keyword causes
    a syntax error.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`STORAGE` 子句对使用除 [`NDB`](mysql-cluster.html "第 25 章 MySQL NDB Cluster 8.0")
    之外的存储引擎的表没有影响。`STORAGE` 关键字仅在随 NDB Cluster 一起提供的 [**mysqld**](mysqld.html "6.3.1
    mysqld — The MySQL Server") 构建中受支持；在 MySQL 的任何其他版本中都不被识别，任何尝试使用 `STORAGE` 关键字都会导致语法错误。'
- en: '`GENERATED ALWAYS`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GENERATED ALWAYS`'
- en: Used to specify a generated column expression. For information about [generated
    columns](glossary.html#glos_generated_column "generated column"), see [Section 15.1.20.8,
    “CREATE TABLE and Generated Columns”](create-table-generated-columns.html "15.1.20.8 CREATE
    TABLE and Generated Columns").
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用于指定生成列表达式。有关[生成列](glossary.html#glos_generated_column "生成列")的信息，请参阅[第 15.1.20.8
    节，“CREATE TABLE 和 Generated Columns”](create-table-generated-columns.html "15.1.20.8
    CREATE TABLE 和 Generated Columns")。
- en: '[Stored generated columns](glossary.html#glos_stored_generated_column "stored
    generated column") can be indexed. `InnoDB` supports secondary indexes on [virtual
    generated columns](glossary.html#glos_virtual_generated_column "virtual generated
    column"). See [Section 15.1.20.9, “Secondary Indexes and Generated Columns”](create-table-secondary-indexes.html
    "15.1.20.9 Secondary Indexes and Generated Columns").'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[存储生成列](glossary.html#glos_stored_generated_column "存储生成列") 可以被索引。`InnoDB`
    支持对[虚拟生成列](glossary.html#glos_virtual_generated_column "虚拟生成列")进行二级索引。请参阅[第 15.1.20.9
    节，“Secondary Indexes and Generated Columns”](create-table-secondary-indexes.html
    "15.1.20.9 Secondary Indexes and Generated Columns")。'
- en: Indexes, Foreign Keys, and CHECK Constraints
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 索引、外键和检查约束
- en: Several keywords apply to creation of indexes, foreign keys, and `CHECK` constraints.
    For general background in addition to the following descriptions, see [Section 15.1.15,
    “CREATE INDEX Statement”](create-index.html "15.1.15 CREATE INDEX Statement"),
    [Section 15.1.20.5, “FOREIGN KEY Constraints”](create-table-foreign-keys.html
    "15.1.20.5 FOREIGN KEY Constraints"), and [Section 15.1.20.6, “CHECK Constraints”](create-table-check-constraints.html
    "15.1.20.6 CHECK Constraints").
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 创建索引、外键和`CHECK`约束时适用几个关键字。除了以下描述外，有关一般背景，请参阅[Section 15.1.15, “CREATE INDEX
    Statement”](create-index.html "15.1.15 CREATE INDEX Statement")，[Section 15.1.20.5,
    “FOREIGN KEY Constraints”](create-table-foreign-keys.html "15.1.20.5 FOREIGN KEY
    Constraints")和[Section 15.1.20.6, “CHECK Constraints”](create-table-check-constraints.html
    "15.1.20.6 CHECK Constraints")。
- en: '`CONSTRAINT *`symbol`*`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONSTRAINT *`symbol`*`'
- en: The `CONSTRAINT *`symbol`*` clause may be given to name a constraint. If the
    clause is not given, or a *`symbol`* is not included following the `CONSTRAINT`
    keyword, MySQL automatically generates a constraint name, with the exception noted
    below. The *`symbol`* value, if used, must be unique per schema (database), per
    constraint type. A duplicate *`symbol`* results in an error. See also the discussion
    about length limits of generated constraint identifiers at [Section 11.2.1, “Identifier
    Length Limits”](identifier-length.html "11.2.1 Identifier Length Limits").
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以使用`CONSTRAINT *`symbol`*`子句来命名约束。如果未给出该子句，或者在`CONSTRAINT`关键字后未包含*`symbol`*，MySQL会自动生成约束名称，以下列出的情况除外。如果使用了*`symbol`*值，必须对每个模式（数据库）的每种约束类型保持唯一性。重复的*`symbol`*会导致错误。另请参阅有关生成约束标识符长度限制的讨论，详见[Section 11.2.1,
    “Identifier Length Limits”](identifier-length.html "11.2.1 Identifier Length Limits")。
- en: Note
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: If the `CONSTRAINT *`symbol`*` clause is not given in a foreign key definition,
    or a *`symbol`* is not included following the `CONSTRAINT` keyword, MySQL uses
    the foreign key index name up to MySQL 8.0.15, and automatically generates a constraint
    name thereafter.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果在外键定义中未给出`CONSTRAINT *`symbol`*`子句，或者在`CONSTRAINT`关键字后未包含*`symbol`*，MySQL在MySQL
    8.0.15之前使用外键索引名称，并在此后自动生成约束名称。
- en: The SQL standard specifies that all types of constraints (primary key, unique
    index, foreign key, check) belong to the same namespace. In MySQL, each constraint
    type has its own namespace per schema. Consequently, names for each type of constraint
    must be unique per schema, but constraints of different types can have the same
    name.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: SQL标准规定所有类型的约束（主键、唯一索引、外键、检查）属于同一命名空间。在MySQL中，每种约束类型在每个模式中都有自己的命名空间。因此，每种约束类型的名称必须在每个模式中保持唯一，但不同类型的约束可以具有相同的名称。
- en: '`PRIMARY KEY`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PRIMARY KEY`'
- en: A unique index where all key columns must be defined as `NOT NULL`. If they
    are not explicitly declared as `NOT NULL`, MySQL declares them so implicitly (and
    silently). A table can have only one `PRIMARY KEY`. The name of a `PRIMARY KEY`
    is always `PRIMARY`, which thus cannot be used as the name for any other kind
    of index.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 唯一索引，所有关键列必须定义为`NOT NULL`。如果它们没有明确声明为`NOT NULL`，MySQL会隐式（并悄无声息地）声明它们。一个表只能有一个`PRIMARY
    KEY`。`PRIMARY KEY`的名称始终为`PRIMARY`，因此不能用作任何其他类型索引的名称。
- en: If you do not have a `PRIMARY KEY` and an application asks for the `PRIMARY
    KEY` in your tables, MySQL returns the first `UNIQUE` index that has no `NULL`
    columns as the `PRIMARY KEY`.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果没有`PRIMARY KEY`，应用程序要求表中的`PRIMARY KEY`，MySQL将第一个没有`NULL`列的`UNIQUE`索引作为`PRIMARY
    KEY`返回。
- en: In `InnoDB` tables, keep the `PRIMARY KEY` short to minimize storage overhead
    for secondary indexes. Each secondary index entry contains a copy of the primary
    key columns for the corresponding row. (See [Section 17.6.2.1, “Clustered and
    Secondary Indexes”](innodb-index-types.html "17.6.2.1 Clustered and Secondary
    Indexes").)
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`InnoDB`表中，保持`PRIMARY KEY`简短，以减少次要索引的存储开销。每个次要索引条目都包含相应行的主键列的副本。（参见[Section 17.6.2.1,
    “Clustered and Secondary Indexes”](innodb-index-types.html "17.6.2.1 Clustered
    and Secondary Indexes")。）
- en: In the created table, a `PRIMARY KEY` is placed first, followed by all `UNIQUE`
    indexes, and then the nonunique indexes. This helps the MySQL optimizer to prioritize
    which index to use and also more quickly to detect duplicated `UNIQUE` keys.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在创建的表中，首先放置`PRIMARY KEY`，然后是所有`UNIQUE`索引，然后是非唯一索引。这有助于MySQL优化器优先考虑使用哪个索引，并更快地检测重复的`UNIQUE`键。
- en: A `PRIMARY KEY` can be a multiple-column index. However, you cannot create a
    multiple-column index using the `PRIMARY KEY` key attribute in a column specification.
    Doing so only marks that single column as primary. You must use a separate `PRIMARY
    KEY(*`key_part`*, ...)` clause.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`PRIMARY KEY`可以是多列索引。但是，您不能在列规范中使用`PRIMARY KEY`关键属性创建多列索引。这样做只会将该单列标记为主键。您必须使用单独的`PRIMARY
    KEY(*`key_part`*, ...)`子句。'
- en: If a table has a `PRIMARY KEY` or `UNIQUE NOT NULL` index that consists of a
    single column that has an integer type, you can use `_rowid` to refer to the indexed
    column in [`SELECT`](select.html "15.2.13 SELECT Statement") statements, as described
    in [Unique Indexes](create-index.html#create-index-unique "Unique Indexes").
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果表具有由整数类型组成的单列`PRIMARY KEY`或`UNIQUE NOT NULL`索引，您可以在[`SELECT`](select.html
    "15.2.13 SELECT Statement")语句中使用`_rowid`来引用索引列，如[Unique Indexes](create-index.html#create-index-unique
    "Unique Indexes")中所述。
- en: In MySQL, the name of a `PRIMARY KEY` is `PRIMARY`. For other indexes, if you
    do not assign a name, the index is assigned the same name as the first indexed
    column, with an optional suffix (`_2`, `_3`, `...`) to make it unique. You can
    see index names for a table using `SHOW INDEX FROM *`tbl_name`*`. See [Section 15.7.7.22,
    “SHOW INDEX Statement”](show-index.html "15.7.7.22 SHOW INDEX Statement").
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在MySQL中，`PRIMARY KEY`的名称是`PRIMARY`。对于其他索引，如果您没有分配名称，则该索引将被分配与第一个索引列相同的名称，并带有可选后缀（`_2`，`_3`，`...`）以使其唯一。您可以使用`SHOW
    INDEX FROM *`tbl_name`*`查看表的索引名称。参见[Section 15.7.7.22, “SHOW INDEX Statement”](show-index.html
    "15.7.7.22 SHOW INDEX Statement")。
- en: '`KEY | INDEX`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KEY | INDEX`'
- en: '`KEY` is normally a synonym for `INDEX`. The key attribute `PRIMARY KEY` can
    also be specified as just `KEY` when given in a column definition. This was implemented
    for compatibility with other database systems.'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`KEY`通常是`INDEX`的同义词。在列定义中给出时，`PRIMARY KEY`关键属性也可以简单地指定为`KEY`。这是为了与其他数据库系统兼容而实现的。'
- en: '`UNIQUE`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UNIQUE`'
- en: A `UNIQUE` index creates a constraint such that all values in the index must
    be distinct. An error occurs if you try to add a new row with a key value that
    matches an existing row. For all engines, a `UNIQUE` index permits multiple `NULL`
    values for columns that can contain `NULL`. If you specify a prefix value for
    a column in a `UNIQUE` index, the column values must be unique within the prefix
    length.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`UNIQUE`索引创建一个约束，使索引中的所有值必须是不同的。如果尝试添加具有与现有行匹配的键值的新行，则会发生错误。对于所有引擎，`UNIQUE`索引允许对可以包含`NULL`的列进行多个`NULL`值。如果为`UNIQUE`索引的列指定前缀值，则列值必须在前缀长度内是唯一的。'
- en: If a table has a `PRIMARY KEY` or `UNIQUE NOT NULL` index that consists of a
    single column that has an integer type, you can use `_rowid` to refer to the indexed
    column in [`SELECT`](select.html "15.2.13 SELECT Statement") statements, as described
    in [Unique Indexes](create-index.html#create-index-unique "Unique Indexes").
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果表具有由整数类型组成的单列`PRIMARY KEY`或`UNIQUE NOT NULL`索引，您可以在[`SELECT`](select.html
    "15.2.13 SELECT Statement")语句中使用`_rowid`来引用索引列，如[Unique Indexes](create-index.html#create-index-unique
    "Unique Indexes")中所述。
- en: '`FULLTEXT`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FULLTEXT`'
- en: A `FULLTEXT` index is a special type of index used for full-text searches. Only
    the [`InnoDB`](innodb-storage-engine.html "Chapter 17 The InnoDB Storage Engine")
    and [`MyISAM`](myisam-storage-engine.html "18.2 The MyISAM Storage Engine") storage
    engines support `FULLTEXT` indexes. They can be created only from [`CHAR`](char.html
    "13.3.2 The CHAR and VARCHAR Types"), [`VARCHAR`](char.html "13.3.2 The CHAR and
    VARCHAR Types"), and [`TEXT`](blob.html "13.3.4 The BLOB and TEXT Types") columns.
    Indexing always happens over the entire column; column prefix indexing is not
    supported and any prefix length is ignored if specified. See [Section 14.9, “Full-Text
    Search Functions”](fulltext-search.html "14.9 Full-Text Search Functions"), for
    details of operation. A `WITH PARSER` clause can be specified as an *`index_option`*
    value to associate a parser plugin with the index if full-text indexing and searching
    operations need special handling. This clause is valid only for `FULLTEXT` indexes.
    [`InnoDB`](innodb-storage-engine.html "Chapter 17 The InnoDB Storage Engine")
    and [`MyISAM`](myisam-storage-engine.html "18.2 The MyISAM Storage Engine") support
    full-text parser plugins. See [Full-Text Parser Plugins](/doc/extending-mysql/8.0/en/plugin-types.html#full-text-plugin-type)
    and [Writing Full-Text Parser Plugins](/doc/extending-mysql/8.0/en/writing-full-text-plugins.html)
    for more information.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`FULLTEXT`索引是用于全文搜索的特殊类型的索引。只有[`InnoDB`](innodb-storage-engine.html "第17章 InnoDB存储引擎")和[`MyISAM`](myisam-storage-engine.html
    "18.2 MyISAM存储引擎")存储引擎支持`FULLTEXT`索引。它们只能从[`CHAR`](char.html "第13.3.2节 CHAR和VARCHAR类型")、[`VARCHAR`](char.html
    "第13.3.2节 CHAR和VARCHAR类型")和[`TEXT`](blob.html "第13.3.4节 BLOB和TEXT类型")列创建。索引始终在整个列上进行；不支持列前缀索引，如果指定了任何前缀长度，则会被忽略。有关操作的详细信息，请参见[第14.9节，“全文搜索函数”](fulltext-search.html
    "14.9 Full-Text Search Functions")。可以指定`WITH PARSER`子句作为*`index_option`*值，以将解析器插件与索引关联，如果全文索引和搜索操作需要特殊处理。此子句仅适用于`FULLTEXT`索引。[`InnoDB`](innodb-storage-engine.html
    "第17章 InnoDB存储引擎")和[`MyISAM`](myisam-storage-engine.html "18.2 MyISAM存储引擎")支持全文解析器插件。有关更多信息，请参见[全文解析器插件](/doc/extending-mysql/8.0/zh/plugin-types.html#full-text-plugin-type)和[编写全文解析器插件](/doc/extending-mysql/8.0/zh/writing-full-text-plugins.html)。'
- en: '`SPATIAL`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`空间`'
- en: You can create `SPATIAL` indexes on spatial data types. Spatial types are supported
    only for `InnoDB` and `MyISAM` tables, and indexed columns must be declared as
    `NOT NULL`. See [Section 13.4, “Spatial Data Types”](spatial-types.html "13.4 Spatial
    Data Types").
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以在空间数据类型上创建`SPATIAL`索引。空间类型仅支持`InnoDB`和`MyISAM`表，并且索引列必须声明为`NOT NULL`。请参见[第13.4节，“空间数据类型”](spatial-types.html
    "13.4 Spatial Data Types")。
- en: '`FOREIGN KEY`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`外键`'
- en: MySQL supports foreign keys, which let you cross-reference related data across
    tables, and foreign key constraints, which help keep this spread-out data consistent.
    For definition and option information, see [*`reference_definition`*](create-table.html#create-table-reference-definition),
    and [*`reference_option`*](create-table.html#create-table-reference-option).
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: MySQL支持外键，允许您在表之间交叉引用相关数据，并支持外键约束，有助于保持这些分散数据的一致性。有关定义和选项信息，请参见[*`reference_definition`*](create-table.html#create-table-reference-definition)，以及[*`reference_option`*](create-table.html#create-table-reference-option)。
- en: Partitioned tables employing the [`InnoDB`](innodb-storage-engine.html "Chapter 17 The
    InnoDB Storage Engine") storage engine do not support foreign keys. See [Section 26.6,
    “Restrictions and Limitations on Partitioning”](partitioning-limitations.html
    "26.6 Restrictions and Limitations on Partitioning"), for more information.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用[`InnoDB`](innodb-storage-engine.html "第17章 InnoDB存储引擎")存储引擎的分区表不支持外键。有关更多信息，请参见[第26.6节，“分区的限制和限制”](partitioning-limitations.html
    "26.6 Restrictions and Limitations on Partitioning")。
- en: '`CHECK`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CHECK`'
- en: The `CHECK` clause enables the creation of constraints to be checked for data
    values in table rows. See [Section 15.1.20.6, “CHECK Constraints”](create-table-check-constraints.html
    "15.1.20.6 CHECK Constraints").
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`CHECK`子句使得可以创建用于检查表行中数据值的约束。请参见[第15.1.20.6节，“CHECK约束”](create-table-check-constraints.html
    "15.1.20.6 CHECK Constraints")。'
- en: '`*`key_part`*`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`key_part`*`'
- en: A *`key_part`* specification can end with `ASC` or `DESC` to specify whether
    index values are stored in ascending or descending order. The default is ascending
    if no order specifier is given.
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*`key_part`*规范可以以`ASC`或`DESC`结尾，以指定索引值是按升序还是降序存储。如果没有给出顺序说明符，则默认为升序。'
- en: Prefixes, defined by the *`length`* attribute, can be up to 767 bytes long for
    `InnoDB` tables that use the `[REDUNDANT](glossary.html#glos_redundant_row_format
    "redundant row format")` or `[COMPACT](glossary.html#glos_compact_row_format "compact
    row format")` row format. The prefix length limit is 3072 bytes for `InnoDB` tables
    that use the `[DYNAMIC](glossary.html#glos_dynamic_row_format "dynamic row format")`
    or `[COMPRESSED](glossary.html#glos_compressed_row_format "compressed row format")`
    row format. For `MyISAM` tables, the prefix length limit is 1000 bytes.
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前缀，由*`length`*属性定义，对于使用`[REDUNDANT](glossary.html#glos_redundant_row_format
    "冗余行格式")`或`[COMPACT](glossary.html#glos_compact_row_format "紧凑行格式")`行格式的`InnoDB`表最多可以达到767字节长。对于使用`[DYNAMIC](glossary.html#glos_dynamic_row_format
    "动态行格式")`或`[COMPRESSED](glossary.html#glos_compressed_row_format "压缩行格式")`行格式的`InnoDB`表，前缀长度限制为3072字节。对于`MyISAM`表，前缀长度限制为1000字节。
- en: Prefix *limits* are measured in bytes. However, prefix *lengths* for index specifications
    in [`CREATE TABLE`](create-table.html "15.1.20 CREATE TABLE Statement"), [`ALTER
    TABLE`](alter-table.html "15.1.9 ALTER TABLE Statement"), and [`CREATE INDEX`](create-index.html
    "15.1.15 CREATE INDEX Statement") statements are interpreted as number of characters
    for nonbinary string types ([`CHAR`](char.html "13.3.2 The CHAR and VARCHAR Types"),
    [`VARCHAR`](char.html "13.3.2 The CHAR and VARCHAR Types"), [`TEXT`](blob.html
    "13.3.4 The BLOB and TEXT Types")) and number of bytes for binary string types
    ([`BINARY`](binary-varbinary.html "13.3.3 The BINARY and VARBINARY Types"), [`VARBINARY`](binary-varbinary.html
    "13.3.3 The BINARY and VARBINARY Types"), [`BLOB`](blob.html "13.3.4 The BLOB
    and TEXT Types")). Take this into account when specifying a prefix length for
    a nonbinary string column that uses a multibyte character set.
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前缀*限制*以字节为单位。但是，在[`CREATE TABLE`](create-table.html "15.1.20 CREATE TABLE语句")、[`ALTER
    TABLE`](alter-table.html "15.1.9 ALTER TABLE语句")和[`CREATE INDEX`](create-index.html
    "15.1.15 CREATE INDEX语句")语句中的索引规范中，对于非二进制字符串类型（[`CHAR`](char.html "13.3.2 CHAR和VARCHAR类型")、[`VARCHAR`](char.html
    "13.3.2 CHAR和VARCHAR类型")、[`TEXT`](blob.html "13.3.4 BLOB和TEXT类型")），前缀*长度*被解释为字符数，对于二进制字符串类型（[`BINARY`](binary-varbinary.html
    "13.3.3 BINARY和VARBINARY类型")、[`VARBINARY`](binary-varbinary.html "13.3.3 BINARY和VARBINARY类型")、[`BLOB`](blob.html
    "13.3.4 BLOB和TEXT类型")），前缀*长度*被解释为字节数。在为使用多字节字符集的非二进制字符串列指定前缀长度时，请考虑这一点。
- en: Beginning with MySQL 8.0.17, the *`expr`* for a *`key_part`* specification can
    take the form `(CAST *`json_path`* AS *`type`* ARRAY)` to create a multi-valued
    index on a [`JSON`](json.html "13.5 The JSON Data Type") column. [Multi-Valued
    Indexes](create-index.html#create-index-multi-valued "Multi-Valued Indexes"),
    provides detailed information regarding creation of, usage of, and restrictions
    and limitations on multi-valued indexes.
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从MySQL 8.0.17开始，*`key_part`*规范的*`expr`*可以采用形式`(CAST *`json_path`* AS *`type`*
    ARRAY)`，以在[`JSON`](json.html "13.5 JSON数据类型")列上创建多值索引。[多值索引](create-index.html#create-index-multi-valued
    "多值索引")提供了有关创建、使用以及多值索引的限制和限制的详细信息。
- en: '`*`index_type`*`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`index_type`*`'
- en: Some storage engines permit you to specify an index type when creating an index.
    The syntax for the *`index_type`* specifier is `USING *`type_name`*`.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一些存储引擎允许在创建索引时指定索引类型。*`index_type`*指定符的语法是`USING *`type_name`*`。
- en: 'Example:'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例子：
- en: '[PRE8]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preferred position for `USING` is after the index column list. It can be
    given before the column list, but support for use of the option in that position
    is deprecated and you should expect it to be removed in a future MySQL release.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`USING`的首选位置是在索引列列表之后。它可以在列列表之前给出，但是在该位置使用该选项的支持已被弃用，您应该期望在未来的MySQL版本中将其移除。'
- en: '`*`index_option`*`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`index_option`*`'
- en: '*`index_option`* values specify additional options for an index.'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*`index_option`*值指定索引的附加选项。'
- en: '`KEY_BLOCK_SIZE`'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KEY_BLOCK_SIZE`'
- en: For [`MyISAM`](myisam-storage-engine.html "18.2 The MyISAM Storage Engine")
    tables, `KEY_BLOCK_SIZE` optionally specifies the size in bytes to use for index
    key blocks. The value is treated as a hint; a different size could be used if
    necessary. A `KEY_BLOCK_SIZE` value specified for an individual index definition
    overrides the table-level `KEY_BLOCK_SIZE` value.
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于[`MyISAM`](myisam-storage-engine.html "18.2 MyISAM存储引擎")表，`KEY_BLOCK_SIZE`可选地指定用于索引键块的字节大小。该值被视为提示；如果需要，可以使用不同的大小。为单个索引定义指定的`KEY_BLOCK_SIZE`值会覆盖表级别的`KEY_BLOCK_SIZE`值。
- en: For information about the table-level `KEY_BLOCK_SIZE` attribute, see [Table
    Options](create-table.html#create-table-options "Table Options").
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有关表级别`KEY_BLOCK_SIZE`属性的信息，请参阅[表选项](create-table.html#create-table-options "表选项")。
- en: '`WITH PARSER`'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WITH PARSER`'
- en: The `WITH PARSER` option can be used only with `FULLTEXT` indexes. It associates
    a parser plugin with the index if full-text indexing and searching operations
    need special handling. [`InnoDB`](innodb-storage-engine.html "Chapter 17 The InnoDB
    Storage Engine") and [`MyISAM`](myisam-storage-engine.html "18.2 The MyISAM Storage
    Engine") support full-text parser plugins. If you have a [`MyISAM`](myisam-storage-engine.html
    "18.2 The MyISAM Storage Engine") table with an associated full-text parser plugin,
    you can convert the table to `InnoDB` using `ALTER TABLE`.
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`WITH PARSER`选项只能与`FULLTEXT`索引一起使用。如果全文索引和搜索操作需要特殊处理，则将解析器插件与索引关联起来。[`InnoDB`](innodb-storage-engine.html
    "第17章 InnoDB存储引擎")和[`MyISAM`](myisam-storage-engine.html "第18.2章 MyISAM存储引擎")支持全文解析器插件。如果您有一个带有关联全文解析器插件的[`MyISAM`](myisam-storage-engine.html
    "第18.2章 MyISAM存储引擎")表，您可以使用`ALTER TABLE`将表转换为`InnoDB`。'
- en: '`COMMENT`'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COMMENT`'
- en: Index definitions can include an optional comment of up to 1024 characters.
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 索引定义可以包括最多1024个字符的可选注释。
- en: You can set the `InnoDB` `MERGE_THRESHOLD` value for an individual index using
    the `*`index_option`*` `COMMENT` clause. See [Section 17.8.11, “Configuring the
    Merge Threshold for Index Pages”](index-page-merge-threshold.html "17.8.11 Configuring
    the Merge Threshold for Index Pages").
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以使用`*`index_option`*` `COMMENT`子句为单个索引设置`InnoDB` `MERGE_THRESHOLD`值。参见[第17.8.11节，“配置索引页合并阈值”](index-page-merge-threshold.html
    "17.8.11 配置索引页合并阈值")。
- en: '`VISIBLE`, `INVISIBLE`'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VISIBLE`，`INVISIBLE`'
- en: Specify index visibility. Indexes are visible by default. An invisible index
    is not used by the optimizer. Specification of index visibility applies to indexes
    other than primary keys (either explicit or implicit). For more information, see
    [Section 10.3.12, “Invisible Indexes”](invisible-indexes.html "10.3.12 Invisible
    Indexes").
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 指定索引可见性。索引默认可见。不可见索引不会被优化器使用。索引可见性的规范适用于主键之外的索引（显式或隐式）。更多信息，请参见[第10.3.12节，“不可见索引”](invisible-indexes.html
    "10.3.12 不可见索引")。
- en: '`ENGINE_ATTRIBUTE` and `SECONDARY_ENGINE_ATTRIBUTE` options (available as of
    MySQL 8.0.21) are used to specify index attributes for primary and secondary storage
    engines. The options are reserved for future use.'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENGINE_ATTRIBUTE`和`SECONDARY_ENGINE_ATTRIBUTE`选项（自MySQL 8.0.21起可用）用于指定主要和次要存储引擎的索引属性。这些选项保留供将来使用。'
- en: For more information about permissible *`index_option`* values, see [Section 15.1.15,
    “CREATE INDEX Statement”](create-index.html "15.1.15 CREATE INDEX Statement").
    For more information about indexes, see [Section 10.3.1, “How MySQL Uses Indexes”](mysql-indexes.html
    "10.3.1 How MySQL Uses Indexes").
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有关可接受的*`index_option`*值的更多信息，请参见[第15.1.15节，“CREATE INDEX语句”](create-index.html
    "15.1.15 CREATE INDEX语句")。有关索引的更多信息，请参见[第10.3.1节，“MySQL如何使用索引”](mysql-indexes.html
    "10.3.1 MySQL如何使用索引")。
- en: '`*`reference_definition`*`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`reference_definition`*`'
- en: For *`reference_definition`* syntax details and examples, see [Section 15.1.20.5,
    “FOREIGN KEY Constraints”](create-table-foreign-keys.html "15.1.20.5 FOREIGN KEY
    Constraints").
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有关*`reference_definition`*语法详细信息和示例，请参见[第15.1.20.5节，“外键约束”](create-table-foreign-keys.html
    "15.1.20.5 外键约束")。
- en: '[`InnoDB`](innodb-storage-engine.html "Chapter 17 The InnoDB Storage Engine")
    and [`NDB`](mysql-cluster.html "Chapter 25 MySQL NDB Cluster 8.0") tables support
    checking of foreign key constraints. The columns of the referenced table must
    always be explicitly named. Both `ON DELETE` and `ON UPDATE` actions on foreign
    keys are supported. For more detailed information and examples, see [Section 15.1.20.5,
    “FOREIGN KEY Constraints”](create-table-foreign-keys.html "15.1.20.5 FOREIGN KEY
    Constraints").'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[`InnoDB`](innodb-storage-engine.html "第17章 InnoDB存储引擎")和[`NDB`](mysql-cluster.html
    "第25章 MySQL NDB Cluster 8.0")表支持检查外键约束。引用表的列必须始终明确命名。外键支持`ON DELETE`和`ON UPDATE`操作。有关更详细的信息和示例，请参见[第15.1.20.5节，“外键约束”](create-table-foreign-keys.html
    "15.1.20.5 外键约束")。'
- en: For other storage engines, MySQL Server parses and ignores the `FOREIGN KEY`
    syntax in [`CREATE TABLE`](create-table.html "15.1.20 CREATE TABLE Statement")
    statements.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于其他存储引擎，MySQL服务器会解析并忽略[`CREATE TABLE`](create-table.html "15.1.20 CREATE TABLE语句")语句中的`FOREIGN
    KEY`语法。
- en: Important
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要
- en: For users familiar with the ANSI/ISO SQL Standard, please note that no storage
    engine, including `InnoDB`, recognizes or enforces the `MATCH` clause used in
    referential integrity constraint definitions. Use of an explicit `MATCH` clause
    does not have the specified effect, and also causes `ON DELETE` and `ON UPDATE`
    clauses to be ignored. For these reasons, specifying `MATCH` should be avoided.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于熟悉 ANSI/ISO SQL 标准的用户，请注意，包括`InnoDB`在内的任何存储引擎都不识别或强制执行用于参照完整性约束定义的`MATCH`子句。明确指定`MATCH`子句不会产生指定的效果，并且还会导致`ON
    DELETE`和`ON UPDATE`子句被忽略。因此，应避免指定`MATCH`。
- en: The `MATCH` clause in the SQL standard controls how `NULL` values in a composite
    (multiple-column) foreign key are handled when comparing to a primary key. `InnoDB`
    essentially implements the semantics defined by `MATCH SIMPLE`, which permit a
    foreign key to be all or partially `NULL`. In that case, the (child table) row
    containing such a foreign key is permitted to be inserted, and does not match
    any row in the referenced (parent) table. It is possible to implement other semantics
    using triggers.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: SQL 标准中的`MATCH`子句控制如何处理复合（多列）外键中的`NULL`值与主键进行比较。`InnoDB`基本上实现了`MATCH SIMPLE`定义的语义，允许外键全部或部分为`NULL`。在这种情况下，包含这种外键的（子表）行允许被插入，并且不匹配参考（父表）中的任何行。可以使用触发器实现其他语义。
- en: Additionally, MySQL requires that the referenced columns be indexed for performance.
    However, `InnoDB` does not enforce any requirement that the referenced columns
    be declared `UNIQUE` or `NOT NULL`. The handling of foreign key references to
    nonunique keys or keys that contain `NULL` values is not well defined for operations
    such as `UPDATE` or `DELETE CASCADE`. You are advised to use foreign keys that
    reference only keys that are both `UNIQUE` (or `PRIMARY`) and `NOT NULL`.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，MySQL 要求被引用的列需要建立索引以提高性能。然而，`InnoDB`不强制要求被引用的列声明为`UNIQUE`或`NOT NULL`。对于引用非唯一键或包含`NULL`值的键的外键引用的处理在`UPDATE`或`DELETE
    CASCADE`等操作中没有明确定义。建议使用只引用既`UNIQUE`（或`PRIMARY`）又`NOT NULL`键的外键。
- en: MySQL parses but ignores “inline `REFERENCES` specifications” (as defined in
    the SQL standard) where the references are defined as part of the column specification.
    MySQL accepts `REFERENCES` clauses only when specified as part of a separate `FOREIGN
    KEY` specification. For more information, see [Section 1.6.2.3, “FOREIGN KEY Constraint
    Differences”](ansi-diff-foreign-keys.html "1.6.2.3 FOREIGN KEY Constraint Differences").
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: MySQL 解析但忽略“内联`REFERENCES`规范”（如 SQL 标准中定义的）中的引用，其中引用被定义为列规范的一部分。只有在作为单独的`FOREIGN
    KEY`规范的一部分指定时，MySQL 才接受`REFERENCES`子句。有关更多信息，请参见[Section 1.6.2.3, “FOREIGN KEY
    Constraint Differences”](ansi-diff-foreign-keys.html "1.6.2.3 FOREIGN KEY Constraint
    Differences")。
- en: '`*`reference_option`*`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`reference_option`*`'
- en: For information about the `RESTRICT`, `CASCADE`, `SET NULL`, `NO ACTION`, and
    `SET DEFAULT` options, see [Section 15.1.20.5, “FOREIGN KEY Constraints”](create-table-foreign-keys.html
    "15.1.20.5 FOREIGN KEY Constraints").
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有关`RESTRICT`、`CASCADE`、`SET NULL`、`NO ACTION`和`SET DEFAULT`选项的信息，请参见[Section 15.1.20.5,
    “FOREIGN KEY Constraints”](create-table-foreign-keys.html "15.1.20.5 FOREIGN KEY
    Constraints")。
- en: Table Options
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 表选项
- en: Table options are used to optimize the behavior of the table. In most cases,
    you do not have to specify any of them. These options apply to all storage engines
    unless otherwise indicated. Options that do not apply to a given storage engine
    may be accepted and remembered as part of the table definition. Such options then
    apply if you later use [`ALTER TABLE`](alter-table.html "15.1.9 ALTER TABLE Statement")
    to convert the table to use a different storage engine.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 表选项用于优化表的行为。在大多数情况下，您不必指定任何选项。除非另有说明，这些选项适用于所有存储引擎。不适用于给定存储引擎的选项可能会被接受并记入表定义中。如果以后使用[`ALTER
    TABLE`](alter-table.html "15.1.9 ALTER TABLE Statement")将表转换为使用不同的存储引擎，则这些选项将适用。
- en: '`ENGINE`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENGINE`'
- en: Specifies the storage engine for the table, using one of the names shown in
    the following table. The engine name can be unquoted or quoted. The quoted name
    `'DEFAULT'` is recognized but ignored.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 指定表的存储引擎，可以使用以下表中显示的名称之一。引擎名称可以是带引号或不带引号的。带引号的名称`'DEFAULT'`会被识别但会被忽略。
- en: '| Storage Engine | Description |'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 存储引擎 | 描述 |'
- en: '| `InnoDB` | Transaction-safe tables with row locking and foreign keys. The
    default storage engine for new tables. See [Chapter 17, *The InnoDB Storage Engine*](innodb-storage-engine.html
    "Chapter 17 The InnoDB Storage Engine"), and in particular [Section 17.1, “Introduction
    to InnoDB”](innodb-introduction.html "17.1 Introduction to InnoDB") if you have
    MySQL experience but are new to `InnoDB`. |'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `InnoDB` | 具有行锁定和外键的事务安全表。新表的默认存储引擎。参见[第17章，*InnoDB存储引擎*](innodb-storage-engine.html
    "第17章 InnoDB存储引擎")，特别是如果您有MySQL经验但是对`InnoDB`不熟悉，请参见[第17.1节，“InnoDB简介”](innodb-introduction.html
    "17.1 InnoDB简介")。 |'
- en: '| `MyISAM` | The binary portable storage engine that is primarily used for
    read-only or read-mostly workloads. See [Section 18.2, “The MyISAM Storage Engine”](myisam-storage-engine.html
    "18.2 The MyISAM Storage Engine"). |'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `MyISAM` | 主要用于只读或读取频繁工作负载的二进制便携式存储引擎。参见[第18.2节，“MyISAM存储引擎”](myisam-storage-engine.html
    "18.2 MyISAM存储引擎")。 |'
- en: '| `MEMORY` | The data for this storage engine is stored only in memory. See
    [Section 18.3, “The MEMORY Storage Engine”](memory-storage-engine.html "18.3 The
    MEMORY Storage Engine"). |'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `MEMORY` | 这种存储引擎的数据仅存储在内存中。参见[第18.3节，“MEMORY存储引擎”](memory-storage-engine.html
    "18.3 MEMORY存储引擎")。 |'
- en: '| `CSV` | Tables that store rows in comma-separated values format. See [Section 18.4,
    “The CSV Storage Engine”](csv-storage-engine.html "18.4 The CSV Storage Engine").
    |'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `CSV` | 以逗号分隔值格式存储行的表。参见[第18.4节，“CSV存储引擎”](csv-storage-engine.html "18.4 CSV存储引擎")。
    |'
- en: '| `ARCHIVE` | The archiving storage engine. See [Section 18.5, “The ARCHIVE
    Storage Engine”](archive-storage-engine.html "18.5 The ARCHIVE Storage Engine").
    |'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `ARCHIVE` | 存档存储引擎。参见[第18.5节，“ARCHIVE存储引擎”](archive-storage-engine.html "18.5 ARCHIVE存储引擎")。
    |'
- en: '| `EXAMPLE` | An example engine. See [Section 18.9, “The EXAMPLE Storage Engine”](example-storage-engine.html
    "18.9 The EXAMPLE Storage Engine"). |'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `EXAMPLE` | 一个示例引擎。参见[第18.9节，“EXAMPLE存储引擎”](example-storage-engine.html "18.9 EXAMPLE存储引擎")。
    |'
- en: '| `FEDERATED` | Storage engine that accesses remote tables. See [Section 18.8,
    “The FEDERATED Storage Engine”](federated-storage-engine.html "18.8 The FEDERATED
    Storage Engine"). |'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `FEDERATED` | 访问远程表的存储引擎。参见[第18.8节，“FEDERATED存储引擎”](federated-storage-engine.html
    "18.8 FEDERATED存储引擎")。 |'
- en: '| `HEAP` | This is a synonym for `MEMORY`. |'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `HEAP` | 这是`MEMORY`的同义词。 |'
- en: '| `MERGE` | A collection of `MyISAM` tables used as one table. Also known as
    `MRG_MyISAM`. See [Section 18.7, “The MERGE Storage Engine”](merge-storage-engine.html
    "18.7 The MERGE Storage Engine"). |'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `MERGE` | 一组作为一个表使用的`MyISAM`表。也称为`MRG_MyISAM`。参见[第18.7节，“MERGE存储引擎”](merge-storage-engine.html
    "18.7 MERGE存储引擎")。 |'
- en: '| [`NDB`](mysql-cluster.html "Chapter 25 MySQL NDB Cluster 8.0") | Clustered,
    fault-tolerant, memory-based tables, supporting transactions and foreign keys.
    Also known as [`NDBCLUSTER`](mysql-cluster.html "Chapter 25 MySQL NDB Cluster
    8.0"). See [Chapter 25, *MySQL NDB Cluster 8.0*](mysql-cluster.html "Chapter 25 MySQL
    NDB Cluster 8.0"). |'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| [`NDB`](mysql-cluster.html "第25章 MySQL NDB Cluster 8.0") | 集群化、容错、基于内存的表，支持事务和外键。也称为[`NDBCLUSTER`](mysql-cluster.html
    "第25章 MySQL NDB Cluster 8.0")。参见[第25章，*MySQL NDB Cluster 8.0*](mysql-cluster.html
    "第25章 MySQL NDB Cluster 8.0")。 |'
- en: '| Storage Engine | Description |'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: 存储引擎 | 描述 |
- en: By default, if a storage engine is specified that is not available, the statement
    fails with an error. You can override this behavior by removing [`NO_ENGINE_SUBSTITUTION`](sql-mode.html#sqlmode_no_engine_substitution)
    from the server SQL mode (see [Section 7.1.11, “Server SQL Modes”](sql-mode.html
    "7.1.11 Server SQL Modes")) so that MySQL allows substitution of the specified
    engine with the default storage engine instead. Normally in such cases, this is
    `InnoDB`, which is the default value for the [`default_storage_engine`](server-system-variables.html#sysvar_default_storage_engine)
    system variable. When `NO_ENGINE_SUBSTITUTION` is disabled, a warning occurs if
    the storage engine specification is not honored.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认情况下，如果指定了不可用的存储引擎，语句将失败并显示错误。您可以通过从服务器SQL模式中删除[`NO_ENGINE_SUBSTITUTION`](sql-mode.html#sqlmode_no_engine_substitution)来覆盖此行为，以便MySQL允许将指定的引擎替换为默认存储引擎。通常在这种情况下，默认值为[`default_storage_engine`](server-system-variables.html#sysvar_default_storage_engine)系统变量的`InnoDB`。当禁用`NO_ENGINE_SUBSTITUTION`时，如果未遵守存储引擎规范，则会发出警告。
- en: '`AUTOEXTEND_SIZE`'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AUTOEXTEND_SIZE`'
- en: Defines the amount by which `InnoDB` extends the size of the tablespace when
    it becomes full. Introduced in MySQL 8.0.23\. The setting must be a multiple of
    4MB. The default setting is 0, which causes the tablespace to be extended according
    to the implicit default behavior. For more information, see [Section 17.6.3.9,
    “Tablespace AUTOEXTEND_SIZE Configuration”](innodb-tablespace-autoextend-size.html
    "17.6.3.9 Tablespace AUTOEXTEND_SIZE Configuration").
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义`InnoDB`在表空间满时扩展的量。在MySQL 8.0.23中引入。设置必须是4MB的倍数。默认设置为0，这将导致表空间根据隐式默认行为进行扩展。有关更多信息，请参见[第17.6.3.9节，“表空间AUTOEXTEND_SIZE配置”](innodb-tablespace-autoextend-size.html
    "17.6.3.9 Tablespace AUTOEXTEND_SIZE Configuration")。
- en: '`AUTO_INCREMENT`'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AUTO_INCREMENT`'
- en: The initial `AUTO_INCREMENT` value for the table. In MySQL 8.0, this works for
    `MyISAM`, `MEMORY`, `InnoDB`, and `ARCHIVE` tables. To set the first auto-increment
    value for engines that do not support the `AUTO_INCREMENT` table option, insert
    a “dummy” row with a value one less than the desired value after creating the
    table, and then delete the dummy row.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表的初始`AUTO_INCREMENT`值。在MySQL 8.0中，这适用于`MyISAM`、`MEMORY`、`InnoDB`和`ARCHIVE`表。对于不支持`AUTO_INCREMENT`表选项的引擎，要设置第一个自动增量值，需要在创建表后插入一个值比所需值小1的“虚拟”行，然后删除虚拟行。
- en: For engines that support the `AUTO_INCREMENT` table option in [`CREATE TABLE`](create-table.html
    "15.1.20 CREATE TABLE Statement") statements, you can also use `ALTER TABLE *`tbl_name`*
    AUTO_INCREMENT = *`N`*` to reset the `AUTO_INCREMENT` value. The value cannot
    be set lower than the maximum value currently in the column.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于支持在[`CREATE TABLE`](create-table.html "15.1.20 CREATE TABLE Statement")语句中使用`AUTO_INCREMENT`表选项的引擎，您也可以使用`ALTER
    TABLE *`tbl_name`* AUTO_INCREMENT = *`N`*`来重置`AUTO_INCREMENT`值。该值不能低于当前列中的最大值。
- en: '`AVG_ROW_LENGTH`'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AVG_ROW_LENGTH`'
- en: An approximation of the average row length for your table. You need to set this
    only for large tables with variable-size rows.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表的平均行长度的近似值。只需为具有可变大小行的大表设置此值。
- en: When you create a `MyISAM` table, MySQL uses the product of the `MAX_ROWS` and
    `AVG_ROW_LENGTH` options to decide how big the resulting table is. If you don't
    specify either option, the maximum size for `MyISAM` data and index files is 256TB
    by default. (If your operating system does not support files that large, table
    sizes are constrained by the file size limit.) If you want to keep down the pointer
    sizes to make the index smaller and faster and you don't really need big files,
    you can decrease the default pointer size by setting the [`myisam_data_pointer_size`](server-system-variables.html#sysvar_myisam_data_pointer_size)
    system variable. (See [Section 7.1.8, “Server System Variables”](server-system-variables.html
    "7.1.8 Server System Variables").) If you want all your tables to be able to grow
    above the default limit and are willing to have your tables slightly slower and
    larger than necessary, you can increase the default pointer size by setting this
    variable. Setting the value to 7 permits table sizes up to 65,536TB.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当您创建一个`MyISAM`表时，MySQL使用`MAX_ROWS`和`AVG_ROW_LENGTH`选项的乘积来决定生成的表有多大。如果您没有指定任何选项，`MyISAM`数据和索引文件的最大大小默认为256TB。（如果您的操作系统不支持那么大的文件，表大小将受文件大小限制。）如果您想要减小指针大小以使索引更小更快，并且您实际上不需要大文件，您可以通过设置[`myisam_data_pointer_size`](server-system-variables.html#sysvar_myisam_data_pointer_size)系统变量来减小默认指针大小。（参见[第7.1.8节，“服务器系统变量”](server-system-variables.html
    "7.1.8 Server System Variables")。）如果您希望所有表都能超过默认限制增长，并且愿意让表比必要的稍慢和稍大，您可以通过设置此变量来增加默认指针大小。将值设置为7允许表大小达到65,536TB。
- en: '`[DEFAULT] CHARACTER SET`'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[DEFAULT] 字符集`'
- en: Specifies a default character set for the table. `CHARSET` is a synonym for
    `CHARACTER SET`. If the character set name is `DEFAULT`, the database character
    set is used.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为表指定默认字符集。`CHARSET`是`CHARACTER SET`的同义词。如果字符集名称为`DEFAULT`，则使用数据库字符集。
- en: '`CHECKSUM`'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`校验和`'
- en: Set this to 1 if you want MySQL to maintain a live checksum for all rows (that
    is, a checksum that MySQL updates automatically as the table changes). This makes
    the table a little slower to update, but also makes it easier to find corrupted
    tables. The [`CHECKSUM TABLE`](checksum-table.html "15.7.3.3 CHECKSUM TABLE Statement")
    statement reports the checksum. (`MyISAM` only.)
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您希望MySQL为所有行维护一个实时校验和（即MySQL在表更改时自动更新的校验和），请将此设置为1。这使得表更新稍慢，但也更容易找到损坏的表。[`CHECKSUM
    TABLE`](checksum-table.html "15.7.3.3 CHECKSUM TABLE Statement")语句报告校验和。（仅适用于`MyISAM`。）
- en: '`[DEFAULT] COLLATE`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[DEFAULT] 校对规则`'
- en: Specifies a default collation for the table.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为表指定默认排序规则。
- en: '`COMMENT`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`注释`'
- en: A comment for the table, up to 2048 characters long.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表的注释，最长可达 2048 个字符。
- en: You can set the `InnoDB` `MERGE_THRESHOLD` value for a table using the `*`table_option`*`
    `COMMENT` clause. See [Section 17.8.11, “Configuring the Merge Threshold for Index
    Pages”](index-page-merge-threshold.html "17.8.11 Configuring the Merge Threshold
    for Index Pages").
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以使用 `*`table_option`*` `COMMENT` 子句为表设置 `InnoDB` `MERGE_THRESHOLD` 值。请参阅 [Section 17.8.11,
    “Configuring the Merge Threshold for Index Pages”](index-page-merge-threshold.html
    "17.8.11 Configuring the Merge Threshold for Index Pages")。
- en: '**Setting NDB_TABLE options. ** The table comment in a `CREATE TABLE` that
    creates an `NDB` table or an [`ALTER TABLE`](alter-table.html "15.1.9 ALTER TABLE
    Statement") statement which alters one can also be used to specify one to four
    of the `NDB_TABLE` options `NOLOGGING`, `READ_BACKUP`, `PARTITION_BALANCE`, or
    `FULLY_REPLICATED` as a set of name-value pairs, separated by commas if need be,
    immediately following the string `NDB_TABLE=` that begins the quoted comment text.
    An example statement using this syntax is shown here (emphasized text):'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**设置 NDB_TABLE 选项。** 在创建 `NDB` 表的 `CREATE TABLE` 或修改一个的 [`ALTER TABLE`](alter-table.html
    "15.1.9 ALTER TABLE Statement") 语句中，表注释也可用于指定 `NDB_TABLE` 选项 `NOLOGGING`、`READ_BACKUP`、`PARTITION_BALANCE`
    或 `FULLY_REPLICATED` 中的一个到四个作为一组名称-值对，如果需要，用逗号分隔，紧随以 `NDB_TABLE=` 开头的引用注释文本。以下是使用此语法的示例语句（强调文本）：'
- en: '[PRE9]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Spaces are not permitted within the quoted string. The string is case-insensitive.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 引号字符串内不允许有空格。字符串不区分大小写。
- en: The comment is displayed as part of the output of [`SHOW CREATE TABLE`](show-create-table.html
    "15.7.7.10 SHOW CREATE TABLE Statement"). The text of the comment is also available
    as the TABLE_COMMENT column of the MySQL Information Schema [`TABLES`](information-schema-tables-table.html
    "28.3.38 The INFORMATION_SCHEMA TABLES Table") table.
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该注释将显示在 [`SHOW CREATE TABLE`](show-create-table.html "15.7.7.10 SHOW CREATE
    TABLE Statement") 的输出中。注释的文本也作为 MySQL 信息模式 [`TABLES`](information-schema-tables-table.html
    "28.3.38 The INFORMATION_SCHEMA TABLES Table") 表的 TABLE_COMMENT 列中可用。
- en: This comment syntax is also supported with [`ALTER TABLE`](alter-table.html
    "15.1.9 ALTER TABLE Statement") statements for `NDB` tables. Keep in mind that
    a table comment used with `ALTER TABLE` replaces any existing comment which the
    table might have had previously.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种注释语法也适用于 `NDB` 表的 [`ALTER TABLE`](alter-table.html "15.1.9 ALTER TABLE Statement")
    语句。请注意，与 `ALTER TABLE` 一起使用的表注释会替换表先前可能具有的任何现有注释。
- en: Setting the `MERGE_THRESHOLD` option in table comments is not supported for
    [`NDB`](mysql-cluster.html "Chapter 25 MySQL NDB Cluster 8.0") tables (it is ignored).
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不支持在表注释中设置 `MERGE_THRESHOLD` 选项用于 [`NDB`](mysql-cluster.html "Chapter 25 MySQL
    NDB Cluster 8.0") 表（将被忽略）。
- en: For complete syntax information and examples, see [Section 15.1.20.12, “Setting
    NDB Comment Options”](create-table-ndb-comment-options.html "15.1.20.12 Setting
    NDB Comment Options").
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有关完整的语法信息和示例，请参阅 [Section 15.1.20.12, “Setting NDB Comment Options”](create-table-ndb-comment-options.html
    "15.1.20.12 Setting NDB Comment Options")。
- en: '`COMPRESSION`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COMPRESSION`'
- en: The compression algorithm used for page level compression for `InnoDB` tables.
    Supported values include `Zlib`, `LZ4`, and `None`. The `COMPRESSION` attribute
    was introduced with the transparent page compression feature. Page compression
    is only supported with `InnoDB` tables that reside in [file-per-table](glossary.html#glos_file_per_table
    "file-per-table") tablespaces, and is only available on Linux and Windows platforms
    that support sparse files and hole punching. For more information, see [Section 17.9.2,
    “InnoDB Page Compression”](innodb-page-compression.html "17.9.2 InnoDB Page Compression").
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用于 `InnoDB` 表的页面级压缩的压缩算法。支持的值包括 `Zlib`、`LZ4` 和 `None`。`COMPRESSION` 属性是通过透明页面压缩功能引入的。页面压缩仅支持驻留在
    [file-per-table](glossary.html#glos_file_per_table "file-per-table") 表空间中的 `InnoDB`
    表，并且仅在支持稀疏文件和孔打孔的 Linux 和 Windows 平台上可用。有关更多信息，请参阅 [Section 17.9.2, “InnoDB Page
    Compression”](innodb-page-compression.html "17.9.2 InnoDB Page Compression")。
- en: '`CONNECTION`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONNECTION`'
- en: The connection string for a `FEDERATED` table.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`FEDERATED` 表的连接字符串。'
- en: Note
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Older versions of MySQL used a `COMMENT` option for the connection string.
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 旧版本的 MySQL 使用 `COMMENT` 选项作为连接字符串的注释。
- en: '`DATA DIRECTORY`, `INDEX DIRECTORY`'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DATA DIRECTORY`、`INDEX DIRECTORY`'
- en: For `InnoDB`, the `DATA DIRECTORY='*`directory`*'` clause permits creating tables
    outside of the data directory. The [`innodb_file_per_table`](innodb-parameters.html#sysvar_innodb_file_per_table)
    variable must be enabled to use the `DATA DIRECTORY` clause. The full directory
    path must be specified. As of MySQL 8.0.21, the directory specified must be known
    to `InnoDB`. For more information, see [Section 17.6.1.2, “Creating Tables Externally”](innodb-create-table-external.html
    "17.6.1.2 Creating Tables Externally").
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于`InnoDB`，`DATA DIRECTORY='*`目录`*'`子句允许在数据目录之外创建表。必须启用[`innodb_file_per_table`](innodb-parameters.html#sysvar_innodb_file_per_table)变量才能使用`DATA
    DIRECTORY`子句。必须指定完整的目录路径。截至MySQL 8.0.21，指定的目录必须为`InnoDB`所知。有关更多信息，请参阅[第17.6.1.2节，“外部创建表”](innodb-create-table-external.html
    "17.6.1.2 外部创建表")。
- en: When creating `MyISAM` tables, you can use the `DATA DIRECTORY='*`directory`*'`
    clause, the `INDEX DIRECTORY='*`directory`*'` clause, or both. They specify where
    to put a `MyISAM` table's data file and index file, respectively. Unlike `InnoDB`
    tables, MySQL does not create subdirectories that correspond to the database name
    when creating a `MyISAM` table with a `DATA DIRECTORY` or `INDEX DIRECTORY` option.
    Files are created in the directory that is specified.
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在创建`MyISAM`表时，可以使用`DATA DIRECTORY='*`目录`*'`子句，`INDEX DIRECTORY='*`目录`*'`子句，或两者。它们分别指定`MyISAM`表的数据文件和索引文件放置的位置。与`InnoDB`表不同，当使用`DATA
    DIRECTORY`或`INDEX DIRECTORY`选项创建`MyISAM`表时，MySQL不会创建与数据库名称对应的子目录。文件将在指定的目录中创建。
- en: You must have the [`FILE`](privileges-provided.html#priv_file) privilege to
    use the `DATA DIRECTORY` or `INDEX DIRECTORY` table option.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您必须具有[`FILE`](privileges-provided.html#priv_file)权限才能使用`DATA DIRECTORY`或`INDEX
    DIRECTORY`表选项。
- en: Important
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要
- en: 'Table-level `DATA DIRECTORY` and `INDEX DIRECTORY` options are ignored for
    partitioned tables. (Bug #32091)'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '对于分区表，将忽略表级`DATA DIRECTORY`和`INDEX DIRECTORY`选项。（Bug #32091）'
- en: These options work only when you are not using the [`--skip-symbolic-links`](server-options.html#option_mysqld_symbolic-links)
    option. Your operating system must also have a working, thread-safe `realpath()`
    call. See [Section 10.12.2.2, “Using Symbolic Links for MyISAM Tables on Unix”](symbolic-links-to-tables.html
    "10.12.2.2 Using Symbolic Links for MyISAM Tables on Unix"), for more complete
    information.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 仅当您未使用[`--skip-symbolic-links`](server-options.html#option_mysqld_symbolic-links)选项时，这些选项才有效。您的操作系统还必须具有可用的、线程安全的`realpath()`调用。有关更完整的信息，请参阅[第10.12.2.2节，“在Unix上为MyISAM表使用符号链接”](symbolic-links-to-tables.html
    "10.12.2.2 在Unix上为MyISAM表使用符号链接")。
- en: If a `MyISAM` table is created with no `DATA DIRECTORY` option, the `.MYD` file
    is created in the database directory. By default, if `MyISAM` finds an existing
    `.MYD` file in this case, it overwrites it. The same applies to `.MYI` files for
    tables created with no `INDEX DIRECTORY` option. To suppress this behavior, start
    the server with the [`--keep_files_on_create`](server-system-variables.html#sysvar_keep_files_on_create)
    option, in which case `MyISAM` does not overwrite existing files and returns an
    error instead.
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果使用没有`DATA DIRECTORY`选项创建`MyISAM`表，则`.MYD`文件将在数据库目录中创建。默认情况下，如果`MyISAM`在这种情况下找到现有的`.MYD`文件，则会覆盖它。对于使用没有`INDEX
    DIRECTORY`选项创建的表的`.MYI`文件也适用相同规则。要抑制此行为，请使用[`--keep_files_on_create`](server-system-variables.html#sysvar_keep_files_on_create)选项启动服务器，在这种情况下，`MyISAM`不会覆盖现有文件，而是返回错误。
- en: If a `MyISAM` table is created with a `DATA DIRECTORY` or `INDEX DIRECTORY`
    option and an existing `.MYD` or `.MYI` file is found, `MyISAM` always returns
    an error, and does not overwrite a file in the specified directory.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果使用`DATA DIRECTORY`或`INDEX DIRECTORY`选项创建`MyISAM`表，并且找到现有的`.MYD`或`.MYI`文件，`MyISAM`将始终返回错误，并且不会覆盖指定目录中的文件。
- en: Important
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要
- en: 'You cannot use path names that contain the MySQL data directory with `DATA
    DIRECTORY` or `INDEX DIRECTORY`. This includes partitioned tables and individual
    table partitions. (See Bug #32167.)'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '您不能使用包含MySQL数据目录的路径名与`DATA DIRECTORY`或`INDEX DIRECTORY`一起使用。这包括分区表和单个表分区。（参见Bug
    #32167。）'
- en: '`DELAY_KEY_WRITE`'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELAY_KEY_WRITE`'
- en: Set this to 1 if you want to delay key updates for the table until the table
    is closed. See the description of the [`delay_key_write`](server-system-variables.html#sysvar_delay_key_write)
    system variable in [Section 7.1.8, “Server System Variables”](server-system-variables.html
    "7.1.8 Server System Variables"). (`MyISAM` only.)
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您希望延迟表的键更新直到表关闭，请将此设置为1。请参阅[第7.1.8节，“服务器系统变量”](server-system-variables.html
    "7.1.8 服务器系统变量")中的[`delay_key_write`](server-system-variables.html#sysvar_delay_key_write)系统变量的描述。（仅适用于`MyISAM`。）
- en: '`ENCRYPTION`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENCRYPTION`'
- en: The `ENCRYPTION` clause enables or disables page-level data encryption for an
    `InnoDB` table. A keyring plugin must be installed and configured before encryption
    can be enabled. Prior to MySQL 8.0.16, the `ENCRYPTION` clause can only be specified
    when creating a table in an a file-per-table tablespace. As of MySQL 8.0.16, the
    `ENCRYPTION` clause can also be specified when creating a table in a general tablespace.
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ENCRYPTION`子句用于启用或禁用`InnoDB`表的页面级数据加密。必须在启用加密之前安装和配置密钥环插件。在MySQL 8.0.16之前，只能在每个表的表空间中创建表时指定`ENCRYPTION`子句。从MySQL
    8.0.16开始，也可以在通用表空间中创建表时指定`ENCRYPTION`子句。'
- en: As of MySQL 8.0.16, a table inherits the default schema encryption if an `ENCRYPTION`
    clause is not specified. If the [`table_encryption_privilege_check`](server-system-variables.html#sysvar_table_encryption_privilege_check)
    variable is enabled, the [`TABLE_ENCRYPTION_ADMIN`](privileges-provided.html#priv_table-encryption-admin)
    privilege is required to create a table with an `ENCRYPTION` clause setting that
    differs from the default schema encryption. When creating a table in a general
    tablespace, table and tablespace encryption must match.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 截至MySQL 8.0.16，如果未指定`ENCRYPTION`子句，表将继承默认的模式加密。如果启用了[`table_encryption_privilege_check`](server-system-variables.html#sysvar_table_encryption_privilege_check)变量，则需要[`TABLE_ENCRYPTION_ADMIN`](privileges-provided.html#priv_table-encryption-admin)权限才能创建具有与默认模式加密不同的`ENCRYPTION`子句设置的表。在通用表空间中创建表时，表和表空间加密必须匹配。
- en: As of MySQL 8.0.16, specifying an `ENCRYPTION` clause with a value other than
    `'N'` or `''` is not permitted when using a storage engine that does not support
    encryption. Previously, the clause was accepted.
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从MySQL 8.0.16开始，在使用不支持加密的存储引擎时，不允许指定值为`'N'`或`''`以外的`ENCRYPTION`子句。以前，该子句被接受。
- en: For more information, see [Section 17.13, “InnoDB Data-at-Rest Encryption”](innodb-data-encryption.html
    "17.13 InnoDB Data-at-Rest Encryption").
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有关更多信息，请参见[第17.13节，“InnoDB数据静态加密”](innodb-data-encryption.html "17.13 InnoDB
    Data-at-Rest Encryption")。
- en: '`ENGINE_ATTRIBUTE` and `SECONDARY_ENGINE_ATTRIBUTE` options (available as of
    MySQL 8.0.21) are used to specify table attributes for primary and secondary storage
    engines. The options are reserved for future use.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENGINE_ATTRIBUTE`和`SECONDARY_ENGINE_ATTRIBUTE`选项（自MySQL 8.0.21起可用）用于指定主存储引擎和次要存储引擎的表属性。这些选项保留供将来使用。'
- en: Permitted values are a string literal containing a valid `JSON` document or
    an empty string (''). Invalid `JSON` is rejected.
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 允许的值是包含有效`JSON`文档的字符串文字或空字符串（''）。无效的`JSON`会被拒绝。
- en: '[PRE10]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`ENGINE_ATTRIBUTE` and `SECONDARY_ENGINE_ATTRIBUTE` values can be repeated
    without error. In this case, the last specified value is used.'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ENGINE_ATTRIBUTE`和`SECONDARY_ENGINE_ATTRIBUTE`值可以重复而不会出错。在这种情况下，将使用最后指定的值。'
- en: '`ENGINE_ATTRIBUTE` and `SECONDARY_ENGINE_ATTRIBUTE` values are not checked
    by the server, nor are they cleared when the table''s storage engine is changed.'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 服务器不会检查`ENGINE_ATTRIBUTE`和`SECONDARY_ENGINE_ATTRIBUTE`值，也不会在更改表的存储引擎时清除这些值。
- en: '`INSERT_METHOD`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INSERT_METHOD`'
- en: If you want to insert data into a `MERGE` table, you must specify with `INSERT_METHOD`
    the table into which the row should be inserted. `INSERT_METHOD` is an option
    useful for `MERGE` tables only. Use a value of `FIRST` or `LAST` to have inserts
    go to the first or last table, or a value of `NO` to prevent inserts. See [Section 18.7,
    “The MERGE Storage Engine”](merge-storage-engine.html "18.7 The MERGE Storage
    Engine").
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果要向`MERGE`表插入数据，必须使用`INSERT_METHOD`指定要将行插入的表。`INSERT_METHOD`仅适用于`MERGE`表的选项。使用`FIRST`或`LAST`的值将插入到第一个或最后一个表中，使用`NO`的值将阻止插入。请参见[第18.7节，“MERGE存储引擎”](merge-storage-engine.html
    "18.7 The MERGE Storage Engine")。
- en: '`KEY_BLOCK_SIZE`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KEY_BLOCK_SIZE`'
- en: For [`MyISAM`](myisam-storage-engine.html "18.2 The MyISAM Storage Engine")
    tables, `KEY_BLOCK_SIZE` optionally specifies the size in bytes to use for index
    key blocks. The value is treated as a hint; a different size could be used if
    necessary. A `KEY_BLOCK_SIZE` value specified for an individual index definition
    overrides the table-level `KEY_BLOCK_SIZE` value.
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于[`MyISAM`](myisam-storage-engine.html "18.2 The MyISAM Storage Engine")表，`KEY_BLOCK_SIZE`可选地指定用于索引键块的字节大小。该值被视为提示；如果需要，可以使用不同的大小。为单个索引定义指定的`KEY_BLOCK_SIZE`值会覆盖表级别的`KEY_BLOCK_SIZE`值。
- en: For [`InnoDB`](innodb-storage-engine.html "Chapter 17 The InnoDB Storage Engine")
    tables, `KEY_BLOCK_SIZE` specifies the [page](glossary.html#glos_page "page")
    size in kilobytes to use for [compressed](glossary.html#glos_compression "compression")
    `InnoDB` tables. The `KEY_BLOCK_SIZE` value is treated as a hint; a different
    size could be used by `InnoDB` if necessary. `KEY_BLOCK_SIZE` can only be less
    than or equal to the [`innodb_page_size`](innodb-parameters.html#sysvar_innodb_page_size)
    value. A value of 0 represents the default compressed page size, which is half
    of the [`innodb_page_size`](innodb-parameters.html#sysvar_innodb_page_size) value.
    Depending on [`innodb_page_size`](innodb-parameters.html#sysvar_innodb_page_size),
    possible `KEY_BLOCK_SIZE` values include 0, 1, 2, 4, 8, and 16\. See [Section 17.9.1,
    “InnoDB Table Compression”](innodb-table-compression.html "17.9.1 InnoDB Table
    Compression") for more information.
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于[`InnoDB`](innodb-storage-engine.html "Chapter 17 The InnoDB Storage Engine")表，`KEY_BLOCK_SIZE`指定了用于[压缩](glossary.html#glos_compression
    "compression")`InnoDB`表的[页](glossary.html#glos_page "page")大小（以千字节为单位）。`KEY_BLOCK_SIZE`值被视为提示；如果必要，`InnoDB`可能会使用不同的大小。`KEY_BLOCK_SIZE`只能小于或等于[`innodb_page_size`](innodb-parameters.html#sysvar_innodb_page_size)值。值为0表示默认的压缩页大小，即[`innodb_page_size`](innodb-parameters.html#sysvar_innodb_page_size)值的一半。根据[`innodb_page_size`](innodb-parameters.html#sysvar_innodb_page_size)，可能的`KEY_BLOCK_SIZE`值包括0、1、2、4、8和16。更多信息请参见[Section 17.9.1,
    “InnoDB Table Compression”](innodb-table-compression.html "17.9.1 InnoDB Table
    Compression")。
- en: Oracle recommends enabling [`innodb_strict_mode`](innodb-parameters.html#sysvar_innodb_strict_mode)
    when specifying `KEY_BLOCK_SIZE` for `InnoDB` tables. When [`innodb_strict_mode`](innodb-parameters.html#sysvar_innodb_strict_mode)
    is enabled, specifying an invalid `KEY_BLOCK_SIZE` value returns an error. If
    [`innodb_strict_mode`](innodb-parameters.html#sysvar_innodb_strict_mode) is disabled,
    an invalid `KEY_BLOCK_SIZE` value results in a warning, and the `KEY_BLOCK_SIZE`
    option is ignored.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Oracle建议在为`InnoDB`表指定`KEY_BLOCK_SIZE`时启用[`innodb_strict_mode`](innodb-parameters.html#sysvar_innodb_strict_mode)。当启用[`innodb_strict_mode`](innodb-parameters.html#sysvar_innodb_strict_mode)时，指定无效的`KEY_BLOCK_SIZE`值会返回错误。如果禁用[`innodb_strict_mode`](innodb-parameters.html#sysvar_innodb_strict_mode)，无效的`KEY_BLOCK_SIZE`值会导致警告，并且`KEY_BLOCK_SIZE`选项会被忽略。
- en: The `Create_options` column in response to [`SHOW TABLE STATUS`](show-table-status.html
    "15.7.7.38 SHOW TABLE STATUS Statement") reports the actual `KEY_BLOCK_SIZE` used
    by the table, as does [`SHOW CREATE TABLE`](show-create-table.html "15.7.7.10 SHOW
    CREATE TABLE Statement").
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于[`SHOW TABLE STATUS`](show-table-status.html "15.7.7.38 SHOW TABLE STATUS
    Statement")响应中的`Create_options`列报告表实际使用的`KEY_BLOCK_SIZE`，[`SHOW CREATE TABLE`](show-create-table.html
    "15.7.7.10 SHOW CREATE TABLE Statement")也是如此。
- en: '`InnoDB` only supports `KEY_BLOCK_SIZE` at the table level.'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`InnoDB`仅支持表级别的`KEY_BLOCK_SIZE`。'
- en: '`KEY_BLOCK_SIZE` is not supported with 32KB and 64KB [`innodb_page_size`](innodb-parameters.html#sysvar_innodb_page_size)
    values. `InnoDB` table compression does not support these pages sizes.'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`KEY_BLOCK_SIZE`不支持32KB和64KB的[`innodb_page_size`](innodb-parameters.html#sysvar_innodb_page_size)值。`InnoDB`表压缩不支持这些页大小。'
- en: '`InnoDB` does not support the `KEY_BLOCK_SIZE` option when creating temporary
    tables.'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在创建临时表时，`InnoDB`不支持`KEY_BLOCK_SIZE`选项。
- en: '`MAX_ROWS`'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MAX_ROWS`'
- en: The maximum number of rows you plan to store in the table. This is not a hard
    limit, but rather a hint to the storage engine that the table must be able to
    store at least this many rows.
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您计划存储在表中的最大行数。这不是一个硬限制，而是一个提示，告诉存储引擎表必须至少能够存储这么多行。
- en: Important
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要
- en: The use of `MAX_ROWS` with `NDB` tables to control the number of table partitions
    is deprecated. It remains supported in later versions for backward compatibility,
    but is subject to removal in a future release. Use PARTITION_BALANCE instead;
    see [Setting NDB_TABLE options](create-table.html#create-table-comment-ndb-table-options
    "Setting NDB_TABLE options").
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`MAX_ROWS`来控制表分区数量的`NDB`表已被弃用。为了向后兼容，它在后续版本中仍然受支持，但可能在未来的版本中被移除。请改用PARTITION_BALANCE；参见[设置NDB_TABLE选项](create-table.html#create-table-comment-ndb-table-options
    "Setting NDB_TABLE options")。
- en: The [`NDB`](mysql-cluster.html "Chapter 25 MySQL NDB Cluster 8.0") storage engine
    treats this value as a maximum. If you plan to create very large NDB Cluster tables
    (containing millions of rows), you should use this option to insure that [`NDB`](mysql-cluster.html
    "Chapter 25 MySQL NDB Cluster 8.0") allocates sufficient number of index slots
    in the hash table used for storing hashes of the table's primary keys by setting
    `MAX_ROWS = 2 * *`rows`*`, where *`rows`* is the number of rows that you expect
    to insert into the table.
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[`NDB`](mysql-cluster.html "第25章 MySQL NDB Cluster 8.0")存储引擎将此值视为最大值。如果计划创建非常大的NDB
    Cluster表（包含数百万行），应使用此选项确保[`NDB`](mysql-cluster.html "第25章 MySQL NDB Cluster 8.0")为存储表主键哈希的哈希表分配足够数量的索引槽，方法是设置`MAX_ROWS
    = 2 * *`rows`*`，其中*`rows`*是您预计插入表中的行数。'
- en: The maximum `MAX_ROWS` value is 4294967295; larger values are truncated to this
    limit.
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最大的`MAX_ROWS`值为4294967295；更大的值将被截断为此限制。
- en: '`MIN_ROWS`'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MIN_ROWS`'
- en: The minimum number of rows you plan to store in the table. The [`MEMORY`](memory-storage-engine.html
    "18.3 The MEMORY Storage Engine") storage engine uses this option as a hint about
    memory use.
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您计划在表中存储的最小行数。[`MEMORY`](memory-storage-engine.html "18.3 MEMORY存储引擎")存储引擎将此选项用作有关内存使用的提示。
- en: '`PACK_KEYS`'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PACK_KEYS`'
- en: Takes effect only with `MyISAM` tables. Set this option to 1 if you want to
    have smaller indexes. This usually makes updates slower and reads faster. Setting
    the option to 0 disables all packing of keys. Setting it to `DEFAULT` tells the
    storage engine to pack only long [`CHAR`](char.html "13.3.2 The CHAR and VARCHAR
    Types"), [`VARCHAR`](char.html "13.3.2 The CHAR and VARCHAR Types"), [`BINARY`](binary-varbinary.html
    "13.3.3 The BINARY and VARBINARY Types"), or [`VARBINARY`](binary-varbinary.html
    "13.3.3 The BINARY and VARBINARY Types") columns.
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 仅对`MyISAM`表生效。如果想要更小的索引，请将此选项设置为1。通常这会使更新变慢，读取变快。将选项设置为0会禁用所有键的压缩。将其设置为`DEFAULT`会告诉存储引擎只压缩长的[`CHAR`](char.html
    "13.3.2 CHAR和VARCHAR类型")、[`VARCHAR`](char.html "13.3.2 CHAR和VARCHAR类型")、[`BINARY`](binary-varbinary.html
    "13.3.3 BINARY和VARBINARY类型")或[`VARBINARY`](binary-varbinary.html "13.3.3 BINARY和VARBINARY类型")列。
- en: If you do not use `PACK_KEYS`, the default is to pack strings, but not numbers.
    If you use `PACK_KEYS=1`, numbers are packed as well.
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果不使用`PACK_KEYS`，默认情况下会压缩字符串，但不会压缩数字。如果使用`PACK_KEYS=1`，数字也会被压缩。
- en: 'When packing binary number keys, MySQL uses prefix compression:'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在压缩二进制数字键时，MySQL使用前缀压缩：
- en: Every key needs one extra byte to indicate how many bytes of the previous key
    are the same for the next key.
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个键需要额外一个字节来指示前一个键的多少个字节与下一个键相同。
- en: The pointer to the row is stored in high-byte-first order directly after the
    key, to improve compression.
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向行的指针以高字节优先顺序直接存储在键后面，以提高压缩效果。
- en: This means that if you have many equal keys on two consecutive rows, all following
    “same” keys usually only take two bytes (including the pointer to the row). Compare
    this to the ordinary case where the following keys takes `storage_size_for_key
    + pointer_size` (where the pointer size is usually 4). Conversely, you get a significant
    benefit from prefix compression only if you have many numbers that are the same.
    If all keys are totally different, you use one byte more per key, if the key is
    not a key that can have `NULL` values. (In this case, the packed key length is
    stored in the same byte that is used to mark if a key is `NULL`.)
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着如果在两个连续行上有许多相同的键，通常后续的“相同”键只需要两个字节（包括指向行的指针）。与普通情况下后续键需要`storage_size_for_key
    + pointer_size`（其中指针大小通常为4）相比，如果有许多相同的数字，则通过前缀压缩可以获得显著的好处。如果所有键都完全不同，每个键会多使用一个字节，如果键不是可以有`NULL`值的键。在这种情况下，压缩的键长度存储在用于标记键是否为`NULL`的同一个字节中。
- en: '`PASSWORD`'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PASSWORD`'
- en: This option is unused.
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此选项未使用。
- en: '`ROW_FORMAT`'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ROW_FORMAT`'
- en: Defines the physical format in which the rows are stored.
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义了行存储的物理格式。
- en: When creating a table with [strict mode](glossary.html#glos_strict_mode "strict
    mode") disabled, the storage engine's default row format is used if the specified
    row format is not supported. The actual row format of the table is reported in
    the `Row_format` column in response to [`SHOW TABLE STATUS`](show-table-status.html
    "15.7.7.38 SHOW TABLE STATUS Statement"). The `Create_options` column shows the
    row format that was specified in the [`CREATE TABLE`](create-table.html "15.1.20 CREATE
    TABLE Statement") statement, as does [`SHOW CREATE TABLE`](show-create-table.html
    "15.7.7.10 SHOW CREATE TABLE Statement").
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在禁用[严格模式](glossary.html#glos_strict_mode "strict mode")时创建表时，如果指定的行格式不受支持，则使用存储引擎的默认行格式。表的实际行格式将在响应[`SHOW
    TABLE STATUS`](show-table-status.html "15.7.7.38 SHOW TABLE STATUS Statement")时的`Row_format`列中报告。`Create_options`列显示了在[`CREATE
    TABLE`](create-table.html "15.1.20 CREATE TABLE Statement")语句中指定的行格式，[`SHOW CREATE
    TABLE`](show-create-table.html "15.7.7.10 SHOW CREATE TABLE Statement")也是如此。
- en: Row format choices differ depending on the storage engine used for the table.
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表使用的行格式取决于用于表的存储引擎。
- en: 'For `InnoDB` tables:'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于`InnoDB`表：
- en: The default row format is defined by [`innodb_default_row_format`](innodb-parameters.html#sysvar_innodb_default_row_format),
    which has a default setting of `DYNAMIC`. The default row format is used when
    the `ROW_FORMAT` option is not defined or when `ROW_FORMAT=DEFAULT` is used.
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认行格式由[`innodb_default_row_format`](innodb-parameters.html#sysvar_innodb_default_row_format)定义，其默认设置为`DYNAMIC`。当未定义`ROW_FORMAT`选项或使用`ROW_FORMAT=DEFAULT`时，将使用默认行格式。
- en: If the `ROW_FORMAT` option is not defined, or if `ROW_FORMAT=DEFAULT` is used,
    operations that rebuild a table also silently change the row format of the table
    to the default defined by [`innodb_default_row_format`](innodb-parameters.html#sysvar_innodb_default_row_format).
    For more information, see [Defining the Row Format of a Table](innodb-row-format.html#innodb-row-format-defining
    "Defining the Row Format of a Table").
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果未定义`ROW_FORMAT`选项，或者使用`ROW_FORMAT=DEFAULT`，重建表的操作也会将表的行格式悄悄地更改为由[`innodb_default_row_format`](innodb-parameters.html#sysvar_innodb_default_row_format)定义的默认值。有关更多信息，请参见[定义表的行格式](innodb-row-format.html#innodb-row-format-defining
    "Defining the Row Format of a Table")。
- en: For more efficient `InnoDB` storage of data types, especially [`BLOB`](blob.html
    "13.3.4 The BLOB and TEXT Types") types, use the `DYNAMIC`. See [DYNAMIC Row Format](innodb-row-format.html#innodb-row-format-dynamic
    "DYNAMIC Row Format") for requirements associated with the `DYNAMIC` row format.
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了更有效地存储数据类型，特别是[`BLOB`](blob.html "13.3.4 The BLOB and TEXT Types")类型，使用`DYNAMIC`。有关与`DYNAMIC`行格式相关的要求，请参见[DYNAMIC行格式](innodb-row-format.html#innodb-row-format-dynamic
    "DYNAMIC Row Format")。
- en: To enable compression for `InnoDB` tables, specify `ROW_FORMAT=COMPRESSED`.
    The `ROW_FORMAT=COMPRESSED` option is not supported when creating temporary tables.
    See [Section 17.9, “InnoDB Table and Page Compression”](innodb-compression.html
    "17.9 InnoDB Table and Page Compression") for requirements associated with the
    `COMPRESSED` row format.
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要为`InnoDB`表启用压缩，请指定`ROW_FORMAT=COMPRESSED`。在创建临时表时，不支持`ROW_FORMAT=COMPRESSED`选项。有关与`COMPRESSED`行格式相关的要求，请参见[第17.9节，“InnoDB表和页面压缩”](innodb-compression.html
    "17.9 InnoDB表和页面压缩")。
- en: The row format used in older versions of MySQL can still be requested by specifying
    the `REDUNDANT` row format.
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旧版本的MySQL中使用的行格式仍可通过指定`REDUNDANT`行格式来请求。
- en: When you specify a non-default `ROW_FORMAT` clause, consider also enabling the
    [`innodb_strict_mode`](innodb-parameters.html#sysvar_innodb_strict_mode) configuration
    option.
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当指定非默认的`ROW_FORMAT`子句时，考虑同时启用[`innodb_strict_mode`](innodb-parameters.html#sysvar_innodb_strict_mode)配置选项。
- en: '`ROW_FORMAT=FIXED` is not supported. If `ROW_FORMAT=FIXED` is specified while
    [`innodb_strict_mode`](innodb-parameters.html#sysvar_innodb_strict_mode) is disabled,
    `InnoDB` issues a warning and assumes `ROW_FORMAT=DYNAMIC`. If `ROW_FORMAT=FIXED`
    is specified while [`innodb_strict_mode`](innodb-parameters.html#sysvar_innodb_strict_mode)
    is enabled, which is the default, `InnoDB` returns an error.'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持`ROW_FORMAT=FIXED`。如果在禁用[`innodb_strict_mode`](innodb-parameters.html#sysvar_innodb_strict_mode)的情况下指定了`ROW_FORMAT=FIXED`，`InnoDB`会发出警告并假定`ROW_FORMAT=DYNAMIC`。如果在启用[`innodb_strict_mode`](innodb-parameters.html#sysvar_innodb_strict_mode)（默认情况下）的情况下指定了`ROW_FORMAT=FIXED`，`InnoDB`会返回错误。
- en: For additional information about `InnoDB` row formats, see [Section 17.10, “InnoDB
    Row Formats”](innodb-row-format.html "17.10 InnoDB Row Formats").
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`InnoDB`行格式的更多信息，请参见[第17.10节，“InnoDB行格式”](innodb-row-format.html "17.10 InnoDB行格式")。
- en: For `MyISAM` tables, the option value can be `FIXED` or `DYNAMIC` for static
    or variable-length row format. [**myisampack**](myisampack.html "6.6.6 myisampack
    — Generate Compressed, Read-Only MyISAM Tables") sets the type to `COMPRESSED`.
    See [Section 18.2.3, “MyISAM Table Storage Formats”](myisam-table-formats.html
    "18.2.3 MyISAM Table Storage Formats").
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于`MyISAM`表，选项值可以是`FIXED`或`DYNAMIC`，用于静态或变长行格式。[**myisampack**](myisampack.html
    "6.6.6 myisampack — Generate Compressed, Read-Only MyISAM Tables")将类型设置为`COMPRESSED`。请参见[Section 18.2.3,
    “MyISAM Table Storage Formats”](myisam-table-formats.html "18.2.3 MyISAM Table
    Storage Formats")。
- en: For [`NDB`](mysql-cluster.html "Chapter 25 MySQL NDB Cluster 8.0") tables, the
    default `ROW_FORMAT` is `DYNAMIC`.
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于[`NDB`](mysql-cluster.html "Chapter 25 MySQL NDB Cluster 8.0")表，默认的`ROW_FORMAT`是`DYNAMIC`。
- en: '`START TRANSACTION`'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`START TRANSACTION`'
- en: This is an internal-use table option. It was introduced in MySQL 8.0.21 to permit
    `CREATE TABLE ... SELECT` to be logged as a single, atomic transaction in the
    binary log when using row-based replication with a storage engine that supports
    atomic DDL. Only [`BINLOG`](binlog.html "15.7.8.1 BINLOG Statement"), [`COMMIT`](commit.html
    "15.3.1 START TRANSACTION, COMMIT, and ROLLBACK Statements"), and [`ROLLBACK`](commit.html
    "15.3.1 START TRANSACTION, COMMIT, and ROLLBACK Statements") statements are permitted
    after `CREATE TABLE ... START TRANSACTION`. For related information, see [Section 15.1.1,
    “Atomic Data Definition Statement Support”](atomic-ddl.html "15.1.1 Atomic Data
    Definition Statement Support").
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个内部使用的表选项。它在MySQL 8.0.21中引入，允许将`CREATE TABLE ... SELECT`作为单个原子事务记录在二进制日志中，当使用支持原子DDL的存储引擎进行基于行的复制时。在`CREATE
    TABLE ... START TRANSACTION`之后只允许[`BINLOG`](binlog.html "15.7.8.1 BINLOG Statement")、[`COMMIT`](commit.html
    "15.3.1 START TRANSACTION, COMMIT, and ROLLBACK Statements")和[`ROLLBACK`](commit.html
    "15.3.1 START TRANSACTION, COMMIT, and ROLLBACK Statements")语句。有关相关信息，请参见[Section 15.1.1,
    “Atomic Data Definition Statement Support”](atomic-ddl.html "15.1.1 Atomic Data
    Definition Statement Support")。
- en: '`STATS_AUTO_RECALC`'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STATS_AUTO_RECALC`'
- en: Specifies whether to automatically recalculate [persistent statistics](glossary.html#glos_persistent_statistics
    "persistent statistics") for an `InnoDB` table. The value `DEFAULT` causes the
    persistent statistics setting for the table to be determined by the [`innodb_stats_auto_recalc`](innodb-parameters.html#sysvar_innodb_stats_auto_recalc)
    configuration option. The value `1` causes statistics to be recalculated when
    10% of the data in the table has changed. The value `0` prevents automatic recalculation
    for this table; with this setting, issue an [`ANALYZE TABLE`](analyze-table.html
    "15.7.3.1 ANALYZE TABLE Statement") statement to recalculate the statistics after
    making substantial changes to the table. For more information about the persistent
    statistics feature, see [Section 17.8.10.1, “Configuring Persistent Optimizer
    Statistics Parameters”](innodb-persistent-stats.html "17.8.10.1 Configuring Persistent
    Optimizer Statistics Parameters").
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 指定是否自动重新计算`InnoDB`表的[持久性统计信息](glossary.html#glos_persistent_statistics "persistent
    statistics")。值`DEFAULT`会导致表的持久性统计设置由[`innodb_stats_auto_recalc`](innodb-parameters.html#sysvar_innodb_stats_auto_recalc)配置选项确定。值`1`会导致当表中的数据变化了10%时重新计算统计信息。值`0`会阻止对该表进行自动重新计算；在这种设置下，在对表进行重大更改后，发出[`ANALYZE
    TABLE`](analyze-table.html "15.7.3.1 ANALYZE TABLE Statement")语句重新计算统计信息。有关持久性统计功能的更多信息，请参见[Section 17.8.10.1,
    “Configuring Persistent Optimizer Statistics Parameters”](innodb-persistent-stats.html
    "17.8.10.1 Configuring Persistent Optimizer Statistics Parameters")。
- en: '`STATS_PERSISTENT`'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STATS_PERSISTENT`'
- en: Specifies whether to enable [persistent statistics](glossary.html#glos_persistent_statistics
    "persistent statistics") for an `InnoDB` table. The value `DEFAULT` causes the
    persistent statistics setting for the table to be determined by the [`innodb_stats_persistent`](innodb-parameters.html#sysvar_innodb_stats_persistent)
    configuration option. The value `1` enables persistent statistics for the table,
    while the value `0` turns off this feature. After enabling persistent statistics
    through a `CREATE TABLE` or `ALTER TABLE` statement, issue an [`ANALYZE TABLE`](analyze-table.html
    "15.7.3.1 ANALYZE TABLE Statement") statement to calculate the statistics, after
    loading representative data into the table. For more information about the persistent
    statistics feature, see [Section 17.8.10.1, “Configuring Persistent Optimizer
    Statistics Parameters”](innodb-persistent-stats.html "17.8.10.1 Configuring Persistent
    Optimizer Statistics Parameters").
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 指定是否为`InnoDB`表启用[持久性统计信息](glossary.html#glos_persistent_statistics "持久性统计信息")。值`DEFAULT`导致表的持久性统计信息设置由[`innodb_stats_persistent`](innodb-parameters.html#sysvar_innodb_stats_persistent)配置选项确定。值`1`为表启用持久性统计信息，而值`0`关闭此功能。通过`CREATE
    TABLE`或`ALTER TABLE`语句启用持久性统计信息后，需发出[`ANALYZE TABLE`](analyze-table.html "15.7.3.1 ANALYZE
    TABLE语句")语句来计算统计信息，在将代表性数据加载到表中后。有关持久性统计信息功能的更多信息，请参见[第17.8.10.1节，“配置持久性优化器统计参数”](innodb-persistent-stats.html
    "17.8.10.1 配置持久性优化器统计参数")。
- en: '`STATS_SAMPLE_PAGES`'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STATS_SAMPLE_PAGES`'
- en: The number of index pages to sample when estimating cardinality and other statistics
    for an indexed column, such as those calculated by [`ANALYZE TABLE`](analyze-table.html
    "15.7.3.1 ANALYZE TABLE Statement"). For more information, see [Section 17.8.10.1,
    “Configuring Persistent Optimizer Statistics Parameters”](innodb-persistent-stats.html
    "17.8.10.1 Configuring Persistent Optimizer Statistics Parameters").
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在估算索引列的基数和其他统计信息时要采样的索引页数，例如由[`ANALYZE TABLE`](analyze-table.html "15.7.3.1 ANALYZE
    TABLE语句")计算的那些。有关更多信息，请参见[第17.8.10.1节，“配置持久性优化器统计参数”](innodb-persistent-stats.html
    "17.8.10.1 配置持久性优化器统计参数")。
- en: '`TABLESPACE`'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TABLESPACE`'
- en: The `TABLESPACE` clause can be used to create an [`InnoDB`](innodb-storage-engine.html
    "Chapter 17 The InnoDB Storage Engine") table in an existing general tablespace,
    a file-per-table tablespace, or the system tablespace.
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`TABLESPACE`子句可用于在现有的通用表空间、每个表的文件表空间或系统表空间中创建[`InnoDB`](innodb-storage-engine.html
    "第17章 InnoDB存储引擎")表。'
- en: '[PRE11]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The general tablespace that you specify must exist prior to using the `TABLESPACE`
    clause. For information about general tablespaces, see [Section 17.6.3.3, “General
    Tablespaces”](general-tablespaces.html "17.6.3.3 General Tablespaces").
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您指定的通用表空间必须在使用`TABLESPACE`子句之前存在。有关通用表空间的信息，请参见[第17.6.3.3节，“通用表空间”](general-tablespaces.html
    "17.6.3.3 通用表空间")。
- en: The `*`tablespace_name`*` is a case-sensitive identifier. It may be quoted or
    unquoted. The forward slash character (“/”) is not permitted. Names beginning
    with “innodb_” are reserved for special use.
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`*`tablespace_name`*`是区分大小写的标识符。它可以带引号也可以不带。不允许使用斜杠字符（“/”）。以“innodb_”开头的名称保留供特殊用途。'
- en: To create a table in the system tablespace, specify `innodb_system` as the tablespace
    name.
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要在系统表空间中创建表，请将`innodb_system`指定为表空间名称。
- en: '[PRE12]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Using `TABLESPACE [=] innodb_system`, you can place a table of any uncompressed
    row format in the system tablespace regardless of the [`innodb_file_per_table`](innodb-parameters.html#sysvar_innodb_file_per_table)
    setting. For example, you can add a table with `ROW_FORMAT=DYNAMIC` to the system
    tablespace using `TABLESPACE [=] innodb_system`.
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`TABLESPACE [=] innodb_system`，您可以将任何未压缩行格式的表放置在系统表空间中，而不受[`innodb_file_per_table`](innodb-parameters.html#sysvar_innodb_file_per_table)设置的影响。例如，您可以使用`TABLESPACE
    [=] innodb_system`将具有`ROW_FORMAT=DYNAMIC`的表添加到系统表空间中。
- en: To create a table in a file-per-table tablespace, specify `innodb_file_per_table`
    as the tablespace name.
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要在每个表的文件表空间中创建表，请将`innodb_file_per_table`指定为表空间名称。
- en: '[PRE13]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: If [`innodb_file_per_table`](innodb-parameters.html#sysvar_innodb_file_per_table)
    is enabled, you need not specify `TABLESPACE=innodb_file_per_table` to create
    an `InnoDB` file-per-table tablespace. `InnoDB` tables are created in file-per-table
    tablespaces by default when [`innodb_file_per_table`](innodb-parameters.html#sysvar_innodb_file_per_table)
    is enabled.
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果启用了[`innodb_file_per_table`](innodb-parameters.html#sysvar_innodb_file_per_table)，则无需指定`TABLESPACE=innodb_file_per_table`来创建`InnoDB`每个表的文件表空间。当启用[`innodb_file_per_table`](innodb-parameters.html#sysvar_innodb_file_per_table)时，默认情况下在每个表的文件表空间中创建`InnoDB`表。
- en: The `DATA DIRECTORY` clause is permitted with `CREATE TABLE ... TABLESPACE=innodb_file_per_table`
    but is otherwise not supported for use in combination with the `TABLESPACE` clause.
    As of MySQL 8.0.21, the directory specified in a `DATA DIRECTORY` clause must
    be known to `InnoDB`. For more information, see [Using the DATA DIRECTORY Clause](innodb-create-table-external.html#innodb-create-table-external-data-directory
    "Using the DATA DIRECTORY Clause").
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`DATA DIRECTORY`子句允许与`CREATE TABLE ... TABLESPACE=innodb_file_per_table`一起使用，但在与`TABLESPACE`子句结合使用时不受支持。从MySQL
    8.0.21开始，`DATA DIRECTORY`子句中指定的目录必须为`InnoDB`所知。更多信息，请参阅[使用DATA DIRECTORY子句](innodb-create-table-external.html#innodb-create-table-external-data-directory
    "Using the DATA DIRECTORY Clause")。'
- en: Note
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Support for `TABLESPACE = innodb_file_per_table` and `TABLESPACE = innodb_temporary`
    clauses with [`CREATE TEMPORARY TABLE`](create-table.html "15.1.20 CREATE TABLE
    Statement") is deprecated as of MySQL 8.0.13; expect it to be removed in a future
    version of MySQL.
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从MySQL 8.0.13开始，使用`TABLESPACE = innodb_file_per_table`和`TABLESPACE = innodb_temporary`子句与[`CREATE
    TEMPORARY TABLE`](create-table.html "15.1.20 CREATE TABLE Statement")已不再受支持；预计将在将来的MySQL版本中删除。
- en: The `STORAGE` table option is employed only with [`NDB`](mysql-cluster.html
    "Chapter 25 MySQL NDB Cluster 8.0") tables. `STORAGE` determines the type of storage
    used, and can be either of `DISK` or `MEMORY`.
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`STORAGE`表选项仅用于[`NDB`](mysql-cluster.html "Chapter 25 MySQL NDB Cluster 8.0")表。`STORAGE`确定所使用的存储类型，可以是`DISK`或`MEMORY`中的任一种。'
- en: '`TABLESPACE ... STORAGE DISK` assigns a table to an NDB Cluster Disk Data tablespace.
    `STORAGE DISK` cannot be used in `CREATE TABLE` unless preceded by `TABLESPACE`
    *`tablespace_name`*.'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`TABLESPACE ... STORAGE DISK`将表分配给NDB Cluster Disk Data表空间。除非在`TABLESPACE`
    *`tablespace_name`*之前，否则不能在`CREATE TABLE`中使用`STORAGE DISK`。'
- en: For `STORAGE MEMORY`, the tablespace name is optional, thus, you can use `TABLESPACE
    *`tablespace_name`* STORAGE MEMORY` or simply `STORAGE MEMORY` to specify explicitly
    that the table is in-memory.
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于`STORAGE MEMORY`，表空间名称是可选的，因此，您可以使用`TABLESPACE *`tablespace_name`* STORAGE
    MEMORY`或简单地使用`STORAGE MEMORY`来明确指定表位于内存中。
- en: See [Section 25.6.11, “NDB Cluster Disk Data Tables”](mysql-cluster-disk-data.html
    "25.6.11 NDB Cluster Disk Data Tables"), for more information.
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有关更多信息，请参阅[第25.6.11节，“NDB Cluster Disk Data Tables”](mysql-cluster-disk-data.html
    "25.6.11 NDB Cluster Disk Data Tables")。
- en: '[`UNION`](union.html "15.2.18 UNION Clause")'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`UNION`](union.html "15.2.18 UNION Clause")'
- en: Used to access a collection of identical `MyISAM` tables as one. This works
    only with `MERGE` tables. See [Section 18.7, “The MERGE Storage Engine”](merge-storage-engine.html
    "18.7 The MERGE Storage Engine").
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用于将一组相同的`MyISAM`表作为一个表访问。这仅适用于`MERGE`表。请参阅[第18.7节，“MERGE存储引擎”](merge-storage-engine.html
    "18.7 The MERGE Storage Engine")。
- en: You must have [`SELECT`](privileges-provided.html#priv_select), [`UPDATE`](privileges-provided.html#priv_update),
    and [`DELETE`](privileges-provided.html#priv_delete) privileges for the tables
    you map to a `MERGE` table.
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您必须对映射到`MERGE`表的表具有[`SELECT`](privileges-provided.html#priv_select)、[`UPDATE`](privileges-provided.html#priv_update)和[`DELETE`](privileges-provided.html#priv_delete)权限。
- en: Note
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Formerly, all tables used had to be in the same database as the `MERGE` table
    itself. This restriction no longer applies.
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以前，所有使用的表都必须与`MERGE`表本身位于同一个数据库中。这个限制不再适用。
- en: Table Partitioning
  id: totrans-310
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 表分区
- en: '*`partition_options`* can be used to control partitioning of the table created
    with [`CREATE TABLE`](create-table.html "15.1.20 CREATE TABLE Statement").'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '*`partition_options`*可用于控制使用[`CREATE TABLE`](create-table.html "15.1.20 CREATE
    TABLE Statement")创建的表的分区。'
- en: Not all options shown in the syntax for *`partition_options`* at the beginning
    of this section are available for all partitioning types. Please see the listings
    for the following individual types for information specific to each type, and
    see [Chapter 26, *Partitioning*](partitioning.html "Chapter 26 Partitioning"),
    for more complete information about the workings of and uses for partitioning
    in MySQL, as well as additional examples of table creation and other statements
    relating to MySQL partitioning.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 此部分开头显示的*`partition_options`*语法中并非所有选项适用于所有分区类型。有关每种类型的特定信息，请参阅以下各个类型的列表，并参阅[第26章，*分区*](partitioning.html
    "Chapter 26 Partitioning")，以获取有关MySQL中分区工作原理和用途的更完整信息，以及有关表创建和其他与MySQL分区相关的语句的其他示例。
- en: Partitions can be modified, merged, added to tables, and dropped from tables.
    For basic information about the MySQL statements to accomplish these tasks, see
    [Section 15.1.9, “ALTER TABLE Statement”](alter-table.html "15.1.9 ALTER TABLE
    Statement"). For more detailed descriptions and examples, see [Section 26.3, “Partition
    Management”](partitioning-management.html "26.3 Partition Management").
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 分区可以被修改、合并、添加到表中，也可以从表中删除。有关完成这些任务的 MySQL 语句的基本信息，请参见 [Section 15.1.9, “ALTER
    TABLE Statement”](alter-table.html "15.1.9 ALTER TABLE Statement")。有关更详细的描述和示例，请参见
    [Section 26.3, “Partition Management”](partitioning-management.html "26.3 Partition
    Management")。
- en: '`PARTITION BY`'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PARTITION BY`'
- en: If used, a *`partition_options`* clause begins with `PARTITION BY`. This clause
    contains the function that is used to determine the partition; the function returns
    an integer value ranging from 1 to *`num`*, where *`num`* is the number of partitions.
    (The maximum number of user-defined partitions which a table may contain is 1024;
    the number of subpartitions—discussed later in this section—is included in this
    maximum.)
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果使用了 *`partition_options`* 子句，它以 `PARTITION BY` 开头。这个子句包含用于确定分区的函数；该函数返回一个从
    1 到 *`num`* 的整数值，其中 *`num`* 是分区的数量。（一个表中可以包含的用户定义分区的最大数量是 1024；本节稍后讨论的子分区数量也包括在这个最大值中。）
- en: Note
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: 'The expression (*`expr`*) used in a `PARTITION BY` clause cannot refer to any
    columns not in the table being created; such references are specifically not permitted
    and cause the statement to fail with an error. (Bug #29444)'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '在 `PARTITION BY` 子句中使用的表达式 (*`expr`*) 不能引用不在被创建的表中的任何列；这样的引用是明确不允许的，并会导致语句失败并出现错误。
    (Bug #29444)'
- en: '`HASH(*`expr`*)`'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HASH(*`expr`*)`'
- en: 'Hashes one or more columns to create a key for placing and locating rows. *`expr`*
    is an expression using one or more table columns. This can be any valid MySQL
    expression (including MySQL functions) that yields a single integer value. For
    example, these are both valid [`CREATE TABLE`](create-table.html "15.1.20 CREATE
    TABLE Statement") statements using `PARTITION BY HASH`:'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对一个或多个列进行哈希运算，创建一个用于定位和查找行的键。*`expr`* 是使用一个或多个表列的表达式。这可以是任何有效的 MySQL 表达式（包括
    MySQL 函数），产生一个单个整数值。例如，以下是使用 `PARTITION BY HASH` 的两个有效的 [`CREATE TABLE`](create-table.html
    "15.1.20 CREATE TABLE Statement") 语句：
- en: '[PRE14]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You may not use either `VALUES LESS THAN` or `VALUES IN` clauses with `PARTITION
    BY HASH`.
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不能在 `PARTITION BY HASH` 中使用 `VALUES LESS THAN` 或 `VALUES IN` 子句。
- en: '`PARTITION BY HASH` uses the remainder of *`expr`* divided by the number of
    partitions (that is, the modulus). For examples and additional information, see
    [Section 26.2.4, “HASH Partitioning”](partitioning-hash.html "26.2.4 HASH Partitioning").'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`PARTITION BY HASH` 使用 *`expr`* 除以分区数后的余数（即模数）。有关示例和额外信息，请参见 [Section 26.2.4,
    “HASH Partitioning”](partitioning-hash.html "26.2.4 HASH Partitioning")。'
- en: The `LINEAR` keyword entails a somewhat different algorithm. In this case, the
    number of the partition in which a row is stored is calculated as the result of
    one or more logical [`AND`](logical-operators.html#operator_and) operations. For
    discussion and examples of linear hashing, see [Section 26.2.4.1, “LINEAR HASH
    Partitioning”](partitioning-linear-hash.html "26.2.4.1 LINEAR HASH Partitioning").
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`LINEAR` 关键字涉及一个略有不同的算法。在这种情况下，存储行的分区号是通过一个或多个逻辑 [`AND`](logical-operators.html#operator_and)
    操作的结果计算得出的。有关线性哈希的讨论和示例，请参见 [Section 26.2.4.1, “LINEAR HASH Partitioning”](partitioning-linear-hash.html
    "26.2.4.1 LINEAR HASH Partitioning")。'
- en: '`KEY(*`column_list`*)`'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KEY(*`column_list`*)`'
- en: 'This is similar to `HASH`, except that MySQL supplies the hashing function
    so as to guarantee an even data distribution. The *`column_list`* argument is
    simply a list of 1 or more table columns (maximum: 16). This example shows a simple
    table partitioned by key, with 4 partitions:'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这类似于 `HASH`，不同之处在于 MySQL 提供了哈希函数，以保证数据均匀分布。*`column_list`* 参数只是一个包含 1 个或多个表列（最多：16）的列表。这个示例展示了一个简单的按键分区的表，有
    4 个分区：
- en: '[PRE15]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For tables that are partitioned by key, you can employ linear partitioning
    by using the `LINEAR` keyword. This has the same effect as with tables that are
    partitioned by `HASH`. That is, the partition number is found using the [`&`](bit-functions.html#operator_bitwise-and)
    operator rather than the modulus (see [Section 26.2.4.1, “LINEAR HASH Partitioning”](partitioning-linear-hash.html
    "26.2.4.1 LINEAR HASH Partitioning"), and [Section 26.2.5, “KEY Partitioning”](partitioning-key.html
    "26.2.5 KEY Partitioning"), for details). This example uses linear partitioning
    by key to distribute data between 5 partitions:'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于按键分区的表，您可以使用`LINEAR`关键字来采用线性分区。这与按`HASH`分区的表具有相同的效果。也就是说，分区号是使用[`&`](bit-functions.html#operator_bitwise-and)运算符而不是取模来确定的（详见[第26.2.4.1节，“线性HASH分区”](partitioning-linear-hash.html
    "26.2.4.1 线性HASH分区")和[第26.2.5节，“KEY分区”](partitioning-key.html "26.2.5 KEY分区")）。此示例使用按键进行线性分区以在5个分区之间分发数据：
- en: '[PRE16]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `ALGORITHM={1 | 2}` option is supported with `[SUB]PARTITION BY [LINEAR]
    KEY`. `ALGORITHM=1` causes the server to use the same key-hashing functions as
    MySQL 5.1; `ALGORITHM=2` means that the server employs the key-hashing functions
    implemented and used by default for new `KEY` partitioned tables in MySQL 5.5
    and later. (Partitioned tables created with the key-hashing functions employed
    in MySQL 5.5 and later cannot be used by a MySQL 5.1 server.) Not specifying the
    option has the same effect as using `ALGORITHM=2`. This option is intended for
    use chiefly when upgrading or downgrading `[LINEAR] KEY` partitioned tables between
    MySQL 5.1 and later MySQL versions, or for creating tables partitioned by `KEY`
    or `LINEAR KEY` on a MySQL 5.5 or later server which can be used on a MySQL 5.1
    server. For more information, see [Section 15.1.9.1, “ALTER TABLE Partition Operations”](alter-table-partition-operations.html
    "15.1.9.1 ALTER TABLE Partition Operations").
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ALGORITHM={1 | 2}`选项支持`[SUB]PARTITION BY [LINEAR] KEY`。`ALGORITHM=1`使服务器使用与MySQL
    5.1相同的键哈希函数；`ALGORITHM=2`表示服务器使用MySQL 5.5及更高版本中默认实现和使用的键哈希函数。 （使用MySQL 5.5及更高版本中实施的键哈希函数创建的分区表不能被MySQL
    5.1服务器使用。）不指定该选项与使用`ALGORITHM=2`具有相同的效果。该选项主要用于在MySQL 5.1和后续MySQL版本之间升级或降级`[LINEAR]
    KEY`分区表时，或者在MySQL 5.5或更高版本服务器上创建按`KEY`或`LINEAR KEY`分区的表，该表可以在MySQL 5.1服务器上使用。有关更多信息，请参见[第15.1.9.1节，“ALTER
    TABLE分区操作”](alter-table-partition-operations.html "15.1.9.1 ALTER TABLE分区操作")。'
- en: '[**mysqldump**](mysqldump.html "6.5.4 mysqldump — A Database Backup Program")
    writes this option encased in versioned comments.'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[**mysqldump**](mysqldump.html "6.5.4 mysqldump — A Database Backup Program")将此选项写入版本化注释中。'
- en: '`ALGORITHM=1` is shown when necessary in the output of [`SHOW CREATE TABLE`](show-create-table.html
    "15.7.7.10 SHOW CREATE TABLE Statement") using versioned comments in the same
    manner as [**mysqldump**](mysqldump.html "6.5.4 mysqldump — A Database Backup
    Program"). `ALGORITHM=2` is always omitted from `SHOW CREATE TABLE` output, even
    if this option was specified when creating the original table.'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在必要时，`ALGORITHM=1`将显示在使用版本化注释的[`SHOW CREATE TABLE`](show-create-table.html "15.7.7.10 SHOW
    CREATE TABLE语句")输出中，方式与[**mysqldump**](mysqldump.html "6.5.4 mysqldump — A Database
    Backup Program")相同。即使在创建原始表时指定了此选项，`SHOW CREATE TABLE`输出中也总是省略`ALGORITHM=2`。
- en: You may not use either `VALUES LESS THAN` or `VALUES IN` clauses with `PARTITION
    BY KEY`.
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您不能在`PARTITION BY KEY`中使用`VALUES LESS THAN`或`VALUES IN`子句。
- en: '`RANGE(*`expr`*)`'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RANGE(*`表达式`*)`'
- en: In this case, *`expr`* shows a range of values using a set of `VALUES LESS THAN`
    operators. When using range partitioning, you must define at least one partition
    using `VALUES LESS THAN`. You cannot use `VALUES IN` with range partitioning.
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，*表达式*使用一组`VALUES LESS THAN`运算符显示一系列值的范围。在使用范围分区时，您必须至少定义一个使用`VALUES LESS
    THAN`的分区。您不能在范围分区中使用`VALUES IN`。
- en: Note
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: For tables partitioned by `RANGE`, `VALUES LESS THAN` must be used with either
    an integer literal value or an expression that evaluates to a single integer value.
    In MySQL 8.0, you can overcome this limitation in a table that is defined using
    `PARTITION BY RANGE COLUMNS`, as described later in this section.
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于按`RANGE`分区的表，`VALUES LESS THAN`必须与整数文字值或评估为单个整数值的表达式一起使用。在MySQL 8.0中，您可以在使用`PARTITION
    BY RANGE COLUMNS`定义的表中克服这一限制，如本节后面所述。
- en: Suppose that you have a table that you wish to partition on a column containing
    year values, according to the following scheme.
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设您有一个希望根据以下方案对包含年份值的列进行分区的表。
- en: '| Partition Number: | Years Range: |'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 分区号： | 年份范围： |'
- en: '| 0 | 1990 and earlier |'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 0 | 1990年及之前 |'
- en: '| 1 | 1991 to 1994 |'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 1 | 1991至1994年 |'
- en: '| 2 | 1995 to 1998 |'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 2 | 1995 to 1998 |'
- en: '| 3 | 1999 to 2002 |'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 3 | 1999 to 2002 |'
- en: '| 4 | 2003 to 2005 |'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 4 | 2003 to 2005 |'
- en: '| 5 | 2006 and later |'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 5 | 2006 and later |'
- en: 'A table implementing such a partitioning scheme can be realized by the [`CREATE
    TABLE`](create-table.html "15.1.20 CREATE TABLE Statement") statement shown here:'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实现这种分区方案的表可以通过以下[`CREATE TABLE`](create-table.html "15.1.20 CREATE TABLE Statement")
    语句实现：
- en: '[PRE17]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`PARTITION ... VALUES LESS THAN ...` statements work in a consecutive fashion.
    `VALUES LESS THAN MAXVALUE` works to specify “leftover” values that are greater
    than the maximum value otherwise specified.'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`PARTITION ... VALUES LESS THAN ...` 语句按顺序工作。`VALUES LESS THAN MAXVALUE` 用于指定大于其他指定最大值的“剩余”值。'
- en: '`VALUES LESS THAN` clauses work sequentially in a manner similar to that of
    the `case` portions of a `switch ... case` block (as found in many programming
    languages such as C, Java, and PHP). That is, the clauses must be arranged in
    such a way that the upper limit specified in each successive `VALUES LESS THAN`
    is greater than that of the previous one, with the one referencing `MAXVALUE`
    coming last of all in the list.'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`VALUES LESS THAN`子句按顺序工作，类似于`switch ... case`块的`case`部分（在许多编程语言中如C、Java和PHP中找到）。也就是说，这些子句必须按照每个连续`VALUES
    LESS THAN`中指定的上限大于前一个的方式排列，其中引用`MAXVALUE`的子句在列表中最后出现。'
- en: '`RANGE COLUMNS(*`column_list`*)`'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RANGE COLUMNS(*`column_list`*)`'
- en: This variant on `RANGE` facilitates partition pruning for queries using range
    conditions on multiple columns (that is, having conditions such as `WHERE a =
    1 AND b < 10` or `WHERE a = 1 AND b = 10 AND c < 10`). It enables you to specify
    value ranges in multiple columns by using a list of columns in the `COLUMNS` clause
    and a set of column values in each `PARTITION ... VALUES LESS THAN (*`value_list`*)`
    partition definition clause. (In the simplest case, this set consists of a single
    column.) The maximum number of columns that can be referenced in the *`column_list`*
    and *`value_list`* is 16.
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种`RANGE`变体便于对使用多列范围条件的查询进行分区修剪（即，具有诸如`WHERE a = 1 AND b < 10`或`WHERE a = 1
    AND b = 10 AND c < 10`条件的查询）。它允许您通过在`COLUMNS`子句中列出的列列表和在每个`PARTITION ... VALUES
    LESS THAN (*`value_list`*)`分区定义子句中设置的列值集来指定多列中的值范围。（在最简单的情况下，此集合由单个列组成。）在`column_list`和`value_list`中引用的列的最大数量为16。
- en: 'The *`column_list`* used in the `COLUMNS` clause may contain only names of
    columns; each column in the list must be one of the following MySQL data types:
    the integer types; the string types; and time or date column types. Columns using
    `BLOB`, `TEXT`, `SET`, `ENUM`, `BIT`, or spatial data types are not permitted;
    columns that use floating-point number types are also not permitted. You also
    may not use functions or arithmetic expressions in the `COLUMNS` clause.'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`COLUMNS`子句中使用的`column_list`可能只包含列名；列表中的每个列必须是以下MySQL数据类型之一：整数类型；字符串类型；时间或日期列类型。不允许使用`BLOB`、`TEXT`、`SET`、`ENUM`、`BIT`或空间数据类型的列；也不允许使用浮点数类型的列。您也不能在`COLUMNS`子句中使用函数或算术表达式。
- en: 'The `VALUES LESS THAN` clause used in a partition definition must specify a
    literal value for each column that appears in the `COLUMNS()` clause; that is,
    the list of values used for each `VALUES LESS THAN` clause must contain the same
    number of values as there are columns listed in the `COLUMNS` clause. An attempt
    to use more or fewer values in a `VALUES LESS THAN` clause than there are in the
    `COLUMNS` clause causes the statement to fail with the error Inconsistency in
    usage of column lists for partitioning.... You cannot use `NULL` for any value
    appearing in `VALUES LESS THAN`. It is possible to use `MAXVALUE` more than once
    for a given column other than the first, as shown in this example:'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在分区定义中使用的`VALUES LESS THAN`子句必须为`COLUMNS()`子句中出现的每个列指定一个文字值；也就是说，用于每个`VALUES
    LESS THAN`子句的值列表必须包含与`COLUMNS`子句中列出的列数相同的值。尝试在`VALUES LESS THAN`子句中使用比`COLUMNS`子句中列出的列数更多或更少的值会导致出现错误Inconsistency
    in usage of column lists for partitioning...。您不能对出现在`VALUES LESS THAN`中的任何值使用`NULL`。可以多次使用`MAXVALUE`来表示给定列，如下例所示：
- en: '[PRE18]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Each value used in a `VALUES LESS THAN` value list must match the type of the
    corresponding column exactly; no conversion is made. For example, you cannot use
    the string `''1''` for a value that matches a column that uses an integer type
    (you must use the numeral `1` instead), nor can you use the numeral `1` for a
    value that matches a column that uses a string type (in such a case, you must
    use a quoted string: `''1''`).'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`VALUES LESS THAN`值列表中使用的每个值必须与相应列的类型完全匹配；不会进行任何转换。例如，您不能为与使用整数类型的列匹配的值使用字符串`'1'`（您必须使用数字`1`），也不能为与使用字符串类型的列匹配的值使用数字`1`（在这种情况下，您必须使用带引号的字符串：`'1'`）。
- en: For more information, see [Section 26.2.1, “RANGE Partitioning”](partitioning-range.html
    "26.2.1 RANGE Partitioning"), and [Section 26.4, “Partition Pruning”](partitioning-pruning.html
    "26.4 Partition Pruning").
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有关更多信息，请参见[第26.2.1节，“RANGE分区”](partitioning-range.html "26.2.1 RANGE Partitioning")和[第26.4节，“分区修剪”](partitioning-pruning.html
    "26.4 Partition Pruning")。
- en: '`LIST(*`expr`*)`'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LIST(*`expr`*)`'
- en: This is useful when assigning partitions based on a table column with a restricted
    set of possible values, such as a state or country code. In such a case, all rows
    pertaining to a certain state or country can be assigned to a single partition,
    or a partition can be reserved for a certain set of states or countries. It is
    similar to `RANGE`, except that only `VALUES IN` may be used to specify permissible
    values for each partition.
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当基于具有受限可能值集的表列分配分区时，这是很有用的，例如州或国家代码。在这种情况下，所有属于某个州或国家的行可以分配到一个分区，或者可以为某个州或国家集保留一个分区。它类似于`RANGE`，只是每个分区只能使用`VALUES
    IN`来指定可允许的值。
- en: '`VALUES IN` is used with a list of values to be matched. For instance, you
    could create a partitioning scheme such as the following:'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`VALUES IN`用于匹配的值列表。例如，您可以创建以下分区方案：'
- en: '[PRE19]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When using list partitioning, you must define at least one partition using `VALUES
    IN`. You cannot use `VALUES LESS THAN` with `PARTITION BY LIST`.
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在使用列表分区时，您必须至少定义一个使用`VALUES IN`的分区。您不能在`PARTITION BY LIST`中使用`VALUES LESS THAN`。
- en: Note
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: For tables partitioned by `LIST`, the value list used with `VALUES IN` must
    consist of integer values only. In MySQL 8.0, you can overcome this limitation
    using partitioning by `LIST COLUMNS`, which is described later in this section.
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于通过`LIST`分区的表，与`VALUES IN`一起使用的值列表必须仅包含整数值。在MySQL 8.0中，您可以通过后面在本节中描述的`LIST
    COLUMNS`进行分区来克服这种限制。
- en: '`LIST COLUMNS(*`column_list`*)`'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LIST COLUMNS(*`column_list`*)`'
- en: This variant on `LIST` facilitates partition pruning for queries using comparison
    conditions on multiple columns (that is, having conditions such as `WHERE a =
    5 AND b = 5` or `WHERE a = 1 AND b = 10 AND c = 5`). It enables you to specify
    values in multiple columns by using a list of columns in the `COLUMNS` clause
    and a set of column values in each `PARTITION ... VALUES IN (*`value_list`*)`
    partition definition clause.
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种`LIST`的变体为使用多列比较条件的查询提供了分区修剪的便利（即，具有诸如`WHERE a = 5 AND b = 5`或`WHERE a = 1
    AND b = 10 AND c = 5`等条件）。它允许您通过在`COLUMNS`子句中使用列列表和在每个`PARTITION ... VALUES IN
    (*`value_list`*)`分区定义子句中使用一组列值来指定多列的值。
- en: The rules governing regarding data types for the column list used in `LIST COLUMNS(*`column_list`*)`
    and the value list used in `VALUES IN(*`value_list`*)` are the same as those for
    the column list used in `RANGE COLUMNS(*`column_list`*)` and the value list used
    in `VALUES LESS THAN(*`value_list`*)`, respectively, except that in the `VALUES
    IN` clause, `MAXVALUE` is not permitted, and you may use `NULL`.
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用于`LIST COLUMNS(*`column_list`*)`中的列列表和`VALUES IN(*`value_list`*)`中使用的值列表的数据类型规则与用于`RANGE
    COLUMNS(*`column_list`*)`中的列列表和`VALUES LESS THAN(*`value_list`*)`中使用的值列表的规则相同，只是在`VALUES
    IN`子句中，不允许使用`MAXVALUE`，您可以使用`NULL`。
- en: There is one important difference between the list of values used for `VALUES
    IN` with `PARTITION BY LIST COLUMNS` as opposed to when it is used with `PARTITION
    BY LIST`. When used with `PARTITION BY LIST COLUMNS`, each element in the `VALUES
    IN` clause must be a *set* of column values; the number of values in each set
    must be the same as the number of columns used in the `COLUMNS` clause, and the
    data types of these values must match those of the columns (and occur in the same
    order). In the simplest case, the set consists of a single column. The maximum
    number of columns that can be used in the *`column_list`* and in the elements
    making up the *`value_list`* is 16.
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在使用`PARTITION BY LIST COLUMNS`时，与在使用`PARTITION BY LIST`时使用`VALUES IN`的值列表之间有一个重要区别。在与`PARTITION
    BY LIST COLUMNS`一起使用时，`VALUES IN`子句中的每个元素必须是一组列值；每组中的值数量必须与`COLUMNS`子句中使用的列数相同，并且这些值的数据类型必须与列的数据类型匹配（并且以相同顺序出现）。在最简单的情况下，该集合由单个列组成。在*`column_list`*和组成*`value_list`*的元素中可以使用的最大列数为16。
- en: 'The table defined by the following `CREATE TABLE` statement provides an example
    of a table using `LIST COLUMNS` partitioning:'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下`CREATE TABLE`语句定义的表提供了使用`LIST COLUMNS`分区的示例：
- en: '[PRE20]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`PARTITIONS *`num`*`'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PARTITIONS *`num`*`'
- en: The number of partitions may optionally be specified with a `PARTITIONS *`num`*`
    clause, where *`num`* is the number of partitions. If both this clause *and* any
    `PARTITION` clauses are used, *`num`* must be equal to the total number of any
    partitions that are declared using `PARTITION` clauses.
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以选择使用`PARTITIONS *`num`*`子句指定分区的数量，其中*`num`*是分区的数量。如果同时使用此子句和任何使用`PARTITION`子句声明的分区，则*`num`*必须等于使用`PARTITION`子句声明的所有分区的总数。
- en: Note
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Whether or not you use a `PARTITIONS` clause in creating a table that is partitioned
    by `RANGE` or `LIST`, you must still include at least one `PARTITION VALUES` clause
    in the table definition (see below).
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在创建按`RANGE`或`LIST`分区的表时，无论是否使用`PARTITIONS`子句，仍必须在表定义中至少包含一个`PARTITION VALUES`子句（见下文）。
- en: '`SUBPARTITION BY`'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SUBPARTITION BY`'
- en: A partition may optionally be divided into a number of subpartitions. This can
    be indicated by using the optional `SUBPARTITION BY` clause. Subpartitioning may
    be done by `HASH` or `KEY`. Either of these may be `LINEAR`. These work in the
    same way as previously described for the equivalent partitioning types. (It is
    not possible to subpartition by `LIST` or `RANGE`.)
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 分区可以选择地分成多个子分区。这可以通过使用可选的`SUBPARTITION BY`子句来指示。子分区可以通过`HASH`或`KEY`进行。其中任何一个都可以是`LINEAR`。这与先前描述的等效分区类型的工作方式相同。（不可能通过`LIST`或`RANGE`进行子分区。）
- en: The number of subpartitions can be indicated using the `SUBPARTITIONS` keyword
    followed by an integer value.
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以使用`SUBPARTITIONS`关键字后跟一个整数值来指示子分区的数量。
- en: 'Rigorous checking of the value used in `PARTITIONS` or `SUBPARTITIONS` clauses
    is applied and this value must adhere to the following rules:'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`PARTITIONS`或`SUBPARTITIONS`子句中使用的值进行严格检查，并且此值必须遵守以下规则：
- en: The value must be a positive, nonzero integer.
  id: totrans-377
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值必须是正的、非零整数。
- en: No leading zeros are permitted.
  id: totrans-378
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不允许前导零。
- en: 'The value must be an integer literal, and cannot not be an expression. For
    example, `PARTITIONS 0.2E+01` is not permitted, even though `0.2E+01` evaluates
    to `2`. (Bug #15890)'
  id: totrans-379
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '值必须是整数文字，并且不能是表达式。例如，`PARTITIONS 0.2E+01`是不允许的，即使`0.2E+01`评估为`2`。（Bug #15890）'
- en: '`*`partition_definition`*`'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`partition_definition`*`'
- en: 'Each partition may be individually defined using a *`partition_definition`*
    clause. The individual parts making up this clause are as follows:'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以使用*`partition_definition`*子句分别定义每个分区。构成此子句的各个部分如下：
- en: '`PARTITION *`partition_name`*`'
  id: totrans-382
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PARTITION *`partition_name`*`'
- en: Specifies a logical name for the partition.
  id: totrans-383
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为分区指定一个逻辑名称。
- en: '`VALUES`'
  id: totrans-384
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VALUES`'
- en: For range partitioning, each partition must include a `VALUES LESS THAN` clause;
    for list partitioning, you must specify a `VALUES IN` clause for each partition.
    This is used to determine which rows are to be stored in this partition. See the
    discussions of partitioning types in [Chapter 26, *Partitioning*](partitioning.html
    "Chapter 26 Partitioning"), for syntax examples.
  id: totrans-385
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于范围分区，每个分区必须包括一个`VALUES LESS THAN`子句；对于列表分区，您必须为每个分区指定一个`VALUES IN`子句。这用于确定哪些行将存储在此分区中。有关分区类型的讨论，请参见[第26章，*分区*](partitioning.html
    "第26章 分区")中的语法示例。
- en: '`[STORAGE] ENGINE`'
  id: totrans-386
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[STORAGE] ENGINE`'
- en: 'MySQL accepts a `[STORAGE] ENGINE` option for both `PARTITION` and `SUBPARTITION`.
    Currently, the only way in which this option can be used is to set all partitions
    or all subpartitions to the same storage engine, and an attempt to set different
    storage engines for partitions or subpartitions in the same table raises the error
    ERROR 1469 (HY000): The mix of handlers in the partitions is not permitted in
    this version of MySQL.'
  id: totrans-387
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'MySQL 接受 `PARTITION` 和 `SUBPARTITION` 的 `[STORAGE] ENGINE` 选项。目前，此选项可用的唯一方式是将所有分区或所有子分区设置为相同的存储引擎，尝试为同一表中的分区或子分区设置不同的存储引擎会引发错误
    ERROR 1469 (HY000): The mix of handlers in the partitions is not permitted in
    this version of MySQL。'
- en: '`COMMENT`'
  id: totrans-388
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COMMENT`'
- en: 'An optional `COMMENT` clause may be used to specify a string that describes
    the partition. Example:'
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以使用可选的 `COMMENT` 子句来指定描述分区的字符串。示例：
- en: '[PRE21]'
  id: totrans-390
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The maximum length for a partition comment is 1024 characters.
  id: totrans-391
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 分区注释的最大长度为 1024 个字符。
- en: '`DATA DIRECTORY` and `INDEX DIRECTORY`'
  id: totrans-392
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DATA DIRECTORY` 和 `INDEX DIRECTORY`'
- en: '`DATA DIRECTORY` and `INDEX DIRECTORY` may be used to indicate the directory
    where, respectively, the data and indexes for this partition are to be stored.
    Both the `*`data_dir`*` and the `*`index_dir`*` must be absolute system path names.'
  id: totrans-393
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`DATA DIRECTORY` 和 `INDEX DIRECTORY` 可用于指示存储此分区数据和索引的目录。`*`data_dir`*` 和 `*`index_dir`*`
    必须是绝对系统路径名。'
- en: As of MySQL 8.0.21, the directory specified in a `DATA DIRECTORY` clause must
    be known to `InnoDB`. For more information, see [Using the DATA DIRECTORY Clause](innodb-create-table-external.html#innodb-create-table-external-data-directory
    "Using the DATA DIRECTORY Clause").
  id: totrans-394
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 截至 MySQL 8.0.21 版本，`DATA DIRECTORY` 子句中指定的目录必须为 `InnoDB` 所知。更多信息，请参阅 [使用 DATA
    DIRECTORY 子句](innodb-create-table-external.html#innodb-create-table-external-data-directory
    "使用 DATA DIRECTORY 子句")。
- en: You must have the [`FILE`](privileges-provided.html#priv_file) privilege to
    use the `DATA DIRECTORY` or `INDEX DIRECTORY` partition option.
  id: totrans-395
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您必须具有 [`FILE`](privileges-provided.html#priv_file) 权限才能使用 `DATA DIRECTORY` 或
    `INDEX DIRECTORY` 分区选项。
- en: 'Example:'
  id: totrans-396
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE22]'
  id: totrans-397
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`DATA DIRECTORY` and `INDEX DIRECTORY` behave in the same way as in the [`CREATE
    TABLE`](create-table.html "15.1.20 CREATE TABLE Statement") statement''s *`table_option`*
    clause as used for `MyISAM` tables.'
  id: totrans-398
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`DATA DIRECTORY` 和 `INDEX DIRECTORY` 的行为与用于 `MyISAM` 表的 [`CREATE TABLE`](create-table.html
    "15.1.20 CREATE TABLE Statement") 语句的 *`table_option`* 子句中的行为相同。'
- en: One data directory and one index directory may be specified per partition. If
    left unspecified, the data and indexes are stored by default in the table's database
    directory.
  id: totrans-399
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个分区可以指定一个数据目录和一个索引目录。如果未指定，数据和索引默认存储在表的数据库目录中。
- en: The `DATA DIRECTORY` and `INDEX DIRECTORY` options are ignored for creating
    partitioned tables if [`NO_DIR_IN_CREATE`](sql-mode.html#sqlmode_no_dir_in_create)
    is in effect.
  id: totrans-400
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果 [`NO_DIR_IN_CREATE`](sql-mode.html#sqlmode_no_dir_in_create) 生效，则在创建分区表时将忽略
    `DATA DIRECTORY` 和 `INDEX DIRECTORY` 选项。
- en: '`MAX_ROWS` and `MIN_ROWS`'
  id: totrans-401
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MAX_ROWS` 和 `MIN_ROWS`'
- en: May be used to specify, respectively, the maximum and minimum number of rows
    to be stored in the partition. The values for *`max_number_of_rows`* and *`min_number_of_rows`*
    must be positive integers. As with the table-level options with the same names,
    these act only as “suggestions” to the server and are not hard limits.
  id: totrans-402
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以分别指定要存储在分区中的最大和最小行数。*`max_number_of_rows`* 和 *`min_number_of_rows`* 的值必须是正整数。与具有相同名称的表级选项一样，这些值仅作为服务器的“建议”，而不是硬限制。
- en: '`TABLESPACE`'
  id: totrans-403
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TABLESPACE`'
- en: May be used to designate an `InnoDB` file-per-table tablespace for the partition
    by specifying `TABLESPACE `innodb_file_per_table``. All partitions must belong
    to the same storage engine.
  id: totrans-404
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以通过指定 `TABLESPACE `innodb_file_per_table`` 为分区指定一个 `InnoDB` 每表表空间。所有分区必须属于相同的存储引擎。
- en: Placing `InnoDB` table partitions in shared `InnoDB` tablespaces is not supported.
    Shared tablespaces include the `InnoDB` system tablespace and general tablespaces.
  id: totrans-405
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不支持将 `InnoDB` 表分区放置在共享的 `InnoDB` 表空间中。共享表空间包括 `InnoDB` 系统表空间和通用表空间。
- en: '`*`subpartition_definition`*`'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`subpartition_definition`*`'
- en: The partition definition may optionally contain one or more *`subpartition_definition`*
    clauses. Each of these consists at a minimum of the `SUBPARTITION *`name`*`, where
    *`name`* is an identifier for the subpartition. Except for the replacement of
    the `PARTITION` keyword with `SUBPARTITION`, the syntax for a subpartition definition
    is identical to that for a partition definition.
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 分区定义可以选择性地包含一个或多个 *`subpartition_definition`* 子句。每个子句至少包含 `SUBPARTITION *`name`*`，其中
    *`name`* 是子分区的标识符。除了将 `PARTITION` 关键字替换为 `SUBPARTITION` 外，子分区定义的语法与分区定义完全相同。
- en: Subpartitioning must be done by `HASH` or `KEY`, and can be done only on `RANGE`
    or `LIST` partitions. See [Section 26.2.6, “Subpartitioning”](partitioning-subpartitions.html
    "26.2.6 Subpartitioning").
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 子分区必须通过`HASH`或`KEY`完成，并且只能在`RANGE`或`LIST`分区上完成。参见[第26.2.6节，“子分区”](partitioning-subpartitions.html
    "26.2.6 子分区")。
- en: '**Partitioning by Generated Columns**'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '**通过生成列进行分区**'
- en: 'Partitioning by generated columns is permitted. For example:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 允许通过生成的列进行分区。例如：
- en: '[PRE23]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Partitioning sees a generated column as a regular column, which enables workarounds
    for limitations on functions that are not permitted for partitioning (see [Section 26.6.3,
    “Partitioning Limitations Relating to Functions”](partitioning-limitations-functions.html
    "26.6.3 Partitioning Limitations Relating to Functions")). The preceding example
    demonstrates this technique: [`EXP()`](mathematical-functions.html#function_exp)
    cannot be used directly in the `PARTITION BY` clause, but a generated column defined
    using [`EXP()`](mathematical-functions.html#function_exp) is permitted.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 分区将生成的列视为常规列，这使得可以解决对于分区不允许的函数的限制（参见[第26.6.3节，“与函数相关的分区限制”](partitioning-limitations-functions.html
    "26.6.3 与函数相关的分区限制")）。前面的示例演示了这种技术：[`EXP()`](mathematical-functions.html#function_exp)不能直接在`PARTITION
    BY`子句中使用，但可以使用使用[`EXP()`](mathematical-functions.html#function_exp)定义的生成列。
