- en: 1\. The Database File
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '-   数据库文件'
- en: 原文：[https://sqlite.com/fileformat2.html](https://sqlite.com/fileformat2.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://sqlite.com/fileformat2.html](https://sqlite.com/fileformat2.html)
- en: This document describes and defines the on-disk database file format used by
    all releases of SQLite since version 3.0.0 (2004-06-18).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本文档描述和定义了自 SQLite 3.0.0 版本（2004-06-18）以来所有版本使用的磁盘上数据库文件格式。
- en: The complete state of an SQLite database is usually contained in a single file
    on disk called the "main database file".
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 数据库的完整状态通常包含在磁盘上的单个文件中，称为“主数据库文件”。
- en: During a transaction, SQLite stores additional information in a second file
    called the "rollback journal", or if SQLite is in [WAL mode](wal.html), a write-ahead
    log file.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在事务期间，SQLite 将额外的信息存储在第二个文件中，称为“回滚日志”，或者如果 SQLite 处于 [WAL 模式](wal.html)，则是写前日志文件。
- en: 1.1\. Hot Journals
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '-   热门日志'
- en: If the application or host computer crashes before the transaction completes,
    then the rollback journal or write-ahead log contains information needed to restore
    the main database file to a consistent state. When a rollback journal or write-ahead
    log contains information necessary for recovering the state of the database, they
    are called a "hot journal" or "hot WAL file". Hot journals and WAL files are only
    a factor during error recovery scenarios and so are uncommon, but they are part
    of the state of an SQLite database and so cannot be ignored. This document defines
    the format of a rollback journal and the write-ahead log file, but the focus is
    on the main database file.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序或主机计算机在事务完成之前崩溃，则回滚日志或写前日志包含恢复主数据库文件到一致状态所需的信息。当回滚日志或写前日志包含恢复数据库状态所需的信息时，它们被称为“热日志”或“热
    WAL 文件”。热日志和 WAL 文件仅在错误恢复场景中才是因素，因此并不常见，但它们是 SQLite 数据库状态的一部分，因此不能被忽视。本文档定义了回滚日志和写前日志文件的格式，但重点在于主数据库文件。
- en: 1.2\. Pages
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '-   页面'
- en: The main database file consists of one or more pages. The size of a page is
    a power of two between 512 and 65536 inclusive. All pages within the same database
    are the same size. The page size for a database file is determined by the 2-byte
    integer located at an offset of 16 bytes from the beginning of the database file.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 主数据库文件由一个或多个页面组成。页面大小是介于 512 和 65536 之间的二的幂。同一数据库中的所有页面大小相同。数据库文件的页面大小由位于距离数据库文件开头
    16 字节处的 2 字节整数确定。
- en: Pages are numbered beginning with 1\. The maximum page number is 4294967294
    (2^(32) - 2). The minimum size SQLite database is a single 512-byte page. The
    maximum size database would be 4294967294 pages at 65536 bytes per page or 281,474,976,579,584
    bytes (about 281 terabytes). Usually SQLite will hit the maximum file size limit
    of the underlying filesystem or disk hardware long before it hits its own internal
    size limit.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 页面从 1 开始编号。最大页面编号为 4294967294（2^(32) - 2）。最小大小的 SQLite 数据库是单个 512 字节页面。最大大小的数据库将是
    4294967294 个页面，每个页面大小为 65536 字节，总共约 281,474,976,579,584 字节（约 281 TB）。通常，SQLite
    在达到底层文件系统或磁盘硬件的最大文件大小限制之前，会达到自身的内部大小限制。
- en: In common use, SQLite databases tend to range in size from a few kilobytes to
    a few gigabytes, though terabyte-size SQLite databases are known to exist in production.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在常见的使用情况下，SQLite数据库的大小通常从几千字节到几个千兆字节不等，尽管已知生产中存在大小为TB级别的SQLite数据库。
- en: 'At any point in time, every page in the main database has a single use which
    is one of the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在主数据库的任何时间点，每页都有一个单一的用途，可以是以下之一：
- en: A b-tree page
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个B树页
- en: A table b-tree interior page
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表B树内部页
- en: A table b-tree leaf page
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表B树叶页
- en: An index b-tree interior page
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个索引B树内部页
- en: An index b-tree leaf page
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个索引B树叶页
- en: A freelist page
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个自由列表页
- en: A freelist trunk page
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个自由列表干页
- en: A freelist leaf page
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个自由列表叶页
- en: A payload overflow page
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效负载溢出页
- en: A pointer map page
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指针映射页
- en: The lock-byte page
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁字节页
- en: All reads from and writes to the main database file begin at a page boundary
    and all writes are an integer number of pages in size. Reads are also usually
    an integer number of pages in size, with the one exception that when the database
    is first opened, the first 100 bytes of the database file (the database file header)
    are read as a sub-page size unit.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从主数据库文件中读取和写入的所有操作都从页边界开始，所有写入操作都是页大小的整数倍。读取通常也是页大小的整数倍，但有一个例外：当首次打开数据库时，会读取数据库文件的前100字节（数据库文件头）作为子页大小单元。
- en: 1.3\. The Database Header
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3\. 数据库头
- en: The first 100 bytes of the database file comprise the database file header.
    The database file header is divided into fields as shown by the table below. All
    multibyte fields in the database file header are stored with the most significant
    byte first (big-endian).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库文件的前100字节包括数据库文件头。数据库文件头按表格显示的字段进行划分。数据库文件头中的所有多字节字段均以最高有效字节在前（大端序）的方式存储。
- en: '*Database Header Format*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据库头格式*'
- en: '| Offset | Size | Description |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 偏移量 | 大小 | 描述 |'
- en: '| 0 | 16 | The header string: "SQLite format 3\000" |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 16 | 头字符串：“SQLite format 3\000” |'
- en: '| 16 | 2 | The database page size in bytes. Must be a power of two between
    512 and 32768 inclusive, or the value 1 representing a page size of 65536. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 2 | 数据库页大小（以字节为单位）。必须是512到32768之间的二的幂次方，或值为1，表示页大小为65536。 |'
- en: '| 18 | 1 | File format write version. 1 for legacy; 2 for [WAL](wal.html).
    |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 18 | 1 | 文件格式写入版本。对于传统格式为1；对于[WAL](wal.html)为2。 |'
- en: '| 19 | 1 | File format read version. 1 for legacy; 2 for [WAL](wal.html). |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 19 | 1 | 文件格式读取版本。对于传统格式为1；对于[WAL](wal.html)为2。 |'
- en: '| 20 | 1 | Bytes of unused "reserved" space at the end of each page. Usually
    0. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 20 | 1 | 每页末尾未使用的“保留”空间字节数。通常为0。 |'
- en: '| 21 | 1 | Maximum embedded payload fraction. Must be 64. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 21 | 1 | 最大嵌入负载分数。必须是64。 |'
- en: '| 22 | 1 | Minimum embedded payload fraction. Must be 32. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 22 | 1 | 最小嵌入负载分数。必须是32。 |'
- en: '| 23 | 1 | Leaf payload fraction. Must be 32. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 23 | 1 | 叶负载分数。必须是32。 |'
- en: '| 24 | 4 | File change counter. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 24 | 4 | 文件更改计数器。 |'
- en: '| 28 | 4 | Size of the database file in pages. The "in-header database size".
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 28 | 4 | 数据库文件大小，以页为单位。“头部数据库大小”。 |'
- en: '| 32 | 4 | Page number of the first freelist trunk page. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 32 | 4 | 第一个自由列表干页的页码。 |'
- en: '| 36 | 4 | Total number of freelist pages. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 36 | 4 | 空闲列表页的总数。 |'
- en: '| 40 | 4 | The schema cookie. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 40 | 4 | 模式 cookie。 |'
- en: '| 44 | 4 | The schema format number. Supported schema formats are 1, 2, 3,
    and 4. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 44 | 4 | 模式格式号。支持的模式格式为 1、2、3 和 4。 |'
- en: '| 48 | 4 | Default page cache size. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 48 | 4 | 默认页面缓存大小。 |'
- en: '| 52 | 4 | The page number of the largest root b-tree page when in auto-vacuum
    or incremental-vacuum modes, or zero otherwise. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 52 | 4 | 在自动清理或增量清理模式下，最大根 b 树页的页码；否则为零。 |'
- en: '| 56 | 4 | The database text encoding. A value of 1 means UTF-8\. A value of
    2 means UTF-16le. A value of 3 means UTF-16be. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 56 | 4 | 数据库文本编码。值为 1 表示 UTF-8。值为 2 表示 UTF-16le。值为 3 表示 UTF-16be。 |'
- en: '| 60 | 4 | The "user version" as read and set by the [user_version pragma](pragma.html#pragma_user_version).
    |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 60 | 4 | 由 [user_version pragma](pragma.html#pragma_user_version) 读取和设置的“用户版本”。
    |'
- en: '| 64 | 4 | True (non-zero) for incremental-vacuum mode. False (zero) otherwise.
    |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 64 | 4 | 增量清理模式时为真（非零）。否则为假（零）。 |'
- en: '| 68 | 4 | The "Application ID" set by [PRAGMA application_id](pragma.html#pragma_application_id).
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 68 | 4 | 由 [PRAGMA application_id](pragma.html#pragma_application_id) 设置的“应用程序
    ID”。 |'
- en: '| 72 | 20 | Reserved for expansion. Must be zero. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 72 | 20 | 用于扩展保留的字段。必须为零。 |'
- en: '| 92 | 4 | The [version-valid-for number](fileformat2.html#validfor). |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 92 | 4 | [version-valid-for number](fileformat2.html#validfor)。 |'
- en: '| 96 | 4 | [SQLITE_VERSION_NUMBER](c3ref/c_source_id.html) |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 96 | 4 | [SQLITE_VERSION_NUMBER](c3ref/c_source_id.html) |'
- en: 1.3.1\. Magic Header String
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.1\. 魔术头字符串
- en: 'Every valid SQLite database file begins with the following 16 bytes (in hex):
    53 51 4c 69 74 65 20 66 6f 72 6d 61 74 20 33 00\. This byte sequence corresponds
    to the UTF-8 string "SQLite format 3" including the nul terminator character at
    the end.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 每个有效的 SQLite 数据库文件以以下 16 字节（十六进制）开头：53 51 4c 69 74 65 20 66 6f 72 6d 61 74 20
    33 00。这个字节序列对应于 UTF-8 字符串“SQLite format 3”，包括末尾的空字符。
- en: 1.3.2\. Page Size
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.2\. 页面大小
- en: The two-byte value beginning at offset 16 determines the page size of the database.
    For SQLite versions 3.7.0.1 (2010-08-04) and earlier, this value is interpreted
    as a big-endian integer and must be a power of two between 512 and 32768, inclusive.
    Beginning with SQLite [version 3.7.1](releaselog/3_7_1.html) (2010-08-23), a page
    size of 65536 bytes is supported. The value 65536 will not fit in a two-byte integer,
    so to specify a 65536-byte page size, the value at offset 16 is 0x00 0x01. This
    value can be interpreted as a big-endian 1 and thought of as a magic number to
    represent the 65536 page size. Or one can view the two-byte field as a little
    endian number and say that it represents the page size divided by 256\. These
    two interpretations of the page-size field are equivalent.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从 SQLite [版本 3.7.1](releaselog/3_7_1.html)（2010-08-23）开始，偏移量 16 处的两字节值确定数据库的页面大小。对于
    SQLite 版本 3.7.0.1（2010-08-04）及更早版本，此值被解释为大端整数，并且必须是 512 到 32768 之间的二的幂次方。从 SQLite
    版本 3.7.1 开始，支持 65536 字节的页面大小。值 65536 无法用两字节整数表示，因此要指定 65536 字节的页面大小，偏移量 16 处的值为
    0x00 0x01。该值可以解释为大端数 1，用来表示 65536 页面大小的魔数。或者可以将两字节字段视为小端数，并说它表示页面大小除以 256。页面大小字段的这两种解释是等效的。
- en: 1.3.3\. File format version numbers
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.3\. 文件格式版本号
- en: The file format write version and file format read version at offsets 18 and
    19 are intended to allow for enhancements of the file format in future versions
    of SQLite. In current versions of SQLite, both of these values are 1 for rollback
    journalling modes and 2 for [WAL](wal.html) journalling mode. If a version of
    SQLite coded to the current file format specification encounters a database file
    where the read version is 1 or 2 but the write version is greater than 2, then
    the database file must be treated as read-only. If a database file with a read
    version greater than 2 is encountered, then that database cannot be read or written.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 文件格式写入版本和文件格式读取版本在偏移量 18 和 19 处，旨在允许 SQLite 的未来版本中对文件格式进行增强。在当前的 SQLite 版本中，这两个值对于回滚日志模式都是
    1，对于[WAL](wal.html)日志模式是 2。如果一个按照当前文件格式规范编码的 SQLite 版本遇到读取版本为 1 或 2 但写入版本大于 2
    的数据库文件，则必须将该数据库文件视为只读。如果遇到读取版本大于 2 的数据库文件，则该数据库无法读取或写入。
- en: 1.3.4\. Reserved bytes per page
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.4\. 每页保留字节
- en: SQLite has the ability to set aside a small number of extra bytes at the end
    of every page for use by extensions. These extra bytes are used, for example,
    by the SQLite Encryption Extension to store a nonce and/or cryptographic checksum
    associated with each page. The "reserved space" size in the 1-byte integer at
    offset 20 is the number of bytes of space at the end of each page to reserve for
    extensions. This value is usually 0\. The value can be odd.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 具有在每个页面末尾预留少量额外字节的能力，供扩展使用。例如，SQLite 加密扩展使用这些额外字节存储与每个页面相关的 nonce 和/或密码校验和。偏移量
    20 处的 1 字节整数 "保留空间" 大小是每页末尾为扩展预留的字节数。通常此值为 0。该值可以是奇数。
- en: The "usable size" of a database page is the page size specified by the 2-byte
    integer at offset 16 in the header less the "reserved" space size recorded in
    the 1-byte integer at offset 20 in the header. The usable size of a page might
    be an odd number. However, the usable size is not allowed to be less than 480\.
    In other words, if the page size is 512, then the reserved space size cannot exceed
    32.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库页面的“可用大小”是头部偏移量16处指定的页面大小减去头部偏移量20处记录的“保留”空间大小。页面的可用大小可能是奇数。但是，可用大小不得少于480。换句话说，如果页面大小为512，则保留空间大小不能超过32。
- en: 1.3.5\. Payload fractions
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.5\. 负载分数
- en: The maximum and minimum embedded payload fractions and the leaf payload fraction
    values must be 64, 32, and 32\. These values were originally intended to be tunable
    parameters that could be used to modify the storage format of the b-tree algorithm.
    However, that functionality is not supported and there are no current plans to
    add support in the future. Hence, these three bytes are fixed at the values specified.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式负载分数的最大和最小值以及叶负载分数值必须为64、32和32。这些值最初设计为可调参数，可用于修改B树算法的存储格式。然而，此功能未得到支持，未来也没有当前计划添加支持。因此，这三个字节的值被固定为指定的值。
- en: 1.3.6\. File change counter
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.6\. 文件更改计数器
- en: The file change counter is a 4-byte big-endian integer at offset 24 that is
    incremented whenever the database file is unlocked after having been modified.
    When two or more processes are reading the same database file, each process can
    detect database changes from other processes by monitoring the change counter.
    A process will normally want to flush its database page cache when another process
    modified the database, since the cache has become stale. The file change counter
    facilitates this.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 文件更改计数器是一个4字节的大端整数，在偏移量24处，每当数据库文件在被修改后解锁时递增。当两个或多个进程读取同一数据库文件时，每个进程可以通过监视更改计数器来检测其他进程的数据库更改。一个进程通常会希望在其他进程修改数据库时刷新其数据库页面缓存，因为缓存已经过时。文件更改计数器有助于实现这一点。
- en: In WAL mode, changes to the database are detected using the wal-index and so
    the change counter is not needed. Hence, the change counter might not be incremented
    on each transaction in WAL mode.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在WAL模式下，使用wal-index检测数据库的更改，因此不需要更改计数器。因此，在WAL模式下，更改计数器可能不会在每个事务中递增。
- en: 1.3.7\. In-header database size
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.7\. 头部中的数据库大小
- en: The 4-byte big-endian integer at offset 28 into the header stores the size of
    the database file in pages. If this in-header datasize size is not valid (see
    the next paragraph), then the database size is computed by looking at the actual
    size of the database file. Older versions of SQLite ignored the in-header database
    size and used the actual file size exclusively. Newer versions of SQLite use the
    in-header database size if it is available but fall back to the actual file size
    if the in-header database size is not valid.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库文件头部偏移量 28 处的 4 字节大端整数存储数据库文件的页面大小。如果此头部数据大小无效（参见下一段），则通过实际数据库文件的大小来计算数据库大小。较早的
    SQLite 版本会忽略头部数据库大小，而仅使用实际文件大小。更新的 SQLite 版本如果可用则使用头部数据库大小，但如果头部数据库大小无效则回退到实际文件大小。
- en: The in-header database size is only considered to be valid if it is non-zero
    and if the 4-byte [change counter](fileformat2.html#chngctr) at offset 24 exactly
    matches the 4-byte [version-valid-for number](fileformat2.html#validfor) at offset
    92. The in-header database size is always valid when the database is only modified
    using recent versions of SQLite, versions 3.7.0 (2010-07-21) and later. If a legacy
    version of SQLite writes to the database, it will not know to update the in-header
    database size and so the in-header database size could be incorrect. But legacy
    versions of SQLite will also leave the version-valid-for number at offset 92 unchanged
    so it will not match the change-counter. Hence, invalid in-header database sizes
    can be detected (and ignored) by observing when the change-counter does not match
    the version-valid-for number.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当头部数据库大小非零且偏移量 24 处的 4 字节[变更计数器](fileformat2.html#chngctr)与偏移量 92 处的 4 字节[适用版本号](fileformat2.html#validfor)完全匹配时，头部数据库大小才被视为有效。当仅使用较新版本的
    SQLite 进行数据库修改时，头部数据库大小始终有效，从 SQLite 3.7.0（2010-07-21）及更高版本开始。如果使用旧版 SQLite 写入数据库，则无法更新头部数据库大小，因此头部数据库大小可能不正确。但是，旧版
    SQLite 也会保持偏移量 92 处的版本号不变，因此它不会与变更计数器匹配。因此，可以通过观察变更计数器与适用版本号不匹配来检测（和忽略）无效的头部数据库大小。
- en: 1.3.8\. Free page list
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.8\. 空闲页列表
- en: Unused pages in the database file are stored on a freelist. The 4-byte big-endian
    integer at offset 32 stores the page number of the first page of the freelist,
    or zero if the freelist is empty. The 4-byte big-endian integer at offset 36 stores
    the total number of pages on the freelist.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库文件中未使用的页面存储在空闲列表中。位于偏移量 32 处的 4 字节大端整数存储空闲列表中第一页的页码，如果空闲列表为空则为零。位于偏移量 36
    处的 4 字节大端整数存储空闲列表中页面的总数。
- en: 1.3.9\. Schema cookie
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.9\. Schema cookie
- en: The schema cookie is a 4-byte big-endian integer at offset 40 that is incremented
    whenever the database schema changes. A prepared statement is compiled against
    a specific version of the database schema. When the database schema changes, the
    statement must be reprepared. When a prepared statement runs, it first checks
    the schema cookie to ensure the value is the same as when the statement was prepared
    and if the schema cookie has changed, the statement either automatically reprepares
    and reruns or it aborts with an [SQLITE_SCHEMA](rescode.html#schema) error.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在偏移量为40的位置，模式cookie是一个4字节的大端整数，每当数据库模式发生更改时就会递增。准备语句是针对特定版本的数据库模式编译的。当数据库模式发生更改时，必须重新准备该语句。当准备语句运行时，首先检查模式cookie以确保其值与准备语句时相同，如果模式cookie发生更改，则该语句要么自动重新准备和重新运行，要么中止并显示[SQLITE_SCHEMA](rescode.html#schema)错误。
- en: 1.3.10\. Schema format number
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.10\. 模式格式编号
- en: 'The schema format number is a 4-byte big-endian integer at offset 44. The schema
    format number is similar to the file format read and write version numbers at
    offsets 18 and 19 except that the schema format number refers to the high-level
    SQL formatting rather than the low-level b-tree formatting. Four schema format
    numbers are currently defined:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 模式格式编号是一个4字节的大端整数，在偏移量44处。模式格式编号类似于偏移量18和19处的文件格式读取和写入版本号，但模式格式编号是高级SQL格式而不是低级B树格式。目前定义了四种模式格式编号：
- en: Format 1 is understood by all versions of SQLite back to [version 3.0.0](releaselog/3_0_0.html)
    (2004-06-18).
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 格式1被所有SQLite版本理解，追溯到[版本3.0.0](releaselog/3_0_0.html)（2004-06-18）。
- en: Format 2 adds the ability of rows within the same table to have a varying number
    of columns, in order to support the [ALTER TABLE ... ADD COLUMN](lang_altertable.html)
    functionality. Support for reading and writing format 2 was added in SQLite [version
    3.1.3](releaselog/3_1_3.html) on 2005-02-20.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 格式2增加了同一表中行可以具有不同列数的能力，以支持[ALTER TABLE ... ADD COLUMN](lang_altertable.html)功能。对格式2的读取和写入支持是在SQLite
    [版本3.1.3](releaselog/3_1_3.html)（2005-02-20）中添加的。
- en: Format 3 adds the ability of extra columns added by [ALTER TABLE ... ADD COLUMN](lang_altertable.html)
    to have non-NULL default values. This capability was added in SQLite [version
    3.1.4](releaselog/3_1_4.html) on 2005-03-11.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 格式3增加了由[ALTER TABLE ... ADD COLUMN](lang_altertable.html)添加的额外列具有非NULL默认值的能力。此功能是在SQLite
    [版本3.1.4](releaselog/3_1_4.html)（2005-03-11）中添加的。
- en: Format 4 causes SQLite to respect the [DESC keyword](lang_createindex.html#descidx)
    on index declarations. (The DESC keyword is ignored in indexes for formats 1,
    2, and 3.) Format 4 also adds two new boolean record type values ([serial types](fileformat2.html#serialtype)
    8 and 9). Support for format 4 was added in SQLite 3.3.0 on 2006-01-10.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 格式4导致SQLite在索引声明中尊重[DESC关键字](lang_createindex.html#descidx)。（在格式1、2和3的索引中，DESC关键字被忽略。）格式4还添加了两个新的布尔记录类型值（[串行类型](fileformat2.html#serialtype)8和9）。支持格式4是在SQLite
    3.3.0（2006-01-10）中添加的。
- en: New database files created by SQLite use format 4 by default. The [legacy_file_format
    pragma](pragma.html#pragma_legacy_file_format) can be used to cause SQLite to
    create new database files using format 1. The format version number can be made
    to default to 1 instead of 4 by setting [SQLITE_DEFAULT_FILE_FORMAT](compile.html#default_file_format)=1
    at compile-time.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 默认使用格式 4 创建新的数据库文件。可以使用 [legacy_file_format pragma](pragma.html#pragma_legacy_file_format)
    来使 SQLite 创建格式 1 的新数据库文件。可以通过在编译时设置 [SQLITE_DEFAULT_FILE_FORMAT](compile.html#default_file_format)=1
    将格式版本号默认设置为 1。
- en: 1.3.11\. Suggested cache size
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.11\. 建议的缓存大小
- en: The 4-byte big-endian signed integer at offset 48 is the suggested cache size
    in pages for the database file. The value is a suggestion only and SQLite is under
    no obligation to honor it. The absolute value of the integer is used as the suggested
    size. The suggested cache size can be set using the [default_cache_size pragma](pragma.html#pragma_default_cache_size).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 偏移量为 48 的四字节大端符号整数是数据库文件的建议缓存大小（以页面为单位）。该值仅供参考，SQLite 不承担任何义务来遵循它。整数的绝对值作为建议大小使用。建议的缓存大小可以使用
    [default_cache_size pragma](pragma.html#pragma_default_cache_size) 设置。
- en: 1.3.12\. Incremental vacuum settings
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.12\. 增量清理设置
- en: The two 4-byte big-endian integers at offsets 52 and 64 are used to manage the
    [auto_vacuum](pragma.html#pragma_auto_vacuum) and [incremental_vacuum](pragma.html#pragma_incremental_vacuum)
    modes. If the integer at offset 52 is zero then pointer-map (ptrmap) pages are
    omitted from the database file and neither auto_vacuum nor incremental_vacuum
    are supported. If the integer at offset 52 is non-zero then it is the page number
    of the largest root page in the database file, the database file will contain
    ptrmap pages, and the mode must be either auto_vacuum or incremental_vacuum. In
    this latter case, the integer at offset 64 is true for incremental_vacuum and
    false for auto_vacuum. If the integer at offset 52 is zero then the integer at
    offset 64 must also be zero.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 偏移量为 52 和 64 的两个四字节大端整数用于管理 [auto_vacuum](pragma.html#pragma_auto_vacuum) 和
    [incremental_vacuum](pragma.html#pragma_incremental_vacuum) 模式。如果偏移量为 52 的整数为零，则数据库文件中省略指针映射（ptrmap）页面，并且不支持自动清理或增量清理。如果偏移量为
    52 的整数非零，则它是数据库文件中最大根页面的页号，数据库文件将包含 ptrmap 页面，并且模式必须是自动清理或增量清理。在后一种情况下，偏移量为 64
    的整数对于增量清理为真，对于自动清理为假。如果偏移量为 52 的整数为零，则偏移量为 64 的整数也必须为零。
- en: 1.3.13\. Text encoding
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.13\. 文本编码
- en: The 4-byte big-endian integer at offset 56 determines the encoding used for
    all text strings stored in the database. A value of 1 means UTF-8. A value of
    2 means UTF-16le. A value of 3 means UTF-16be. No other values are allowed. The
    sqlite3.h header file defines C-preprocessor macros SQLITE_UTF8 as 1, SQLITE_UTF16LE
    as 2, and SQLITE_UTF16BE as 3, to use in place of the numeric codes for the text
    encoding.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 偏移量为 56 的 4 字节大端整数确定数据库中存储的所有文本字符串所使用的编码。值为 1 表示 UTF-8，值为 2 表示 UTF-16le，值为 3
    表示 UTF-16be。不允许其他值。sqlite3.h 头文件定义了 C 预处理宏 SQLITE_UTF8 为 1，SQLITE_UTF16LE 为 2，SQLITE_UTF16BE
    为 3，用于替代文本编码的数值代码。
- en: 1.3.14\. User version number
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.14\. 用户版本号
- en: The 4-byte big-endian integer at offset 60 is the user version which is set
    and queried by the [user_version pragma](pragma.html#pragma_user_version). The
    user version is not used by SQLite.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 偏移量为 60 的 4 字节大端整数是由 [user_version pragma](pragma.html#pragma_user_version)
    设置和查询的用户版本。SQLite 不使用用户版本。
- en: 1.3.15\. Application ID
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.15\. 应用程序 ID
- en: The 4-byte big-endian integer at offset 68 is an "Application ID" that can be
    set by the [PRAGMA application_id](pragma.html#pragma_application_id) command
    in order to identify the database as belonging to or associated with a particular
    application. The application ID is intended for database files used as an [application
    file-format](appfileformat.html). The application ID can be used by utilities
    such as [file(1)](http://www.darwinsys.com/file/) to determine the specific file
    type rather than just reporting "SQLite3 Database". A list of assigned application
    IDs can be seen by consulting the [magic.txt](https://www.sqlite.org/src/artifact?ci=trunk&filename=magic.txt)
    file in the SQLite source repository.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 偏移量为 68 的 4 字节大端整数是可以通过 [PRAGMA application_id](pragma.html#pragma_application_id)
    命令设置的“应用程序 ID”，以便识别数据库所属或与特定应用程序相关联。应用程序 ID 用于作为 [应用程序文件格式](appfileformat.html)
    使用的数据库文件。应用程序 ID 可以被诸如 [file(1)](http://www.darwinsys.com/file/) 的实用程序使用，以确定具体的文件类型，而不仅仅报告“SQLite3
    数据库”。可以通过查阅 SQLite 源代码仓库中的 [magic.txt](https://www.sqlite.org/src/artifact?ci=trunk&filename=magic.txt)
    文件来查看分配的应用程序 ID 的列表。
- en: 1.3.16\. Write library version number and version-valid-for number
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.16\. 写库版本号和版本有效号码
- en: The 4-byte big-endian integer at offset 96 stores the [SQLITE_VERSION_NUMBER](c3ref/c_source_id.html)
    value for the SQLite library that most recently modified the database file. The
    4-byte big-endian integer at offset 92 is the value of the [change counter](fileformat2.html#chngctr)
    when the version number was stored. The integer at offset 92 indicates which transaction
    the version number is valid for and is sometimes called the "version-valid-for
    number".
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 偏移量为 96 的 4 字节大端整数存储了最近修改数据库文件的 [SQLITE_VERSION_NUMBER](c3ref/c_source_id.html)
    值。偏移量为 92 的 4 字节大端整数是版本号存储时的 [更改计数器](fileformat2.html#chngctr) 值。偏移量为 92 的整数指示版本号有效的事务，并有时称为“版本有效号码”。
- en: 1.3.17\. Header space reserved for expansion
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.17\. 头部空间保留用于扩展
- en: All other bytes of the database file header are reserved for future expansion
    and must be set to zero.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库文件头的所有其他字节均保留供未来扩展使用，并且必须设置为零。
- en: 1.4\. The Lock-Byte Page
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4\. 锁字节页
- en: The lock-byte page is the single page of the database file that contains the
    bytes at offsets between 1073741824 and 1073742335, inclusive. A database file
    that is less than or equal to 1073741824 bytes in size contains no lock-byte page.
    A database file larger than 1073741824 contains exactly one lock-byte page.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 锁字节页是数据库文件中的单个页面，在1073741824到1073742335之间的偏移量包含字节。文件大小小于或等于1073741824字节的数据库文件不包含锁字节页。大于1073741824的数据库文件包含恰好一个锁字节页。
- en: The lock-byte page is set aside for use by the operating-system specific [VFS](vfs.html)
    implementation in implementing the database file locking primitives. SQLite does
    not use the lock-byte page. The SQLite core will never read or write the lock-byte
    page, though operating-system specific [VFS](vfs.html) implementations may choose
    to read or write bytes on the lock-byte page according to the needs and proclivities
    of the underlying system. The unix and win32 [VFS](vfs.html) implementations that
    come built into SQLite do not write to the lock-byte page, but third-party VFS
    implementations for other operating systems might.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 锁字节页专门供操作系统特定的[VFS](vfs.html)实现使用，用于实现数据库文件锁定原语。SQLite不使用锁字节页。SQLite核心永远不会读取或写入锁字节页，尽管操作系统特定的[VFS](vfs.html)实现可以根据底层系统的需要选择性地读取或写入锁字节页上的字节。内置于SQLite的unix和win32[VFS](vfs.html)实现不会写入锁字节页，但是针对其他操作系统的第三方VFS实现可能会。
- en: The lock-byte page arose from the need to support Win95 which was the predominant
    operating system when this file format was designed and which only supported mandatory
    file locking. All modern operating systems that we know of support advisory file
    locking, and so the lock-byte page is not really needed any more, but is retained
    for backwards compatibility.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 锁字节页源于支持Win95的需求，当时它是设计此文件格式的主要操作系统，并且仅支持强制文件锁定。我们所知的所有现代操作系统都支持建议性文件锁定，因此锁字节页现在实际上不再需要，但为了向后兼容性而保留。
- en: 1.5\. The Freelist
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.5\. 自由列表
- en: A database file might contain one or more pages that are not in active use.
    Unused pages can come about, for example, when information is deleted from the
    database. Unused pages are stored on the freelist and are reused when additional
    pages are required.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库文件可能包含一个或多个未处于活动使用状态的页。未使用的页可能是由于从数据库中删除信息而导致的。未使用的页存储在自由列表上，并在需要更多页时进行重用。
- en: The freelist is organized as a linked list of freelist trunk pages with each
    trunk page containing page numbers for zero or more freelist leaf pages.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 自由列表以自由列表主干页的链表形式组织，每个主干页包含零个或多个自由列表叶页的页码。
- en: A freelist trunk page consists of an array of 4-byte big-endian integers. The
    size of the array is as many integers as will fit in the usable space of a page.
    The minimum usable space is 480 bytes so the array will always be at least 120
    entries in length. The first integer on a freelist trunk page is the page number
    of the next freelist trunk page in the list or zero if this is the last freelist
    trunk page. The second integer on a freelist trunk page is the number of leaf
    page pointers to follow. Call the second integer on a freelist trunk page L. If
    L is greater than zero then integers with array indexes between 2 and L+1 inclusive
    contain page numbers for freelist leaf pages.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 空闲列表主干页由一个 4 字节大端整数数组组成。数组的大小是尽可能多的整数，以适合页面的可用空间。最小可用空间为 480 字节，因此数组的长度始终至少为
    120 个条目。空闲列表主干页的第一个整数是列表中下一个空闲列表主干页的页号，如果这是最后一个空闲列表主干页，则为零。空闲列表主干页的第二个整数是要跟随的叶页指针的数量。将空闲列表主干页上的第二个整数称为
    L。如果 L 大于零，则数组索引在 2 到 L+1 之间的整数包含空闲列表叶页的页号。
- en: Freelist leaf pages contain no information. SQLite avoids reading or writing
    freelist leaf pages in order to reduce disk I/O.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 空闲列表叶页不包含任何信息。SQLite 避免读取或写入空闲列表叶页以减少磁盘 I/O。
- en: A bug in SQLite versions prior to 3.6.0 (2008-07-16) caused the database to
    be reported as corrupt if any of the last 6 entries in the freelist trunk page
    array contained non-zero values. Newer versions of SQLite do not have this problem.
    However, newer versions of SQLite still avoid using the last six entries in the
    freelist trunk page array in order that database files created by newer versions
    of SQLite can be read by older versions of SQLite.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLite 3.6.0（2008-07-16）之前的版本中存在一个 bug，如果空闲列表主干页数组的最后 6 个条目中有任何非零值，将会导致数据库报告为损坏。新版本的
    SQLite 没有这个问题。然而，为了使由新版本的 SQLite 创建的数据库文件能够被旧版本的 SQLite 读取，新版本的 SQLite 仍然避免使用空闲列表主干页数组的最后六个条目。
- en: The number of freelist pages is stored as a 4-byte big-endian integer in the
    database header at an offset of 36 from the beginning of the file. The database
    header also stores the page number of the first freelist trunk page as a 4-byte
    big-endian integer at an offset of 32 from the beginning of the file.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库头部存储空闲列表页数，以从文件开始处偏移 36 字节的 4 字节大端整数形式存储。数据库头部还以从文件开始处偏移 32 字节的 4 字节大端整数形式存储第一个空闲列表主干页的页号。
- en: 1.6\. B-tree Pages
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.6\. B-tree 页
- en: The b-tree algorithm provides key/data storage with unique and ordered keys
    on page-oriented storage devices. For background information on b-trees, see Knuth,
    The Art Of Computer Programming, Volume 3 "Sorting and Searching", pages 471-479\.
    Two variants of b-trees are used by SQLite. "Table b-trees" use a 64-bit signed
    integer key and store all data in the leaves. "Index b-trees" use arbitrary keys
    and store no data at all.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: B 树算法提供了基于页面的存储设备上的唯一和有序键/数据存储。有关 B 树的背景信息，请参阅 Knuth 的《计算机程序设计艺术》，第 3 卷《排序与搜索》，第
    471-479 页。SQLite 使用两种 B 树变体。"表 B 树" 使用 64 位有符号整数键，并在叶子节点中存储所有数据。"索引 B 树" 使用任意键，并且根本不存储数据。
- en: A b-tree page is either an interior page or a leaf page. A leaf page contains
    keys and in the case of a table b-tree each key has associated data. An interior
    page contains K keys together with K+1 pointers to child b-tree pages. A "pointer"
    in an interior b-tree page is just the 32-bit unsigned integer page number of
    the child page.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: B 树页面可以是内部页面或叶子页面。叶子页面包含键，而在表 B 树的情况下，每个键都有关联数据。内部页面包含 K 个键以及 K+1 个指向子 B 树页面的指针。在内部
    B 树页面中，"指针" 只是子页面的 32 位无符号整数页面号。
- en: The number of keys on an interior b-tree page, K, is almost always at least
    2 and is usually much more than 2. The only exception is when page 1 is an interior
    b-tree page. Page 1 has 100 fewer bytes of storage space available, due to the
    presence of the database header at the beginning of that page, and so sometimes
    (rarely) if page 1 is an interior b-tree page, it can end up holding just a single
    key. In all other cases, K is 2 or more. The upper bound on K is as many keys
    as will fit on the page. Large keys on index b-trees are split up into [overflow
    pages](fileformat2.html#ovflpgs) so that no single key uses more than one fourth
    of the available storage space on the page and hence every internal page is able
    to store at least 4 keys. The integer keys of table b-trees are never large enough
    to require overflow, so key overflow only occurs on index b-trees.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 内部 B 树页面上的键数 K 几乎总是至少为 2，并且通常远远超过 2。唯一的例外是当页面 1 是内部 B 树页面时。由于该页面开头处有数据库头部的存在，页面
    1 可用的存储空间少了 100 字节，因此有时（很少情况下），如果页面 1 是内部 B 树页面，则可能只容纳一个单一键。在所有其他情况下，K 都是 2 或更多。K
    的上限是页面上能容纳的键的数量。索引 B 树上的大键被分割成 [溢出页面](fileformat2.html#ovflpgs)，以便没有单个键使用超过页面上四分之一的可用存储空间，因此每个内部页面能够存储至少
    4 个键。表 B 树的整数键永远不会太大而需要溢出，因此键溢出仅发生在索引 B 树上。
- en: Define the depth of a leaf b-tree to be 1 and the depth of any interior b-tree
    to be one more than the maximum depth of any of its children. In a well-formed
    database, all children of an interior b-tree have the same depth.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 将叶子 B 树的深度定义为 1，并将任何内部 B 树的深度定义为比其任何子节点的最大深度多 1。在良好形式的数据库中，内部 B 树的所有子节点具有相同的深度。
- en: In an interior b-tree page, the pointers and keys logically alternate with a
    pointer on both ends. (The previous sentence is to be understood conceptually
    - the actual layout of the keys and pointers within the page is more complicated
    and will be described in the sequel.) All keys within the same page are unique
    and are logically organized in ascending order from left to right. (Again, this
    ordering is logical, not physical. The actual location of keys within the page
    is arbitrary.) For any key X, pointers to the left of a X refer to b-tree pages
    on which all keys are less than or equal to X. Pointers to the right of X refer
    to pages where all keys are greater than X.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部B树页面中，指针和键在逻辑上交替，并且两端都有指针。（前面的句子在概念上理解 - 实际的键和指针布局更加复杂，并将在后续描述。）同一页内的所有键都是唯一的，并且按照从左到右升序逻辑排序。（再次强调，这种顺序是逻辑上的，不是物理上的。键在页面中的实际位置是任意的。）对于任何键X，指向X左侧的指针指向的是所有键小于或等于X的B树页面。指向X右侧的指针指向的是所有键大于X的页面。
- en: Within an interior b-tree page, each key and the pointer to its immediate left
    are combined into a structure called a "cell". The right-most pointer is held
    separately. A leaf b-tree page has no pointers, but it still uses the cell structure
    to hold keys for index b-trees or keys and content for table b-trees. Data is
    also contained in the cell.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部B树页面中，每个键及其左侧的指针被合并成称为“单元”的结构。最右边的指针单独保存。叶B树页面没有指针，但仍使用单元结构来保存索引B树的键或表B树的键和内容。数据也包含在单元中。
- en: Every b-tree page has at most one parent b-tree page. A b-tree page without
    a parent is called a root page. A root b-tree page together with the closure of
    its children form a complete b-tree. It is possible (and in fact rather common)
    to have a complete b-tree that consists of a single page that is both a leaf and
    the root. Because there are pointers from parents to children, every page of a
    complete b-tree can be located if only the root page is known. Hence, b-trees
    are identified by their root page number.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 每个B树页面最多只有一个父B树页面。没有父页面的B树页面称为根页面。根B树页面与其子页面的闭包形成一个完整的B树。可能（事实上相当普遍）存在一个完整的B树，它由一个既是叶子又是根的单个页面组成。由于存在从父页面到子页面的指针，如果仅知道根页面，则可以定位完整B树的每个页面。因此，B树是由其根页面编号来标识的。
- en: 'A b-tree page is either a table b-tree page or an index b-tree page. All pages
    within each complete b-tree are of the same type: either table or index. There
    is one table b-trees in the database file for each rowid table in the database
    schema, including system tables such as [sqlite_schema](schematab.html). There
    is one index b-tree in the database file for each index in the schema, including
    implied indexes created by uniqueness constraints. There are no b-trees associated
    with [virtual tables](vtab.html). Specific virtual table implementations might
    make use of [shadow tables](vtab.html#xshadowname) for storage, but those shadow
    tables will have separate entries in the database schema. [WITHOUT ROWID](withoutrowid.html)
    tables use index b-trees rather than a table b-trees, so there is one index b-tree
    in the database file for each [WITHOUT ROWID](withoutrowid.html) table. The b-tree
    corresponding to the sqlite_schema table is always a table b-tree and always has
    a root page of 1. The sqlite_schema table contains the root page number for every
    other table and index in the database file.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: B树页可以是表B树页或索引B树页。在每个完整的B树中，所有页都是相同类型的：表或索引。数据库文件中每个行ID表（包括[sqlite_schema](schematab.html)等系统表）都有一个表B树。数据库文件中每个索引（包括由唯一性约束创建的隐式索引）都有一个索引B树。与[虚拟表](vtab.html)无关联的B树。特定的虚拟表实现可能使用[影子表](vtab.html#xshadowname)进行存储，但这些影子表在数据库模式中将有单独的条目。[WITHOUT
    ROWID](withoutrowid.html)表使用索引B树而不是表B树，因此数据库文件中每个[WITHOUT ROWID](withoutrowid.html)表都有一个索引B树。与sqlite_schema表对应的B树始终是表B树，并且始终具有根页为1。sqlite_schema表包含数据库文件中每个其他表和索引的根页号。
- en: Each entry in a table b-tree consists of a 64-bit signed integer key and up
    to 2147483647 bytes of arbitrary data. (The key of a table b-tree corresponds
    to the [rowid](lang_createtable.html#rowid) of the SQL table that the b-tree implements.)
    Interior table b-trees hold only keys and pointers to children. All data is contained
    in the table b-tree leaves.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 表B树中的每个条目由64位有符号整数键和最多2147483647字节的任意数据组成。（表B树的键对应于B树实现的SQL表的[rowid](lang_createtable.html#rowid)。）内部表B树仅保存键和指向子节点的指针。所有数据都包含在表B树叶页中。
- en: Each entry in an index b-tree consists of an arbitrary key of up to 2147483647
    bytes in length and no data.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 索引B树中的每个条目由最多2147483647字节长的任意键组成，而没有数据。
- en: Define the "payload" of a cell to be the arbitrary length section of the cell.
    For an index b-tree, the key is always arbitrary in length and hence the payload
    is the key. There are no arbitrary length elements in the cells of interior table
    b-tree pages and so those cells have no payload. Table b-tree leaf pages contain
    arbitrary length content and so for cells on those pages the payload is the content.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 定义单元格的“有效载荷”是单元格的任意长度部分。对于索引B树，键始终是任意长度的，因此有效载荷即为键。在内部表B树页的单元格中没有任意长度的元素，因此这些单元格没有有效载荷。表B树叶页包含任意长度的内容，因此对于这些页上的单元格，有效载荷即为内容。
- en: When the size of payload for a cell exceeds a certain threshold (to be defined
    later) then only the first few bytes of the payload are stored on the b-tree page
    and the balance is stored in a linked list of content overflow pages.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当单元的有效载荷大小超过一定阈值（稍后定义），则仅在 b 树页上存储有效载荷的前几个字节，其余存储在内容溢出页的链接列表中。
- en: 'A b-tree page is divided into regions in the following order:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: b 树页按以下顺序分为各个区域：
- en: The 100-byte database file header (found on page 1 only)
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 100 字节的数据库文件头部（仅在页面 1 上找到）
- en: The 8 or 12 byte b-tree page header
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 8 或 12 字节的 b 树页头部。
- en: The cell pointer array
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元指针数组。
- en: Unallocated space
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 未分配空间。
- en: The cell content area
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元内容区域。
- en: The reserved region.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保留区域。
- en: The 100-byte database file header is found only on page 1, which is always a
    table b-tree page. All other b-tree pages in the database file omit this 100-byte
    header.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 100 字节的数据库文件头部仅在页面 1 上找到，该页面始终是表 b 树页。
- en: The reserved region is an area of unused space at the end of every page (except
    the locking page) that extensions can use to hold per-page information. The size
    of the reserved region is determined by the one-byte unsigned integer found at
    an offset of 20 into the database file header. The size of the reserved region
    is usually zero.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 保留区域是每页（除了锁定页）末尾未使用空间的区域，用于保存每页信息。保留区域的大小由数据库文件头部偏移量为 20 处的单字节无符号整数确定。保留区域的大小通常为零。
- en: 'The b-tree page header is 8 bytes in size for leaf pages and 12 bytes for interior
    pages. All multibyte values in the page header are big-endian. The b-tree page
    header is composed of the following fields:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 叶页的 b 树页头部大小为 8 字节，内部页为 12 字节。页面头部中的所有多字节值均为大端序。b 树页头部由以下字段组成：
- en: '*B-tree Page Header Format*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*B 树页头格式*'
- en: '| Offset | Size | Description |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| Offset | Size | 描述 |'
- en: '| 0 | 1 | The one-byte flag at offset 0 indicating the b-tree page type.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '| 0 | 1 | 偏移量为 0 的单字节标志，表示 b 树页的类型。'
- en: A value of 2 (0x02) means the page is an interior index b-tree page.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值为 2（0x02）表示该页为内部索引 b 树页。
- en: A value of 5 (0x05) means the page is an interior table b-tree page.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值为 5（0x05）表示该页为内部表 b 树页。
- en: A value of 10 (0x0a) means the page is a leaf index b-tree page.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值为 10（0x0a）表示该页为叶索引 b 树页。
- en: A value of 13 (0x0d) means the page is a leaf table b-tree page.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值为 13（0x0d）表示该页为叶表 b 树页。
- en: Any other value for the b-tree page type is an error. |
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: b 树页类型的任何其他值都是错误。 |
- en: '| 1 | 2 | The two-byte integer at offset 1 gives the start of the first freeblock
    on the page, or is zero if there are no freeblocks. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 | 偏移量为 1 的两字节整数，表示页面上第一个空闲块的起始位置，如果没有空闲块则为零。 |'
- en: '| 3 | 2 | The two-byte integer at offset 3 gives the number of cells on the
    page. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 2 | 偏移量为 3 的两字节整数，表示页面上的单元数。 |'
- en: '| 5 | 2 | The two-byte integer at offset 5 designates the start of the cell
    content area. A zero value for this integer is interpreted as 65536. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 2 | 偏移量为 5 的两字节整数指定单元格内容区域的起始位置。如果这个整数的值为零，则解释为 65536。'
- en: '| 7 | 1 | The one-byte integer at offset 7 gives the number of fragmented free
    bytes within the cell content area. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 1 | 偏移量为 7 的一字节整数给出单元格内容区域内碎片化的空闲字节数。'
- en: '| 8 | 4 | The four-byte page number at offset 8 is the right-most pointer.
    This value appears in the header of interior b-tree pages only and is omitted
    from all other pages. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 4 | 偏移量为 8 的四字节页码是最右侧指针。该值仅出现在内部 b 树页面的头部，并且在所有其他页面中被省略。'
- en: The cell pointer array of a b-tree page immediately follows the b-tree page
    header. Let K be the number of cells on the btree. The cell pointer array consists
    of K 2-byte integer offsets to the cell contents. The cell pointers are arranged
    in key order with left-most cell (the cell with the smallest key) first and the
    right-most cell (the cell with the largest key) last.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: b 树页面的单元格指针数组紧随 b 树页面头部之后。设 K 为 b 树上的单元格数。单元格指针数组由 K 个 2 字节整数偏移量组成，指向单元格内容。单元格指针按键顺序排列，最左侧的单元格（具有最小键的单元格）在最前面，最右侧的单元格（具有最大键的单元格）在最后面。
- en: Cell content is stored in the cell content region of the b-tree page. SQLite
    strives to place cells as far toward the end of the b-tree page as it can, in
    order to leave space for future growth of the cell pointer array. The area in
    between the last cell pointer array entry and the beginning of the first cell
    is the unallocated region.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 单元格内容存储在 b 树页面的单元格内容区域中。SQLite 努力将单元格尽可能放在 b 树页面的末尾，以便为单元格指针数组的未来增长留出空间。最后一个单元格指针数组条目与第一个单元格的开头之间的区域是未分配区域。
- en: If a page contains no cells (which is only possible for a root page of a table
    that contains no rows) then the offset to the cell content area will equal the
    page size minus the bytes of reserved space. If the database uses a 65536-byte
    page size and the reserved space is zero (the usual value for reserved space)
    then the cell content offset of an empty page wants to be 65536\. However, that
    integer is too large to be stored in a 2-byte unsigned integer, so a value of
    0 is used in its place.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个页面不包含任何单元格（这只可能发生在包含零行的表的根页面上），那么到单元格内容区域的偏移量将等于页面大小减去保留空间的字节数。如果数据库使用的是
    65536 字节的页面大小，并且保留空间为零（保留空间的通常值），那么空页面的单元格内容偏移量将是 65536。然而，该整数太大，无法存储在一个 2 字节的无符号整数中，因此使用
    0 代替。
- en: A freeblock is a structure used to identify unallocated space within a b-tree
    page. Freeblocks are organized as a chain. The first 2 bytes of a freeblock are
    a big-endian integer which is the offset in the b-tree page of the next freeblock
    in the chain, or zero if the freeblock is the last on the chain. The third and
    fourth bytes of each freeblock form a big-endian integer which is the size of
    the freeblock in bytes, including the 4-byte header. Freeblocks are always connected
    in order of increasing offset. The second field of the b-tree page header is the
    offset of the first freeblock, or zero if there are no freeblocks on the page.
    In a well-formed b-tree page, there will always be at least one cell before the
    first freeblock.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 自由块是用于标识 B 树页面内未分配空间的结构。自由块按链式组织。自由块的前 2 个字节是一个大端整数，表示链中下一个自由块的偏移量，或者如果自由块是链中的最后一个，则为零。每个自由块的第三和第四个字节组成一个大端整数，表示自由块的字节大小，包括
    4 字节的头部。自由块总是按偏移量递增的顺序连接在一起。B 树页面头的第二个字段是第一个自由块的偏移量，如果页面上没有自由块，则为零。在格式良好的 B 树页面中，第一个自由块之前总会有至少一个单元。
- en: A freeblock requires at least 4 bytes of space. If there is an isolated group
    of 1, 2, or 3 unused bytes within the cell content area, those bytes comprise
    a fragment. The total number of bytes in all fragments is stored in the fifth
    field of the b-tree page header. In a well-formed b-tree page, the total number
    of bytes in fragments may not exceed 60.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一个自由块至少需要 4 个字节的空间。如果在单元内容区域中有一组孤立的 1、2 或 3 个未使用的字节，则这些字节构成一个片段。所有片段中的字节总数存储在
    B 树页面头的第五个字段中。在格式良好的 B 树页面中，片段中的字节总数不得超过 60。
- en: The total amount of free space on a b-tree page consists of the size of the
    unallocated region plus the total size of all freeblocks plus the number of fragmented
    free bytes. SQLite may from time to time reorganize a b-tree page so that there
    are no freeblocks or fragment bytes, all unused bytes are contained in the unallocated
    space region, and all cells are packed tightly at the end of the page. This is
    called "defragmenting" the b-tree page.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: B 树页面上的空闲空间总量包括未分配区域的大小、所有自由块的总大小以及片段化的空闲字节数。SQLite 有时会重新组织 B 树页面，以确保没有自由块或片段字节，所有未使用的字节都包含在未分配空间区域中，并且所有单元紧密打包在页面的末尾。这称为“碎片整理”B
    树页面。
- en: 'A variable-length integer or "varint" is a static Huffman encoding of 64-bit
    twos-complement integers that uses less space for small positive values. A varint
    is between 1 and 9 bytes in length. The varint consists of either zero or more
    bytes which have the high-order bit set followed by a single byte with the high-order
    bit clear, or nine bytes, whichever is shorter. The lower seven bits of each of
    the first eight bytes and all 8 bits of the ninth byte are used to reconstruct
    the 64-bit twos-complement integer. Varints are big-endian: bits taken from the
    earlier byte of the varint are more significant than bits taken from the later
    bytes.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 变长整数或“varint”是64位二补数整数的静态哈夫曼编码，对于小正值使用较少空间。Varint的长度在1到9字节之间。Varint由零个或多个设置高位比特的字节组成，后跟一个清除高位比特的单个字节，或者九个字节，以较短者为准。前八个字节的低七位和第九个字节的所有8位用于重构64位二补数整数。Varint是大端序的：来自varint较早字节的位比来自后续字节的位更重要。
- en: The format of a cell depends on which kind of b-tree page the cell appears on.
    The following table shows the elements of a cell, in order of appearance, for
    the various b-tree page types.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 单元的格式取决于单元出现在哪种B-Tree页上。下表按照各种B-Tree页类型中单元出现的顺序显示了单元的各个元素。
- en: 'Table B-Tree Leaf Cell (header 0x0d):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 表B-Tree叶子单元（头部0x0d）：
- en: A varint which is the total number of bytes of payload, including any overflow
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载的总字节数，包括任何溢出，作为varint
- en: A varint which is the integer key, a.k.a. "[rowid](lang_createtable.html#rowid)"
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数键的varint，又称“[行ID](lang_createtable.html#rowid)”
- en: The initial portion of the payload that does not spill to overflow pages.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载的初始部分不会溢出到溢出页面。
- en: A 4-byte big-endian integer page number for the first page of the overflow page
    list - omitted if all payload fits on the b-tree page.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一页溢出页列表的4字节大端整数页号 - 如果所有负载都适合B-Tree页，则省略。
- en: 'Table B-Tree Interior Cell (header 0x05):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 表B-Tree内部单元（头部0x05）：
- en: A 4-byte big-endian page number which is the left child pointer.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左子指针的4字节大端页号。
- en: A varint which is the integer key
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: varint作为整数键
- en: 'Index B-Tree Leaf Cell (header 0x0a):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 索引B-Tree叶子单元（头部0x0a）：
- en: A varint which is the total number of bytes of key payload, including any overflow
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键负载的总字节数，包括任何溢出，作为varint
- en: The initial portion of the payload that does not spill to overflow pages.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载的初始部分不会溢出到溢出页面。
- en: A 4-byte big-endian integer page number for the first page of the overflow page
    list - omitted if all payload fits on the b-tree page.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一页溢出页列表的4字节大端整数页号 - 如果所有负载都适合B-Tree页，则省略。
- en: 'Index B-Tree Interior Cell (header 0x02):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 索引B-Tree内部单元（头部0x02）：
- en: A 4-byte big-endian page number which is the left child pointer.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左子指针的4字节大端页号。
- en: A varint which is the total number of bytes of key payload, including any overflow
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键负载的总字节数，包括任何溢出，作为varint
- en: The initial portion of the payload that does not spill to overflow pages.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载的初始部分不会溢出到溢出页面。
- en: A 4-byte big-endian integer page number for the first page of the overflow page
    list - omitted if all payload fits on the b-tree page.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 字节大端整数页码，表示溢出页面列表的第一个页面的页码 - 如果所有有效载荷都适合于 B 树页面，则省略。
- en: 'The information above can be recast into a table format as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 上述信息可以按以下表格格式重新整理：
- en: '*B-tree Cell Format*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*B 树单元格格式*'
- en: '| Datatype | Appears in... | Description |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型 | 出现在... | 描述 |'
- en: '| Table Leaf (0x0d) | Table Interior (0x05) | Index Leaf (0x0a) | Index Interior
    (0x02) |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 表叶（0x0d） | 表内部（0x05） | 索引叶（0x0a） | 索引内部（0x02） |'
- en: '| 4-byte integer |   | ✔ |   | ✔ | Page number of left child |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 4 字节整数 |   | ✔ |   | ✔ | 左子节点的页面编号 |'
- en: '| varint | ✔ |   | ✔ | ✔ | Number of bytes of payload |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| varint | ✔ |   | ✔ | ✔ | 有效载荷字节数 |'
- en: '| varint | ✔ | ✔ |   |   | Rowid |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| varint | ✔ | ✔ |   |   | 行标识符 |'
- en: '| byte array | ✔ |   | ✔ | ✔ | Payload |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 字节数组 | ✔ |   | ✔ | ✔ | 有效载荷 |'
- en: '| 4-byte integer | ✔ |   | ✔ | ✔ | Page number of first overflow page |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 4 字节整数 | ✔ |   | ✔ | ✔ | 第一个溢出页面的页面编号 |'
- en: The amount of payload that spills onto overflow pages also depends on the page
    type. For the following computations, let U be the usable size of a database page,
    the total page size less the reserved space at the end of each page. And let P
    be the payload size. In the following, symbol X represents the maximum amount
    of payload that can be stored directly on the b-tree page without spilling onto
    an overflow page and symbol M represents the minimum amount of payload that must
    be stored on the btree page before spilling is allowed.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 溢出到溢出页面的有效载荷量还取决于页面类型。对于以下计算，让 U 表示数据库页面的可用大小，即每个页面末尾的保留空间减去总页面大小。让 P 表示有效载荷大小。在下文中，符号
    X 表示可以直接存储在 B 树页面上的最大有效载荷量，而符号 M 表示必须在允许溢出之前存储在 B 树页面上的最小有效载荷量。
- en: 'Table B-Tree Leaf Cell:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 表 B 树叶单元格：
- en: Let X be U-35\. If the payload size P is less than or equal to X then the entire
    payload is stored on the b-tree leaf page. Let M be ((U-12)*32/255)-23 and let
    K be M+((P-M)%(U-4)). If P is greater than X then the number of bytes stored on
    the table b-tree leaf page is K if K is less or equal to X or M otherwise. The
    number of bytes stored on the leaf page is never less than M.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让 X 等于 U-35。如果有效载荷大小 P 小于或等于 X，则整个有效载荷存储在 B 树叶页面上。让 M 等于 ((U-12)*32/255)-23，让
    K 等于 M+((P-M)%(U-4))。如果 P 大于 X，则在表 b 树叶页面上存储的字节数为 K，如果 K 小于或等于 X，则为 M。页面上存储的字节数永远不会少于
    M。
- en: 'Table B-Tree Interior Cell:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 表 B 树内部单元格：
- en: Interior pages of table b-trees have no payload and so there is never any payload
    to spill.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 表 b 树的内部页面没有有效载荷，因此永远不会有需要溢出的有效载荷。
- en: 'Index B-Tree Leaf Or Interior Cell:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 索引 B 树叶或内部单元格：
- en: Let X be ((U-12)*64/255)-23\. If the payload size P is less than or equal to
    X then the entire payload is stored on the b-tree page. Let M be ((U-12)*32/255)-23
    and let K be M+((P-M)%(U-4)). If P is greater than X then the number of bytes
    stored on the index b-tree page is K if K is less than or equal to X or M otherwise.
    The number of bytes stored on the index page is never less than M.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 设X为((U-12)*64/255)-23。如果有效载荷大小P小于或等于X，则整个有效载荷存储在B树页面上。设M为((U-12)*32/255)-23，K为M+((P-M)%(U-4))。如果P大于X，则在索引B树页面上存储的字节数为K（如果K小于或等于X），否则为M。在索引页面上存储的字节数永远不会小于M。
- en: 'Here is an alternative description of the same computation:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是相同计算的另一种描述：
- en: X is U-35 for table btree leaf pages or ((U-12)*64/255)-23 for index pages.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于表B树叶页，X为U-35，对于索引页，X为((U-12)*64/255)-23。
- en: M is always ((U-12)*32/255)-23.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: M始终为((U-12)*32/255)-23。
- en: Let K be M+((P-M)%(U-4)).
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设K为M+((P-M)%(U-4))。
- en: If P<=X then all P bytes of payload are stored directly on the btree page without
    overflow.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果P<=X，则有效载荷的所有P字节直接存储在B树页面上，无需溢出。
- en: If P>X and K<=X then the first K bytes of P are stored on the btree page and
    the remaining P-K bytes are stored on overflow pages.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果P>X且K<=X，则P的前K字节存储在B树页面上，剩余的P-K字节存储在溢出页面上。
- en: If P>X and K>X then the first M bytes of P are stored on the btree page and
    the remaining P-M bytes are stored on overflow pages.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果P>X且K>X，则P的前M字节存储在B树页面上，剩余的P-M字节存储在溢出页面上。
- en: The overflow thresholds are designed to give a minimum fanout of 4 for index
    b-trees and to make sure enough of the payload is on the b-tree page that the
    record header can usually be accessed without consulting an overflow page. In
    hindsight, the designer of the SQLite b-tree logic realized that these thresholds
    could have been made much simpler. However, the computations cannot be changed
    without resulting in an incompatible file format. And the current computations
    work well, even if they are a little complex.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 溢出阈值的设计旨在为索引B树提供至少4个最小扇出，并确保足够的有效负载位于B树页面上，以便记录头通常无需查看溢出页面即可访问。事后，SQLite B树逻辑的设计者意识到这些阈值本可以简化得多。但是，这些计算不能更改，否则将导致不兼容的文件格式。当前的计算方法即使有些复杂，但效果仍然不错。
- en: 1.7\. Cell Payload Overflow Pages
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.7\. 单元载荷溢出页面
- en: When the payload of a b-tree cell is too large for the b-tree page, the surplus
    is spilled onto overflow pages. Overflow pages form a linked list. The first four
    bytes of each overflow page are a big-endian integer which is the page number
    of the next page in the chain, or zero for the final page in the chain. The fifth
    byte through the last usable byte are used to hold overflow content.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当B树单元的有效载荷过大无法在B树页面上容纳时，剩余部分会溢出到溢出页面上。溢出页面形成一个链表。每个溢出页面的前四个字节是大端整数，表示链中下一页的页码，或者对于链的最后一页为零。从第五个字节到最后一个可用字节用于存储溢出内容。
- en: 1.8\. Pointer Map or Ptrmap Pages
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.8\. 指针映射或Ptrmap页面
- en: Pointer map or ptrmap pages are extra pages inserted into the database to make
    the operation of [auto_vacuum](pragma.html#pragma_auto_vacuum) and [incremental_vacuum](pragma.html#pragma_incremental_vacuum)
    modes more efficient. Other page types in the database typically have pointers
    from parent to child. For example, an interior b-tree page contains pointers to
    its child b-tree pages and an overflow chain has a pointer from earlier to later
    links in the chain. A ptrmap page contains linkage information going in the opposite
    direction, from child to parent.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 指针映射或Ptrmap页是额外插入数据库的页面，以使[auto_vacuum](pragma.html#pragma_auto_vacuum)和[incremental_vacuum](pragma.html#pragma_incremental_vacuum)模式的操作更加高效。数据库中的其他页面类型通常具有从父到子的指针。例如，内部b树页包含指向其子b树页的指针，溢出链有从链中较早到较晚链接的指针。Ptrmap页包含相反方向的链接信息，即从子到父。
- en: Ptrmap pages must exist in any database file which has a non-zero largest root
    b-tree page value at offset 52 in the database header. If the largest root b-tree
    page value is zero, then the database must not contain ptrmap pages.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库文件中，如果偏移量52处的数据库头部存在非零的最大根b树页值，则必须存在Ptrmap页。如果最大根b树页值为零，则数据库不得包含Ptrmap页。
- en: In a database with ptrmap pages, the first ptrmap page is page 2. A ptrmap page
    consists of an array of 5-byte entries. Let J be the number of 5-byte entries
    that will fit in the usable space of a page. (In other words, J=U/5.) The first
    ptrmap page will contain back pointer information for pages 3 through J+2, inclusive.
    The second pointer map page will be on page J+3 and that ptrmap page will provide
    back pointer information for pages J+4 through 2*J+3 inclusive. And so forth for
    the entire database file.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有Ptrmap页的数据库中，第一个Ptrmap页是第2页。Ptrmap页由一组5字节条目组成。设J为可用空间中适合的5字节条目的数量。（换句话说，J=U/5。）第一个Ptrmap页将包含页面3到J+2的反向指针信息，包括在内。第二个指针映射页将位于页J+3，并且该Ptrmap页将为页面J+4到2*J+3提供反向指针信息。整个数据库文件也是如此。
- en: In a database that uses ptrmap pages, all pages at locations identified by the
    computation in the previous paragraph must be ptrmap page and no other page may
    be a ptrmap page. Except, if the byte-lock page happens to fall on the same page
    number as a ptrmap page, then the ptrmap is moved to the following page for that
    one case.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Ptrmap页的数据库中，所有通过上一段计算确定位置的页面必须是Ptrmap页，不能有其他页面是Ptrmap页。除非字节锁页恰好落在与Ptrmap页相同的页码上，那么对于这种情况，Ptrmap将移至后续页。
- en: Each 5-byte entry on a ptrmap page provides back-link information about one
    of the pages that immediately follow the pointer map. If page B is a ptrmap page
    then back-link information about page B+1 is provided by the first entry on the
    pointer map. Information about page B+2 is provided by the second entry. And so
    forth.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Ptrmap页上的每个5字节条目提供关于紧随指针映射的页面之一的反向链接信息。如果页面B是Ptrmap页，则第一个条目提供关于页面B+1的反向链接信息。第二个条目提供关于页面B+2的信息，依此类推。
- en: 'Each 5-byte ptrmap entry consists of one byte of "page type" information followed
    by a 4-byte big-endian page number. Five page types are recognized:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 每个5字节的ptrmap条目由一字节的“页面类型”信息和随后的4字节大端页号组成。识别了五种页面类型：
- en: A b-tree root page. The page number should be zero.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个B树根页面。页号应为零。
- en: A freelist page. The page number should be zero.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个空闲列表页面。页号应为零。
- en: The first page of a cell payload overflow chain. The page number is the b-tree
    page that contains the cell whose content has overflowed.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元负载溢出链的第一页。页号是包含溢出单元内容的B树页面。
- en: A page in an overflow chain other than the first page. The page number is the
    prior page of the overflow chain.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个溢出链中除第一页外的页面。页号是溢出链的前一页。
- en: A non-root b-tree page. The page number is the parent b-tree page.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个非根B树页面。页号是父B树页面。
- en: In any database file that contains ptrmap pages, all b-tree root pages must
    come before any non-root b-tree page, cell payload overflow page, or freelist
    page. This restriction ensures that a root page will never be moved during an
    auto-vacuum or incremental-vacuum. The auto-vacuum logic does not know how to
    update the root_page field of the sqlite_schema table and so it is necessary to
    prevent root pages from being moved during an auto-vacuum in order to preserve
    the integrity of the sqlite_schema table. Root pages are moved to the beginning
    of the database file by the CREATE TABLE, CREATE INDEX, DROP TABLE, and DROP INDEX
    operations.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何包含ptrmap页面的数据库文件中，所有B树根页面必须位于任何非根B树页面、单元负载溢出页面或空闲列表页面之前。此限制确保根页面在自动清理或增量清理期间永不移动。自动清理逻辑不知道如何更新sqlite_schema表的root_page字段，因此有必要在自动清理期间阻止根页面的移动，以保持sqlite_schema表的完整性。根页面通过CREATE
    TABLE、CREATE INDEX、DROP TABLE和DROP INDEX操作移动到数据库文件的开头。
- en: 2\. Schema Layer
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2\. 架构层
- en: The foregoing text describes low-level aspects of the SQLite file format. The
    b-tree mechanism provides a powerful and efficient means of accessing a large
    data set. This section will describe how the low-level b-tree layer is used to
    implement higher-level SQL capabilities.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 前述文本描述了SQLite文件格式的低级方面。B树机制提供了访问大数据集的强大高效手段。本节将描述如何使用低级B树层来实现更高级别的SQL功能。
- en: 2.1\. Record Format
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1\. 记录格式
- en: The data for a table b-tree leaf page and the key of an index b-tree page was
    characterized above as an arbitrary sequence of bytes. The prior discussion mentioned
    one key being less than another, but did not define what "less than" meant. The
    current section will address these omissions.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 表B树叶页的数据和索引B树页的键被描述为任意字节序列。前面的讨论提到了一个键小于另一个键，但没有定义“小于”是什么意思。当前章节将解决这些遗漏。
- en: Payload, either table b-tree data or index b-tree keys, is always in the "record
    format". The record format defines a sequence of values corresponding to columns
    in a table or index. The record format specifies the number of columns, the datatype
    of each column, and the content of each column.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '负载，无论是表B树数据还是索引B树键，始终处于“记录格式”中。 记录格式定义了与表或索引中的列对应的值序列。 记录格式指定了列的数量，每列的数据类型以及每列的内容。  '
- en: The record format makes extensive use of the [variable-length integer](fileformat2.html#varint)
    or [varint](fileformat2.html#varint) representation of 64-bit signed integers
    defined above.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '记录格式广泛使用上述定义的64位有符号整数的[变长整数](fileformat2.html#varint)或[变长整数](fileformat2.html#varint)表示。  '
- en: 'A record contains a header and a body, in that order. The header begins with
    a single varint which determines the total number of bytes in the header. The
    varint value is the size of the header in bytes including the size varint itself.
    Following the size varint are one or more additional varints, one per column.
    These additional varints are called "serial type" numbers and determine the datatype
    of each column, according to the following chart:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '记录包含头部和主体，按顺序排列。 头部以单个变长整数开始，该整数确定头部总字节数。 变长整数的值是头部字节数，包括变长整数本身的大小。 在大小变长整数之后，每列有一个或多个额外的变长整数，每个变长整数对应一个列。
    这些额外的变长整数称为“序列类型”号码，并根据以下图表确定每列的数据类型：  '
- en: '*Serial Type Codes Of The Record Format*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*记录格式的序列类型代码*'
- en: '| Serial Type | Content Size | Meaning |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 序列类型 | 内容大小 | 意义 |  '
- en: '| 0 | 0 | Value is a NULL. |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 值为NULL。  '
- en: '| 1 | 1 | Value is an 8-bit twos-complement integer. |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 值是8位补码整数。  '
- en: '| 2 | 2 | Value is a big-endian 16-bit twos-complement integer. |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2 | 值是大端序的16位补码整数。  '
- en: '| 3 | 3 | Value is a big-endian 24-bit twos-complement integer. |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 3 | 值是大端序的24位补码整数。  '
- en: '| 4 | 4 | Value is a big-endian 32-bit twos-complement integer. |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 4 | 值是大端序的32位补码整数。  '
- en: '| 5 | 6 | Value is a big-endian 48-bit twos-complement integer. |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 6 | 值是大端序的48位补码整数。  '
- en: '| 6 | 8 | Value is a big-endian 64-bit twos-complement integer. |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 8 | 值是大端序的64位补码整数。  '
- en: '| 7 | 8 | Value is a big-endian IEEE 754-2008 64-bit floating point number.
    |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 8 | 值是大端序的IEEE 754-2008标准的64位浮点数。  '
- en: '| 8 | 0 | Value is the integer 0\. (Only available for [schema format](fileformat2.html#schemaformat)
    4 and higher.) |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 0 | 值是整数0。（仅适用于[模式格式](fileformat2.html#schemaformat)4及更高版本。）  '
- en: '| 9 | 0 | Value is the integer 1\. (Only available for [schema format](fileformat2.html#schemaformat)
    4 and higher.) |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 0 | 值是整数1。（仅适用于[模式格式](fileformat2.html#schemaformat)4及更高版本。）  '
- en: '| 10,11 | *variable* | *Reserved for internal use. These serial type codes
    will never appear in a well-formed database file, but they might be used in transient
    and temporary database files that SQLite sometimes generates for its own use.
    The meanings of these codes can shift from one release of SQLite to the next.*
    |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 10,11 | *variable* | *保留供内部使用。这些序列类型代码不会出现在格式良好的数据库文件中，但它们可能会在SQLite为自己使用时生成的瞬时和临时数据库文件中使用。这些代码的含义可能会从一个SQLite版本转变到下一个版本。*'
- en: '| N≥12 and even | (N-12)/2 | Value is a BLOB that is (N-12)/2 bytes in length.
    |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| N≥12 且为偶数 | (N-12)/2 | 值是一个BLOB，长度为(N-12)/2字节。 |'
- en: '| N≥13 and odd | (N-13)/2 | Value is a string in the [text encoding](fileformat2.html#enc)
    and (N-13)/2 bytes in length. The nul terminator is not stored. |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| N≥13 且为奇数 | (N-13)/2 | 值是使用 [文本编码](fileformat2.html#enc) 的字符串，长度为(N-13)/2字节。不存储空终止符。'
- en: The header size varint and serial type varints will usually consist of a single
    byte. The serial type varints for large strings and BLOBs might extend to two
    or three byte varints, but that is the exception rather than the rule. The varint
    format is very efficient at coding the record header.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 头部大小的可变整数和序列类型的可变整数通常只包含一个字节。对于大字符串和BLOBs的序列类型可变整数可能会延伸到两到三个字节的可变整数，但这只是例外而非规则。可变整数格式在编码记录头部时非常高效。
- en: The values for each column in the record immediately follow the header. For
    serial types 0, 8, 9, 12, and 13, the value is zero bytes in length. If all columns
    are of these types then the body section of the record is empty.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 记录中每列的值紧跟在头部之后。对于序列类型为0、8、9、12和13的情况，值的长度为零字节。如果所有列都是这些类型，则记录的正文部分为空。
- en: A record might have fewer values than the number of columns in the corresponding
    table. This can happen, for example, after an [ALTER TABLE ... ADD COLUMN](lang_altertable.html)
    SQL statement has increased the number of columns in the table schema without
    modifying preexisting rows in the table. Missing values at the end of the record
    are filled in using the [default value](lang_createtable.html#dfltval) for the
    corresponding columns defined in the table schema.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一个记录可能比相应表中的列数少。例如，在执行 [ALTER TABLE ... ADD COLUMN](lang_altertable.html) SQL
    语句增加表模式中的列数后，表中的预先存在的行未修改的情况下可能发生这种情况。记录末尾的缺失值使用表模式中相应列的 [默认值](lang_createtable.html#dfltval)
    进行填充。
- en: 2.2\. Record Sort Order
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2\. 记录排序顺序
- en: 'The order of keys in an index b-tree is determined by the sort order of the
    records that the keys represent. Record comparison progresses column by column.
    Columns of a record are examined from left to right. The first pair of columns
    that are not equal determines the relative order of the two records. The sort
    order of individual columns is as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 索引B树中键的顺序由它们所代表的记录的排序顺序决定。记录比较逐列进行。记录的列从左到右进行检查。第一对不相等的列确定了两条记录的相对顺序。各列的排序顺序如下：
- en: NULL values (serial type 0) sort first.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NULL 值（序列类型0）排序最优先。
- en: Numeric values (serial types 1 through 9) sort after NULLs and in numeric order.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数值（序列类型 1 到 9）在 NULL 值之后按数值顺序排序。
- en: Text values (odd serial types 13 and larger) sort after numeric values in the
    order determined by the columns [collating function](datatype3.html#collation).
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文本值（奇数序列类型 13 及更大）在数值值之后按照列 [排序函数](datatype3.html#collation) 确定的顺序排序。
- en: BLOB values (even serial types 12 and larger) sort last and in the order determined
    by memcmp().
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: BLOB 值（包括序列类型 12 及更大）在排序时排在最后，并且按照 memcmp() 确定的顺序排序。
- en: 'A [collating function](datatype3.html#collation) for each column is necessary
    in order to compute the order of text fields. SQLite defines three built-in collating
    functions:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 每个列的 [排序函数](datatype3.html#collation) 都是为了计算文本字段的顺序而必需的。SQLite 定义了三个内置的排序函数：
- en: '| BINARY | The built-in BINARY collation compares strings byte by byte using
    the memcmp() function from the standard C library. |'
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 二进制 | 内置的二进制排序通过使用标准 C 库中的 memcmp() 函数逐字节比较字符串。'
- en: '| NOCASE | The NOCASE collation is like BINARY except that uppercase ASCII
    characters (''A'' through ''Z'') are folded into their lowercase equivalents prior
    to running the comparison. Only ASCII characters are case-folded. NOCASE does
    not implement a general purpose unicode caseless comparison. |'
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| NOCASE | NOCASE 排序与 BINARY 排序类似，但是大写 ASCII 字符（''A'' 到 ''Z''）在进行比较之前会转换为它们的小写等效字符。只有
    ASCII 字符会进行大小写折叠。NOCASE 不实现通用的 Unicode 无大小写比较功能。'
- en: '| RTRIM | RTRIM is like BINARY except that extra spaces at the end of either
    string do not change the result. In other words, strings will compare equal to
    one another as long as they differ only in the number of spaces at the end. |'
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| RTRIM | RTRIM 与 BINARY 类似，但是字符串末尾的额外空格不会改变结果。换句话说，只要它们仅在末尾空格数量上有所不同，字符串就会相等。'
- en: Additional application-specific collating functions can be added to SQLite using
    the [sqlite3_create_collation()](c3ref/create_collation.html) interface.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 [sqlite3_create_collation()](c3ref/create_collation.html) 接口向 SQLite 添加额外的应用特定排序函数。
- en: The default collating function for all strings is BINARY. Alternative collating
    functions for table columns can be specified in the [CREATE TABLE](lang_createtable.html)
    statement using the COLLATE clause on the [column definition](lang_createtable.html#tablecoldef).
    When a column is indexed, the same collating function specified in the [CREATE
    TABLE](lang_createtable.html) statement is used for the column in the index, by
    default, though this can be overridden using a COLLATE clause in the [CREATE INDEX](lang_createindex.html)
    statement.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 所有字符串的默认排序函数都是 BINARY。可以在 [CREATE TABLE](lang_createtable.html) 语句的 [列定义](lang_createtable.html#tablecoldef)
    中使用 COLLATE 子句指定表列的备选排序函数。当列被索引时，默认情况下使用在 [CREATE TABLE](lang_createtable.html)
    语句中指定的相同排序函数作为索引中的列，尽管可以使用 [CREATE INDEX](lang_createindex.html) 语句中的 COLLATE
    子句进行覆盖。
- en: 2.3\. Representation Of SQL Tables
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3\. SQL 表的表示
- en: Each ordinary SQL table in the database schema is represented on-disk by a table
    b-tree. Each entry in the table b-tree corresponds to a row of the SQL table.
    The [rowid](lang_createtable.html#rowid) of the SQL table is the 64-bit signed
    integer key for each entry in the table b-tree.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库架构中每个普通的 SQL 表都由一个表 b 树在磁盘上表示。表 b 树中的每个条目对应于 SQL 表的一行。SQL 表的 [rowid](lang_createtable.html#rowid)
    是表 b 树中每个条目的 64 位有符号整数键。
- en: The content of each SQL table row is stored in the database file by first combining
    the values in the various columns into a byte array in the record format, then
    storing that byte array as the payload in an entry in the table b-tree. The order
    of values in the record is the same as the order of columns in the SQL table definition.
    When an SQL table includes an [INTEGER PRIMARY KEY](lang_createtable.html#rowid)
    column (which aliases the [rowid](lang_createtable.html#rowid)) then that column
    appears in the record as a NULL value. SQLite will always use the table b-tree
    key rather than the NULL value when referencing the [INTEGER PRIMARY KEY](lang_createtable.html#rowid)
    column.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 SQL 表行的内容首先通过将各列的值组合成记录格式的字节数组，然后将该字节数组作为表 b 树中条目的有效载荷存储在数据库文件中。记录中的值顺序与
    SQL 表定义中列的顺序相同。当 SQL 表包括一个 [INTEGER PRIMARY KEY](lang_createtable.html#rowid)
    列（别名为 [rowid](lang_createtable.html#rowid)）时，该列在记录中表现为 NULL 值。SQLite 在引用 [INTEGER
    PRIMARY KEY](lang_createtable.html#rowid) 列时总是使用表 b 树键而不是 NULL 值。
- en: If the [affinity](datatype3.html#affinity) of a column is REAL and that column
    contains a value that can be converted to an integer without loss of information
    (if the value contains no fractional part and is not too large to be represented
    as an integer) then the column may be stored in the record as an integer. SQLite
    will convert the value back to floating point when extracting it from the record.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列的亲和性为 REAL 并且该列包含的值可以在不丢失信息的情况下转换为整数（如果值不包含小数部分且不太大以至于不能表示为整数），则该列可能作为整数存储在记录中。SQLite
    在从记录中提取值时将该值转换回浮点数。
- en: 2.4\. Representation of WITHOUT ROWID Tables
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4\. WITHOUT ROWID 表的表示
- en: If an SQL table is created using the "WITHOUT ROWID" clause at the end of its
    CREATE TABLE statement, then that table is a [WITHOUT ROWID](withoutrowid.html)
    table and uses a different on-disk representation. A WITHOUT ROWID table uses
    an index b-tree rather than a table b-tree for storage. The key for each entry
    in the WITHOUT ROWID b-tree is a record composed of the columns of the PRIMARY
    KEY followed by all remaining columns of the table. The primary key columns appear
    in the order that they were declared in the PRIMARY KEY clause and the remaining
    columns appear in the order they occur in the CREATE TABLE statement.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在其 CREATE TABLE 语句的末尾使用了 "WITHOUT ROWID" 子句来创建 SQL 表，那么该表就是一个[无ROWID](withoutrowid.html)表，并且使用不同的磁盘表示。无ROWID表使用索引B树而不是表B树进行存储。每个无ROWID
    B树中条目的键是由主键列组成的记录，后跟表的所有剩余列。主键列按照它们在主键子句中声明的顺序排列，剩余列按照它们在 CREATE TABLE 语句中出现的顺序排列。
- en: Hence, the content encoding for a WITHOUT ROWID table is the same as the content
    encoding for an ordinary rowid table, except that the order of the columns is
    rearranged so that PRIMARY KEY columns come first, and the content is used as
    the key in an index b-tree rather than as the data in a table b-tree. The special
    encoding rules for columns with REAL affinity apply to WITHOUT ROWID tables the
    same as they do with rowid tables.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，无ROWID表的内容编码与普通行ID表的内容编码相同，只是列的顺序重新排列，使主键列首先出现，并且内容用作索引B树中的键，而不是表B树中的数据。具有REAL亲和性的列的特殊编码规则也适用于无ROWID表，就像它们对行ID表一样。
- en: 2.4.1\. Suppression of redundant columns in the PRIMARY KEY of WITHOUT ROWID
    tables
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.1\. 在无ROWID表的主键中抑制冗余列
- en: 'If the PRIMARY KEY of a WITHOUT ROWID tables uses the same columns with the
    same collating sequence more than once, then the second and subsequent occurrences
    of that column in the PRIMARY KEY definition are ignored. For example, the following
    CREATE TABLE statements all specify the same table, which will have the exact
    same representation on disk:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无ROWID表的主键使用相同的列和相同的排序顺序超过一次，那么在主键定义中第二次及后续出现的该列会被忽略。例如，以下 CREATE TABLE 语句都指定了相同的表，该表在磁盘上具有完全相同的表示：
- en: '[PRE0]'
  id: totrans-250
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first example above is the preferred definition of the table, of course.
    All of the examples create a WITHOUT ROWID table with two PRIMARY KEY columns,
    "a" and "c", in that order, followed by two data columns "b" and "d", also in
    that order.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，上述第一个示例是表的首选定义。所有示例都创建了一个无ROWID表，其中有两个主键列 "a" 和 "c"，按顺序排列，后跟两个数据列 "b" 和 "d"，同样按顺序排列。
- en: 2.5\. Representation Of SQL Indices
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5\. SQL索引的表示
- en: Each SQL index, whether explicitly declared via a [CREATE INDEX](lang_createindex.html)
    statement or implied by a UNIQUE or PRIMARY KEY constraint, corresponds to an
    index b-tree in the database file. Each entry in the index b-tree corresponds
    to a single row in the associated SQL table. The key to an index b-tree is a record
    composed of the columns that are being indexed followed by the key of the corresponding
    table row. For ordinary tables, the row key is the [rowid](lang_createtable.html#rowid),
    and for [WITHOUT ROWID](withoutrowid.html) tables the row key is the PRIMARY KEY.
    Because every row in the table has a unique row key, all keys in an index are
    unique.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 每个SQL索引，无论是通过[CREATE INDEX](lang_createindex.html)语句显式声明还是由UNIQUE或PRIMARY KEY约束隐含声明，都对应于数据库文件中的一个索引B树。索引B树中的每个条目对应于关联SQL表中的单个行。索引B树的键是由正在索引的列组成，后跟相应表行的键。对于普通表，行键是[rowid](lang_createtable.html#rowid)，对于[WITHOUT
    ROWID](withoutrowid.html)表，行键是主键。因为表中的每一行都有唯一的行键，索引中的所有键都是唯一的。
- en: In a normal index, there is a one-to-one mapping between rows in a table and
    entries in each index associated with that table. However, in a [partial index](partialindex.html),
    the index b-tree only contains entries corresponding to table rows for which the
    WHERE clause expression on the CREATE INDEX statement is true. Corresponding rows
    in the index and table b-trees share the same rowid or primary key values and
    contain the same value for all indexed columns.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常的索引中，表中的行与与该表关联的每个索引中的条目之间存在一对一的映射。但是，在[部分索引](partialindex.html)中，索引B树仅包含CREATE
    INDEX语句的WHERE子句表达式为true的表行对应的条目。索引和表B树中的相应行共享相同的rowid或主键值，并且对于所有索引列都包含相同的值。
- en: 2.5.1\. Suppression of redundant columns in WITHOUT ROWID secondary indexes
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.1\. 在WITHOUT ROWID次要索引中抑制冗余列
- en: 'In an index on a WITHOUT ROWID table, if a column of the PRIMARY KEY is also
    a column in the index and has a matching collating sequence, then the indexed
    column is not repeated in the table-key suffix on the end of the index record.
    As an example, consider the following SQL:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在WITHOUT ROWID表的索引中，如果主键的某列也是索引中的列，并且具有匹配的排序序列，那么该索引列在索引记录末尾的表键后缀中不会重复出现。例如，请考虑以下SQL：
- en: '[PRE1]'
  id: totrans-257
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Each row in the ex25ce index is a record with these columns: c, e, d, a. The
    first two columns are the columns being indexed, c and e. The remaining columns
    are the primary key of the corresponding table row. Normally, the primary key
    would be columns d, c, and a, but because column c already appears earlier in
    the index, it is omitted from the key suffix.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ex25ce索引中的每一行都是一个记录，具有以下列：c、e、d、a。前两列是正在索引的列，即c和e。剩余的列是相应表行的主键。通常，主键将是列d、c和a，但由于列c已在索引中首次出现，因此在键后缀中被省略。
- en: In the extreme case where the columns being indexed cover all columns of the
    PRIMARY KEY, the index will consist of only the columns being indexed. The ex25acde
    example above demonstrates this. Each entry in the ex25acde index consists of
    only the columns a, c, d, and e, in that order.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在索引的列涵盖主键的所有列的极端情况下，索引将仅由索引的列组成。上面的 ex25acde 示例演示了这一点。ex25acde 索引中的每个条目仅由列 a、c、d
    和 e 组成，按顺序排列。
- en: 'Each row in ex25ae contains five columns: a, e, d, c, a. The "a" column is
    repeated since the first occurrence of "a" has a collating function of "nocase"
    and the second has a collating sequence of "binary". If the "a" column is not
    repeated and if the table contains two or more entries with the same "e" value
    and where "a" differs only in case, then all of those table entries would correspond
    to a single entry in the index, which would break the one-to-one correspondence
    between the table and the index.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ex25ae 中的每一行包含五列：a、e、d、c、a。由于第一次出现的 "a" 列具有 "nocase" 的排序功能，而第二次出现的具有 "binary"
    的排序序列，因此 "a" 列被重复。如果 "a" 列不重复，并且表中包含两个或更多具有相同 "e" 值的条目，并且 "a" 只是大小写不同，则所有这些表条目将对应于索引中的一个条目，这将打破表与索引之间的一对一对应关系。
- en: The suppression of redundant columns in the key suffix of an index entry only
    occurs in WITHOUT ROWID tables. In an ordinary rowid table, the index entry always
    ends with the rowid even if the [INTEGER PRIMARY KEY](lang_createtable.html#rowid)
    column is one of the columns being indexed.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有 ROWID 表中，索引条目的键后缀中冗余列的抑制仅发生在普通 ROWID 表中。在普通 ROWID 表中，即使 [INTEGER PRIMARY
    KEY](lang_createtable.html#rowid) 列是被索引的列之一，索引条目也总是以 ROWID 结束。
- en: 2.6\. Storage Of The SQL Database Schema
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.6\. SQL 数据库模式的存储
- en: 'Page 1 of a database file is the root page of a table b-tree that holds a special
    table named "[sqlite_schema](schematab.html)". This b-tree is known as the "schema
    table" since it stores the complete database schema. The structure of the sqlite_schema
    table is as if it had been created using the following SQL:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库文件的第一页是保存名为 "[sqlite_schema](schematab.html)" 的特殊表的表 b-tree 的根页。这个 b-tree
    被称为“模式表”，因为它存储了完整的数据库模式。sqlite_schema 表的结构就像是使用以下 SQL 创建的：
- en: '[PRE2]'
  id: totrans-264
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The sqlite_schema table contains one row for each table, index, view, and trigger
    (collectively "objects") in the database schema, except there is no entry for
    the sqlite_schema table itself. The sqlite_schema table contains entries for [internal
    schema objects](fileformat2.html#intschema) in addition to application- and programmer-defined
    objects.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: sqlite_schema 表中每个表、索引、视图和触发器（统称为“对象”）都有一行记录，但 sqlite_schema 表本身没有条目。除了应用程序和程序员定义的对象外，sqlite_schema
    表还包含[内部模式对象](fileformat2.html#intschema)的条目。
- en: 'The sqlite_schema.type column will be one of the following text strings: ''table'',
    ''index'', ''view'', or ''trigger'' according to the type of object defined. The
    ''table'' string is used for both ordinary and [virtual tables](vtab.html).'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 列 `sqlite_schema.type` 将是以下文本字符串之一：'table'、'index'、'view' 或 'trigger'，根据定义的对象类型而定。'table'
    字符串用于普通和[virtual tables](vtab.html)。
- en: The sqlite_schema.name column will hold the name of the object. [UNIQUE](lang_createtable.html#uniqueconst)
    and [PRIMARY KEY](lang_createtable.html#primkeyconst) constraints on tables cause
    SQLite to create [internal indexes](fileformat2.html#intschema) with names of
    the form "sqlite_autoindex_TABLE_N" where TABLE is replaced by the name of the
    table that contains the constraint and N is an integer beginning with 1 and increasing
    by one with each constraint seen in the table definition. In a [WITHOUT ROWID](withoutrowid.html)
    table, there is no sqlite_schema entry for the PRIMARY KEY, but the "sqlite_autoindex_TABLE_N"
    name is set aside for the PRIMARY KEY as if the sqlite_schema entry did exist.
    This will affect the numbering of subsequent UNIQUE constraints. The "sqlite_autoindex_TABLE_N"
    name is never allocated for an [INTEGER PRIMARY KEY](lang_createtable.html#rowid),
    either in rowid tables or WITHOUT ROWID tables.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 列 `sqlite_schema.name` 将保存对象的名称。对表的[UNIQUE](lang_createtable.html#uniqueconst)和[PRIMARY
    KEY](lang_createtable.html#primkeyconst)约束会导致SQLite创建形如"sqlite_autoindex_TABLE_N"的[内部索引](fileformat2.html#intschema)，其中TABLE被替换为包含约束的表的名称，N是从1开始逐个递增的整数，每个约束在表定义中都会看到。在[WITHOUT
    ROWID](withoutrowid.html)表中，没有主键的sqlite_schema条目，但"sqlite_autoindex_TABLE_N"名称被保留用于主键，就像sqlite_schema条目确实存在一样。这将影响后续UNIQUE约束的编号。"sqlite_autoindex_TABLE_N"名称在[INTEGER
    PRIMARY KEY](lang_createtable.html#rowid)中从不分配，无论是在rowid表还是WITHOUT ROWID表中。
- en: The sqlite_schema.tbl_name column holds the name of a table or view that the
    object is associated with. For a table or view, the tbl_name column is a copy
    of the name column. For an index, the tbl_name is the name of the table that is
    indexed. For a trigger, the tbl_name column stores the name of the table or view
    that causes the trigger to fire.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 列 `sqlite_schema.tbl_name` 保存对象关联的表或视图的名称。对于表或视图，tbl_name列是名称列的副本。对于索引，tbl_name是被索引的表的名称。对于触发器，tbl_name列存储引发触发器的表或视图的名称。
- en: The sqlite_schema.rootpage column stores the page number of the root b-tree
    page for tables and indexes. For rows that define views, triggers, and virtual
    tables, the rootpage column is 0 or NULL.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 列 `sqlite_schema.rootpage` 存储表和索引的根b-tree页的页码。对于定义视图、触发器和虚拟表的行，rootpage列为0或NULL。
- en: 'The sqlite_schema.sql column stores SQL text that describes the object. This
    SQL text is a [CREATE TABLE](lang_createtable.html), [CREATE VIRTUAL TABLE](lang_createvtab.html),
    [CREATE INDEX](lang_createindex.html), [CREATE VIEW](lang_createview.html), or
    [CREATE TRIGGER](lang_createtrigger.html) statement that if evaluated against
    the database file when it is the main database of a [database connection](c3ref/sqlite3.html)
    would recreate the object. The text is usually a copy of the original statement
    used to create the object but with normalizations applied so that the text conforms
    to the following rules:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlite_schema.sql` 列存储描述对象的 SQL 文本。此 SQL 文本是 [CREATE TABLE](lang_createtable.html)、[CREATE
    VIRTUAL TABLE](lang_createvtab.html)、[CREATE INDEX](lang_createindex.html)、[CREATE
    VIEW](lang_createview.html) 或 [CREATE TRIGGER](lang_createtrigger.html) 语句，如果在作为
    [数据库连接](c3ref/sqlite3.html) 的主数据库时对数据库文件进行评估，则会重新创建对象。该文本通常是用于创建对象的原始语句的副本，但已应用了归一化，以便文本符合以下规则：'
- en: The CREATE, TABLE, VIEW, TRIGGER, and INDEX keywords at the beginning of the
    statement are converted to all upper case letters.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语句开头的 `CREATE`、`TABLE`、`VIEW`、`TRIGGER` 和 `INDEX` 关键字会转换为大写字母。
- en: The TEMP or TEMPORARY keyword is removed if it occurs after the initial CREATE
    keyword.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在初始 `CREATE` 关键字之后出现，则移除 `TEMP` 或 `TEMPORARY` 关键字。
- en: Any database name qualifier that occurs prior to the name of the object being
    created is removed.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建对象的名称之前出现的任何数据库名称限定符都被移除。
- en: Leading spaces are removed.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除前导空格。
- en: All spaces following the first two keywords are converted into a single space.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前两个关键字之后的所有空格都被转换为单个空格。
- en: The text in the sqlite_schema.sql column is a copy of the original CREATE statement
    text that created the object, except normalized as described above and as modified
    by subsequent [ALTER TABLE](lang_altertable.html) statements. The sqlite_schema.sql
    is NULL for the [internal indexes](fileformat2.html#intschema) that are automatically
    created by [UNIQUE](lang_createtable.html#uniqueconst) or [PRIMARY KEY](lang_createtable.html#primkeyconst)
    constraints.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `sqlite_schema.sql` 列中的文本是创建对象的原始 `CREATE` 语句文本的副本，除了按上述方式归一化和后续 [ALTER TABLE](lang_altertable.html)
    语句的修改。对于由 [UNIQUE](lang_createtable.html#uniqueconst) 或 [PRIMARY KEY](lang_createtable.html#primkeyconst)
    约束自动创建的 [内部索引](fileformat2.html#intschema)，`sqlite_schema.sql` 为 `NULL`。
- en: 2.6.1\. Alternative Names For The Schema Table
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6.1\. 模式表的备选名称
- en: 'The name "sqlite_schema" does not appear anywhere in the file format. That
    name is just a convention used by the database implementation. Due to historical
    and operational considerations, the "sqlite_schema" table can also sometimes be
    called by one of the following aliases:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件格式中不会出现名称 "sqlite_schema"。该名称只是数据库实现中使用的约定。出于历史和操作考虑，"sqlite_schema" 表有时也称为以下其中一个别名：
- en: sqlite_master
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sqlite_master`'
- en: sqlite_temp_schema
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sqlite_temp_schema`'
- en: sqlite_temp_master
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sqlite_temp_master`'
- en: Because the name of the schema table does not appear anywhere in the file format,
    the meaning of the database file is not changed if the application chooses to
    refer to the schema table by one of these alternative names.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 因为模式表的名称在文件格式中没有出现，所以如果应用程序选择用这些替代名称之一来引用模式表，数据库文件的含义不会改变。
- en: 2.6.2\. Internal Schema Objects
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6.2\. 内部模式对象
- en: In addition to the tables, indexes, views, and triggers created by the application
    and/or the developer using CREATE statements SQL, the sqlite_schema table may
    contain zero or more entries for *internal schema objects* that are created by
    SQLite for its own internal use. The names of internal schema objects always begin
    with "sqlite_" and any table, index, view, or trigger whose name begins with "sqlite_"
    is an internal schema object. SQLite prohibits applications from creating objects
    whose names begin with "sqlite_".
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 除了由应用程序和/或开发者使用CREATE语句SQL创建的表、索引、视图和触发器外，sqlite_schema表中可能包含零个或多个*内部模式对象*的条目，这些对象由SQLite为其自身的内部使用而创建。内部模式对象的名称始终以"sqlite_"开头，任何以"sqlite_"开头的表、索引、视图或触发器都是内部模式对象。SQLite禁止应用程序创建名称以"sqlite_"开头的对象。
- en: 'Internal schema objects used by SQLite may include the following:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite使用的内部模式对象可能包括以下内容：
- en: Indices with names of the form "sqlite_autoindex_TABLE_N" that are used to implement
    [UNIQUE](lang_createtable.html#uniqueconst) and [PRIMARY KEY](lang_createtable.html#primkeyconst)
    constraints on ordinary tables.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称为"sqlite_autoindex_TABLE_N"的索引，用于实现普通表上的[UNIQUE](lang_createtable.html#uniqueconst)和[PRIMARY
    KEY](lang_createtable.html#primkeyconst)约束。
- en: A table with the name "sqlite_sequence" that is used to keep track of the maximum
    historical [INTEGER PRIMARY KEY](lang_createtable.html#rowid) for a table using
    [AUTOINCREMENT](autoinc.html).
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称为"sqlite_sequence"的表，用于跟踪使用[AUTOINCREMENT](autoinc.html)的表的最大历史[INTEGER PRIMARY
    KEY](lang_createtable.html#rowid)。
- en: Tables with names of the form "sqlite_statN" where N is an integer. Such tables
    store database statistics gathered by the [ANALYZE](lang_analyze.html) command
    and used by the query planner to help determine the best algorithm to use for
    each query.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称为"sqlite_statN"（其中N是整数）的表。这些表存储由[ANALYZE](lang_analyze.html)命令收集的数据库统计信息，并由查询规划器用于帮助确定每个查询使用的最佳算法。
- en: New internal schema objects names, always beginning with "sqlite_", may be added
    to the SQLite file format in future releases.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 新的内部模式对象名称，始终以"sqlite_"开头，可能会在将来的SQLite文件格式发布中添加。
- en: 2.6.3\. The sqlite_sequence table
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6.3\. sqlite_sequence表
- en: 'The sqlite_sequence table is an internal table used to help implement [AUTOINCREMENT](autoinc.html).
    The sqlite_sequence table is created automatically whenever any ordinary table
    with an AUTOINCREMENT integer primary key is created. Once created, the sqlite_sequence
    table exists in the sqlite_schema table forever; it cannot be dropped. The schema
    for the sqlite_sequence table is:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: sqlite_sequence表是一个内部表，用于帮助实现[AUTOINCREMENT](autoinc.html)。每当创建具有AUTOINCREMENT整数主键的任何普通表时，sqlite_sequence表会自动创建。一旦创建，sqlite_sequence表将永远存在于sqlite_schema表中；它无法被删除。sqlite_sequence表的模式如下：
- en: '[PRE3]'
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There is a single row in the sqlite_sequence table for each ordinary table that
    uses AUTOINCREMENT. The name of the table (as it appears in sqlite_schema.name)
    is in the sqlite_sequence.name field and the largest [INTEGER PRIMARY KEY](lang_createtable.html#rowid)
    ever inserted into that table is in the sqlite_sequence.seq field. New automatically
    generated integer primary keys for AUTOINCREMENT tables are guaranteed to be larger
    than the sqlite_sequence.seq field for that table. If the sqlite_sequence.seq
    field of an AUTOINCREMENT table is already at the largest integer value (9223372036854775807)
    then attempts to add new rows to that table with an automatically generated integer
    primary will fail with an [SQLITE_FULL](rescode.html#full) error. The sqlite_sequence.seq
    field is automatically updated if required when new entries are inserted to an
    AUTOINCREMENT table. The sqlite_sequence row for an AUTOINCREMENT table is automatically
    deleted when the table is dropped. If the sqlite_sequence row for an AUTOINCREMENT
    table does not exist when the AUTOINCREMENT table is updated, then a new sqlite_sequence
    row is created. If the sqlite_sequence.seq value for an AUTOINCREMENT table is
    manually set to something other than an integer and there is a subsequent attempt
    to insert the or update the AUTOINCREMENT table, then the behavior is undefined.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 每个使用AUTOINCREMENT的普通表在sqlite_sequence表中都有一行。表的名称（如在sqlite_schema.name中显示的）在sqlite_sequence.name字段中，而插入到该表中的最大[INTEGER
    PRIMARY KEY](lang_createtable.html#rowid)在sqlite_sequence.seq字段中。为AUTOINCREMENT表新生成的整数主键保证大于该表的sqlite_sequence.seq字段。如果AUTOINCREMENT表的sqlite_sequence.seq字段已经达到最大整数值（9223372036854775807），则尝试向该表添加具有自动生成的整数主键的新行将失败，并显示[SQLITE_FULL](rescode.html#full)错误。如果需要，在插入新条目到AUTOINCREMENT表时，sqlite_sequence.seq字段将自动更新。当删除表时，AUTOINCREMENT表的sqlite_sequence行会被自动删除。如果更新AUTOINCREMENT表时sqlite_sequence行不存在，则会创建新的sqlite_sequence行。如果为AUTOINCREMENT表的sqlite_sequence.seq值手动设置为非整数，并且随后尝试插入或更新AUTOINCREMENT表，则行为未定义。
- en: Application code is allowed to modify the sqlite_sequence table, to add new
    rows, to delete rows, or to modify existing rows. However, application code cannot
    create the sqlite_sequence table if it does not already exist. Application code
    can delete all entries from the sqlite_sequence table, but application code cannot
    drop the sqlite_sequence table.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序代码允许修改 sqlite_sequence 表，添加新行、删除行或修改现有行。但是，如果 sqlite_sequence 表不存在，则应用程序代码不能创建
    sqlite_sequence 表。应用程序代码可以删除 sqlite_sequence 表中的所有条目，但不能删除 sqlite_sequence 表。
- en: 2.6.4\. The sqlite_stat1 table
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6.4\. sqlite_stat1 表
- en: 'The sqlite_stat1 is an internal table created by the [ANALYZE](lang_analyze.html)
    command and used to hold supplemental information about tables and indexes that
    the query planner can use to help it find better ways of performing queries. Applications
    can update, delete from, insert into or drop the sqlite_stat1 table, but may not
    create or alter the sqlite_stat1 table. The schema of the sqlite_stat1 table is
    as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: sqlite_stat1 是由 [ANALYZE](lang_analyze.html) 命令创建的内部表，用于存储关于表和索引的补充信息，查询规划器可以利用这些信息来帮助找到更好的执行查询的方式。应用程序可以更新、删除、插入或删除
    sqlite_stat1 表，但不能创建或修改 sqlite_stat1 表。sqlite_stat1 表的架构如下：
- en: '[PRE4]'
  id: totrans-297
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There is normally one row per index, with the index identified by the name in
    the sqlite_stat1.idx column. The sqlite_stat1.tbl column is the name of the table
    to which the index belongs. In each such row, the sqlite_stat.stat column will
    be a string consisting of a list of integers followed by zero or more arguments.
    The first integer in this list is the approximate number of rows in the index.
    (The number of rows in the index is the same as the number of rows in the table,
    except for [partial indexes](partialindex.html).) The second integer is the approximate
    number of rows in the index that have the same value in the first column of the
    index. The third integer is the number of rows in the index that have the same
    value for the first two columns. The N-th integer (for N>1) is the estimated average
    number of rows in the index which have the same value for the first N-1 columns.
    For a K-column index, there will be K+1 integers in the stat column. If the index
    is unique, then the last integer will be 1.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 每个索引通常有一行，索引由 sqlite_stat1.idx 列中的名称标识。sqlite_stat1.tbl 列是索引所属表的名称。在每一行中，sqlite_stat.stat
    列将是一个字符串，由一系列整数和零个或多个参数组成。此列表中的第一个整数是索引中行的大约数量。（索引中的行数与表中的行数相同，除了 [部分索引](partialindex.html)。）第二个整数是索引中具有相同值的第一列的行数的大约数量。第三个整数是索引中具有相同值的前两列的行数。第
    N 个整数（对于 N>1）是索引中具有相同值的前 N-1 列的行的估计平均数量。对于 K 列索引，stat 列中将有 K+1 个整数。如果索引是唯一的，则最后一个整数将为
    1.
- en: The list of integers in the stat column can optionally be followed by arguments,
    each of which is a sequence of non-space characters. All arguments are preceded
    by a single space. Unrecognized arguments are silently ignored.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: stat列中的整数列表可以选择地跟随参数，每个参数是一系列非空格字符。所有参数前都有一个单独的空格。未识别的参数将被静默忽略。
- en: If the "unordered" argument is present, then the query planner assumes that
    the index is unordered and will not use the index for a range query or for sorting.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在"unordered"参数，则查询规划器假定索引是无序的，并且不会将其用于范围查询或排序。
- en: The "sz=NNN" argument (where NNN represents a sequence of 1 or more digits)
    means that the average row size over all records of the table or index is NNN
    bytes per row. The SQLite query planner might use the estimated row size information
    provided by the "sz=NNN" token to help it choose smaller tables and indexes that
    require less disk I/O.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '"sz=NNN"参数（其中NNN代表1个或多个数字的序列）表示表或索引所有记录的平均行大小为每行NNN字节。SQLite查询规划器可能使用"sz=NNN"标记提供的估计行大小信息，以帮助选择更小的表和索引，从而减少磁盘I/O。'
- en: The presence of the "noskipscan" token on the sqlite_stat1.stat field of an
    index prevents that index from being used with the [skip-scan optimization](optoverview.html#skipscan).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在索引的sqlite_stat1.stat字段上存在"noskipscan"标记，阻止该索引与[跳跃扫描优化](optoverview.html#skipscan)一起使用。
- en: New text tokens may be added to the end of the stat column in future enhancements
    to SQLite. For compatibility, unrecognized tokens at the end of the stat column
    are silently ignored.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 未来增强SQLite时，可以向stat列的末尾添加新的文本标记。为了兼容性，stat列末尾的未识别标记会被静默忽略。
- en: If the sqlite_stat1.idx column is NULL, then the sqlite_stat1.stat column contains
    a single integer which is the approximate number of rows in the table identified
    by sqlite_stat1.tbl. If the sqlite_stat1.idx column is the same as the sqlite_stat1.tbl
    column, then the table is a [WITHOUT ROWID](withoutrowid.html) table and the sqlite_stat1.stat
    field contains information about the index btree that implements the WITHOUT ROWID
    table.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果sqlite_stat1.idx列为NULL，则sqlite_stat1.stat列包含一个单独的整数，该整数是sqlite_stat1.tbl标识的表中行的大致数量。如果sqlite_stat1.idx列与sqlite_stat1.tbl列相同，则该表是[无行ID](withoutrowid.html)表，sqlite_stat1.stat字段包含实现无行ID表的索引B树的信息。
- en: 2.6.5\. The sqlite_stat2 table
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6.5\. sqlite_stat2表
- en: 'The sqlite_stat2 is only created and is only used if SQLite is compiled with
    SQLITE_ENABLE_STAT2 and if the SQLite version number is between 3.6.18 (2009-09-11)
    and 3.7.8 (2011-09-19). The sqlite_stat2 table is neither read nor written by
    any version of SQLite before 3.6.18 nor after 3.7.8. The sqlite_stat2 table contains
    additional information about the distribution of keys within an index. The schema
    of the sqlite_stat2 table is as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当 SQLite 编译时启用了 SQLITE_ENABLE_STAT2，并且 SQLite 版本号在 3.6.18（2009-09-11）到 3.7.8（2011-09-19）之间时，才会创建并使用
    sqlite_stat2。sqlite_stat2 表在 SQLite 3.6.18 之前和 3.7.8 之后的版本中都不会被读取或写入。sqlite_stat2
    表包含关于索引内键分布的附加信息。sqlite_stat2 表的模式如下：
- en: '[PRE5]'
  id: totrans-307
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The sqlite_stat2.idx column and the sqlite_stat2.tbl column in each row of the
    sqlite_stat2 table identify an index described by that row. There are usually
    10 rows in the sqlite_stat2 table for each index.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: sqlite_stat2 表中每行的 sqlite_stat2.idx 列和 sqlite_stat2.tbl 列标识由该行描述的索引。每个索引通常在
    sqlite_stat2 表中有 10 行。
- en: The sqlite_stat2 entries for an index that have sqlite_stat2.sampleno between
    0 and 9 inclusive are samples of the left-most key value in the index taken at
    evenly spaced points along the index. Let C be the number of rows in the index.
    Then the sampled rows are given by
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 索引的 sqlite_stat2 条目，其 sqlite_stat2.sampleno 值介于 0 和 9 之间（包括边界值），是在索引上均匀间隔的点上取得的左侧键值的样本。设
    C 为索引中的行数。则取样行由以下公式给出：
- en: rownumber = (i*C*2 + C)/20
  id: totrans-310
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: rownumber = (i*C*2 + C)/20
- en: The variable i in the previous expression varies between 0 and 9. Conceptually,
    the index space is divided into 10 uniform buckets and the samples are the middle
    row from each bucket.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 前述表达式中的变量 i 的值在 0 和 9 之间变化。在概念上，索引空间被分为 10 个均匀的桶，样本是每个桶中间的行。
- en: The format for sqlite_stat2 is recorded here for legacy reference. Recent versions
    of SQLite no longer support sqlite_stat2 and the sqlite_stat2 table, if is exists,
    is simply ignored.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: sqlite_stat2 的格式在此记录，供遗留参考。SQLite 的最新版本不再支持 sqlite_stat2，如果存在 sqlite_stat2 表，则会被简单地忽略。
- en: 2.6.6\. The sqlite_stat3 table
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6.6\. sqlite_stat3 表
- en: 'The sqlite_stat3 is only used if SQLite is compiled with [SQLITE_ENABLE_STAT3](compile.html#enable_stat3)
    or [SQLITE_ENABLE_STAT4](compile.html#enable_stat4) and if the SQLite version
    number is 3.7.9 (2011-11-01) or greater. The sqlite_stat3 table is neither read
    nor written by any version of SQLite before 3.7.9. If the [SQLITE_ENABLE_STAT4](compile.html#enable_stat4)
    compile-time option is used and the SQLite version number is 3.8.1 (2013-10-17)
    or greater, then sqlite_stat3 might be read but not written. The sqlite_stat3
    table contains additional information about the distribution of keys within an
    index, information that the query planner can use to devise better and faster
    query algorithms. The schema of the sqlite_stat3 table is as follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在 SQLite 编译时启用了 [SQLITE_ENABLE_STAT3](compile.html#enable_stat3) 或 [SQLITE_ENABLE_STAT4](compile.html#enable_stat4)，并且
    SQLite 版本号为 3.7.9（2011-11-01）或更高时，才会使用 sqlite_stat3 表。sqlite_stat3 表在 SQLite 3.7.9
    之前的任何版本中既不读也不写。如果使用了 [SQLITE_ENABLE_STAT4](compile.html#enable_stat4) 编译选项，并且
    SQLite 版本号为 3.8.1（2013-10-17）或更高，则可能会读取但不会写入 sqlite_stat3 表。sqlite_stat3 表包含有关索引内键分布的附加信息，查询规划器可以利用这些信息来设计更好更快的查询算法。sqlite_stat3
    表的模式如下：
- en: '[PRE6]'
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There are usually multiple entries in the sqlite_stat3 table for each index.
    The sqlite_stat3.sample column holds the value of the left-most field of an index
    identified by sqlite_stat3.idx and sqlite_stat3.tbl. The sqlite_stat3.nEq column
    holds the approximate number of entries in the index whose left-most column exactly
    matches the sample. The sqlite_stat3.nLt holds the approximate number of entries
    in the index whose left-most column is less than the sample. The sqlite_stat3.nDLt
    column holds the approximate number of distinct left-most entries in the index
    that are less than the sample.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: sqlite_stat3 表中通常会为每个索引存在多个条目。sqlite_stat3.sample 列保存的是由 sqlite_stat3.idx 和
    sqlite_stat3.tbl 标识的索引的最左边字段的值。sqlite_stat3.nEq 列保存的是索引中确切匹配样本的条目数的近似值。sqlite_stat3.nLt
    列保存的是索引中最左边列小于样本的条目数的近似值。sqlite_stat3.nDLt 列保存的是索引中最左边的唯一条目小于样本的近似不同条目数。
- en: There can be an arbitrary number of sqlite_stat3 entries per index. The [ANALYZE](lang_analyze.html)
    command will typically generate sqlite_stat3 tables that contain between 10 and
    40 samples that are distributed across the key space and with large nEq values.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 每个索引可以有任意数量的 sqlite_stat3 条目。[ANALYZE](lang_analyze.html) 命令通常会生成包含分布在键空间中且具有大
    nEq 值的 10 到 40 个样本的 sqlite_stat3 表。
- en: In a well-formed sqlite_stat3 table, the samples for any single index must appear
    in the same order that they occur in the index. In other words, if the entry with
    left-most column S1 is earlier in the index b-tree than the entry with left-most
    column S2, then in the sqlite_stat3 table, sample S1 must have a smaller rowid
    than sample S2.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在格式良好的 sqlite_stat3 表中，任何单个索引的样本必须按其在索引中出现的顺序出现。换句话说，如果具有最左列 S1 的条目在索引 b 树中早于具有最左列
    S2 的条目，则在 sqlite_stat3 表中，样本 S1 必须比样本 S2 的 rowid 小。
- en: 2.6.7\. The sqlite_stat4 table
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6.7\. sqlite_stat4 表
- en: 'The sqlite_stat4 is only created and is only used if SQLite is compiled with
    [SQLITE_ENABLE_STAT4](compile.html#enable_stat4) and if the SQLite version number
    is 3.8.1 (2013-10-17) or greater. The sqlite_stat4 table is neither read nor written
    by any version of SQLite before 3.8.1. The sqlite_stat4 table contains additional
    information about the distribution of keys within an index or the distribution
    of keys in the primary key of a [WITHOUT ROWID](withoutrowid.html) table. The
    query planner can sometimes use the additional information in the sqlite_stat4
    table to devise better and faster query algorithms. The schema of the sqlite_stat4
    table is as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当 SQLite 编译时启用了 [SQLITE_ENABLE_STAT4](compile.html#enable_stat4) 并且 SQLite
    版本号为 3.8.1 (2013-10-17) 或更高时，才会创建并使用 sqlite_stat4 表。sqlite_stat4 表在 SQLite 3.8.1
    之前的版本中既不读取也不写入。sqlite_stat4 表包含有关索引内键分布或 [WITHOUT ROWID](withoutrowid.html) 表主键键分布的附加信息。查询规划器有时可以利用
    sqlite_stat4 表中的附加信息来设计更好更快的查询算法。sqlite_stat4 表的模式如下：
- en: '[PRE7]'
  id: totrans-321
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There are typically between 10 to 40 entries in the sqlite_stat4 table for
    each index for which statistics are available, however these limits are not hard
    bounds. The meanings of the columns in the sqlite_stat4 table are as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 通常对于每个可用统计信息的索引，sqlite_stat4 表中会有 10 到 40 个条目，但这些限制并非硬性限制。sqlite_stat4 表中各列的含义如下：
- en: '| tbl: | The sqlite_stat4.tbl column holds name of the table that owns the
    index that the row describes |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| tbl: | sqlite_stat4.tbl 列存储了描述的索引所属的表名 |'
- en: '| idx: | The sqlite_stat4.idx column holds name of the index that the row describes,
    or in the case of an sqlite_stat4 entry for a [WITHOUT ROWID](withoutrowid.html)
    table, the name of the table itself. |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| idx: | sqlite_stat4.idx 列存储了描述的索引名，或者对于 [WITHOUT ROWID](withoutrowid.html)
    表的 sqlite_stat4 条目，存储的是表的名称本身。 |'
- en: '| sample: | The sqlite_stat4.sample column holds a BLOB in the [record format](fileformat2.html#record_format)
    that encodes the indexed columns followed by the rowid for a rowid table or by
    the columns of the primary key for a WITHOUT ROWID table. The sqlite_stat4.sample
    BLOB for the WITHOUT ROWID table itself contains just the columns of the primary
    key. Let the number of columns encoded by the sqlite_stat4.sample blob be N. For
    indexes on an ordinary rowid table, N will be one more than the number of columns
    indexed. For indexes on WITHOUT ROWID tables, N will be the number of columns
    indexed plus the number of columns in the primary key. For a WITHOUT ROWID table,
    N will be the number of columns in the primary key. |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| sample: | sqlite_stat4.sample 列存储一个 BLOB，以记录格式编码索引列，后跟行 ID（对于 rowid 表）或主键列（对于
    WITHOUT ROWID 表）。对于 WITHOUT ROWID 表本身的 sqlite_stat4.sample BLOB，仅包含主键列。设由 sqlite_stat4.sample
    BLOB 编码的列数为 N。对于普通 rowid 表的索引，N 将比索引列数多一列。对于 WITHOUT ROWID 表的索引，N 将是索引列数加上主键列数。对于
    WITHOUT ROWID 表，N 将是主键列数。'
- en: '| nEq: | The sqlite_stat4.nEq column holds a list of N integers where the K-th
    integer is the approximate number of entries in the index whose left-most K columns
    exactly match the K left-most columns of the sample. |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| nEq: | sqlite_stat4.nEq 列保存了一个包含 N 个整数的列表，其中第 K 个整数是索引中确切匹配样本的 K 个最左列的条目的大约数量。
    |'
- en: '| nLt: | The sqlite_stat4.nLt column holds a list of N integers where the K-th
    integer is the approximate number of entries in the index whose K left-most columns
    are collectively less than the K left-most columns of the sample. |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| nLt: | sqlite_stat4.nLt 列保存了一个包含 N 个整数的列表，其中第 K 个整数是索引中条目的大约数量，其 K 个最左列总体小于样本的
    K 个最左列。 |'
- en: '| nDLt: | The sqlite_stat4.nDLt column holds a list of N integers where the
    K-th integer is the approximate number of entries in the index that are distinct
    in the first K columns and where the left-most K columns are collectively less
    than the left-most K columns of the sample. |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| nDLt: | sqlite_stat4.nDLt 列保存了一个包含 N 个整数的列表，其中第 K 个整数是索引中条目的大约数量，其前 K 列是不同的，并且其
    K 个最左列总体小于样本的 K 个最左列。 |'
- en: The sqlite_stat4 is a generalization of the sqlite_stat3 table. The sqlite_stat3
    table provides information about the left-most column of an index whereas the
    sqlite_stat4 table provides information about all columns of the index.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: sqlite_stat4 是 sqlite_stat3 表的泛化。sqlite_stat3 表提供了关于索引最左列的信息，而 sqlite_stat4
    表提供了关于索引所有列的信息。
- en: There can be an arbitrary number of sqlite_stat4 entries per index. The [ANALYZE](lang_analyze.html)
    command will typically generate sqlite_stat4 tables that contain between 10 and
    40 samples that are distributed across the key space and with large nEq values.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 每个索引可以有任意数量的 sqlite_stat4 条目。 [ANALYZE](lang_analyze.html) 命令通常会生成包含分布在键空间中的大约
    10 到 40 个样本以及大 nEq 值的 sqlite_stat4 表。
- en: In a well-formed sqlite_stat4 table, the samples for any single index must appear
    in the same order that they occur in the index. In other words, if entry S1 is
    earlier in the index b-tree than entry S2, then in the sqlite_stat4 table, sample
    S1 must have a smaller rowid than sample S2.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在良好形式的 sqlite_stat4 表中，任何单个索引的样本必须按照它们在索引中出现的顺序出现。换句话说，如果条目 S1 在索引 b 树中比条目 S2
    更早出现，那么在 sqlite_stat4 表中，样本 S1 的 rowid 必须比样本 S2 的小。
- en: 3\. The Rollback Journal
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3\. 回滚日志
- en: The rollback journal is a file associated with each SQLite database file that
    holds information used to restore the database file to its initial state during
    the course of a transaction. The rollback journal file is always located in the
    same directory as the database file and has the same name as the database file
    but with the string "`-journal`" appended. There can only be a single rollback
    journal associated with a give database and hence there can only be one write
    transaction open against a single database at one time.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 回滚日志是与每个SQLite数据库文件相关联的文件，它保存了在事务进行过程中将数据库文件恢复到初始状态所需的信息。回滚日志文件始终位于与数据库文件相同的目录中，并且具有与数据库文件相同的名称，但附加了字符串“-journal”。给定数据库只能关联一个回滚日志，因此同一时间只能对单个数据库开放一个写事务。
- en: Before any information-bearing page of the database is modified, the original
    unmodified content of that page is written into the rollback journal. If a transaction
    is interrupted and needs to be rolled back, the rollback journal can then be used
    to restore the database to its original state. Freelist leaf pages bear no information
    that would need to be restored on a rollback and so they are not written to the
    journal prior to modification, in order to reduce disk I/O.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改数据库的任何信息页之前，该页的原始未修改内容将被写入回滚日志。如果事务中断并需要回滚，则可以使用回滚日志将数据库恢复到其原始状态。自由列表叶页不包含需要在回滚时恢复的信息，因此它们在修改之前不会写入日志，以减少磁盘I/O。
- en: If a transaction is aborted due to an application crash, or a single, or an
    operating system crash, or a hardware power failure or crash, then the main database
    file might be left in an inconsistent state. The next time SQLite attempts to
    open the database file, the presence of the rollback journal file will be detected
    and the journal will be automatically played back to restore the database to its
    state at the start of the incomplete transaction.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个事务因应用程序崩溃、单个操作系统崩溃、硬件断电故障或崩溃而中止，那么主数据库文件可能会留在不一致的状态。下次SQLite尝试打开数据库文件时，将检测回滚日志文件的存在，并自动回放日志，将数据库恢复到未完成事务开始时的状态。
- en: 'A rollback journal is only considered to be valid if it exists and contains
    a valid header. Hence a transaction can be committed in one of three ways:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 只有存在回滚日志文件并包含有效头部时，才认为回滚日志是有效的。因此，事务可以通过以下三种方式提交：
- en: The rollback journal file can be deleted,
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回滚日志文件可以被删除，
- en: The rollback journal file can be truncated to zero length, or
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回滚日志文件可以被截断为零长度，或者
- en: The header of the rollback journal can be overwritten with invalid header text
    (for example, all zeros).
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回滚日志的头部可以被用无效头部文本覆盖（例如，全部为零）。
- en: These three ways of committing a transaction correspond to the DELETE, TRUNCATE,
    and PERSIST settings, respectively, of the [journal_mode pragma](pragma.html#pragma_journal_mode).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种提交事务的方式分别对应于[日志模式控制器](pragma.html#pragma_journal_mode)的DELETE、TRUNCATE和PERSIST设置。
- en: 'A valid rollback journal begins with a header in the following format:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有效的回滚日志以以下格式的头部开始：
- en: '*Rollback Journal Header Format*'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '*回滚日志头部格式*'
- en: '| Offset | Size | Description |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| 偏移量 | 大小 | 描述 |'
- en: '| 0 | 8 | Header string: 0xd9, 0xd5, 0x05, 0xf9, 0x20, 0xa1, 0x63, 0xd7 |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 8 | 头字符串：0xd9, 0xd5, 0x05, 0xf9, 0x20, 0xa1, 0x63, 0xd7 |'
- en: '| 8 | 4 | The "Page Count" - The number of pages in the next segment of the
    journal, or -1 to mean all content to the end of the file |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 4 | "页计数" - 下一个日志段中的页面数，或者为-1表示所有内容直到文件末尾 |'
- en: '| 12 | 4 | A random nonce for the checksum |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 4 | 用于校验和的随机Nonce值 |'
- en: '| 16 | 4 | Initial size of the database in pages |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 4 | 数据库初始大小（以页为单位） |'
- en: '| 20 | 4 | Size of a disk sector assumed by the process that wrote this journal.
    |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| 20 | 4 | 由写入此日志的进程假定的磁盘扇区大小。 |'
- en: '| 24 | 4 | Size of pages in this journal. |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| 24 | 4 | 该日志中页面的大小。 |'
- en: A rollback journal header is padded with zeros out to the size of a single sector
    (as defined by the sector size integer at offset 20). The header is in a sector
    by itself so that if a power loss occurs while writing the sector, information
    that follows the header will be (hopefully) undamaged.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 回滚日志头部用零填充，直到达到一个扇区的大小（由偏移量20处的扇区大小整数定义）。该头部位于一个扇区内，因此如果在写入扇区时发生断电，头部之后的信息应该是（希望）不会受损的。
- en: After the header and zero padding are zero or more page records. Each page record
    stores a copy of the content of a page from the database file before it was changed.
    The same page may not appear more than once within a single rollback journal.
    To rollback an incomplete transaction, a process has merely to read the rollback
    journal from beginning to end and write pages found in the journal back into the
    database file at the appropriate location.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 头部和零填充后是零个或多个页面记录。每个页面记录存储了数据库文件中页面在被更改之前的内容的副本。同一页面在单个回滚日志中不得出现多次。要回滚一个不完整的事务，一个进程只需从头到尾读取回滚日志，并将找到的页面写回到数据库文件的适当位置。
- en: 'Let the database page size (the value of the integer at offset 24 in the journal
    header) be N. Then the format of a page record is as follows:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 设数据库页大小（日志头部偏移量24处的整数值）为N。那么页面记录的格式如下：
- en: '*Rollback Journal Page Record Format*'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '*回滚日志页记录格式*'
- en: '| Offset | Size | Description |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| 偏移量 | 大小 | 描述 |'
- en: '| 0 | 4 | The page number in the database file |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 4 | 数据库文件中的页号 |'
- en: '| 4 | N | Original content of the page prior to the start of the transaction
    |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| 4 | N | 事务开始前数据库页面的原始内容 |'
- en: '| N+4 | 4 | Checksum |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| N+4 | 4 | 校验和 |'
- en: 'The checksum is an unsigned 32-bit integer computed as follows:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 校验和是通过以下方式计算的无符号32位整数：
- en: Initialize the checksum to the checksum nonce value found in the journal header
    at offset 12.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将校验和初始化为日志头部偏移量12处找到的校验和Nonce值。
- en: Initialize index X to be N-200 (where N is the size of a database page in bytes.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将索引X初始化为N-200（其中N是以字节为单位的数据库页面大小）。
- en: Interpret the byte at offset X into the page as an 8-bit unsigned integer and
    add the value of that integer to the checksum.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释位于偏移量 X 处的字节作为一个 8 位无符号整数，并将该整数的值添加到校验和中。
- en: Subtract 200 from X.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 X 中减去 200。
- en: If X is greater than or equal to zero, go back to step 3.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 X 大于或等于零，则返回步骤 3。
- en: The checksum value is used to guard against incomplete writes of a journal page
    record following a power failure. A different random nonce is used each time a
    transaction is started in order to minimize the risk that unwritten sectors might
    by chance contain data from the same page that was a part of prior journals. By
    changing the nonce for each transaction, stale data on disk will still generate
    an incorrect checksum and be detected with high probability. The checksum only
    uses a sparse sample of 32-bit words from the data record for performance reasons
    - design studies during the planning phases of SQLite 3.0.0 showed a significant
    performance hit in checksumming the entire page.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 校验和值用于防止在断电后写入不完整的日志页面记录。每次启动事务时都使用不同的随机 nonce，以最小化未写入的扇区可能包含前期日志中同一页面的数据的风险。通过为每个事务更改
    nonce，磁盘上的旧数据仍将生成不正确的校验和，并且高概率地检测到。出于性能原因，校验和仅使用数据记录中的稀疏样本的 32 位字 - SQLite 3.0.0
    计划阶段的设计研究显示在对整个页面进行校验和时会有显著的性能损失。
- en: Let the page count value at offset 8 in the journal header be M. If M is greater
    than zero then after M page records the journal file may be zero padded out to
    the next multiple of the sector size and another journal header may be inserted.
    All journal headers within the same journal must contain the same database page
    size and sector size.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 让日志头中偏移量为 8 的页面计数值为 M。如果 M 大于零，则在 M 个页面记录后，日志文件可能会被填充为下一个扇区大小的倍数，并且可能会插入另一个日志头。同一日志中的所有日志头必须包含相同的数据库页面大小和扇区大小。
- en: If M is -1 in the initial journal header, then the number of page records that
    follow is computed by computing how many page records will fit in the available
    space of the remainder of the journal file.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果初始日志头中的 M 为 -1，则接下来的页面记录数由计算日志文件剩余可用空间中可以容纳多少页面记录来确定。
- en: 4\. The Write-Ahead Log
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4\. 写前日志
- en: Beginning with [version 3.7.0](releaselog/3_7_0.html) (2010-07-21), SQLite supports
    a new transaction control mechanism called "[write-ahead log](wal.html)" or "[WAL](wal.html)".
    When a database is in WAL mode, all connections to that database must use the
    WAL. A particular database will use either a rollback journal or a WAL, but not
    both at the same time. The WAL is always located in the same directory as the
    database file and has the same name as the database file but with the string "`-wal`"
    appended.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [版本 3.7.0](releaselog/3_7_0.html) (2010-07-21) 开始，SQLite 支持一种新的事务控制机制称为 "[写前日志](wal.html)"
    或 "[WAL](wal.html)"。当数据库处于 WAL 模式时，所有连接到该数据库的连接必须使用 WAL。特定数据库将仅使用回滚日志或 WAL，但不会同时使用两者。WAL
    总是位于与数据库文件相同的目录中，并且具有与数据库文件相同但附加字符串 "`-wal`" 的文件名。
- en: 4.1\. WAL File Format
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1\. WAL 文件格式
- en: A [WAL file](wal.html#walfile) consists of a header followed by zero or more
    "frames". Each frame records the revised content of a single page from the database
    file. All changes to the database are recorded by writing frames into the WAL.
    Transactions commit when a frame is written that contains a commit marker. A single
    WAL can and usually does record multiple transactions. Periodically, the content
    of the WAL is transferred back into the database file in an operation called a
    "checkpoint".
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 一个[WAL文件](wal.html#walfile)由一个头部和零个或多个“帧”组成。每个帧记录了数据库文件中单个页面的修改内容。所有对数据库的更改都通过将帧写入WAL来记录。当写入包含提交标记的帧时，事务即提交。一个单独的WAL可以且通常记录多个事务。定期地，WAL的内容被转移回数据库文件，这个操作称为“检查点”。
- en: A single WAL file can be reused multiple times. In other words, the WAL can
    fill up with frames and then be checkpointed and then new frames can overwrite
    the old ones. A WAL always grows from beginning toward the end. Checksums and
    counters attached to each frame are used to determine which frames within the
    WAL are valid and which are leftovers from prior checkpoints.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单独的WAL文件可以多次重复使用。换句话说，WAL可以充满帧，然后被检查点，并且新的帧可以覆盖旧的帧。WAL总是从开头向末尾增长。附加到每个帧的校验和和计数器用于确定WAL内哪些帧是有效的，哪些是前一个检查点遗留的。
- en: 'The WAL header is 32 bytes in size and consists of the following eight big-endian
    32-bit unsigned integer values:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: WAL头部大小为32字节，包括以下八个大端序的32位无符号整数值：
- en: '*WAL Header Format*'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '*WAL头部格式*'
- en: '| Offset | Size | Description |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| Offset | Size | 描述 |'
- en: '| 0 | 4 | Magic number. 0x377f0682 or 0x377f0683 |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 4 | 魔术数。0x377f0682或0x377f0683 |'
- en: '| 4 | 4 | File format version. Currently 3007000. |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 4 | 文件格式版本。当前为3007000。 |'
- en: '| 8 | 4 | Database page size. Example: 1024 |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 4 | 数据库页面大小。例如：1024 |'
- en: '| 12 | 4 | Checkpoint sequence number |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 4 | 检查点序列号 |'
- en: '| 16 | 4 | Salt-1: random integer incremented with each checkpoint |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 4 | 盐值-1：随每次检查点增加的随机整数 |'
- en: '| 20 | 4 | Salt-2: a different random number for each checkpoint |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| 20 | 4 | 盐值-2：每个检查点的不同随机数 |'
- en: '| 24 | 4 | Checksum-1: First part of a checksum on the first 24 bytes of header
    |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| 24 | 4 | 校验和-1：对头部前24字节的第一部分进行校验和 |'
- en: '| 28 | 4 | Checksum-2: Second part of the checksum on the first 24 bytes of
    header |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| 28 | 4 | 校验和-2：对头部前24字节的第二部分进行校验和 |'
- en: 'Immediately following the wal-header are zero or more frames. Each frame consists
    of a 24-byte frame-header followed by a *page-size* bytes of page data. The frame-header
    is six big-endian 32-bit unsigned integer values, as follows:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 紧随WAL头部之后的是零个或多个帧。每个帧由一个24字节的帧头部和*页面大小*字节的页面数据组成。帧头部是六个大端序的32位无符号整数值，如下所示：
- en: '*WAL Frame Header Format*'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '*WAL帧头部格式*'
- en: '| Offset | Size | Description |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| Offset | Size | 描述 |'
- en: '| 0 | 4 | Page number |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 4 | 页面编号 |'
- en: '| 4 | 4 | For commit records, the size of the database file in pages after
    the commit. For all other records, zero. |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 4 | 对于提交记录，提交后数据库文件的页面大小。对于所有其他记录，为零。 |'
- en: '| 8 | 4 | Salt-1 copied from the WAL header |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 4 | 从WAL头部复制的Salt-1 |'
- en: '| 12 | 4 | Salt-2 copied from the WAL header |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 4 | 从WAL头部复制的Salt-2 |'
- en: '| 16 | 4 | Checksum-1: Cumulative checksum up through and including this page
    |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 4 | 校验和-1：通过并包括此页的累积校验和 |'
- en: '| 20 | 4 | Checksum-2: Second half of the cumulative checksum. |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| 20 | 4 | 校验和-2：累积校验和的后半部分。'
- en: 'A frame is considered valid if and only if the following conditions are true:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 当且仅当以下条件为真时，帧才被视为有效：
- en: The salt-1 and salt-2 values in the frame-header match salt values in the wal-header
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 帧头中的salt-1和salt-2值与wal-header中的salt值匹配
- en: The checksum values in the final 8 bytes of the frame-header exactly match the
    checksum computed consecutively on the first 24 bytes of the WAL header and the
    first 8 bytes and the content of all frames up to and including the current frame.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 帧头最后8字节中的校验和值必须与在WAL头的前24字节和前8字节以及包括当前帧在内的所有帧的内容上连续计算的校验和完全匹配。
- en: 4.2\. Checksum Algorithm
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2\. 校验和算法
- en: 'The checksum is computed by interpreting the input as an even number of unsigned
    32-bit integers: x(0) through x(N). The 32-bit integers are big-endian if the
    magic number in the first 4 bytes of the WAL header is 0x377f0683 and the integers
    are little-endian if the magic number is 0x377f0682. The checksum values are always
    stored in the frame header in a big-endian format regardless of which byte order
    is used to compute the checksum.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 校验和是通过将输入解释为偶数个无符号32位整数来计算的：x(0)至x(N)。如果WAL头的前4字节中的魔数是0x377f0683，则32位整数为大端序；如果魔数是0x377f0682，则为小端序。无论使用哪种字节顺序计算校验和，校验和值始终以大端序格式存储在帧头中。
- en: 'The checksum algorithm only works for content which is a multiple of 8 bytes
    in length. In other words, if the inputs are x(0) through x(N) then N must be
    odd. The checksum algorithm is as follows:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 校验和算法仅适用于长度为8字节的倍数的内容。换句话说，如果输入为x(0)至x(N)，则N必须是奇数。校验和算法如下：
- en: '[PRE8]'
  id: totrans-398
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The outputs s0 and s1 are both weighted checksums using Fibonacci weights in
    reverse order. (The largest Fibonacci weight occurs on the first element of the
    sequence being summed.) The s1 value spans all 32-bit integer terms of the sequence
    whereas s0 omits the final term.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 输出s0和s1都是使用逆向斐波那契权重的加权校验和。（序列的第一个元素上具有最大的斐波那契权重。）s1值跨越序列的所有32位整数项，而s0省略了最后一个项。
- en: 4.3\. Checkpoint Algorithm
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3\. 检查点算法
- en: On a [checkpoint](wal.html#ckpt), the WAL is first flushed to persistent storage
    using the xSync method of the [VFS](c3ref/io_methods.html). Then valid content
    of the WAL is transferred into the database file. Finally, the database is flushed
    to persistent storage using another xSync method call. The xSync operations serve
    as write barriers - all writes launched before the xSync must complete before
    any write that launches after the xSync begins.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在[检查点](wal.html#ckpt)上，首先使用[VFS](c3ref/io_methods.html)的xSync方法将WAL刷新到持久存储中。然后将WAL的有效内容转移到数据库文件中。最后，使用另一个xSync方法调用将数据库刷新到持久存储中。xSync操作作为写障碍
    - 在xSync之前启动的所有写操作必须在xSync之后启动的任何写操作开始之前完成。
- en: A checkpoint need not run to completion. It might be that some readers are still
    using older transactions with data that is contained in the database file. In
    that case, transferring content for newer transactions from the WAL file into
    the database would delete the content out from under readers still using the older
    transactions. To avoid that, checkpoints only run to completion if all reader
    are using the last transaction in the WAL.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 一个检查点不需要完全运行。可能会有一些读者仍在使用包含在数据库文件中的旧事务数据。在这种情况下，将新事务的内容从WAL文件转移到数据库中会删除仍在使用旧事务的读者的内容。为了避免这种情况，只有当所有读者都在使用WAL中的最后一个事务时，检查点才会完全运行。
- en: 4.4\. WAL Reset
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4\. WAL重置
- en: After a complete checkpoint, if no other connections are in transactions that
    use the WAL, then subsequent write transactions can overwrite the WAL file from
    the beginning. This is called "resetting the WAL". At the start of the first new
    write transaction, the WAL header salt-1 value is incremented and the salt-2 value
    is randomized. These changes to the salts invalidate old frames in the WAL that
    have already been checkpointed but not yet overwritten, and prevent them from
    being checkpointed again.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 完成检查点后，如果没有其他连接处于使用WAL的事务中，那么随后的写事务可以从WAL文件的开头重写。这称为"重置WAL"。在第一个新的写事务开始时，WAL头部的salt-1值会增加，salt-2值会随机化。这些对盐的更改使得已经被检查点但尚未被覆盖的WAL中的旧帧无效，并防止它们再次被检查点。
- en: The WAL file can optionally be truncated on a reset, but it need not be. Performance
    is usually a little better if the WAL is not truncated, since filesystems generally
    will overwrite an existing file faster than they will grow a file.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在重置时，可以选择截断WAL文件，但不一定需要这样做。通常情况下，如果不截断WAL，则性能会略有提高，因为文件系统通常会比增长文件更快地覆盖现有文件。
- en: 4.5\. Reader Algorithm
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5\. 读者算法
- en: To read a page from the database (call it page number P), a reader first checks
    the WAL to see if it contains page P. If so, then the last valid instance of page
    P that is followed by a commit frame or is a commit frame itself becomes the value
    read. If the WAL contains no copies of page P that are valid and which are a commit
    frame or are followed by a commit frame, then page P is read from the database
    file.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 要从数据库中读取页面（称为页号 P），读取器首先检查 WAL，以查看是否包含页面 P。如果是，则最后一个有效的页面 P 实例，其后跟一个提交帧或者是提交帧本身，将成为读取的值。如果
    WAL 不包含任何有效的页面 P 的副本，或者这些副本是提交帧或者跟随提交帧，则从数据库文件中读取页面 P。
- en: To start a read transaction, the reader records the number of value frames in
    the WAL as "mxFrame". ([More detail](walformat.html#mxframe)) The reader uses
    this recorded mxFrame value for all subsequent read operations. New transactions
    can be appended to the WAL, but as long as the reader uses its original mxFrame
    value and ignores subsequently appended content, the reader will see a consistent
    snapshot of the database from a single point in time. This technique allows multiple
    concurrent readers to view different versions of the database content simultaneously.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动读取事务，读取器记录 WAL 中值帧的数量作为 "mxFrame"。([更多细节](walformat.html#mxframe)) 读取器在所有后续读取操作中使用此记录的
    mxFrame 值。可以向 WAL 追加新事务，但只要读取器使用其原始的 mxFrame 值并忽略随后追加的内容，读取器将看到数据库的一致快照从单一时间点。这种技术允许多个并发读取器同时查看数据库内容的不同版本。
- en: The reader algorithm in the previous paragraphs works correctly, but because
    frames for page P can appear anywhere within the WAL, the reader has to scan the
    entire WAL looking for page P frames. If the WAL is large (multiple megabytes
    is typical) that scan can be slow, and read performance suffers. To overcome this
    problem, a separate data structure called the wal-index is maintained to expedite
    the search for frames of a particular page.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 前面段落中的读取器算法是正确的，但由于页面 P 的帧可以出现在 WAL 的任何位置，因此读取器必须扫描整个 WAL，以查找页面 P 的帧。如果 WAL
    很大（典型情况下是多兆字节），这种扫描可能很慢，读取性能会受到影响。为了解决这个问题，维护了一个名为 wal-index 的单独数据结构，以加快对特定页面帧的搜索。
- en: 4.6\. WAL-Index Format
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6\. WAL-Index 格式
- en: Conceptually, the wal-index is shared memory, though the current VFS implementations
    use a memory-mapped file for operating-system portability. The memory-mapped file
    is in the same directory as the database and has the same name as the database
    with a "`-shm`" suffix appended. Because the wal-index is shared memory, SQLite
    does not support [journal_mode=WAL](pragma.html#pragma_journal_mode) on a network
    filesystem when clients are on different machines, as all clients of the database
    must be able to share the same memory.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，wal-index 是共享内存，尽管当前的 VFS 实现使用内存映射文件来实现操作系统的可移植性。内存映射文件位于与数据库相同的目录中，并且具有与数据库相同的名称，附加有
    "`-shm`" 后缀。由于 wal-index 是共享内存，当客户端位于不同机器上时，SQLite 不支持在网络文件系统上使用 [journal_mode=WAL](pragma.html#pragma_journal_mode)，因为所有数据库的客户端必须能够共享相同的内存。
- en: 'The purpose of the wal-index is to answer this question quickly:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: wal-index的目的是快速回答这个问题：
- en: '*Given a page number P and a maximum WAL frame index M, return the largest
    WAL frame index for page P that does not exceed M, or return NULL if there are
    no frames for page P that do not exceed M.*'
  id: totrans-413
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*给定页码P和最大WAL帧索引M，返回不超过M的页P的最大WAL帧索引，如果没有超过M的帧则返回NULL。*'
- en: The *M* value in the previous paragraph is the "mxFrame" value defined in [section
    4.4](fileformat2.html#walread) that is read at the start of a transaction and
    which defines the maximum frame from the WAL that the reader will use.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 前段中的*M*值是在[第4.4节](fileformat2.html#walread)中定义的“mxFrame”值，在事务开始时读取，并定义了阅读器将使用的WAL中的最大帧。
- en: The wal-index is transient. After a crash, the wal-index is reconstructed from
    the original WAL file. The VFS is required to either truncate or zero the header
    of the wal-index when the last connection to it closes. Because the wal-index
    is transient, it can use an architecture-specific format; it does not have to
    be cross-platform. Hence, unlike the database and WAL file formats which store
    all values as big endian, the wal-index stores multi-byte values in the native
    byte order of the host computer.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: wal-index是临时的。崩溃后，wal-index将从原始WAL文件重建。当最后一个连接关闭时，VFS需要截断或清零wal-index的标头。由于wal-index是临时的，它可以使用特定于体系结构的格式；它不必跨平台。因此，与将所有值存储为大端的数据库和WAL文件格式不同，wal-index将多字节值存储在主机计算机的本机字节顺序中。
- en: This document is concerned with the persistent state of the database file, and
    since the wal-index is a transient structure, no further information about the
    format of the wal-index will be provided here. Additional details on the format
    of the wal-index are contained in the separate [WAL-index File Format](walformat.html#walidxfmt)
    document.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 本文关注数据库文件的持久状态，由于wal-index是一个临时结构，这里不会提供关于wal-index格式的更多信息。有关wal-index格式的详细信息包含在单独的[WAL索引文件格式](walformat.html#walidxfmt)文档中。
