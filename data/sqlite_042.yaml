- en: 1\. Introduction to FTS3 and FTS4
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1\. FTS3 和 FTS4 简介
- en: 原文：[https://sqlite.com/fts3.html](https://sqlite.com/fts3.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://sqlite.com/fts3.html](https://sqlite.com/fts3.html)
- en: Overview
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: FTS3 and FTS4 are SQLite virtual table modules that allows users to perform
    full-text searches on a set of documents. The most common (and effective) way
    to describe full-text searches is "what Google, Yahoo, and Bing do with documents
    placed on the World Wide Web". Users input a term, or series of terms, perhaps
    connected by a binary operator or grouped together into a phrase, and the full-text
    query system finds the set of documents that best matches those terms considering
    the operators and groupings the user has specified. This article describes the
    deployment and usage of FTS3 and FTS4.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: FTS3 和 FTS4 是SQLite虚拟表模块，允许用户在一组文档上执行全文搜索。描述全文搜索最常见（也是最有效）的方式是"Google、Yahoo
    和 Bing 如何处理放置在万维网上的文档"。用户输入一个术语或一系列术语，可能由二进制运算符连接或组合成一个短语，全文查询系统找到最符合用户指定的操作符和分组的文档集。本文描述了FTS3
    和 FTS4 的部署和使用。
- en: FTS1 and FTS2 are obsolete full-text search modules for SQLite. There are known
    issues with these older modules and their use should be avoided. Portions of the
    original FTS3 code were contributed to the SQLite project by Scott Hess of [Google](http://www.google.com).
    It is now developed and maintained as part of SQLite.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: FTS1 和 FTS2 是过时的SQLite全文搜索模块。这些旧模块存在已知问题，应避免使用。FTS3 的部分原始代码由[Google](http://www.google.com)的Scott
    Hess贡献给SQLite项目。现在它作为SQLite的一部分进行开发和维护。
- en: The FTS3 and FTS4 extension modules allows users to create special tables with
    a built-in full-text index (hereafter "FTS tables"). The full-text index allows
    the user to efficiently query the database for all rows that contain one or more
    words (hereafter "tokens"), even if the table contains many large documents.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: FTS3 和 FTS4 扩展模块允许用户创建具有内置全文索引（以下简称"FTS表"）的特殊表。全文索引允许用户高效地查询数据库中包含一个或多个单词（以下简称"标记"）的所有行，即使表中包含许多大型文档。
- en: 'For example, if each of the 517430 documents in the "[Enron E-Mail Dataset](http://www.cs.cmu.edu/~enron/)"
    is inserted into both an FTS table and an ordinary SQLite table created using
    the following SQL script:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果"[Enron 电子邮件数据集](http://www.cs.cmu.edu/~enron/)"中的每个517430个文档都插入到FTS表和使用以下SQL脚本创建的普通SQLite表中：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Then either of the two queries below may be executed to find the number of documents
    in the database that contain the word "linux" (351). Using one desktop PC hardware
    configuration, the query on the FTS3 table returns in approximately 0.03 seconds,
    versus 22.5 for querying the ordinary table.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以执行以下两个查询中的任一个来查找数据库中包含单词"linux"的文档数量（351）。在一个桌面PC硬件配置上，对FTS3表的查询大约需要0.03秒，而对普通表的查询则需要22.5秒。
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Of course, the two queries above are not entirely equivalent. For example the
    LIKE query matches rows that contain terms such as "linuxophobe" or "EnterpriseLinux"
    (as it happens, the Enron E-Mail Dataset does not actually contain any such terms),
    whereas the MATCH query on the FTS3 table selects only those rows that contain
    "linux" as a discrete token. Both searches are case-insensitive. The FTS3 table
    consumes around 2006 MB on disk compared to just 1453 MB for the ordinary table.
    Using the same hardware configuration used to perform the SELECT queries above,
    the FTS3 table took just under 31 minutes to populate, versus 25 for the ordinary
    table.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，上述两个查询并不完全相同。例如，LIKE 查询会匹配包含诸如"linuxophobe"或"EnterpriseLinux"等术语的行（事实上，Enron
    电子邮件数据集实际上并不包含任何此类术语），而FTS3表上的MATCH 查询只选择包含"linux"作为离散标记的行。两种搜索均不区分大小写。与普通表相比，FTS3表在磁盘上占用大约2006
    MB，而普通表只占用1453 MB。使用执行上述SELECT查询的相同硬件配置，FTS3表的填充时间略低于31分钟，而普通表为25分钟。
- en: 1.1\. Differences between FTS3 and FTS4
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1\. FTS3 和 FTS4 的区别
- en: 'FTS3 and FTS4 are nearly identical. They share most of their code in common,
    and their interfaces are the same. The differences are:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: FTS3 和 FTS4 几乎相同。它们大部分代码共享，接口也相同。它们的区别在于：
- en: FTS4 contains query performance optimizations that may significantly improve
    the performance of full-text queries that contain terms that are very common (present
    in a large percentage of table rows).
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FTS4 包含查询性能优化，可以显著改善包含非常常见术语（存在于大部分表行中）的全文查询的性能。
- en: FTS4 supports some additional options that may used with the [matchinfo()](fts3.html#matchinfo)
    function.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FTS4 支持一些额外的选项，可以与[matchinfo()](fts3.html#matchinfo)函数一起使用。
- en: Because it stores extra information on disk in two new [shadow tables](fts3.html#*shadowtab)
    in order to support the performance optimizations and extra matchinfo() options,
    FTS4 tables may consume more disk space than the equivalent table created using
    FTS3\. Usually the overhead is 1-2% or less, but may be as high as 10% if the
    documents stored in the FTS table are very small. The overhead may be reduced
    by specifying the directive ["matchinfo=fts3"](fts3.html#fts4matchinfo) as part
    of the FTS4 table declaration, but this comes at the expense of sacrificing some
    of the extra supported matchinfo() options.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为它在磁盘上存储了额外的信息，用于支持性能优化和额外的matchinfo()选项，所以FTS4表可能比使用FTS3创建的等效表占用更多的磁盘空间。 通常，开销只有1-2％或更少，但如果存储在FTS表中的文档非常小，则可能高达10％。
    通过在FTS4表声明的一部分指定指令["matchinfo=fts3"](fts3.html#fts4matchinfo)可以减少开销，但这会牺牲一些额外支持的matchinfo()选项。
- en: FTS4 provides hooks (the compress and uncompress [options](fts3.html#fts4_options))
    allowing data to be stored in a compressed form, reducing disk usage and IO.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FTS4提供了钩子（压缩和解压缩[选项](fts3.html#fts4_options)），允许数据以压缩形式存储，减少磁盘使用和IO。
- en: FTS4 is an enhancement to FTS3. FTS3 has been available since SQLite [version
    3.5.0](releaselog/3_5_0.html) (2007-09-04) The enhancements for FTS4 were added
    with SQLite [version 3.7.4](releaselog/3_7_4.html) (2010-12-07).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: FTS4是FTS3的增强版。 FTS3自[版本3.5.0](releaselog/3_5_0.html)以来一直可用（2007-09-04）。 FTS4的增强功能是在SQLite
    [版本3.7.4](releaselog/3_7_4.html)（2010-12-07）中添加的。
- en: Which module, FTS3 or FTS4, should you use in your application? FTS4 is sometimes
    significantly faster than FTS3, even orders of magnitude faster depending on the
    query, though in the common case the performance of the two modules is similar.
    FTS4 also offers the enhanced [matchinfo()](fts3.html#matchinfo) outputs which
    can be useful in ranking the results of a [MATCH](fts3.html#full_text_index_queries)
    operation. On the other hand, in the absence of a [matchinfo=fts3](fts3.html#fts4matchinfo)
    directive FTS4 requires a little more disk space than FTS3, though only a percent
    of two in most cases.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用程序中应该使用哪个模块，FTS3还是FTS4？ FTS4有时比FTS3快得多，查询速度甚至可以快几个数量级，尽管在常见情况下，这两个模块的性能相似。
    FTS4还提供了增强的[matchinfo()](fts3.html#matchinfo)输出，可以在排列[匹配](fts3.html#full_text_index_queries)操作的结果时非常有用。
    另一方面，在没有[matchinfo=fts3](fts3.html#fts4matchinfo)指令的情况下，FTS4对比FTS3需要更多的磁盘空间，尽管在大多数情况下只有1-2％。
- en: For newer applications, FTS4 is recommended; though if compatibility with older
    versions of SQLite is important, then FTS3 will usually serve just as well.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较新的应用程序，建议使用FTS4；尽管如果兼容性与旧版本的SQLite重要，那么FTS3通常也可以很好地满足需求。
- en: 1.2\. Creating and Destroying FTS Tables
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2\. 创建和销毁FTS表
- en: Like other virtual table types, new FTS tables are created using a [CREATE VIRTUAL
    TABLE](lang_createvtab.html) statement. The module name, which follows the USING
    keyword, is either "fts3" or "fts4". The virtual table module arguments may be
    left empty, in which case an FTS table with a single user-defined column named
    "content" is created. Alternatively, the module arguments may be passed a list
    of comma separated column names.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他虚拟表类型一样，可以使用[CREATE VIRTUAL TABLE](lang_createvtab.html)语句创建新的FTS表。 遵循USING关键字的模块名称要么是"fts3"要么是"fts4"。
    虚拟表模块参数可以为空，这样就创建了一个具有名为"content"的单个用户定义列的FTS表。 或者，模块参数可以传递逗号分隔的列名列表。
- en: If column names are explicitly provided for the FTS table as part of the CREATE
    VIRTUAL TABLE statement, then a datatype name may be optionally specified for
    each column. This is pure syntactic sugar, the supplied typenames are not used
    by FTS or the SQLite core for any purpose. The same applies to any constraints
    specified along with an FTS column name - they are parsed but not used or recorded
    by the system in any way.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在CREATE VIRTUAL TABLE语句的一部分作为FTS表明确提供列名，则可以为每列可选择地指定数据类型。 这只是纯语法糖，提供的类型名称不会被FTS或SQLite核心用于任何目的。
    同样适用于与FTS列名一起指定的任何约束 - 它们被解析，但系统不以任何方式使用或记录它们。
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As well as a list of columns, the module arguments passed to a CREATE VIRTUAL
    TABLE statement used to create an FTS table may be used to specify a [tokenizer](fts3.html#tokenizer).
    This is done by specifying a string of the form "tokenize=<tokenizer name> <tokenizer
    args>" in place of a column name, where <tokenizer name> is the name of the tokenizer
    to use and <tokenizer args> is an optional list of whitespace separated qualifiers
    to pass to the tokenizer implementation. A tokenizer specification may be placed
    anywhere in the column list, but at most one tokenizer declaration is allowed
    for each CREATE VIRTUAL TABLE statement. [See below](fts3.html#tokenizer) for
    a detailed description of using (and, if necessary, implementing) a tokenizer.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除了列的列表外，在用于创建FTS表的CREATE VIRTUAL TABLE语句中传递的模块参数也可以用于指定[分词器](fts3.html#tokenizer)。这可以通过在列名的位置指定形如“tokenize=<tokenizer
    name> <tokenizer args>”的字符串来完成，其中<tokenizer name>是要使用的分词器的名称，<tokenizer args>是要传递给分词器实现的可选的以空格分隔的限定符列表。分词器规范可以放置在列列表的任何位置，但每个CREATE
    VIRTUAL TABLE语句只允许最多一个分词器声明。有关使用（以及必要时实现）分词器的详细描述，请参见下文[fts3.html#tokenizer](fts3.html#tokenizer)。
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'FTS tables may be dropped from the database using an ordinary [DROP TABLE](lang_droptable.html)
    statement. For example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: FTS表可以使用普通的[DROP TABLE](lang_droptable.html)语句从数据库中删除。例如：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 1.3\. Populating FTS Tables
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3\. 填充FTS表
- en: FTS tables are populated using [INSERT](lang_insert.html), [UPDATE](lang_update.html)
    and [DELETE](lang_delete.html) statements in the same way as ordinary SQLite tables
    are.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: FTS表可以使用与普通SQLite表相同的方式使用[INSERT](lang_insert.html)、[UPDATE](lang_update.html)和[DELETE](lang_delete.html)语句进行填充。
- en: As well as the columns named by the user (or the "content" column if no module
    arguments were specified as part of the [CREATE VIRTUAL TABLE](lang_createvtab.html)
    statement), each FTS table has a "rowid" column. The rowid of an FTS table behaves
    in the same way as the rowid column of an ordinary SQLite table, except that the
    values stored in the rowid column of an FTS table remain unchanged if the database
    is rebuilt using the [VACUUM](lang_vacuum.html) command. For FTS tables, "docid"
    is allowed as an alias along with the usual "rowid", "oid" and "_oid_" identifiers.
    Attempting to insert or update a row with a docid value that already exists in
    the table is an error, just as it would be with an ordinary SQLite table.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用户命名的列（或者如果CREATE VIRTUAL TABLE语句中未指定模块参数作为一部分，则为“content”列），每个FTS表还有一个“rowid”列。FTS表的rowid的行为与普通SQLite表的rowid列相同，不同之处在于，在使用VACUUM命令重建数据库时，FTS表的rowid列中存储的值保持不变。对于FTS表，除了通常的“rowid”、“oid”和“_oid_”标识符外，“docid”也被允许作为别名。尝试插入或更新表中已存在的docid值将被视为错误，就像在普通的SQLite表中一样。
- en: There is one other subtle difference between "docid" and the normal SQLite aliases
    for the rowid column. Normally, if an INSERT or UPDATE statement assigns discrete
    values to two or more aliases of the rowid column, SQLite writes the rightmost
    of such values specified in the INSERT or UPDATE statement to the database. However,
    assigning a non-NULL value to both the "docid" and one or more of the SQLite rowid
    aliases when inserting or updating an FTS table is considered an error. See below
    for an example.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '"docid"和普通的SQLite行ID列的别名之间还有一个细微的区别。通常情况下，如果INSERT或UPDATE语句将离散值分配给两个或多个行ID列的别名，SQLite会将指定在INSERT或UPDATE语句中的最右边的这些值写入数据库。然而，在插入或更新FTS表时，如果同时给"docid"和一个或多个SQLite行ID列的别名分配非NULL值，则会被视为错误。请参见下文的示例。'
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To support full-text queries, FTS maintains an inverted index that maps from
    each unique term or word that appears in the dataset to the locations in which
    it appears within the table contents. For the curious, a complete description
    of the [data structure](fts3.html#data_structures) used to store this index within
    the database file appears below. A feature of this data structure is that at any
    time the database may contain not one index b-tree, but several different b-trees
    that are incrementally merged as rows are inserted, updated and deleted. This
    technique improves performance when writing to an FTS table, but causes some overhead
    for full-text queries that use the index. Evaluating the special ["optimize" command](fts3.html#*fts4optcmd),
    an SQL statement of the form "INSERT INTO <fts-table>(<fts-table>) VALUES('optimize')",
    causes FTS to merge all existing index b-trees into a single large b-tree containing
    the entire index. This can be an expensive operation, but may speed up future
    queries.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持全文查询，FTS维护一个倒排索引，将数据集中每个唯一术语或单词映射到其出现在表内容中的位置。对于好奇的人，数据库文件中用于存储该索引的[数据结构](fts3.html#data_structures)的完整描述如下。该数据结构的一个特点是，数据库可能在任何时候包含不止一个索引B树，而是几个增量合并的B树，随着行的插入、更新和删除而增加。这种技术在写入FTS表时提高了性能，但对使用索引的全文查询造成了一些开销。评估特殊的["optimize"命令](fts3.html#*fts4optcmd)，一个形如"INSERT
    INTO <fts-table>(<fts-table>) VALUES('optimize')"的SQL语句，使FTS将所有现有的索引B树合并为一个包含整个索引的单个大B树。这可能是一个昂贵的操作，但可以加快未来的查询速度。
- en: 'For example, to optimize the full-text index for an FTS table named "docs":'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要优化名为"docs"的FTS表的全文索引：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The statement above may appear syntactically incorrect to some. Refer to the
    section describing the [simple fts queries](fts3.html#simple_fts_queries) for
    an explanation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语句可能在语法上对某些人来说看起来不正确。请参阅描述[简单fts查询](fts3.html#simple_fts_queries)的部分以获取解释。
- en: There is another, deprecated, method for invoking the optimize operation using
    a SELECT statement. New code should use statements similar to the INSERT above
    to optimize FTS structures.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SELECT语句调用优化操作的另一种已废弃方法。新代码应该使用类似上面的INSERT语句来优化FTS结构。
- en: 1.4\. Simple FTS Queries
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4\. 简单的FTS查询
- en: As for all other SQLite tables, virtual or otherwise, data is retrieved from
    FTS tables using a [SELECT](lang_select.html) statement.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有其他SQLite表，无论是虚拟的还是其他类型的表，都可以使用[SELECT](lang_select.html)语句从FTS表中检索数据。
- en: 'FTS tables can be queried efficiently using SELECT statements of two different
    forms:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: FTS表可以通过两种不同形式的SELECT语句进行有效查询：
- en: '**Query by rowid**. If the WHERE clause of the SELECT statement contains a
    sub-clause of the form "rowid = ?", where ? is an SQL expression, FTS is able
    to retrieve the requested row directly using the equivalent of an SQLite [INTEGER
    PRIMARY KEY](lang_createtable.html#rowid) index.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按rowid查询**。如果SELECT语句的WHERE子句包含形式为"rowid = ?"的子句，其中？是一个SQL表达式，FTS能够使用类似SQLite的[INTEGER
    PRIMARY KEY](lang_createtable.html#rowid)索引直接检索请求的行。'
- en: '**Full-text query**. If the WHERE clause of the SELECT statement contains a
    sub-clause of the form "<column> MATCH ?", FTS is able to use the built-in full-text
    index to restrict the search to those documents that match the full-text query
    string specified as the right-hand operand of the MATCH clause.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全文查询**。如果SELECT语句的WHERE子句包含形式为"<column> MATCH ?"的子句，FTS能够使用内置的全文索引来限制搜索，以匹配作为MATCH子句右操作数指定的全文查询字符串的文档。'
- en: If neither of these two query strategies can be used, all queries on FTS tables
    are implemented using a linear scan of the entire table. If the table contains
    large amounts of data, this may be an impractical approach (the first example
    on this page shows that a linear scan of 1.5 GB of data takes around 30 seconds
    using a modern PC).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这两种查询策略都不能使用，则对FTS表的所有查询都使用整个表的线性扫描实现。如果表中包含大量数据，这可能是一种不实际的方法（本页第一个示例显示，使用现代PC对1.5GB数据进行线性扫描大约需要30秒）。
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In all of the full-text queries above, the right-hand operand of the MATCH operator
    is a string consisting of a single term. In this case, the MATCH expression evaluates
    to true for all documents that contain one or more instances of the specified
    word ("sqlite", "search" or "database", depending on which example you look at).
    Specifying a single term as the right-hand operand of the MATCH operator results
    in the simplest and most common type of full-text query possible. However more
    complicated queries are possible, including phrase searches, term-prefix searches
    and searches for documents containing combinations of terms occurring within a
    defined proximity of each other. The various ways in which the full-text index
    may be queried are [described below](fts3.html#full_text_index_queries).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述所有全文查询中，MATCH运算符的右操作数是由单个术语组成的字符串。在这种情况下，MATCH表达式对包含指定词汇（“sqlite”、“search”或“database”，具体取决于查看的示例）的所有文档求值为true。将单个术语指定为MATCH运算符的右操作数导致了可能的最简单和最常见的全文查询类型。然而，可能存在更复杂的查询，包括短语搜索、术语前缀搜索以及搜索包含在定义的接近性内部的术语组合的文档。可以通过[以下描述](fts3.html#full_text_index_queries)了解全文索引可查询的各种方式。
- en: Normally, full-text queries are case-insensitive. However, this is dependent
    on the specific [tokenizer](fts3.html#tokenizer) used by the FTS table being queried.
    Refer to the section on [tokenizers](fts3.html#tokenizer) for details.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，全文查询是不区分大小写的。然而，这取决于查询的FTS表所使用的具体[标记器](fts3.html#tokenizer)。有关详细信息，请参阅[标记器](fts3.html#tokenizer)部分。
- en: 'The paragraph above notes that a MATCH operator with a simple term as the right-hand
    operand evaluates to true for all documents that contain the specified term. In
    this context, the "document" may refer to either the data stored in a single column
    of a row of an FTS table, or to the contents of all columns in a single row, depending
    on the identifier used as the left-hand operand to the MATCH operator. If the
    identifier specified as the left-hand operand of the MATCH operator is an FTS
    table column name, then the document that the search term must be contained in
    is the value stored in the specified column. However, if the identifier is the
    name of the FTS *table* itself, then the MATCH operator evaluates to true for
    each row of the FTS table for which any column contains the search term. The following
    example demonstrates this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的段落指出，带有简单术语作为右操作数的MATCH运算符对包含指定术语的所有文档求值为true。在此上下文中，“文档”可以指代FTS表行的单列中存储的数据，或者指代单行中所有列的内容，具体取决于作为MATCH运算符左操作数使用的标识符。如果作为MATCH运算符左操作数指定的标识符是FTS表列名，则搜索术语必须包含在指定列中存储的值中的文档。然而，如果标识符是FTS
    *表* 自身的名称，则MATCH运算符对FTS表的每一行求值为true，只要任何列包含搜索术语即可。以下示例演示了这一点：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: At first glance, the final two full-text queries in the example above seem to
    be syntactically incorrect, as there is a table name ("mail") used as an SQL expression.
    The reason this is acceptable is that each FTS table actually has a [HIDDEN](c3ref/declare_vtab.html)
    column with the same name as the table itself (in this case, "mail"). The value
    stored in this column is not meaningful to the application, but can be used as
    the left-hand operand to a MATCH operator. This special column may also be passed
    as an argument to the [FTS auxiliary functions](fts3.html#snippet).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，上面示例中的最后两个全文查询似乎在语法上不正确，因为作为SQL表达式使用了表名（“mail”）。之所以可以接受这种情况，是因为每个FTS表实际上都有一个与表本身相同名称的[HIDDEN](c3ref/declare_vtab.html)列（在本例中为“mail”）。存储在此列中的值对应用程序没有意义，但可以用作MATCH运算符的左操作数。这个特殊列也可以作为[FTS辅助函数](fts3.html#snippet)的参数传递。
- en: The following example illustrates the above. The expressions "docs", "docs.docs"
    and "main.docs.docs" all refer to column "docs". However, the expression "main.docs"
    does not refer to any column. It could be used to refer to a table, but a table
    name is not allowed in the context in which it is used below.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了上述内容。表达式“docs”、“docs.docs”和“main.docs.docs”都指向列“docs”。然而，“main.docs”表达式并不指向任何列。它可能用于引用表，但是在下文中使用时，上下文不允许使用表名。
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 1.5\. Summary
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.5\. 总结
- en: 'From the users point of view, FTS tables are similar to ordinary SQLite tables
    in many ways. Data may be added to, modified within and removed from FTS tables
    using the INSERT, UPDATE and DELETE commands just as it may be with ordinary tables.
    Similarly, the SELECT command may be used to query data. The following list summarizes
    the differences between FTS and ordinary tables:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户的角度来看，FTS 表在许多方面与普通的 SQLite 表类似。数据可以像操作普通表一样使用 INSERT、UPDATE 和 DELETE 命令添加、修改和删除
    FTS 表中的数据。同样地，SELECT 命令可以用于查询数据。以下列表总结了 FTS 表与普通表之间的区别：
- en: As with all virtual table types, it is not possible to create indices or triggers
    attached to FTS tables. Nor is it possible to use the ALTER TABLE command to add
    extra columns to FTS tables (although it is possible to use ALTER TABLE to rename
    an FTS table).
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与所有虚拟表类型一样，不可能为 FTS 表创建索引或触发器。也不可能使用 ALTER TABLE 命令向 FTS 表添加额外的列（尽管可以使用 ALTER
    TABLE 命令来重命名 FTS 表）。
- en: Data-types specified as part of the "CREATE VIRTUAL TABLE" statement used to
    create an FTS table are ignored completely. Instead of the normal rules for applying
    type [affinity](datatype3.html#affinity) to inserted values, all values inserted
    into FTS table columns (except the special rowid column) are converted to type
    TEXT before being stored.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '"CREATE VIRTUAL TABLE" 语句中指定的数据类型将完全被忽略。与插入值应用类型 [亲和性](datatype3.html#affinity)
    的常规规则不同，插入到 FTS 表列（除了特殊的 rowid 列外）的所有值在存储之前都会转换为 TEXT 类型。'
- en: FTS tables permit the special alias "docid" to be used to refer to the rowid
    column supported by all [virtual tables](vtab.html).
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FTS 表允许使用特殊别名 "docid" 来引用所有 [虚拟表](vtab.html) 支持的 rowid 列。
- en: The [FTS MATCH](fts3.html#full_text_index_queries) operator is supported for
    queries based on the built-in full-text index.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[FTS MATCH](fts3.html#full_text_index_queries) 运算符支持基于内置全文索引的查询。'
- en: The [FTS auxiliary functions](fts3.html#snippet), [snippet()](fts3.html#snippet),
    [offsets()](fts3.html#offsets), and [matchinfo()](fts3.html#matchinfo) are available
    to support full-text queries.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[FTS 辅助函数](fts3.html#snippet)，[snippet()](fts3.html#snippet)，[offsets()](fts3.html#offsets)
    和 [matchinfo()](fts3.html#matchinfo) 可用于支持全文查询。'
- en: Every FTS table has a [hidden column](vtab.html#hiddencol) with the same name
    as the table itself. The value contained in each row for the hidden column is
    a blob that is only useful as the left operand of a [MATCH](fts3.html#full_text_index_queries)
    operator, or as the left-most argument to one of the [FTS auxiliary functions](fts3.html#snippet).
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个 FTS 表都有一个与表名相同的 [隐藏列](vtab.html#hiddencol)。每行中隐藏列包含的值是一个 blob，只能作为 [MATCH](fts3.html#full_text_index_queries)
    运算符的左操作数，或作为 [FTS 辅助函数](fts3.html#snippet) 的最左参数使用。
- en: 2\. Compiling and Enabling FTS3 and FTS4
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2\. 编译和启用 FTS3 和 FTS4
- en: 'Although FTS3 and FTS4 are included with the SQLite core source code, they
    are not enabled by default. To build SQLite with FTS functionality enabled, define
    the preprocessor macro [SQLITE_ENABLE_FTS3](compile.html#enable_fts3) when compiling.
    New applications should also define the [SQLITE_ENABLE_FTS3_PARENTHESIS](compile.html#enable_fts3_parenthesis)
    macro to enable the [enhanced query syntax](fts3.html#_set_operations_using_the_enhanced_query_syntax)
    (see below). Usually, this is done by adding the following two switches to the
    compiler command line:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 FTS3 和 FTS4 包含在 SQLite 核心源代码中，但它们默认未启用。要在编译时启用带 FTS 功能的 SQLite，需在编译时定义预处理宏
    [SQLITE_ENABLE_FTS3](compile.html#enable_fts3)。新应用程序还应定义 [SQLITE_ENABLE_FTS3_PARENTHESIS](compile.html#enable_fts3_parenthesis)
    宏以启用 [增强的查询语法](fts3.html#_set_operations_using_the_enhanced_query_syntax)（见下文）。通常情况下，可以通过在编译器命令行中添加以下两个开关来完成这一设置：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that enabling FTS3 also makes FTS4 available. There is not a separate SQLITE_ENABLE_FTS4
    compile-time option. A build of SQLite either supports both FTS3 and FTS4 or it
    supports neither.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，启用 FTS3 也会使 FTS4 可用。没有单独的 SQLITE_ENABLE_FTS4 编译选项。SQLite 的构建要么同时支持 FTS3 和
    FTS4，要么两者都不支持。
- en: 'If using the amalgamation autoconf based build system, setting the CPPFLAGS
    environment variable while running the ''configure'' script is an easy way to
    set these macros. For example, the following command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用自动配置的混合编译系统，可以在运行 'configure' 脚本时设置 CPPFLAGS 环境变量是设置这些宏的简便方法。例如，以下命令：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: where *<configure options>* are those options normally passed to the configure
    script, if any.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *<configure options>* 是通常传递给配置脚本的选项（如果有的话）。
- en: Because FTS3 and FTS4 are virtual tables, The [SQLITE_ENABLE_FTS3](compile.html#enable_fts3)
    compile-time option is incompatible with the [SQLITE_OMIT_VIRTUALTABLE](compile.html#omit_virtualtable)
    option.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 FTS3 和 FTS4 是虚拟表，编译时选项 [SQLITE_ENABLE_FTS3](compile.html#enable_fts3) 与 [SQLITE_OMIT_VIRTUALTABLE](compile.html#omit_virtualtable)
    不兼容。
- en: 'If a build of SQLite does not include the FTS modules, then any attempt to
    prepare an SQL statement to create an FTS3 or FTS4 table or to drop or access
    an existing FTS table in any way will fail. The error message returned will be
    similar to "no such module: ftsN" (where N is either 3 or 4).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 SQLite 的编译中不包括 FTS 模块，则任何尝试准备 SQL 语句以创建 FTS3 或 FTS4 表格，或以任何方式删除或访问现有 FTS
    表格的操作都将失败。返回的错误消息将类似于 "no such module: ftsN"（其中 N 是 3 或 4）。'
- en: If the C version of the [ICU library](https://icu.unicode.org) is available,
    then FTS may also be compiled with the SQLITE_ENABLE_ICU pre-processor macro defined.
    Compiling with this macro enables an FTS [tokenizer](fts3.html#tokenizer) that
    uses the ICU library to split a document into terms (words) using the conventions
    for a specified language and locale.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可用 C 版本的 [ICU 库](https://icu.unicode.org)，则 FTS 也可以使用 SQLITE_ENABLE_ICU 预处理宏定义编译。使用此宏编译时启用
    FTS [分词器](fts3.html#tokenizer)，该分词器使用 ICU 库按照指定语言和区域设置的约定将文档分割为术语（单词）。
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 3\. Full-text Index Queries
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3\. 全文索引查询
- en: The most useful thing about FTS tables is the queries that may be performed
    using the built-in full-text index. Full-text queries are performed by specifying
    a clause of the form "<column> MATCH <full-text query expression>" as part of
    the WHERE clause of a SELECT statement that reads data from an FTS table. [Simple
    FTS queries](fts3.html#simple_fts_queries) that return all documents that contain
    a given term are described above. In that discussion the right-hand operand of
    the MATCH operator was assumed to be a string consisting of a single term. This
    section describes the more complex query types supported by FTS tables, and how
    they may be utilized by specifying a more complex query expression as the right-hand
    operand of a MATCH operator.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: FTS 表格最有用的地方在于可以使用内置的全文索引进行查询。全文查询通过在 SELECT 语句的 WHERE 子句中指定形如 "<column> MATCH
    <full-text query expression>" 的子句来执行，该子句读取来自 FTS 表格的数据。在上述讨论中，假定 MATCH 操作符的右操作数是由单个术语组成的字符串。本节描述了由
    FTS 表格支持的更复杂的查询类型，并且通过指定更复杂的查询表达式作为 MATCH 操作符的右操作数来利用这些查询。
- en: 'FTS tables support three basic query types:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: FTS 表格支持三种基本的查询类型：
- en: '**Token or token prefix queries**. An FTS table may be queried for all documents
    that contain a specified term (the [simple case](fts3.html#simple_fts_queries)
    described above), or for all documents that contain a term with a specified prefix.
    As we have seen, the query expression for a specific term is simply the term itself.
    The query expression used to search for a term prefix is the prefix itself with
    a ''*'' character appended to it. For example:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标记或标记前缀查询**。可以查询 FTS 表格以获取包含指定术语的所有文档（如上所述的[简单情况](fts3.html#simple_fts_queries)），或者包含具有指定前缀的术语的所有文档。正如我们所见，用于特定术语的查询表达式就是术语本身。用于搜索术语前缀的查询表达式是将前缀本身与
    ''*'' 字符附加到术语后面。例如：'
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Normally, a token or token prefix query is matched against the FTS table column
    specified as the left-hand side of the MATCH operator. Or, if the special column
    with the same name as the FTS table itself is specified, against all columns.
    This may be overridden by specifying a column-name followed by a ":" character
    before a basic term query. There may be space between the ":" and the term to
    query for, but not between the column-name and the ":" character. For example:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，标记或标记前缀查询与作为 MATCH 操作符左操作数指定的 FTS 表格列匹配。或者，如果指定了与 FTS 表格本身同名的特殊列，则匹配所有列。这可以通过在基本术语查询之前指定列名后跟
    ":" 字符来覆盖。在 ":" 字符和查询术语之间可能有空格，但列名和 ":" 字符之间不允许有空格。例如：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If the FTS table is an FTS4 table (not FTS3), a token may also be prefixed
    with a "^" character. In this case, in order to match the token must appear as
    the very first token in any column of the matching row. Examples:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 FTS 表格是 FTS4 表格（而不是 FTS3），则标记还可以以 "^" 字符为前缀。在这种情况下，为了匹配，标记必须出现在匹配行的任何列的第一个标记位置。例如：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Phrase queries**. A phrase query is a query that retrieves all documents
    that contain a nominated set of terms or term prefixes in a specified order with
    no intervening tokens. Phrase queries are specified by enclosing a space separated
    sequence of terms or term prefixes in double quotes ("). For example:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**短语查询**。短语查询是一种检索所有包含指定顺序的一组术语或术语前缀的文档的查询，中间没有其他标记。短语查询通过在双引号（"）中包围一个空格分隔的术语或术语前缀序列来指定。例如：'
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**NEAR queries**. A NEAR query is a query that returns documents that contain
    a two or more nominated terms or phrases within a specified proximity of each
    other (by default with 10 or less intervening terms). A NEAR query is specified
    by putting the keyword "NEAR" between two phrase, token or token prefix queries.
    To specify a proximity other than the default, an operator of the form "NEAR/*<N>*"
    may be used, where *<N>* is the maximum number of intervening terms allowed. For
    example:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NEAR查询**。NEAR查询是一种查询，返回包含在指定接近程度内（默认情况下为10个或更少的中间术语）的两个或多个指定术语或短语的文档。NEAR查询通过在两个短语、令牌或令牌前缀查询之间放置关键字“NEAR”来指定。要指定除默认值外的接近程度，可以使用形式为“NEAR/*<N>*”的操作符，其中*<N>*是允许的最大中间术语数。例如：'
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'More than one NEAR operator may appear in a single query. In this case each
    pair of terms or phrases separated by a NEAR operator must appear within the specified
    proximity of each other in the document. Using the same table and data as in the
    block of examples above:'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个查询中可以出现多个NEAR运算符。在这种情况下，每对通过NEAR运算符分隔的术语或短语必须在文档中以指定的接近程度出现。使用与上述示例块中相同的表格和数据：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Phrase and NEAR queries may not span multiple columns within a row.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 短语和NEAR查询不能跨越行内的多个列。
- en: 'The three basic query types described above may be used to query the full-text
    index for the set of documents that match the specified criteria. Using the FTS
    query expression language it is possible to perform various set operations on
    the results of basic queries. There are currently three supported operations:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 上述三种基本查询类型可用于查询符合指定条件的全文索引文档集。使用FTS查询表达语言可以对基本查询结果执行各种集合操作。当前支持三种操作：
- en: The AND operator determines the **intersection** of two sets of documents.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AND运算符确定两组文档的**交集**。
- en: The OR operator calculates the **union** of two sets of documents.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OR运算符计算两组文档的**并集**。
- en: The NOT operator (or, if using the standard syntax, a unary "-" operator) may
    be used to compute the **relative complement** of one set of documents with respect
    to another.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NOT运算符（或者如果使用标准语法，则为一元“-”运算符）可用于计算一个文档集相对于另一个文档集的**相对补集**。
- en: The FTS modules may be compiled to use one of two slightly different versions
    of the full-text query syntax, the "standard" query syntax and the "enhanced"
    query syntax. The basic term, term-prefix, phrase and NEAR queries described above
    are the same in both versions of the syntax. The way in which set operations are
    specified is slightly different. The following two sub-sections describe the part
    of the two query syntaxes that pertains to set operations. Refer to the description
    of how to [compile fts](fts3.html#compiling_and_enabling_fts3_and_fts4) for compilation
    notes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: FTS模块可以编译为使用两个略有不同的全文查询语法版本之一，即“标准”查询语法和“增强”查询语法。上述的基本术语、术语前缀、短语和NEAR查询在这两个语法版本中都是相同的。指定集合操作的方式略有不同。下面的两个子部分描述了涉及集合操作的这两个查询语法的部分。有关如何[编译fts](fts3.html#compiling_and_enabling_fts3_and_fts4)的编译说明，请参阅。
- en: 3.1\. Set Operations Using The Enhanced Query Syntax
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1\. 使用增强查询语法进行集合操作
- en: The enhanced query syntax supports the AND, OR and NOT binary set operators.
    Each of the two operands to an operator may be a basic FTS query, or the result
    of another AND, OR or NOT set operation. Operators must be entered using capital
    letters. Otherwise, they are interpreted as basic term queries instead of set
    operators.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 增强查询语法支持AND、OR和NOT二进制集运算符。每个运算符的两个操作数可以是基本的FTS查询，或另一个AND、OR或NOT集合操作的结果。操作符必须使用大写字母输入，否则它们将被解释为基本的术语查询，而不是集合操作。
- en: The AND operator may be implicitly specified. If two basic queries appear with
    no operator separating them in an FTS query string, the results are the same as
    if the two basic queries were separated by an AND operator. For example, the query
    expression "implicit operator" is a more succinct version of "implicit AND operator".
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 可以隐式指定AND运算符。如果在FTS查询字符串中两个基本查询出现且没有操作符将它们分隔开，则结果与将这两个基本查询分隔开的AND运算符的结果相同。例如，查询表达式“implicit
    operator”是“implicit AND operator”的更简洁版本。
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The examples above all use basic full-text term queries as both operands of
    the set operations demonstrated. Phrase and NEAR queries may also be used, as
    may the results of other set operations. When more than one set operation is present
    in an FTS query, the precedence of operators is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例都使用基本全文项查询作为所演示的集合操作的两个操作数。也可以使用短语和NEAR查询，以及其他集合操作的结果。在FTS查询中存在多个集合操作时，运算符的优先级如下：
- en: '| Operator | Enhanced Query Syntax Precedence |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 增强查询语法优先级 |'
- en: '| NOT | Highest precedence (tightest grouping). |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| NOT | 最高优先级（分组最紧密）。 |'
- en: '| AND |  |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| AND |  |'
- en: '| OR | Lowest precedence (loosest grouping). |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| OR | 优先级最低（分组最宽）。 |'
- en: 'When using the enhanced query syntax, parenthesis may be used to override the
    default precedence of the various operators. For example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用增强查询语法时，可以使用括号来覆盖各种运算符的默认优先级。例如：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 3.2\. Set Operations Using The Standard Query Syntax
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2\. 使用标准查询语法进行集合操作
- en: 'FTS query set operations using the standard query syntax are similar, but not
    identical, to set operations with the enhanced query syntax. There are four differences,
    as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准查询语法的FTS查询集合操作与增强查询语法的集合操作类似但不完全相同，存在四个差异，如下：
- en: Only the implicit version of the AND operator is supported. Specifying the string
    "AND" as part of a standard query syntax query is interpreted as a term query
    for the set of documents containing the term "and".
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅支持AND运算符的隐式版本。将字符串“AND”作为标准查询语法查询的一部分指定时，将解释为包含术语“and”的文档集的术语查询。
- en: Parenthesis are not supported.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不支持括号。
- en: The NOT operator is not supported. Instead of the NOT operator, the standard
    query syntax supports a unary "-" operator that may be applied to basic term and
    term-prefix queries (but not to phrase or NEAR queries). A term or term-prefix
    that has a unary "-" operator attached to it may not appear as an operand to an
    OR operator. An FTS query may not consist entirely of terms or term-prefix queries
    with unary "-" operators attached to them.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不支持NOT运算符。标准查询语法支持一元“-”运算符，可应用于基本项和项前缀查询（但不能应用于短语或NEAR查询）。带有一元“-”运算符的项或项前缀不能作为OR运算符的操作数。FTS查询不能完全由带有一元“-”运算符的项或项前缀查询组成。
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The relative precedence of the set operations is different. In particular,
    using the standard query syntax the "OR" operator has a higher precedence than
    "AND". The precedence of operators when using the standard query syntax is:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集合操作的相对优先级不同。特别是，使用标准查询语法，“OR”运算符的优先级高于“AND”。使用标准查询语法时运算符的优先级为：
- en: '| Operator | Standard Query Syntax Precedence |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 标准查询语法优先级 |'
- en: '| Unary "-" | Highest precedence (tightest grouping). |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 一元“-” | 最高优先级（分组最紧密）。 |'
- en: '| OR |  |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| OR |  |'
- en: '| AND | Lowest precedence (loosest grouping). |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| AND | 优先级最低（分组最宽）。 |'
- en: 'The following example illustrates precedence of operators using the standard
    query syntax:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下示例说明了使用标准查询语法运算符的优先级：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 4\. Auxiliary Functions - Snippet, Offsets and Matchinfo
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4\. 辅助函数 - 片段、偏移和匹配信息
- en: 'The FTS3 and FTS4 modules provide three special SQL scalar functions that may
    be useful to the developers of full-text query systems: "snippet", "offsets" and
    "matchinfo". The purpose of the "snippet" and "offsets" functions is to allow
    the user to identify the location of queried terms in the returned documents.
    The "matchinfo" function provides the user with metrics that may be useful for
    filtering or sorting query results according to relevance.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: FTS3和FTS4模块提供了三个特殊的SQL标量函数，对于开发全文查询系统的开发人员可能会有用：“snippet”、“offsets”和“matchinfo”。
    “snippet”和“offsets”函数的目的是允许用户在返回的文档中标识查询词的位置。“matchinfo”函数提供的指标可能对根据相关性对查询结果进行过滤或排序很有用。
- en: 'The first argument to all three special SQL scalar functions must be the [FTS
    hidden column](fts3.html#hiddencol) of the FTS table that the function is applied
    to. The [FTS hidden column](fts3.html#hiddencol) is an automatically-generated
    column found on all FTS tables that has the same name as the FTS table itself.
    For example, given an FTS table named "mail":'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个特殊的SQL标量函数的第一个参数必须是应用该函数的FTS表的FTS隐藏列。FTS隐藏列是在所有FTS表上找到的自动生成列，其名称与FTS表本身相同。例如，给定名为“mail”的FTS表：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The three auxiliary functions are only useful within a SELECT statement that
    uses the FTS table's full-text index. If used within a SELECT that uses the "query
    by rowid" or "linear scan" strategies, then the snippet and offsets both return
    an empty string, and the matchinfo function returns a blob value zero bytes in
    size.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 三个辅助函数仅在使用FTS表的全文索引的SELECT语句中有用。如果在使用“按行ID查询”或“线性扫描”策略的SELECT语句中使用，则snippet和offsets都返回空字符串，并且matchinfo函数返回大小为零字节的blob值。
- en: All three auxiliary functions extract a set of "matchable phrases" from the
    FTS query expression to work with. The set of matchable phrases for a given query
    consists of all phrases (including unquoted tokens and token prefixes) in the
    expression except those that are prefixed with a unary "-" operator (standard
    syntax) or are part of a sub-expression that is used as the right-hand operand
    of a NOT operator.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个辅助函数从FTS查询表达式中提取一组“可匹配短语”以进行处理。给定查询的可匹配短语集包括表达式中的所有短语（包括未引用的标记和标记前缀），但不包括那些带有一元“-”运算符前缀的短语（标准语法）或用作NOT运算符右操作数的子表达式的一部分。
- en: 'With the following provisos, each series of tokens in the FTS table that matches
    one of the matchable phrases in the query expression is known as a "phrase match":'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下条件下，FTS表中与查询表达式中的可匹配短语之一匹配的每个标记系列称为“短语匹配”：
- en: If a matchable phrase is part of a series of phrases connected by NEAR operators
    in the FTS query expression, then each phrase match must be sufficiently close
    to other phrase matches of the relevant types to satisfy the NEAR condition.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果可匹配短语是FTS查询表达式中由NEAR操作符连接的一系列短语的一部分，则每个短语匹配必须足够接近相关类型的其他短语匹配，以满足NEAR条件。
- en: If the matchable phrase in the FTS query is restricted to matching data in a
    specified FTS table column, then only phrase matches that occur within that column
    are considered.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果FTS查询中的可匹配短语仅限于匹配指定FTS表列中的数据，则仅考虑出现在该列中的短语匹配。
- en: 4.1\. The Offsets Function
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1\. offsets函数
- en: 'For a SELECT query that uses the full-text index, the offsets() function returns
    a text value containing a series of space-separated integers. For each term in
    each [phrase match](#matchable) of the current row, there are four integers in
    the returned list. Each set of four integers is interpreted as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用全文索引的SELECT查询，offsets()函数返回一个包含一系列以空格分隔的整数的文本值。对于当前行的每个[短语匹配](#matchable)，返回的列表中有四个整数。每组四个整数的解释如下：
- en: '| Integer | Interpretation |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 整数 | 解释 |'
- en: '| 0 | The column number that the term instance occurs in (0 for the leftmost
    column of the FTS table, 1 for the next leftmost, etc.). |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 项实例出现的列编号（FTS表的最左列为0，其次为1，依此类推）。 |'
- en: '| 1 | The term number of the matching term within the full-text query expression.
    Terms within a query expression are numbered starting from 0 in the order that
    they occur. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 完全文本查询表达式中匹配项的项编号。查询表达式中的项从0开始编号，按其出现顺序排列。 |'
- en: '| 2 | The byte offset of the matching term within the column. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 匹配项在列内的字节偏移量。 |'
- en: '| 3 | The size of the matching term in bytes. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 匹配项的字节大小。 |'
- en: The following block contains examples that use the offsets function.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的块包含使用offsets函数的示例。
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 4.2\. The Snippet Function
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2\. 片段函数
- en: 'The snippet function is used to create formatted fragments of document text
    for display as part of a full-text query results report. The snippet function
    may be passed between one and six arguments, as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: snippet函数用于创建文档文本的格式化片段，以便作为全文查询结果报告的一部分显示。 snippet函数可以传递一个到六个参数，如下：
- en: '| Argument | Default Value | Description |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 默认值 | 描述 |'
- en: '| 0 | N/A | The first argument to the snippet function must always be the [FTS
    hidden column](fts3.html#hiddencol) of the FTS table being queried and from which
    the snippet is to be taken. The [FTS hidden column](fts3.html#hiddencol) is an
    automatically generated column with the same name as the FTS table itself. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 0 | N/A | 代码片段函数的第一个参数必须始终是正在查询的FTS表的[FTS隐藏列](fts3.html#hiddencol)，并从中提取片段。[FTS隐藏列](fts3.html#hiddencol)是一个与FTS表本身同名的自动生成列。
    |'
- en: '| 1 | "<b>" | The "start match" text. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 1 | "<b>" | "开始匹配"文本。 |'
- en: '| 2 | "</b>" | The "end match" text. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 2 | "</b>" | "结束匹配"文本。 |'
- en: '| 3 | "<b>...</b>" | The "ellipses" text. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 3 | "<b>...</b>" | "省略"文本。 |'
- en: '| 4 | -1 | The FTS table column number to extract the returned fragments of
    text from. Columns are numbered from left to right starting with zero. A negative
    value indicates that the text may be extracted from any column. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 4 | -1 | 从中提取返回文本片段的FTS表列号。列从左到右编号，从零开始。负值表示文本可以从任何列提取。 |'
- en: '| 5 | -15 | The absolute value of this integer argument is used as the (approximate)
    number of tokens to include in the returned text value. The maximum allowable
    absolute value is 64\. The value of this argument is referred to as *N* in the
    discussion below. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 5 | -15 | 这个整数参数的绝对值用作返回的文本值中包含的（近似）标记数。允许的最大绝对值为64。该参数的值在下文中称为*N*。 |'
- en: The snippet function first attempts to find a fragment of text consisting of
    *|N|* tokens within the current row that contains at least one phrase match for
    each matchable phrase matched somewhere in the current row, where *|N|* is the
    absolute value of the sixth argument passed to the snippet function. If the text
    stored in a single column contains less than *|N|* tokens, then the entire column
    value is considered. Text fragments may not span multiple columns.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段函数首先尝试在当前行内找到由*|N|*标记组成的文本片段，该片段至少包含当前行某处匹配的每个可匹配短语。其中*|N|*是传递给片段函数的第六个参数的绝对值。如果单列存储的文本少于*|N|*个标记，则整个列值被视为文本片段。文本片段不能跨越多列。
- en: 'If such a text fragment can be found, it is returned with the following modifications:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到这样的文本片段，则返回它并进行以下修改：
- en: If the text fragment does not begin at the start of a column value, the "ellipses"
    text is prepended to it.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文本片段不是从列值的开头开始的，则在其前面加上"省略"文本。
- en: If the text fragment does not finish at the end of a column value, the "ellipses"
    text is appended to it.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文本片段不是以列值的末尾结束的，则在其后追加"省略"文本。
- en: For each token in the text fragment that is part of a phrase match, the "start
    match" text is inserted into the fragment before the token, and the "end match"
    text is inserted immediately after it.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于文本片段中的每个属于短语匹配的标记，在该标记之前插入"开始匹配"文本，并在其后立即插入"结束匹配"文本。
- en: If more than one such fragment can be found, then fragments that contain a larger
    number of "extra" phrase matches are favored. The start of the selected text fragment
    may be moved a few tokens forward or backward to attempt to concentrate the phrase
    matches toward the center of the fragment.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以找到多个这样的片段，则优先选择包含较多“额外”短语匹配的片段。所选文本片段的开始可能向前或向后移动几个标记，以集中短语匹配于片段中心。
- en: Assuming *N* is a positive value, if no fragments can be found that contain
    a phrase match corresponding to each matchable phrase, the snippet function attempts
    to find two fragments of approximately *N*/2 tokens that between them contain
    at least one phrase match for each matchable phrase matched by the current row.
    If this fails, attempts are made to find three fragments of *N*/3 tokens each
    and finally four *N*/4 token fragments. If a set of four fragments cannot be found
    that encompasses the required phrase matches, the four fragments of *N*/4 tokens
    that provide the best coverage are selected.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 假设*N*为正值，则如果找不到包含每个可匹配短语的短语匹配的片段，则代码片段函数尝试找到大约*N*/2个标记的两个片段，这两个片段之间包含当前行匹配的每个可匹配短语的至少一个短语匹配。如果失败，则尝试找到三个*N*/3标记的片段，最后是四个*N*/4标记的片段。如果找不到涵盖所需短语匹配的四个片段，则选择提供最佳覆盖率的四个*N*/4标记片段。
- en: If *N* is a negative value, and no single fragment can be found containing the
    required phrase matches, the snippet function searches for two fragments of *|N|*
    tokens each, then three, then four. In other words, if the specified value of
    *N* is negative, the sizes of the fragments is not decreased if more than one
    fragment is required to provide the desired phrase match coverage.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 * N * 是负值，并且找不到包含所需短语匹配的单个片段，则 snippet 函数将搜索每个 * | N | * 个标记的两个片段，然后三个片段，然后四个片段。换句话说，如果指定的
    * N * 值为负，则如果需要多个片段来提供所需的短语匹配覆盖，则不会减少片段的大小。
- en: After the *M* fragments have been located, where *M* is between two and four
    as described in the paragraphs above, they are joined together in sorted order
    with the "ellipses" text separating them. The three modifications enumerated earlier
    are performed on the text before it is returned.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在已定位* M *片段后，其中 * M * 介于上述段落中描述的两到四之间，它们按排序顺序连接在一起，并用“省略号”文本分隔。在返回文本之前，执行了前面列举的三个修改。
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 4.3\. The Matchinfo Function
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3\. matchinfo 函数
- en: The matchinfo function returns a blob value. If it is used within a query that
    does not use the full-text index (a "query by rowid" or "linear scan"), then the
    blob is zero bytes in size. Otherwise, the blob consists of zero or more 32-bit
    unsigned integers in machine byte-order. The exact number of integers in the returned
    array depends on both the query and the value of the second argument (if any)
    passed to the matchinfo function.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: matchinfo 函数返回一个 blob 值。如果它在不使用全文索引的查询中使用（即“按行号查询”或“线性扫描”），则 blob 的大小为零字节。否则，blob
    包含机器字节顺序中的零个或多个 32 位无符号整数。返回数组中确切的整数数量取决于查询和传递给 matchinfo 函数的第二个参数（如果有的话）的值。
- en: The matchinfo function is called with either one or two arguments. As for all
    auxiliary functions, the first argument must be the special [FTS hidden column](fts3.html#hiddencol).
    The second argument, if it is specified, must be a text value comprised only of
    the characters 'p', 'c', 'n', 'a', 'l', 's', 'x', 'y' and 'b'. If no second argument
    is explicitly supplied, it defaults to "pcx". The second argument is referred
    to as the "format string" below.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: matchinfo 函数被调用时可以有一个或两个参数。与所有辅助函数一样，第一个参数必须是特殊的[FTS 隐藏列](fts3.html#hiddencol)。如果指定了第二个参数，则必须是仅包含字符
    'p'、'c'、'n'、'a'、'l'、's'、'x'、'y' 和 'b' 的文本值。如果没有显式提供第二个参数，则默认为 "pcx"。以下将第二个参数称为“格式字符串”。
- en: Characters in the matchinfo format string are processed from left to right.
    Each character in the format string causes one or more 32-bit unsigned integer
    values to be added to the returned array. The "values" column in the following
    table contains the number of integer values appended to the output buffer for
    each supported format string character. In the formula given, *cols* is the number
    of columns in the FTS table, and *phrases* is the number of [matchable phrases](#matchable)
    in the query.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: matchinfo 格式字符串中的字符是从左到右处理的。格式字符串中的每个字符会导致一个或多个 32 位无符号整数值被添加到返回的数组中。以下表中的“值”列包含了每个支持的格式字符串字符附加到输出缓冲区的整数值的数量。在给定的公式中，*cols*
    是 FTS 表中的列数，而 *phrases* 是查询中的[可匹配短语](#matchable)的数量。
- en: '| Character | Values | Description |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 字符 | 值 | 描述 |'
- en: '| p | 1 | The number of matchable phrases in the query. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| p | 1 | 查询中可匹配短语的数量。 |'
- en: '| c | 1 | The number of user defined columns in the FTS table (i.e. not including
    the docid or the [FTS hidden column](fts3.html#hiddencol)). |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| c | 1 | FTS 表中的用户定义列的数量（即不包括 docid 或[FTS 隐藏列](fts3.html#hiddencol)）。 |'
- en: '| x | 3 * *cols* * *phrases* | For each distinct combination of a phrase and
    table column, the following three values:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '| x | 3 * *cols* * *phrases* | 对于每个短语和表列的不同组合，以下三个值：'
- en: In the current row, the number of times the phrase appears in the column.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在当前行中，短语在列中出现的次数。
- en: The total number of times the phrase appears in the column in all rows in the
    FTS table.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 短语在所有 FTS 表中所有行中出现的总次数。
- en: The total number of rows in the FTS table for which the column contains at least
    one instance of the phrase.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FTS 表中包含至少一个短语实例的行的总数。
- en: 'The first set of three values corresponds to the left-most column of the table
    (column 0) and the left-most matchable phrase in the query (phrase 0). If the
    table has more than one column, the second set of three values in the output array
    correspond to phrase 0 and column 1\. Followed by phrase 0, column 2 and so on
    for all columns of the table. And so on for phrase 1, column 0, then phrase 1,
    column 1 etc. In other words, the data for occurrences of phrase *p* in column
    *c* may be found using the following formula:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组三个值对应表的最左列（列 0）和查询中可匹配的最左短语（短语 0）。如果表有多列，则输出数组中的第二组三个值对应短语 0 和列 1。随后是短语 0，列
    2 等等，适用于表的所有列。同样适用于短语 1，列 0，然后短语 1，列 1 等等。换句话说，可以使用以下公式找到在列 *c* 中发生的短语 *p* 的数据：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| y | *cols* * *phrases* | For each distinct combination of a phrase and table
    column, the number of usable phrase matches that appear in the column. This is
    usually identical to the first value in each set of three returned by the [matchinfo
    ''x'' flag](fts3.html#matchinfo-x). However, the number of hits reported by the
    ''y'' flag is zero for any phrase that is part of a sub-expression that does not
    match the current row. This makes a difference for expressions that contain AND
    operators that are descendants of OR operators. For example, consider the expression:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '| y | *cols* * *phrases* | 对于每个独特的短语和表列的组合，显示在列中出现的可用短语匹配的数量。这通常与由[matchinfo
    ''x'' flag](https://fts3.html#matchinfo-x)返回的三个值中的第一个值相同。然而，对于任何作为不匹配当前行的子表达式一部分的短语，''y''标志报告的命中次数为零。这对于包含OR运算符的后代AND运算符的表达式有影响。例如，考虑以下表达式：'
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'and the document:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 和文档
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The [matchinfo ''x'' flag](fts3.html#matchinfo-x) would report a single hit
    for the phrases "a" and "c". However, the ''y'' directive reports the number of
    hits for "c" as zero, as it is part of a sub-expression that does not match the
    document - (b AND c). For queries that do not contain AND operators descended
    from OR operators, the result values returned by ''y'' are always the same as
    those returned by ''x''.The first value in the array of integer values corresponds
    to the leftmost column of the table (column 0) and the first phrase in the query
    (phrase 0). The values corresponding to other column/phrase combinations may be
    located using the following formula:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[matchinfo ''x'' flag](https://fts3.html#matchinfo-x)报告短语"a"和"c"各自的单次命中。然而，''y''指令报告"c"的命中次数为零，因为它是一个与文档不匹配的子表达式的一部分
    - (b AND c)。对于不包含从OR运算符衍生的AND运算符的查询，''y''返回的结果值始终与''x''返回的结果值相同。整数值数组中的第一个值对应表的最左列（列
    0）和查询的第一个短语（短语 0）。可以使用以下公式找到对应于其他列/短语组合的值：'
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: For queries that use OR expressions, or those that use LIMIT or return many
    rows, the 'y' matchinfo option may be faster than 'x'. |
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用OR表达式的查询或使用LIMIT或返回多行的查询，'y' matchinfo 选项可能比'x'更快。 |
- en: '| b | *((cols+31)/32)* * *phrases* | The matchinfo ''b'' flag provides similar
    information to the [matchinfo ''y'' flag](fts3.html#matchinfo-y), but in a more
    compact form. Instead of the precise number of hits, ''b'' provides a single boolean
    flag for each phrase/column combination. If the phrase is present in the column
    at least once (i.e. if the corresponding integer output of ''y'' would be non-zero),
    the corresponding flag is set. Otherwise cleared.If the table has 32 or fewer
    columns, a single unsigned integer is output for each phrase in the query. The
    least significant bit of the integer is set if the phrase appears at least once
    in column 0\. The second least significant bit is set if the phrase appears once
    or more in column 1\. And so on.If the table has more than 32 columns, an extra
    integer is added to the output of each phrase for each extra 32 columns or part
    thereof. Integers corresponding to the same phrase are clumped together. For example,
    if a table with 45 columns is queried for two phrases, 4 integers are output.
    The first corresponds to phrase 0 and columns 0-31 of the table. The second integer
    contains data for phrase 0 and columns 32-44, and so on.For example, if nCol is
    the number of columns in the table, to determine if phrase p is present in column
    c:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '| b | *((cols+31)/32)* * *phrases* | matchinfo ''b'' 标志提供类似于 [matchinfo ''y''
    标志](fts3.html#matchinfo-y) 的信息，但以更紧凑的形式呈现。与精确的命中次数不同，''b'' 为每个短语/列组合提供单一的布尔标志。如果短语至少出现在列中一次（即
    ''y'' 的相应整数输出为非零），则设置相应的标志。否则清除。如果表格有 32 列或更少，对于查询中的每个短语，将输出一个单一的无符号整数。整数的最低有效位设置为如果短语在列
    0 中至少出现一次。第二个最低有效位设置为如果短语在列 1 中出现一次或更多，依此类推。如果表格有超过 32 列，将为每个超过的 32 列或其一部分在每个短语的输出中添加一个额外的整数。对应于相同短语的整数被分组在一起。例如，如果查询具有
    45 列的表格中的两个短语，将输出 4 个整数。第一个对应于短语 0 和表的列 0-31。第二个整数包含短语 0 和列 32-44 的数据，依此类推。例如，如果
    nCol 是表中的列数，要确定短语 p 是否存在于列 c 中：'
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '|'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| n | 1 | The number of rows in the FTS4 table. This value is only available
    when querying FTS4 tables, not FTS3. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| n | 1 | FTS4 表中的行数。此值仅在查询 FTS4 表时可用，不适用于 FTS3。 |'
- en: '| a | *cols* | For each column, the average number of tokens in the text values
    stored in the column (considering all rows in the FTS4 table). This value is only
    available when querying FTS4 tables, not FTS3. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| a | *cols* | 对于每一列，存储在列中的文本值的平均标记数（考虑 FTS4 表中的所有行）。此值仅在查询 FTS4 表时可用，不适用于
    FTS3。 |'
- en: '| l | *cols* | For each column, the length of the value stored in the current
    row of the FTS4 table, in tokens. This value is only available when querying FTS4
    tables, not FTS3\. And only if the "matchinfo=fts3" directive was not specified
    as part of the "CREATE VIRTUAL TABLE" statement used to create the FTS4 table.
    |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| l | *cols* | 对于每一列，当前行中存储的 FTS4 表的值的长度（以标记计算）。此值仅在查询 FTS4 表时可用，不适用于 FTS3。并且仅当未在用于创建
    FTS4 表的 "CREATE VIRTUAL TABLE" 语句中指定 "matchinfo=fts3" 指令时。 |'
- en: '| s | *cols* | For each column, the length of the longest subsequence of phrase
    matches that the column value has in common with the query text. For example,
    if a table column contains the text ''a b c d e'' and the query is ''a c "d e"'',
    then the length of the longest common subsequence is 2 (phrase "c" followed by
    phrase "d e"). |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| s | *cols* | 对于每一列，最长子序列的长度是该列值与查询文本共有的短语匹配。例如，如果表列包含文本 ''a b c d e''，查询是
    ''a c "d e"''，则最长公共子序列的长度为2（短语 "c" 后跟短语 "d e"）。 |'
- en: 'For example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The matchinfo function is much faster than either the snippet or offsets functions.
    This is because the implementation of both snippet and offsets is required to
    retrieve the documents being analyzed from disk, whereas all data required by
    matchinfo is available as part of the same portions of the full-text index that
    are required to implement the full-text query itself. This means that of the following
    two queries, the first may be an order of magnitude faster than the second:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: matchinfo 函数比片段或偏移函数快得多。这是因为片段和偏移的实现需要从磁盘检索正在分析的文档，而 matchinfo 所需的所有数据都作为完全文本索引的一部分而可用，这些数据还需要实现全文查询本身。这意味着在以下两个查询中，第一个查询可能比第二个查询快一个数量级：
- en: '[PRE32]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The matchinfo function provides all the information required to calculate probabilistic
    "bag-of-words" relevancy scores such as [Okapi BM25/BM25F](http://en.wikipedia.org/wiki/Okapi_BM25)
    that may be used to order results in a full-text search application. Appendix
    A of this document, "[search application tips](fts3.html#appendix_a)", contains
    an example of using the matchinfo() function efficiently.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: matchinfo函数提供了计算概率“词袋”相关性分数所需的所有信息，例如 [Okapi BM25/BM25F](http://en.wikipedia.org/wiki/Okapi_BM25)，可用于在全文搜索应用程序中排序结果。本文的附录A，“[搜索应用程序提示](fts3.html#appendix_a)”，包含了有效使用matchinfo()函数的示例。
- en: 5\. Fts4aux - Direct Access to the Full-Text Index
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5\. Fts4aux - 直接访问全文索引
- en: As of [version 3.7.6](releaselog/3_7_6.html) (2011-04-12), SQLite includes a
    new virtual table module called "fts4aux", which can be used to inspect the full-text
    index of an existing FTS table directly. Despite its name, fts4aux works just
    as well with FTS3 tables as it does with FTS4 tables. Fts4aux tables are read-only.
    The only way to modify the contents of an fts4aux table is by modifying the contents
    of the associated FTS table. The fts4aux module is automatically included in all
    [builds that include FTS](fts3.html#compiling_and_enabling_fts3_and_fts4).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 [版本 3.7.6](releaselog/3_7_6.html)（2011-04-12），SQLite 包含一个名为 "fts4aux" 的新虚拟表模块，可直接用于检查现有FTS表的全文索引。尽管名称如此，fts4aux
    与 FTS3 表和 FTS4 表一样有效。fts4aux表是只读的。修改fts4aux表内容的唯一方法是修改关联的FTS表的内容。fts4aux模块会自动包含在所有包含FTS的
    [构建版本](fts3.html#compiling_and_enabling_fts3_and_fts4) 中。
- en: 'An fts4aux virtual table is constructed with one or two arguments. When used
    with a single argument, that argument is the unqualified name of the FTS table
    that it will be used to access. To access a table in a different database (for
    example, to create a TEMP fts4aux table that will access an FTS3 table in the
    MAIN database) use the two-argument form and give the name of the target database
    (ex: "main") in the first argument and the name of the FTS3/4 table as the second
    argument. (The two-argument form of fts4aux was added for SQLite [version 3.7.17](releaselog/3_7_17.html)
    (2013-05-20) and will throw an error in prior releases.) For example:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: fts4aux虚拟表可以用一个或两个参数构建。使用单个参数时，该参数是将用于访问的FTS表的未限定名称。要访问不同数据库中的表（例如，创建一个将访问MAIN数据库中的FTS3表的TEMP
    fts4aux表），请使用两参数形式，并在第一个参数中给出目标数据库的名称（例如，“main”），在第二个参数中给出FTS3/4表的名称。（fts4aux的两参数形式添加于SQLite
    [版本 3.7.17](releaselog/3_7_17.html)（2013-05-20），在之前的版本中将引发错误。）例如：
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'For each term present in the FTS table, there are between 2 and N+1 rows in
    the fts4aux table, where N is the number of user-defined columns in the associated
    FTS table. An fts4aux table always has the same four columns, as follows, from
    left to right:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 每个出现在FTS表中的术语，在fts4aux表中都会有2到N+1行，其中N是关联的FTS表中用户定义列的数量。fts4aux表始终具有相同的四列，从左到右如下：
- en: '| Column Name | Column Contents |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 列名 | 列内容 |'
- en: '| term | Contains the text of the term for this row. |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 术语 | 包含此行术语的文本。 |'
- en: '| col | This column may contain either the text value ''*'' (i.e. a single
    character, U+002a) or an integer between 0 and N-1, where N is again the number
    of user-defined columns in the corresponding FTS table. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| col | 此列可以包含文本值 ''*''（即一个字符，U+002a）或介于0和N-1之间的整数，其中N再次是对应FTS表中用户定义列的数量。 |'
- en: '| documents | This column always contains an integer value greater than zero.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '| 文档 | 此列始终包含大于零的整数值。'
- en: If the "col" column contains the value '*', then this column contains the number
    of rows of the FTS table that contain at least one instance of the term (in any
    column). If col contains an integer value, then this column contains the number
    of rows of the FTS table that contain at least one instance of the term in the
    column identified by the col value. As usual, the columns of the FTS table are
    numbered from left to right, starting with zero. |
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果“col”列包含值 '*'，则该列包含FTS表中至少包含一个该术语实例的行数（在任何列中）。如果col包含整数值，则该列包含FTS表中在由col值标识的列中至少包含一个术语实例的行数。与往常一样，FTS表的列从左到右编号，从零开始。
- en: '| occurrences | This column also always contains an integer value greater than
    zero.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '| 发生次数 | 此列同样始终包含大于零的整数值。'
- en: If the "col" column contains the value '*', then this column contains the total
    number of instances of the term in all rows of the FTS table (in any column).
    Otherwise, if col contains an integer value, then this column contains the total
    number of instances of the term that appear in the FTS table column identified
    by the col value. |
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果“col”列包含值‘*’，则该列包含FTS表所有行中术语实例的总数（无论在哪一列）。否则，如果col包含整数值，则该列包含在由col值标识的FTS表列中出现的术语实例的总数。
- en: '| languageid *(hidden)* | This column determines which [languageid](fts3.html#*fts4languageid)
    is used to extract vocabulary from the FTS3/4 table.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '| languageid *(隐藏)* | 此列决定从FTS3/4表中提取词汇所使用的[languageid](fts3.html#*fts4languageid)。'
- en: The default value for languageid is 0\. If an alternative language is specified
    in WHERE clause constraints, then that alternative is used instead of 0\. There
    can only be a single languageid per query. In other words, the WHERE clause cannot
    contain a range constraint or IN operator on the languageid. |
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: languageid的默认值为0。如果在WHERE子句约束中指定了替代语言，则使用该替代语言而不是0。每个查询只能有一个languageid。换句话说，WHERE子句不能在languageid上包含范围约束或IN运算符。
- en: 'For example, using the tables created above:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用上面创建的表：
- en: '[PRE34]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the example, the values in the "term" column are all lower case, even though
    they were inserted into table "ft" in mixed case. This is because an fts4aux table
    contains the terms as extracted from the document text by the [tokenizer](fts3.html#tokenizer).
    In this case, since table "ft" uses the [simple tokenizer](fts3.html#tokenizer),
    this means all terms have been folded to lower case. Also, there is (for example)
    no row with column "term" set to "apple" and column "col" set to 1\. Since there
    are no instances of the term "apple" in column 1, no row is present in the fts4aux
    table.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在“term”列中的值全为小写，即使它们以混合大小写插入到“ft”表中。这是因为fts4aux表包含了通过[分词器](fts3.html#tokenizer)从文档文本中提取的术语。在这种情况下，由于“ft”表使用了[简单分词器](fts3.html#tokenizer)，这意味着所有术语都已折叠为小写。此外，例如，“term”列设置为“apple”并且“col”列设置为1的行不存在。由于在列1中没有术语“apple”的实例，fts4aux表中也没有对应的行。
- en: During a transaction, some of the data written to an FTS table may be cached
    in memory and written to the database only when the transaction is committed.
    However the implementation of the fts4aux module is only able to read data from
    the database. In practice this means that if an fts4aux table is queried from
    within a transaction in which the associated FTS table has been modified, the
    results of the query are likely to reflect only a (possibly empty) subset of the
    changes made.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在事务期间，写入FTS表的某些数据可能会被缓存在内存中，并且只有在提交事务时才会写入数据库。但是，fts4aux模块的实现只能从数据库中读取数据。实际上，这意味着如果在修改了关联的FTS表的事务中查询fts4aux表，查询结果可能仅反映所做更改的（可能为空的）子集。
- en: 6\. FTS4 Options
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6\. FTS4 选项
- en: 'If the "CREATE VIRTUAL TABLE" statement specifies module FTS4 (not FTS3), then
    special directives - FTS4 options - similar to the "tokenize=*" option may also
    appear in place of column names. An FTS4 option consists of the option name, followed
    by an "=" character, followed by the option value. The option value may optionally
    be enclosed in single or double quotes, with embedded quote characters escaped
    in the same way as for SQL literals. There may not be whitespace on either side
    of the "=" character. For example, to create an FTS4 table with the value of option
    "matchinfo" set to "fts3":'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果“CREATE VIRTUAL TABLE”语句指定模块为FTS4（而不是FTS3），那么特殊指令——FTS4选项——类似于“tokenize=*”选项也可能出现在列名的位置。FTS4选项由选项名称、后跟“=”字符、后跟选项值组成。选项值可以选择性地用单引号或双引号括起来，并且嵌入的引号字符需要像SQL文本字面量一样进行转义。在“=”字符两侧不能有空白字符。例如，要创建一个FTS4表，使选项“matchinfo”的值设置为“fts3”：
- en: '[PRE35]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'FTS4 currently supports the following options:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: FTS4目前支持以下选项：
- en: '| Option | Interpretation |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| Option | Interpretation |'
- en: '| compress | The compress option is used to specify the compress function.
    It is an error to specify a compress function without also specifying an uncompress
    function. [See below](fts3.html#the_compress_and_uncompress_options) for details.
    |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| compress | compress选项用于指定压缩函数。如果指定了压缩函数而没有指定解压函数，则会出错。详细信息请参见[下文](fts3.html#the_compress_and_uncompress_options)。|'
- en: '| content | The content allows the text being indexed to be stored in a separate
    table distinct from the FTS4 table, or even outside of SQLite. |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| content | content允许将被索引的文本存储在与FTS4表不同的单独表中，甚至在SQLite之外。|'
- en: '| languageid | The languageid option causes the FTS4 table to have an additional
    hidden integer column that identifies the language of the text contained in each
    row. The use of the languageid option allows the same FTS4 table to hold text
    in multiple languages or scripts, each with different tokenizer rules, and to
    query each language independently of the others. |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| languageid | languageid 选项会导致 FTS4 表有一个额外的隐藏整数列，用于标识每行文本的语言。使用 languageid
    选项允许同一个 FTS4 表存储多种语言或脚本的文本，每种语言使用不同的分词规则，并且可以独立查询每种语言的内容。 |'
- en: '| matchinfo | When set to the value "fts3", the matchinfo option reduces the
    amount of information stored by FTS4 with the consequence that the "l" option
    of [matchinfo()](fts3.html#matchinfo) is no longer available. |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| matchinfo | 当设置为值 "fts3" 时，matchinfo 选项会减少 FTS4 存储的信息量，因此 [matchinfo()](fts3.html#matchinfo)
    的 "l" 选项不再可用。 |'
- en: '| notindexed | This option is used to specify the name of a column for which
    data is not indexed. Values stored in columns that are not indexed are not matched
    by MATCH queries. Nor are they recognized by auxiliary functions. A single CREATE
    VIRTUAL TABLE statement may have any number of notindexed options. |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| notindexed | 这个选项用于指定一个列名，该列的数据不会被索引。未索引的列存储的值不会被 MATCH 查询匹配，也不会被辅助函数识别。单个
    CREATE VIRTUAL TABLE 语句可以有任意数量的 notindexed 选项。 |'
- en: '| order | The "order" option may be set to either "DESC" or "ASC" (in upper
    or lower case). If it is set to "DESC", then FTS4 stores its data in such a way
    as to optimize returning results in descending order by docid. If it is set to
    "ASC" (the default), then the data structures are optimized for returning results
    in ascending order by docid. In other words, if many of the queries run against
    the FTS4 table use "ORDER BY docid DESC", then it may improve performance to add
    the "order=desc" option to the CREATE VIRTUAL TABLE statement. |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| order | "order" 选项可以设置为 "DESC" 或 "ASC"（不区分大小写）。如果设置为 "DESC"，那么 FTS4 将数据存储以优化按
    docid 降序返回结果。如果设置为 "ASC"（默认值），则数据结构优化用于按 docid 升序返回结果。换句话说，如果针对 FTS4 表运行的查询中有很多使用
    "ORDER BY docid DESC"，则在 CREATE VIRTUAL TABLE 语句中添加 "order=desc" 选项可能会提高性能。 |'
- en: '| prefix | This option may be set to a comma-separated list of positive non-zero
    integers. For each integer N in the list, a separate index is created in the database
    file to optimize [prefix queries](fts3.html#termprefix) where the query term is
    N bytes in length, not including the ''*'' character, when encoded using UTF-8\.
    [See below](fts3.html#the_prefix_option) for details. |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| prefix | 这个选项可以设置为正整数的逗号分隔列表。列表中的每个整数 N，都会在数据库文件中创建一个单独的索引，用于优化 [前缀查询](fts3.html#termprefix)，其中查询项长度为
    N 字节（不包括 ''*'' 字符），使用 UTF-8 编码。详细信息请参见 [下文](fts3.html#the_prefix_option)。 |'
- en: '| uncompress | This option is used to specify the uncompress function. It is
    an error to specify an uncompress function without also specifying a compress
    function. [See below](fts3.html#the_compress_and_uncompress_options) for details.
    |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| uncompress | 这个选项用于指定解压函数。指定解压函数而不同时指定压缩函数是错误的。详细信息请参见 [下文](fts3.html#the_compress_and_uncompress_options)。'
- en: 'When using FTS4, specifying a column name that contains an "=" character and
    is not either a "tokenize=*" specification or a recognized FTS4 option is an error.
    With FTS3, the first token in the unrecognized directive is interpreted as a column
    name. Similarly, specifying multiple "tokenize=*" directives in a single table
    declaration is an error when using FTS4, whereas the second and subsequent "tokenize=*"
    directives are interpreted as column names by FTS3\. For example:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 FTS4 时，指定包含 "=" 字符且不是 "tokenize=*" 规范或已识别的 FTS4 选项的列名是错误的。对于 FTS3，未识别指令中的第一个标记会被解释为列名。类似地，当使用
    FTS4 时，在单个表声明中指定多个 "tokenize=*" 规范是错误的，而在 FTS3 中，第二个及后续的 "tokenize=*" 规范会被解释为列名。例如：
- en: '[PRE36]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 6.1\. The compress= and uncompress= options
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1\. compress= 和 uncompress= 选项
- en: The compress and uncompress options allow FTS4 content to be stored in the database
    in a compressed form. Both options should be set to the name of an SQL scalar
    function registered using [sqlite3_create_function()](c3ref/create_function.html)
    that accepts a single argument.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: compress 和 uncompress 选项允许以压缩形式存储 FTS4 内容在数据库中。两个选项应设置为使用 [sqlite3_create_function()](c3ref/create_function.html)
    注册的 SQL 标量函数的名称，该函数接受一个参数。
- en: The compress function should return a compressed version of the value passed
    to it as an argument. Each time data is written to the FTS4 table, each column
    value is passed to the compress function and the result value stored in the database.
    The compress function may return any type of SQLite value (blob, text, real, integer
    or null).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: compress 函数应返回传递给它作为参数的值的压缩版本。每次向 FTS4 表写入数据时，将每个列值传递给 compress 函数，并将结果值存储在数据库中。compress
    函数可以返回任何类型的 SQLite 值（blob、text、real、integer 或 null）。
- en: The uncompress function should uncompress data previously compressed by the
    compress function. In other words, for all SQLite values X, it should be true
    that uncompress(compress(X)) equals X. When data that has been compressed by the
    compress function is read from the database by FTS4, it is passed to the uncompress
    function before it is used.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: uncompress 函数应解压先前由 compress 函数压缩的数据。换句话说，对于所有 SQLite 值 X，应该成立 uncompress(compress(X))
    等于 X。当由 FTS4 从数据库读取通过 compress 函数压缩的数据时，它会在使用之前将其传递给 uncompress 函数。
- en: If the specified compress or uncompress functions do not exist, the table may
    still be created. An error is not returned until the FTS4 table is read (if the
    uncompress function does not exist) or written (if it is the compress function
    that does not exist).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定的 compress 或 uncompress 函数不存在，则可能仍然创建表。只有在读取 FTS4 表时（如果 uncompress 函数不存在）或写入时（如果不存在
    compress 函数）才会返回错误。
- en: '[PRE37]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When implementing the compress and uncompress functions it is important to pay
    attention to data types. Specifically, when a user reads a value from a compressed
    FTS table, the value returned by FTS is exactly the same as the value returned
    by the uncompress function, including the data type. If that data type is not
    the same as the data type of the original value as passed to the compress function
    (for example if the uncompress function is returning BLOB when compress was originally
    passed TEXT), then the users query may not function as expected.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现 compress 和 uncompress 函数时，重要的是注意数据类型。具体来说，当用户从压缩的 FTS 表中读取值时，FTS 返回的值与通过
    uncompress 函数返回的值完全相同，包括数据类型。如果该数据类型与最初传递给 compress 函数的原始值的数据类型不同（例如，如果 uncompress
    函数在原始传递 TEXT 时返回 BLOB），则用户的查询可能不会按预期功能运行。
- en: 6.2\. The content= option
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2. content= 选项
- en: 'The content option allows FTS4 to forego storing the text being indexed. The
    content option can be used in two ways:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: content 选项允许 FTS4 跳过存储正在索引的文本。content 选项可以有两种用法：
- en: The indexed documents are not stored within the SQLite database at all (a "contentless"
    FTS4 table), or
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引文档根本不存储在 SQLite 数据库中（“无内容”FTS4 表），或者
- en: The indexed documents are stored in a database table created and managed by
    the user (an "external content" FTS4 table).
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引文档存储在用户创建和管理的数据库表中（“外部内容”FTS4 表）。
- en: Because the indexed documents themselves are usually much larger than the full-text
    index, the content option can be used to achieve significant space savings.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 因为索引文档本身通常比全文索引大得多，因此可以使用 content 选项实现显著的节省空间。
- en: 6.2.1\. Contentless FTS4 Tables
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.1. 无内容的 FTS4 表
- en: 'In order to create an FTS4 table that does not store a copy of the indexed
    documents at all, the content option should be set to an empty string. For example,
    the following SQL creates such an FTS4 table with three columns - "a", "b", and
    "c":'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个完全不存储索引文档副本的 FTS4 表，content 选项应设置为空字符串。例如，以下 SQL 创建了一个带有三列“a”、“b”和“c”的这样的
    FTS4 表：
- en: '[PRE38]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Data can be inserted into such an FTS4 table using an INSERT statements. However,
    unlike ordinary FTS4 tables, the user must supply an explicit integer docid value.
    For example:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 INSERT 语句将数据插入这样的 FTS4 表中。但与普通的 FTS4 表不同，用户必须提供显式整数 docid 值。例如：
- en: '[PRE39]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It is not possible to UPDATE or DELETE a row stored in a contentless FTS4 table.
    Attempting to do so is an error.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 无法在存储“无内容”FTS4 表中的行中进行 UPDATE 或 DELETE 操作。尝试这样做会导致错误。
- en: 'Contentless FTS4 tables also support SELECT statements. However, it is an error
    to attempt to retrieve the value of any table column other than the docid column.
    The auxiliary function matchinfo() may be used, but snippet() and offsets() may
    not. For example:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: “无内容”FTS4 表也支持 SELECT 语句。但是，尝试检索除 docid 列以外的任何表列的值会导致错误。可以使用辅助函数 matchinfo()，但不能使用
    snippet() 和 offsets()。例如：
- en: '[PRE40]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Errors related to attempting to retrieve column values other than docid are
    runtime errors that occur within sqlite3_step(). In some cases, for example if
    the MATCH expression in a SELECT query matches zero rows, there may be no error
    at all even if a statement does refer to column values other than docid.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 试图检索除 docid 外的列值时的错误是在 sqlite3_step() 中发生的运行时错误。在某些情况下，例如如果 SELECT 查询中的 MATCH
    表达式匹配零行，即使语句确实引用除 docid 外的列值，也可能没有任何错误。
- en: 6.2.2\. External Content FTS4 Tables
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.2\. 外部内容 FTS4 表
- en: An "external content" FTS4 table is similar to a contentless table, except that
    if evaluation of a query requires the value of a column other than docid, FTS4
    attempts to retrieve that value from a table (or view, or virtual table) nominated
    by the user (hereafter referred to as the "content table"). The FTS4 module never
    writes to the content table, and writing to the content table does not affect
    the full-text index. It is the responsibility of the user to ensure that the content
    table and the full-text index are consistent.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '"外部内容" FTS4 表类似于无内容表，不同之处在于，如果查询的评估需要除 docid 外的列值，FTS4 会尝试从用户指定的表（或视图，或虚拟表，以下简称为“内容表”）中检索该值。FTS4
    模块永远不会向内容表写入，并且向内容表写入不会影响全文索引。用户有责任确保内容表和全文索引的一致性。'
- en: 'An external content FTS4 table is created by setting the content option to
    the name of a table (or view, or virtual table) that may be queried by FTS4 to
    retrieve column values when required. If the nominated table does not exist, then
    an external content table behaves in the same way as a contentless table. For
    example:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 外部内容 FTS4 表是通过将 content 选项设置为一个表（或视图，或虚拟表）的名称来创建的，FTS4 可以在需要时查询这些表以检索列值。如果提名的表不存在，则外部内容表的行为与无内容表相同。例如：
- en: '[PRE41]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Assuming the nominated table does exist, then its columns must be the same as
    or a superset of those defined for the FTS table. The external table must also
    be in the same database file as the FTS table. In other words, The external table
    cannot be in a different database file connected using [ATTACH](lang_attach.html)
    nor may one of the FTS table and the external content be in the TEMP database
    when the other is in a persistent database file such as MAIN.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 假设提名的表确实存在，则其列必须与 FTS 表定义的列相同或超集。外部表必须与 FTS 表位于同一数据库文件中。换句话说，外部表不能位于通过 [ATTACH](lang_attach.html)
    连接的不同数据库文件中，也不能是 FTS 表和外部内容之一位于 TEMP 数据库，而另一者位于如 MAIN 等持久性数据库文件中。
- en: 'When a users query on the FTS table requires a column value other than docid,
    FTS attempts to read the requested value from the corresponding column of the
    row in the content table with a rowid value equal to the current FTS docid. Only
    the subset of content-table columns duplicated in the FTS/34 table declaration
    can be queried for - to retrieve values from any other columns the content table
    must be queried directly. Or, if such a row cannot be found in the content table,
    a NULL value is used instead. For example:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在 FTS 表上查询需要除 docid 外的列值时，FTS 尝试从内容表中具有与当前 FTS docid 相等的 rowid 值的行的相应列读取请求的值。只能查询
    FTS/34 表声明中复制的内容表列子集，以检索任何其他列的值，必须直接查询内容表。或者，如果在内容表中找不到这样的行，则使用 NULL 值。例如：
- en: '[PRE42]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: When a row is deleted from an external content FTS4 table, FTS4 needs to retrieve
    the column values of the row being deleted from the content table. This is so
    that FTS4 can update the full-text index entries for each token that occurs within
    the deleted row to indicate that row has been deleted. If the content table row
    cannot be found, or if it contains values inconsistent with the contents of the
    FTS index, the results can be difficult to predict. The FTS index may be left
    containing entries corresponding to the deleted row, which can lead to seemingly
    nonsensical results being returned by subsequent SELECT queries. The same applies
    when a row is updated, as internally an UPDATE is the same as a DELETE followed
    by an INSERT.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当从外部内容 FTS4 表中删除一行时，FTS4 需要从内容表中检索正在删除的行的列值。这样，FTS4 可以更新每个出现在已删除行内的标记的全文索引条目，以指示该行已被删除。如果找不到内容表行，或者其包含与
    FTS 索引内容不一致的值，则结果可能难以预测。FTS 索引可能会保留与已删除行对应的条目，这可能导致后续 SELECT 查询返回看似荒谬的结果。当更新行时情况也相同，因为内部上
    UPDATE 相当于 DELETE 后跟 INSERT。
- en: 'This means that in order to keep an FTS in sync with an external content table,
    any UPDATE or DELETE operations must be applied first to the FTS table, and then
    to the external content table. For example:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着为了使 FTS 与外部内容表保持同步，任何 UPDATE 或 DELETE 操作必须先应用于 FTS 表，然后应用于外部内容表。例如：
- en: '[PRE43]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Instead of writing separately to the full-text index and the content table,
    some users may wish to use database triggers to keep the full-text index up to
    date with respect to the set of documents stored in the content table. For example,
    using the tables from earlier examples:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 有些用户可能希望使用数据库触发器而不是分别编写到全文索引和内容表，以使全文索引保持与存储在内容表中的文档集合同步。例如，使用早期示例中的表：
- en: '[PRE44]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The DELETE trigger must be fired before the actual delete takes place on the
    content table. This is so that FTS4 can still retrieve the original values in
    order to update the full-text index. And the INSERT trigger must be fired after
    the new row is inserted, so as to handle the case where the rowid is assigned
    automatically within the system. The UPDATE trigger must be split into two parts,
    one fired before and one after the update of the content table, for the same reasons.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: DELETE 触发器必须在实际删除内容表的操作之前触发。这样 FTS4 仍然可以检索原始值以更新全文索引。INSERT 触发器必须在插入新行后触发，以处理系统内自动分配
    rowid 的情况。UPDATE 触发器必须分为两部分，一部分在更新内容表之前触发，另一部分在更新后触发，原因相同。
- en: 'The [FTS4 "rebuild" command](fts3.html#*fts4rebuidcmd) deletes the entire full-text
    index and rebuilds it based on the current set of documents in the content table.
    Assuming again that "t3" is the name of the external content FTS4 table, the rebuild
    command looks like this:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[FTS4 "重建" 命令](fts3.html#*fts4rebuidcmd) 删除整个全文索引，并根据内容表中当前的文档集合进行重建。假设"t3"是外部内容
    FTS4 表的名称，重建命令如下所示：'
- en: '[PRE45]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This command may also be used with ordinary FTS4 tables, for example if the
    implementation of the tokenizer changes. It is an error to attempt to rebuild
    the full-text index maintained by a contentless FTS4 table, since no content will
    be available to do the rebuilding.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令也可以用于普通的 FTS4 表，例如如果分词器的实现发生了变化。试图重建由无内容的 FTS4 表维护的全文索引是错误的，因为没有可用的内容来执行重建。
- en: 6.3\. The languageid= option
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3\. languageid= 选项
- en: 'When the languageid option is present, it specifies the name of another [hidden
    column](vtab.html#hiddencol) that is added to the FTS4 table and which is used
    to specify the language stored in each row of the FTS4 table. The name of the
    languageid hidden column must be distinct from all other column names in the FTS4
    table. Example:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在 languageid 选项时，它指定了添加到 FTS4 表的另一个[隐藏列](vtab.html#hiddencol)，用于指定 FTS4 表中每行存储的语言。languageid
    隐藏列的名称必须与 FTS4 表中的所有其他列名不同。示例：
- en: '[PRE46]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The default value of a languageid column is 0\. Any value inserted into a languageid
    column is converted to a 32-bit (not 64) signed integer.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: languageid 列的默认值为 0。插入到 languageid 列的任何值都会转换为 32 位（而不是 64 位）有符号整数。
- en: By default, FTS queries (those that use the MATCH operator) consider only those
    rows with the languageid column set to 0\. To query for rows with other languageid
    values, a constraint of the form "
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，FTS 查询（使用 MATCH 操作符的查询）仅考虑那些 languageid 列设置为 0 的行。要查询具有其他 languageid 值的行，需要一个形式为"
- en: '<language-id>= <integer>" must be added to the queries WHERE clause. For example:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 必须将"<language-id>= <integer>" 添加到查询的 WHERE 子句中。例如：
- en: '[PRE47]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: It is not possible for a single FTS query to return rows with different languageid
    values. The results of adding WHERE clauses that use other operators (e.g. lid!=5,
    or lid<=5) are undefined.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 一条 FTS 查询不可能返回具有不同 languageid 值的行。使用其他操作符（例如 lid!=5 或 lid<=5）的 WHERE 子句的结果是未定义的。
- en: If the content option is used along with the languageid option, then the named
    languageid column must exist in the content= table (subject to the usual rules
    - if a query never needs to read the content table then this restriction does
    not apply).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 content 选项与 languageid 选项一起使用，则命名的 languageid 列必须存在于 content= 表中（受通常规则约束
    - 如果查询从不需要读取内容表，则不适用此限制）。
- en: When the languageid option is used, SQLite invokes the xLanguageid() on the
    sqlite3_tokenizer_module object immediately after the object is created in order
    to pass in the language id that the tokenizer should use. The xLanguageid() method
    will never be called more than once for any single tokenizer object. The fact
    that different languages might be tokenized differently is one reason why no single
    FTS query can return rows with different languageid values.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用languageid选项时，SQLite在sqlite3_tokenizer_module对象创建后立即调用xLanguageid()，以便传递分词器应使用的语言ID。xLanguageid()方法不会对单个分词器对象多次调用。不同语言可能以不同方式进行分词是为何没有单一的FTS查询可以返回具有不同languageid值的行的一个原因。
- en: 6.4\. The matchinfo= option
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4\. matchinfo=选项
- en: The matchinfo option may only be set to the value "fts3". Attempting to set
    matchinfo to anything other than "fts3" is an error. If this option is specified,
    then some of the extra information stored by FTS4 is omitted. This reduces the
    amount of disk space consumed by an FTS4 table until it is almost the same as
    the amount that would be used by the equivalent FTS3 table, but also means that
    the data accessed by passing the 'l' flag to the [matchinfo()](fts3.html#matchinfo)
    function is not available.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: matchinfo选项只能设置为"fts3"值。尝试将matchinfo设置为除"fts3"之外的任何值都会引发错误。如果指定了此选项，则FTS4存储的一些额外信息将被省略。这减少了FTS4表所占用的磁盘空间，使其几乎与等效的FTS3表所需的空间相同，但同时意味着通过将'l'标志传递给[matchinfo()](fts3.html#matchinfo)函数访问的数据不可用。
- en: 6.5\. The notindexed= option
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5\. notindexed=选项
- en: 'Normally, the FTS module maintains an inverted index of all terms in all columns
    of the table. This option is used to specify the name of a column for which entries
    should not be added to the index. Multiple "notindexed" options may be used to
    specify that multiple columns should be omitted from the index. For example:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，FTS模块维护表的所有列中所有术语的倒排索引。此选项用于指定不应将条目添加到索引中的列的名称。可以使用多个"notindexed"选项指定应从索引中省略的多个列。例如：
- en: '[PRE48]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Values stored in unindexed columns are not eligible to match MATCH operators.
    They do not influence the results of the offsets() or matchinfo() auxiliary functions.
    Nor will the snippet() function ever return a snippet based on a value stored
    in an unindexed column.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在非索引列中的值不符合MATCH运算符的匹配条件。它们不会影响offsets()或matchinfo()辅助函数的结果。而snippet()函数也不会基于存储在非索引列中的值返回片段。
- en: 6.6\. The prefix= option
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6\. prefix=选项
- en: The FTS4 prefix option causes FTS to index term prefixes of specified lengths
    in the same way that it always indexes complete terms. The prefix option must
    be set to a comma separated list of positive non-zero integers. For each value
    N in the list, prefixes of length N bytes (when encoded using UTF-8) are indexed.
    FTS4 uses term prefix indexes to speed up [prefix queries](fts3.html#termprefix).
    The cost, of course, is that indexing term prefixes as well as complete terms
    increases the database size and slows down write operations on the FTS4 table.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: FTS4前缀选项导致FTS索引指定长度的术语前缀，就像它总是索引完整术语一样。前缀选项必须设置为正的非零整数的逗号分隔列表。对于列表中的每个值N，编码为UTF-8时长度为N字节的前缀将被索引。FTS4使用术语前缀索引加速[前缀查询](fts3.html#termprefix)。当然，代价是将术语前缀以及完整术语一起索引会增加数据库大小，并减慢对FTS4表的写操作。
- en: Prefix indexes may be used to optimize [prefix queries](fts3.html#termprefix)
    in two cases. If the query is for a prefix of N bytes, then a prefix index created
    with "prefix=N" provides the best optimization. Or, if no "prefix=N" index is
    available, a "prefix=N+1" index may be used instead. Using a "prefix=N+1" index
    is less efficient than a "prefix=N" index, but is better than no prefix index
    at all.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀索引可以在两种情况下优化[前缀查询](fts3.html#termprefix)。如果查询的前缀是N字节，则使用"prefix=N"创建的前缀索引提供最佳优化。或者，如果没有可用的"prefix=N"索引，则可以使用"prefix=N+1"索引。使用"prefix=N+1"索引比"prefix=N"索引效率低，但优于没有前缀索引。
- en: '[PRE49]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 7\. Special Commands For FTS3 and FTS4
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7\. FTS3和FTS4的特殊命令
- en: 'Special INSERT operates can be used to issue commands to FTS3 and FTS4 tables.
    Every FTS3 and FTS4 has a hidden, read-only column which is the same name as the
    table itself. INSERTs into this hidden column are interpreted as commands to the
    FTS3/4 table. For a table with the name "xyz" the following commands are supported:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用特殊的INSERT操作向FTS3和FTS4表发出命令。每个FTS3和FTS4表都有一个隐藏的只读列，其名称与表本身相同。对该隐藏列的INSERT被解释为对FTS3/4表的命令。对于名称为"xyz"的表，支持以下命令：
- en: INSERT INTO xyz(xyz) VALUES('optimize');
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: INSERT INTO xyz(xyz) VALUES('optimize');
- en: INSERT INTO xyz(xyz) VALUES('rebuild');
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: INSERT INTO xyz(xyz) VALUES('rebuild');
- en: INSERT INTO xyz(xyz) VALUES('integrity-check');
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: INSERT INTO xyz(xyz) VALUES('integrity-check');
- en: INSERT INTO xyz(xyz) VALUES('merge=X,Y');
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: INSERT INTO xyz(xyz) VALUES('merge=X,Y');
- en: INSERT INTO xyz(xyz) VALUES('automerge=N');
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: INSERT INTO xyz(xyz) VALUES('automerge=N');
- en: 7.1\. The "optimize" command
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1\. “optimize”命令
- en: The "optimize" command causes FTS3/4 to merge together all of its inverted index
    b-trees into one large and complete b-tree. Doing an optimize will make subsequent
    queries run faster since there are fewer b-trees to search, and it may reduce
    disk usage by coalescing redundant entries. However, for a large FTS table, running
    optimize can be as expensive as running [VACUUM](lang_vacuum.html). The optimize
    command essentially has to read and write the entire FTS table, resulting in a
    large transaction.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: “optimize”命令使 FTS3/4 将其所有反向索引 B 树合并为一个大而完整的 B 树。进行优化后，后续查询速度更快，因为要搜索的 B 树更少，并且通过合并冗余条目可能减少磁盘使用量。然而，对于大型
    FTS 表，运行优化可能会像运行[VACUUM](lang_vacuum.html)一样昂贵。优化命令本质上必须读取和写入整个 FTS 表，导致大事务。
- en: In batch-mode operation, where an FTS table is initially built up using a large
    number of INSERT operations, then queried repeatedly without further changes,
    it is often a good idea to run "optimize" after the last INSERT and before the
    first query.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在批处理模式操作中，即首先使用大量 INSERT 操作构建 FTS 表，然后重复查询而没有进一步更改时，通常建议在最后一个 INSERT 之后和第一个查询之前运行“optimize”。
- en: 7.2\. The "rebuild" command
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2\. “rebuild”命令
- en: The "rebuild" command causes SQLite to discard the entire FTS3/4 table and then
    rebuild it again from original text. The concept is similar to [REINDEX](lang_reindex.html),
    only that it applies to an FTS3/4 table instead of an ordinary index.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: “rebuild”命令使 SQLite 丢弃整个 FTS3/4 表，然后从原始文本重新构建。该概念类似于[REINDEX](lang_reindex.html)，只是适用于
    FTS3/4 表而不是普通索引。
- en: The "rebuild" command should be run whenever the implementation of a custom
    tokenizer changes, so that all content can be retokenized. The "rebuild" command
    is also useful when using the [FTS4 content option](fts3.html#*fts4content) after
    changes have been made to the original content table.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当自定义标记器的实现发生更改时，应该运行“rebuild”命令以重新标记所有内容。在对原始内容表进行更改后，使用[FTS4 内容选项](fts3.html#*fts4content)时，也很有用。
- en: 7.3\. The "integrity-check" command
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3\. “integrity-check”命令
- en: The "integrity-check" command causes SQLite to read and verify the accuracy
    of all inverted indices in an FTS3/4 table by comparing those inverted indices
    against the original content. The "integrity-check" command silently succeeds
    if the inverted indices are all ok, but will fail with an SQLITE_CORRUPT error
    if any problems are found.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: “integrity-check”命令通过将反向索引与原始内容进行比较，使 SQLite 读取并验证 FTS3/4 表中所有反向索引的准确性。如果反向索引全部正常，该命令将悄无声息地成功，但如果发现任何问题，则会出现
    SQLITE_CORRUPT 错误。
- en: 'The "integrity-check" command is similar in concept to [PRAGMA integrity_check](pragma.html#pragma_integrity_check).
    In a working system, the "integrity-command" should always be successful. Possible
    causes of integrity-check failures include:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: “integrity-check”命令在概念上类似于[PRAGMA integrity_check](pragma.html#pragma_integrity_check)。在正常工作的系统中，“integrity-command”应始终成功。integrity-check
    失败的可能原因包括：
- en: The application has made changes to the [FTS shadow tables](fts3.html#*shadowtab)
    directly, without using the FTS3/4 virtual table, causing the shadow tables to
    become out of sync with each other.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序直接对[FTS 阴影表](fts3.html#*shadowtab)进行更改，而不使用 FTS3/4 虚拟表，导致阴影表与彼此不同步。
- en: Using the [FTS4 content option](fts3.html#*fts4content) and failing to manually
    keep the content in sync with the FTS4 inverted indices.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用[FTS4 内容选项](fts3.html#*fts4content)，但未能手动保持内容与 FTS4 反向索引同步。
- en: Bugs in the FTS3/4 virtual table. (The "integrity-check" command was original
    conceived as part of the test suite for FTS3/4.)
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FTS3/4 虚拟表中的错误。（“integrity-check”命令最初作为 FTS3/4 的测试套件的一部分而构思。）
- en: Corruption to the underlying SQLite database file. (See documentation on [how
    to corrupt](howtocorrupt.html) and SQLite database for additional information.)
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 损坏底层的 SQLite 数据库文件。（参见[如何损坏](howtocorrupt.html)的文档和 SQLite 数据库以获取更多信息。）
- en: 7.4\. The "merge=X,Y" command
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4\. “merge=X,Y”命令
- en: The "merge=X,Y" command (where X and Y are integers) causes SQLite to do a limited
    amount of work toward merging the various inverted index b-trees of an FTS3/4
    table together into one large b-tree. The X value is the target number of "blocks"
    to be merged, and Y is the minimum number of b-tree segments on a level required
    before merging will be applied to that level. The value of Y should be between
    2 and 16 with a recommended value of 8\. The value of X can be any positive integer
    but values on the order of 100 to 300 are recommended.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '"merge=X,Y" 命令（其中 X 和 Y 是整数）会导致 SQLite 对 FTS3/4 表的各种倒排索引 B 树进行有限的合并工作，合并成一个大的
    B 树。X 值是要合并的 "块" 的目标数量，Y 是在应用合并到该级别之前所需的最小 B 树段数量。Y 的值应在 2 到 16 之间，推荐值为 8。X 的值可以是任何正整数，但建议在
    100 到 300 范围内。'
- en: When an FTS table accumulates 16 b-tree segments at the same level, the next
    INSERT into that table will cause all 16 segments to be merged into a single b-tree
    segment at the next higher level. The effect of these level merges is that most
    INSERTs into an FTS table are very fast and take minimal memory, but an occasional
    INSERT is slow and generates a large transaction because of the need to do merging.
    This results in "spiky" performance of INSERTs.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个 FTS 表积累了 16 个相同级别的 B 树段时，插入该表的下一个操作将导致这 16 个段合并为一个单一的 B 树段，并升级到更高级别。这些级别合并的效果是，大多数插入操作到
    FTS 表都非常快且占用极少内存，但偶尔的插入操作由于需要合并而变慢，并生成大的事务。这导致插入操作的性能出现 "波动"。
- en: To avoid spiky INSERT performance, an application can run the "merge=X,Y" command
    periodically, possibly in an idle thread or idle process, to ensure that the FTS
    table never accumulates too many b-tree segments at the same level. INSERT performance
    spikes can generally be avoided, and performance of FTS3/4 can be maximized, by
    running "merge=X,Y" after every few thousand document inserts. Each "merge=X,Y"
    command will run in a separate transaction (unless they are grouped together using
    [BEGIN](lang_transaction.html)...[COMMIT](lang_transaction.html), of course).
    The transactions can be kept small by choosing a value for X in the range of 100
    to 300\. The idle thread that is running the merge commands can know when it is
    done by checking the difference in [sqlite3_total_changes()](c3ref/total_changes.html)
    before and after each "merge=X,Y" command and stopping the loop when the difference
    drops below two.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 为避免插入性能波动，应用程序可以定期运行 "merge=X,Y" 命令，可能在空闲线程或空闲进程中，以确保 FTS 表在同一级别上从不积累过多的 B 树段。通常可以通过每隔几千个文档插入运行
    "merge=X,Y" 来避免插入性能波动，并最大化 FTS3/4 的性能。每个 "merge=X,Y" 命令将在单独的事务中运行（当然，除非它们使用 [BEGIN](lang_transaction.html)...[COMMIT](lang_transaction.html)
    被分组在一起）。通过选择 X 值在 100 到 300 范围内，可以保持事务的小规模。运行 merge 命令的空闲线程可以通过检查每个 "merge=X,Y"
    命令之前和之后的 [sqlite3_total_changes()](c3ref/total_changes.html) 差异来判断何时完成，并在差异小于两个时停止循环。
- en: 7.5\. The "automerge=N" command
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5\. "automerge=N" 命令
- en: The "automerge=N" command (where N is an integer between 0 and 15, inclusive)
    is used to configure an FTS3/4 tables "automerge" parameter, which controls automatic
    incremental inverted index merging. The default automerge value for new tables
    is 0, meaning that automatic incremental merging is completely disabled. If the
    value of the automerge parameter is modified using the "automerge=N" command,
    the new parameter value is stored persistently in the database and is used by
    all subsequently established database connections.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '"automerge=N" 命令（其中 N 是介于 0 和 15 之间的整数）用于配置 FTS3/4 表的 "automerge" 参数，该参数控制自动增量倒排索引合并。新表的默认
    automerge 值为 0，表示完全禁用自动增量合并。如果使用 "automerge=N" 命令修改 automerge 参数的值，新的参数值将持久存储在数据库中，并由随后建立的所有数据库连接使用。'
- en: Setting the automerge parameter to a non-zero value enables automatic incremental
    merging. This causes SQLite to do a small amount of inverted index merging after
    every INSERT operation. The amount of merging performed is designed so that the
    FTS3/4 table never reaches a point where it has 16 segments at the same level
    and hence has to do a large merge in order to complete an insert. In other words,
    automatic incremental merging is designed to prevent spiky INSERT performance.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 将 automerge 参数设置为非零值可启用自动增量合并。这会导致 SQLite 在每次 INSERT 操作后执行少量倒排索引合并。合并的量设计得使
    FTS3/4 表永远不会达到同一级别有 16 个段的情况，从而避免需要大规模合并以完成插入操作。换句话说，自动增量合并旨在防止插入性能波动。
- en: The downside of automatic incremental merging is that it makes every INSERT,
    UPDATE, and DELETE operation on an FTS3/4 table run a little slower, since extra
    time must be used to do the incremental merge. For maximum performance, it is
    recommended that applications disable automatic incremental merge and instead
    use the ["merge" command](fts3.html#*fts4mergecmd) in an idle process to keep
    the inverted indices well merged. But if the structure of an application does
    not easily allow for idle processes, the use of automatic incremental merge is
    a very reasonable fallback solution.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 自动增量合并的缺点在于，它使得对FTS3/4表的每次INSERT、UPDATE和DELETE操作都稍慢一些，因为额外的时间必须用于执行增量合并。为了最大化性能，建议应用程序禁用自动增量合并，而是在空闲进程中使用["merge"命令](fts3.html#*fts4mergecmd)定期合并倒排索引。但如果应用程序结构不容易支持空闲进程，使用自动增量合并是一个非常合理的备选方案。
- en: The actual value of the automerge parameter determines the number of index segments
    merged simultaneously by an automatic inverted index merge. If the value is set
    to N, the system waits until there are at least N segments on a single level before
    beginning to incrementally merge them. Setting a lower value of N causes segments
    to be merged more quickly, which may speed up full-text queries and, if the workload
    contains UPDATE or DELETE operations as well as INSERTs, reduce the space on disk
    consumed by the full-text index. However, it also increases the amount of data
    written to disk.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: automerge参数的实际值确定了自动倒排索引合并同时合并的索引段数。如果值设置为N，则系统等待在单个级别上至少有N个段，然后开始逐增合并它们。将N设置为较低的值会导致段合并更快，这可能加速全文查询并且如果工作负载包含UPDATE或DELETE操作以及INSERT，则减少全文索引占用的磁盘空间。然而，这也会增加写入磁盘的数据量。
- en: For general use in cases where the workload contains few UPDATE or DELETE operations,
    a good choice for automerge is 8\. If the workload contains many UPDATE or DELETE
    commands, or if query speed is a concern, it may be advantageous to reduce automerge
    to 2.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 对于工作负载中包含较少UPDATE或DELETE操作的一般用途，automerge值为8是一个不错的选择。如果工作负载包含许多UPDATE或DELETE命令，或者如果查询速度是一个问题，将automerge值减少到2可能是有利的。
- en: For reasons of backwards compatibility, the "automerge=1" command sets the automerge
    parameter to 8, not 1 (a value of 1 would make no sense anyway, as merging data
    from a single segment is a no-op).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 由于向后兼容性的原因，“automerge=1”命令将automerge参数设置为8，而不是1（无论如何，将单个段的数据合并是无效的操作）。
- en: 8\. Tokenizers
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8\. 分词器
- en: An FTS tokenizer is a set of rules for extracting terms from a document or basic
    FTS full-text query.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: FTS分词器是从文档或基本的FTS全文查询中提取术语的一组规则。
- en: 'Unless a specific tokenizer is specified as part of the CREATE VIRTUAL TABLE
    statement used to create the FTS table, the default tokenizer, "simple", is used.
    The simple tokenizer extracts tokens from a document or basic FTS full-text query
    according to the following rules:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 除非在用于创建FTS表的CREATE VIRTUAL TABLE语句的一部分中指定了特定的分词器，否则将使用默认的分词器“simple”。简单的分词器根据以下规则从文档或基本的FTS全文查询中提取标记：
- en: A term is a contiguous sequence of eligible characters, where eligible characters
    are all alphanumeric characters and all characters with Unicode codepoint values
    greater than or equal to 128. All other characters are discarded when splitting
    a document into terms. Their only contribution is to separate adjacent terms.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 术语是一系列可接受字符的连续序列，其中可接受字符是所有字母数字字符和Unicode代码点值大于或等于128的所有字符。在将文档分割成术语时，所有其他字符都被丢弃。它们的唯一贡献是分隔相邻的术语。
- en: All uppercase characters within the ASCII range (Unicode codepoints less than
    128), are transformed to their lowercase equivalents as part of the tokenization
    process. Thus, full-text queries are case-insensitive when using the simple tokenizer.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在ASCII范围内的所有大写字符（Unicode代码点小于128）在标记化过程中被转换为它们的小写等价物。因此，在使用简单分词器时，全文查询不区分大小写。
- en: For example, when a document containing the text "Right now, they're very frustrated.",
    the terms extracted from the document and added to the full-text index are, in
    order, "right now they re very frustrated". Such a document would match a full-text
    query such as "MATCH 'Frustrated'", as the simple tokenizer transforms the term
    in the query to lowercase before searching the full-text index.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当一个包含文本“Right now, they're very frustrated.”的文档被处理时，从文档中提取的术语按顺序添加到全文索引中，如“right
    now they re very frustrated”。这样的文档将匹配像“MATCH 'Frustrated'”这样的全文查询，因为简单分词器在搜索全文索引之前将查询中的术语转换为小写。
- en: 'As well as the "simple" tokenizer, the FTS source code features a tokenizer
    that uses the [Porter Stemming algorithm](http://tartarus.org/~martin/PorterStemmer/).
    This tokenizer uses the same rules to separate the input document into terms including
    folding all terms into lower case, but also uses the Porter Stemming algorithm
    to reduce related English language words to a common root. For example, using
    the same input document as in the paragraph above, the porter tokenizer extracts
    the following tokens: "right now thei veri frustrat". Even though some of these
    terms are not even English words, in some cases using them to build the full-text
    index is more useful than the more intelligible output produced by the simple
    tokenizer. Using the porter tokenizer, the document not only matches full-text
    queries such as "MATCH ''Frustrated''", but also queries such as "MATCH ''Frustration''",
    as the term "Frustration" is reduced by the Porter stemmer algorithm to "frustrat"
    - just as "Frustrated" is. So, when using the porter tokenizer, FTS is able to
    find not just exact matches for queried terms, but matches against similar English
    language terms. For more information on the Porter Stemmer algorithm, please refer
    to the page linked above.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 除了“简单”分词器外，FTS源代码还包含一个使用[Porter Stemming算法](http://tartarus.org/~martin/PorterStemmer/)的分词器。该分词器使用相同的规则将输入文档分解为术语，包括将所有术语折叠为小写，但还使用Porter
    Stemming算法将相关的英语单词减少到共同的词根。例如，使用与上段相同的输入文档，porter分词器提取以下标记：“right now thei veri
    frustrat”。尽管其中一些术语甚至不是英语单词，在某些情况下，使用它们来构建全文索引比简单分词器产生的更可理解的输出更有用。使用porter分词器时，文档不仅匹配全文查询，如“MATCH
    'Frustrated'”，还匹配诸如“MATCH 'Frustration'”之类的查询，因为Porter词干提取算法将术语“Frustration”减少到“frustrat”——正如“Frustrated”一样。因此，使用porter分词器时，FTS能够找到不仅仅是查询术语的精确匹配，还能匹配类似的英语术语。有关Porter
    Stemmer算法的更多信息，请参阅上面链接的页面。
- en: 'Example illustrating the difference between the "simple" and "porter" tokenizers:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 示例说明“simple”和“porter”分词器之间的差异：
- en: '[PRE50]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If this extension is compiled with the SQLITE_ENABLE_ICU pre-processor symbol
    defined, then there exists a built-in tokenizer named "icu" implemented using
    the ICU library. The first argument passed to the xCreate() method (see fts3_tokenizer.h)
    of this tokenizer may be an ICU locale identifier. For example "tr_TR" for Turkish
    as used in Turkey, or "en_AU" for English as used in Australia. For example:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编译此扩展时定义了SQLITE_ENABLE_ICU预处理符号，则存在一个使用ICU库实现的内置分词器，名为“icu”。传递给此分词器的xCreate()方法（参见fts3_tokenizer.h）的第一个参数可以是ICU语言环境标识符。例如，用于土耳其土耳其语的“tr_TR”，或用于澳大利亚英语的“en_AU”。例如：
- en: '[PRE51]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The ICU tokenizer implementation is very simple. It splits the input text according
    to the ICU rules for finding word boundaries and discards any tokens that consist
    entirely of white-space. This may be suitable for some applications in some locales,
    but not all. If more complex processing is required, for example to implement
    stemming or discard punctuation, this can be done by creating a tokenizer implementation
    that uses the ICU tokenizer as part of its implementation.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: ICU分词器实现非常简单。它根据ICU规则分割输入文本以找到单词边界，并丢弃完全由空白组成的任何标记。这可能适用于某些区域的某些应用程序，但不适用于所有应用程序。如果需要更复杂的处理，例如实现词干处理或丢弃标点符号，则可以创建一个使用ICU分词器作为其实现部分的分词器实现。
- en: The "unicode61" tokenizer is available beginning with SQLite [version 3.7.13](releaselog/3_7_13.html)
    (2012-06-11). Unicode61 works very much like "simple" except that it does simple
    unicode case folding according to rules in Unicode Version 6.1 and it recognizes
    unicode space and punctuation characters and uses those to separate tokens. The
    simple tokenizer only does case folding of ASCII characters and only recognizes
    ASCII space and punctuation characters as token separators.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: “unicode61”分词器从SQLite [版本3.7.13](releaselog/3_7_13.html)（2012-06-11）开始提供。Unicode61的工作方式与“simple”非常相似，只是根据Unicode
    Version 6.1中的规则执行简单的Unicode大小写折叠，并识别Unicode空格和标点符号字符，并使用它们来分隔标记。简单分词器仅对ASCII字符执行大小写折叠，并仅识别ASCII空格和标点符号字符作为标记分隔符。
- en: 'By default, "unicode61" attempts to remove diacritics from Latin script characters.
    This behaviour can be overridden by adding the tokenizer argument "remove_diacritics=0".
    For example:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，“unicode61”尝试从拉丁字母脚本字符中删除变音符号。可以通过添加分词器参数“remove_diacritics=0”来覆盖此行为。例如：
- en: '[PRE52]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The remove_diacritics option may be set to "0", "1" or "2". The default value
    is "1". If it is set to "1" or "2", then diacritics are removed from Latin script
    characters as described above. However, if it is set to "1", then diacritics are
    not removed in the fairly uncommon case where a single unicode codepoint is used
    to represent a character with more that one diacritic. For example, diacritics
    are not removed from codepoint 0x1ED9 ("LATIN SMALL LETTER O WITH CIRCUMFLEX AND
    DOT BELOW"). This is technically a bug, but cannot be fixed without creating backwards
    compatibility problems. If this option is set to "2", then diacritics are correctly
    removed from all Latin characters.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 选项`remove_diacritics`可以设置为"0"、"1"或"2"。默认值为"1"。如果设置为"1"或"2"，则如上所述，拉丁字母文字中的变音符号将被移除。然而，如果设置为"1"，则在少见的情况下，即使用单个Unicode代码点表示带有多个变音符号的字符时，变音符号不会被移除。例如，从代码点0x1ED9（"LATIN
    SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW"）中不会移除变音符号。这在技术上是一个错误，但不能修复，因为会造成向后兼容性问题。如果此选项设置为"2"，则所有拉丁字符中的变音符号都会被正确移除。
- en: 'It is also possible to customize the set of codepoints that unicode61 treats
    as separator characters. The "separators=" option may be used to specify one or
    more extra characters that should be treated as separator characters, and the
    "tokenchars=" option may be used to specify one or more extra characters that
    should be treated as part of tokens instead of as separator characters. For example:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以自定义unicode61将其视为分隔符字符的代码点集合。可以使用"separators="选项指定一个或多个额外字符，这些字符应被视为分隔符字符，并且可以使用"tokenchars="选项指定一个或多个额外字符，这些字符应被视为令牌的一部分而不是分隔符字符。例如：
- en: '[PRE53]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If a character specified as part of the argument to "tokenchars=" is considered
    to be a token character by default, it is ignored. This is true even if it has
    been marked as a separator by an earlier "separators=" option. Similarly, if a
    character specified as part of a "separators=" option is treated as a separator
    character by default, it is ignored. If multiple "tokenchars=" or "separators="
    options are specified, all are processed. For example:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果作为"tokenchars="参数的一部分指定的字符默认被视为令牌字符，则它将被忽略。即使它已被早期的"separators="选项标记为分隔符也是如此。类似地，如果作为"separators="选项的一部分指定的字符默认被视为分隔符字符，则它将被忽略。如果指定了多个"tokenchars="或"separators="选项，则所有选项都将被处理。例如：
- en: '[PRE54]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The arguments passed to the "tokenchars=" or "separators=" options are case-sensitive.
    In the example above, specifying that "X" is a separator character does not affect
    the way "x" is handled.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '"tokenchars="或"separators="选项传递的参数对大小写敏感。在上面的示例中，指定"X"是分隔符字符不会影响对"x"的处理方式。'
- en: 8.1\. Custom (Application Defined) Tokenizers
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1\. 自定义（应用定义）分词器
- en: In addition to providing built-in "simple", "porter" and (possibly) "icu" and
    "unicode61" tokenizers, FTS provides an interface for applications to implement
    and register custom tokenizers written in C. The interface used to create a new
    tokenizer is defined and described in the fts3_tokenizer.h source file.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供内置的"simple"、"porter"以及（可能的）"icu"和"unicode61"分词器外，FTS还为应用程序提供了一个接口，用于实现并注册用C编写的自定义分词器。用于创建新分词器的接口在fts3_tokenizer.h源文件中定义和描述。
- en: Registering a new FTS tokenizer is similar to registering a new virtual table
    module with SQLite. The user passes a pointer to a structure containing pointers
    to various callback functions that make up the implementation of the new tokenizer
    type. For tokenizers, the structure (defined in fts3_tokenizer.h) is called "sqlite3_tokenizer_module".
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 注册新的FTS分词器类似于在SQLite中注册新的虚拟表模块。用户传递一个指针到包含各种回调函数指针的结构体中，这些函数组成了新分词器类型的实现。对于分词器，该结构体（在fts3_tokenizer.h中定义）称为"sqlite3_tokenizer_module"。
- en: 'FTS does not expose a C-function that users call to register new tokenizer
    types with a database handle. Instead, the pointer must be encoded as an SQL blob
    value and passed to FTS through the SQL engine by evaluating a special scalar
    function, "fts3_tokenizer()". The fts3_tokenizer() function may be called with
    one or two arguments, as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: FTS不公开一个供用户调用以向数据库句柄注册新分词器类型的C函数。相反，指针必须被编码为SQL blob值，并通过评估特殊标量函数"fts3_tokenizer()"通过SQL引擎传递给FTS。fts3_tokenizer()函数可带有一个或两个参数，如下所示：
- en: '[PRE55]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Where <tokenizer-name> is [parameter](lang_expr.html#varparam) to which a string
    is bound using [sqlite3_bind_text()](c3ref/bind_blob.html) where the string identifies
    the tokenizer and <sqlite3_tokenizer_module ptr> is a [parameter](lang_expr.html#varparam)
    to which a BLOB is bound using [sqlite3_bind_blob()](c3ref/bind_blob.html) where
    the value of the BLOB is a pointer to an sqlite3_tokenizer_module structure. If
    the second argument is present, it is registered as tokenizer <tokenizer-name>
    and a copy of it returned. If only one argument is passed, a pointer to the tokenizer
    implementation currently registered as <tokenizer-name> is returned, encoded as
    a blob. Or, if no such tokenizer exists, an SQL exception (error) is raised.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 <tokenizer-name> 是一个参数，使用 [sqlite3_bind_text()](c3ref/bind_blob.html) 绑定一个标识分词器的字符串；<sqlite3_tokenizer_module
    ptr> 是一个参数，使用 [sqlite3_bind_blob()](c3ref/bind_blob.html) 绑定一个值为 sqlite3_tokenizer_module
    结构体指针的 BLOB。如果第二个参数存在，则将其注册为分词器 <tokenizer-name> 并返回其副本。如果只传递一个参数，则返回当前注册为 <tokenizer-name>
    的分词器实现的指针，编码为 BLOB。或者，如果不存在这样的分词器，则会引发 SQL 异常（错误）。
- en: Prior to SQLite [version 3.11.0](releaselog/3_11_0.html) (2016-02-15), the arguments
    to fts3_tokenizer() could be literal strings or BLOBs. They did not have to be
    [bound parameters](lang_expr.html#varparam). But that could lead to security problems
    in the event of an SQL injection. Hence, the legacy behavior is now disabled by
    default. But the old legacy behavior can be enabled, for backwards compatibility
    in applications that really need it, by calling [sqlite3_db_config](c3ref/db_config.html)(db,[SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER](c3ref/c_dbconfig_defensive.html#sqlitedbconfigenablefts3tokenizer),1,0).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQLite [版本 3.11.0](releaselog/3_11_0.html)（2016-02-15）之前，fts3_tokenizer() 的参数可以是文字字符串或
    BLOBs。它们不需要是 [绑定参数](lang_expr.html#varparam)。但这可能导致 SQL 注入时出现安全问题。因此，默认情况下现已禁用旧的遗留行为。但可以通过调用
    [sqlite3_db_config](c3ref/db_config.html)(db,[SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER](c3ref/c_dbconfig_defensive.html#sqlitedbconfigenablefts3tokenizer),1,0)
    来启用旧的遗留行为，以确保在确实需要的应用程序中保持向后兼容性。
- en: 'The following block contains an example of calling the fts3_tokenizer() function
    from C code:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码块包含了从 C 代码调用 fts3_tokenizer() 函数的示例：
- en: '[PRE56]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 8.2\. Querying Tokenizers
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2\. 查询 Tokenizers
- en: 'The "fts3tokenize" virtual table can be used to directly access any tokenizer.
    The following SQL demonstrates how to create an instance of the fts3tokenize virtual
    table:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '"fts3tokenize" 虚拟表可用于直接访问任何分词器。以下 SQL 展示了如何创建 fts3tokenize 虚拟表的实例：'
- en: '[PRE57]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The name of the desired tokenizer should be substituted in place of ''porter''
    in the example, of course. If the tokenizer requires one or more arguments, they
    should be separated by commas in the fts3tokenize declaration (even though they
    are separated by spaces in declarations of regular fts4 tables). The following
    creates fts4 and fts3tokenize tables that use the same tokenizer:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，应该将所需的分词器名称替换为 'porter'。如果分词器需要一个或多个参数，在 fts3tokenize 声明中应使用逗号分隔（即使在常规
    fts4 表的声明中它们以空格分隔）。以下创建使用相同分词器的 fts4 和 fts3tokenize 表：
- en: '[PRE58]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Once the virtual table is created, it can be queried as follows:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 创建虚拟表后，可以如下查询该虚拟表：
- en: '[PRE59]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The virtual table will return one row of output for each token in the input
    string. The "token" column is the text of the token. The "start" and "end" columns
    are the byte offset to the beginning and end of the token in the original input
    string. The "position" column is the sequence number of the token in the original
    input string. There is also an "input" column which is simply a copy of the input
    string that is specified in the WHERE clause. Note that a constraint of the form
    "input=?" must appear in the WHERE clause or else the virtual table will have
    no input to tokenize and will return no rows. The example above generates the
    following output:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟表将为输入字符串中的每个标记返回一行输出。"token" 列是标记的文本。"start" 和 "end" 列是标记在原始输入字符串中的起始字节偏移量和结束字节偏移量。"position"
    列是标记在原始输入字符串中的序列号。还有一个 "input" 列，它只是 WHERE 子句中指定的输入字符串的副本。请注意，WHERE 子句必须出现形式为
    "input=?" 的约束，否则虚拟表将没有输入要分词，并且不会返回任何行。上面的示例生成以下输出：
- en: '[PRE60]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Notice that the tokens in the result set from the fts3tokenize virtual table
    have been transformed according to the rules of the tokenizer. Since this example
    used the "porter" tokenizer, the "This" token was converted into "thi". If the
    original text of the token is desired, it can be retrieved using the "start" and
    "end" columns with the [substr()](lang_corefunc.html#substr) function. For example:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，fts3tokenize 虚拟表结果集中的标记已根据分词器的规则进行了转换。由于此示例使用了 "porter" 分词器，"This" 标记转换为
    "thi"。如果需要标记的原始文本，则可以使用 [substr()](lang_corefunc.html#substr) 函数检索 "start" 和 "end"
    列。例如：
- en: '[PRE61]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The fts3tokenize virtual table can be used on any tokenizer, regardless of whether
    or not there exists an FTS3 or FTS4 table that actually uses that tokenizer.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: fts3tokenize 虚拟表可用于任何分词器，无论是否存在实际使用该分词器的 FTS3 或 FTS4 表。
- en: 9\. Data Structures
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9\. 数据结构
- en: This section describes at a high-level the way the FTS module stores its index
    and content in the database. It is **not necessary to read or understand the material
    in this section in order to use FTS** in an application. However, it may be useful
    to application developers attempting to analyze and understand FTS performance
    characteristics, or to developers contemplating enhancements to the existing FTS
    feature set.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 本节高层次描述了 FTS 模块在数据库中存储其索引和内容的方式。**不需要在使用 FTS 的应用程序中阅读或理解本节的内容**。但是，对于试图分析和理解
    FTS 性能特征的应用程序开发人员或考虑增强现有 FTS 功能集的开发人员可能会有用。
- en: 9.1\. Shadow Tables
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1\. 阴影表
- en: For each FTS virtual table in a database, three to five real (non-virtual) tables
    are created to store the underlying data. These real tables are called "shadow
    tables". The real tables are named "%_content", "%_segdir", "%_segments", "%_stat",
    and "%_docsize", where "%" is replaced by the name of the FTS virtual table.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据库中的每个 FTS 虚拟表，将创建三到五个真实（非虚拟）表来存储底层数据。这些真实表称为 "阴影表"。真实表的名称分别为 "%_content"、"%_segdir"、"%_segments"、"%_stat"
    和 "%_docsize"，其中 "%" 被替换为 FTS 虚拟表的名称。
- en: 'The leftmost column of the "%_content" table is an INTEGER PRIMARY KEY field
    named "docid". Following this is one column for each column of the FTS virtual
    table as declared by the user, named by prepending the column name supplied by
    the user with "c*N*", where *N* is the index of the column within the table, numbered
    from left to right starting with 0\. Data types supplied as part of the virtual
    table declaration are not used as part of the %_content table declaration. For
    example:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '"%_content" 表的最左列是名为 "docid" 的 INTEGER PRIMARY KEY 字段。其后是用户在虚拟表声明中声明的每个列的一列，列名以
    "c*N*" 开头，其中 *N* 是从左到右从 0 开始编号的列的索引。作为虚拟表声明的一部分提供的数据类型不用作 %_content 表声明的一部分。例如：'
- en: '[PRE62]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The %_content table contains the unadulterated data inserted by the user into
    the FTS virtual table by the user. If the user does not explicitly supply a "docid"
    value when inserting records, one is selected automatically by the system.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '%_content 表包含用户插入到 FTS 虚拟表中的未经修改的数据。如果用户在插入记录时没有明确提供 "docid" 值，则系统会自动选择一个。'
- en: 'The %_stat and %_docsize tables are only created if the FTS table uses the
    FTS4 module, not FTS3\. Furthermore, the %_docsize table is omitted if the FTS4
    table is created with the ["matchinfo=fts3"](fts3.html#fts4matchinfo) directive
    specified as part of the CREATE VIRTUAL TABLE statement. If they are created,
    the schema of the two tables is as follows:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '%_stat 和 %_docsize 表仅在 FTS 表使用 FTS4 模块时才会创建，而不是 FTS3。此外，如果 FTS4 表创建时指定了 ["matchinfo=fts3"](fts3.html#fts4matchinfo)
    指令作为 CREATE VIRTUAL TABLE 语句的一部分，则会省略 %_docsize 表。如果创建了这两个表，则两个表的架构如下：'
- en: '[PRE63]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: For each row in the FTS table, the %_docsize table contains a corresponding
    row with the same "docid" value. The "size" field contains a blob consisting of
    *N* FTS varints, where *N* is the number of user-defined columns in the table.
    Each varint in the "size" blob is the number of tokens in the corresponding column
    of the associated row in the FTS table. The %_stat table always contains a single
    row with the "id" column set to 0\. The "value" column contains a blob consisting
    of *N+1* FTS varints, where *N* is again the number of user-defined columns in
    the FTS table. The first varint in the blob is set to the total number of rows
    in the FTS table. The second and subsequent varints contain the total number of
    tokens stored in the corresponding column for all rows of the FTS table.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 对于FTS表中的每一行，%_docsize表包含一个具有相同“docid”值的相应行。“size”字段包含一个由*N*个FTS变长整数（varints）组成的blob，其中*N*是表中用户定义列的数量。“size”
    blob中的每个varint是FTS表相关行中相应列中的标记数。%_stat表始终包含一个“id”列设置为0的单行。“value”列包含一个由*N+1*个FTS变长整数组成的blob，其中*N*是FTS表中用户定义列的数量。blob中的第一个varint设置为FTS表中的总行数。blob中的第二个及后续varints包含FTS表所有行中对应列中存储的标记总数。
- en: 'The two remaining tables, %_segments and %_segdir, are used to store the full-text
    index. Conceptually, this index is a lookup table that maps each term (word) to
    the set of docid values corresponding to records in the %_content table that contain
    one or more occurrences of the term. To retrieve all documents that contain a
    specified term, the FTS module queries this index to determine the set of docid
    values for records that contain the term, then retrieves the required documents
    from the %_content table. Regardless of the schema of the FTS virtual table, the
    %_segments and %_segdir tables are always created as follows:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 余下的两个表，%_segments和%_segdir，用于存储全文索引。从概念上讲，此索引是一个查找表，将每个术语（单词）映射到%_content表中包含术语一次或多次出现的记录的docid值集合。为了检索包含特定术语的所有文档，FTS模块查询此索引以确定包含术语的记录的docid值集合，然后从%_content表中检索所需的文档。无论FTS虚拟表的架构如何，%_segments和%_segdir表总是按以下方式创建：
- en: '[PRE64]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The schema depicted above is not designed to store the full-text index directly.
    Instead, it is used to store one or more b-tree structures. There is one b-tree
    for each row in the %_segdir table. The %_segdir table row contains the root node
    and various meta-data associated with the b-tree structure, and the %_segments
    table contains all other (non-root) b-tree nodes. Each b-tree is referred to as
    a "segment". Once it has been created, a segment b-tree is never updated (although
    it may be deleted altogether).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 上述所示的模式并非直接设计用于直接存储全文索引。而是用于存储一个或多个B树结构。%_segdir表中每一行对应一个B树。%_segdir表行包含根节点和与B树结构相关的各种元数据，而%_segments表包含所有其他（非根）B树节点。每个B树称为一个“段”。创建后，段B树永不更新（尽管可以完全删除）。
- en: 'The keys used by each segment b-tree are terms (words). As well as the key,
    each segment b-tree entry has an associated "doclist" (document list). A doclist
    consists of zero or more entries, where each entry consists of:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 每个段B树使用的键是术语（单词）。除了键外，每个段B树条目还有一个关联的“doclist”（文档列表）。文档列表由零个或多个条目组成，其中每个条目包括：
- en: A docid (document id), and
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档ID（文档ID），以及
- en: A list of term offsets, one for each occurrence of the term within the document.
    A term offset indicates the number of tokens (words) that occur before the term
    in question, not the number of characters or bytes. For example, the term offset
    of the term "war" in the phrase "Ancestral voices prophesying war!" is 3.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 术语偏移列表，每个术语在文档中的每次出现都有一个。术语偏移表示在问题术语之前出现的标记（单词）数量，而不是字符或字节数量。例如，在短语“祖先的声音预言战争！”中，“战争”一词的术语偏移为3。
- en: Entries within a doclist are sorted by docid. Positions within a doclist entry
    are stored in ascending order.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 文档列表中的条目按文档ID排序。文档列表条目内的位置按升序存储。
- en: The contents of the logical full-text index is found by merging the contents
    of all segment b-trees. If a term is present in more than one segment b-tree,
    then it maps to the union of each individual doclist. If, for a single term, the
    same docid occurs in more than one doclist, then only the doclist that is part
    of the most recently created segment b-tree is considered valid.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑全文索引的内容通过合并所有段B树的内容来找到。如果一个术语在多个段B树中存在，则映射到每个单独文档列表的并集。对于单个术语，如果同一文档ID出现在多个文档列表中，则只考虑最近创建的段B树的文档列表有效。
- en: Multiple b-tree structures are used instead of a single b-tree to reduce the
    cost of inserting records into FTS tables. When a new record is inserted into
    an FTS table that already contains a lot of data, it is likely that many of the
    terms in the new record are already present in a large number of existing records.
    If a single b-tree were used, then large doclist structures would have to be loaded
    from the database, amended to include the new docid and term-offset list, then
    written back to the database. Using multiple b-tree tables allows this to be avoided
    by creating a new b-tree which can be merged with the existing b-tree (or b-trees)
    later on. Merging of b-tree structures can be performed as a background task,
    or once a certain number of separate b-tree structures have been accumulated.
    Of course, this scheme makes queries more expensive (as the FTS code may have
    to look up individual terms in more than one b-tree and merge the results), but
    it has been found that in practice this overhead is often negligible.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 用多个B树结构而不是单个B树来减少插入记录到FTS表中的成本。当向已包含大量数据的FTS表中插入新记录时，新记录中的许多术语可能已经存在于大量现有记录中。如果使用单个B树，则必须从数据库加载大的文档列表结构，修改以包含新的文档ID和术语偏移列表，然后写回数据库。使用多个B树表可以避免这种情况，方法是创建一个新的B树，稍后可以与现有的B树（或B树）合并。可以将B树结构的合并作为后台任务执行，或者一旦累积了一定数量的单独的B树结构就执行。当然，这种方案会使查询变得更加昂贵（因为FTS代码可能需要在多个B树中查找单个术语并合并结果），但实际上已经发现这种开销通常是可以忽略不计的。
- en: 9.2\. Variable Length Integer (varint) Format
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2\. 变长整数（varint）格式
- en: Integer values stored as part of segment b-tree nodes are encoded using the
    FTS varint format. This encoding is similar, but **not identical**, to the [SQLite
    varint format](fileformat2.html#varint).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 存储为段B-Tree节点的整数值使用FTS varint格式进行编码。该编码与SQLite varint格式不完全相同，但类似。
- en: An encoded FTS varint consumes between one and ten bytes of space. The number
    of bytes required is determined by the sign and magnitude of the integer value
    encoded. More accurately, the number of bytes used to store the encoded integer
    depends on the position of the most significant set bit in the 64-bit twos-complement
    representation of the integer value. Negative values always have the most significant
    bit set (the sign bit), and so are always stored using the full ten bytes. Positive
    integer values may be stored using less space.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 一个编码后的FTS varint占用一到十个字节的空间。所需的字节数取决于编码整数值的符号和大小。更确切地说，存储编码整数所需的字节数取决于整数值的64位二进制补码表示中最高设置位的位置。负值始终具有最高位设置（符号位），因此始终使用全部十个字节。正整数值可能使用更少的空间。
- en: 'The final byte of an encoded FTS varint has its most significant bit cleared.
    All preceding bytes have the most significant bit set. Data is stored in the remaining
    seven least significant bits of each byte. The first byte of the encoded representation
    contains the least significant seven bits of the encoded integer value. The second
    byte of the encoded representation, if it is present, contains the seven next
    least significant bits of the integer value, and so on. The following table contains
    examples of encoded integer values:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 一个编码后的FTS varint的最后一个字节的最高位被清除。所有前面的字节的最高位都被设置。数据存储在每个字节的剩余七个最低位中。编码表示的第一个字节包含编码整数值的最低的七位。如果存在第二个字节的编码表示，它包含整数值的接下来的七个最低位，依此类推。以下表格包含编码整数值的示例：
- en: '| Decimal | Hexadecimal | Encoded Representation |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| 十进制 | 十六进制 | 编码表示 |'
- en: '| 43 | 0x000000000000002B | 0x2B |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| 43 | 0x000000000000002B | 0x2B |'
- en: '| 200815 | 0x000000000003106F | 0xEF 0xA0 0x0C |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| 200815 | 0x000000000003106F | 0xEF 0xA0 0x0C |'
- en: '| -1 | 0xFFFFFFFFFFFFFFFF | 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0x01
    |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| -1 | 0xFFFFFFFFFFFFFFFF | 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0x01
    |'
- en: 9.3\. Segment B-Tree Format
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3\. 段B-Tree格式
- en: 'Segment b-trees are prefix-compressed b+-trees. There is one segment b-tree
    for each row in the %_segdir table (see above). The root node of the segment b-tree
    is stored as a blob in the "root" field of the corresponding row of the %_segdir
    table. All other nodes (if any exist) are stored in the "blob" column of the %_segments
    table. Nodes within the %_segments table are identified by the integer value in
    the blockid field of the corresponding row. The following table describes the
    fields of the %_segdir table:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 段B树是前缀压缩的B+树。%_segdir表中每行对应一个段B树（详见上文）。段B树的根节点以Blob形式存储在%_segdir表相应行的“root”字段中。所有其他节点（如果存在）存储在%_segments表的“blob”列中。%_segments表中的节点由相应行的blockid字段中的整数值标识。以下表格描述了%_segdir表的字段：
- en: '| Column | Interpretation |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| Column | Interpretation |'
- en: '| level | Between them, the contents of the "level" and "idx" fields define
    the relative age of the segment b-tree. The smaller the value stored in the "level"
    field, the more recently the segment b-tree was created. If two segment b-trees
    are of the same "level", the segment with the larger value stored in the "idx"
    column is more recent. The PRIMARY KEY constraint on the %_segdir table prevents
    any two segments from having the same value for both the "level" and "idx" fields.
    |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| level | "level"和"idx"字段的内容共同定义段B树的相对年龄。存储在“level”字段中的值越小，段B树创建时间越近。如果两个段B树的“level”相同，则在“idx”列中存储较大值的段更为新。%_segdir表上的PRIMARY
    KEY约束阻止任何两个段在“level”和“idx”字段上具有相同的值。 |'
- en: '| idx | See above. |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| idx | 请参见上文。 |'
- en: '| start_block | The blockid that corresponds to the node with the smallest
    blockid that belongs to this segment b-tree. Or zero if the entire segment b-tree
    fits on the root node. If it exists, this node is always a leaf node. |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| start_block | 对应于属于该段B树的具有最小块ID的节点的块ID。如果整个段B树适合根节点，则为零。如果存在，该节点始终是叶子节点。
    |'
- en: '| leaves_end_block | The blockid that corresponds to the leaf node with the
    largest blockid that belongs to this segment b-tree. Or zero if the entire segment
    b-tree fits on the root node. |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| leaves_end_block | 对应于具有最大块ID的叶节点的块ID，该节点属于该段B树。如果整个段B树适合根节点，则为零。 |'
- en: '| end_block | This field may contain either an integer or a text field consisting
    of two integers separated by a space character (unicode codepoint 0x20).The first,
    or only, integer is the blockid that corresponds to the interior node with the
    largest blockid that belongs to this segment b-tree. Or zero if the entire segment
    b-tree fits on the root node. If it exists, this node is always an interior node.The
    second integer, if it is present, is the aggregate size of all data stored on
    leaf pages in bytes. If the value is negative, then the segment is the output
    of an unfinished incremental-merge operation, and the absolute value is current
    size in bytes. |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| end_block | 此字段可以包含整数或由空格字符（Unicode代码点0x20）分隔的两个整数组成的文本字段。第一个或唯一的整数是与该段B树中具有最大块ID的内部节点对应的块ID。如果整个段B树适合根节点，则为零。如果存在，该节点始终是内部节点。如果存在第二个整数，则为叶页中存储的所有数据的总大小（以字节为单位）。如果值为负数，则段是未完成增量合并操作的输出，并且绝对值是当前以字节为单位的大小。
    |'
- en: '| root | Blob containing the root node of the segment b-tree. |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| root | 包含段B树根节点的Blob。 |'
- en: Apart from the root node, the nodes that make up a single segment b-tree are
    always stored using a contiguous sequence of blockids. Furthermore, the nodes
    that make up a single level of the b-tree are themselves stored as a contiguous
    block, in b-tree order. The contiguous sequence of blockids used to store the
    b-tree leaves are allocated starting with the blockid value stored in the "start_block"
    column of the corresponding %_segdir row, and finishing at the blockid value stored
    in the "leaves_end_block" field of the same row. It is therefore possible to iterate
    through all the leaves of a segment b-tree, in key order, by traversing the %_segments
    table in blockid order from "start_block" to "leaves_end_block".
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 除了根节点外，组成单个段B树的节点始终使用连续的块ID序列存储。此外，组成B树单个级别的节点本身按B树顺序存储为连续块。用于存储B树叶子节点的连续块ID序列从相应的%_segdir行的“start_block”列中存储的块ID值开始分配，并在同一行的“leaves_end_block”字段中存储的块ID值结束。因此，通过按块ID顺序从“start_block”到“leaves_end_block”遍历%_segments表，可以按键顺序迭代段B树的所有叶子节点。
- en: 9.3.1\. Segment B-Tree Leaf Nodes
  id: totrans-386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.1\. 段B树叶节点
- en: The following diagram depicts the format of a segment b-tree leaf node.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了段B树叶子节点的格式。
- en: '![](../Images/3569763fbfe879eb171b338fc76bf4d6.png)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3569763fbfe879eb171b338fc76bf4d6.png)'
- en: Segment B-Tree Leaf Node Format
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 段B树叶子节点格式
- en: The first term stored on each node ("Term 1" in the figure above) is stored
    verbatim. Each subsequent term is prefix-compressed with respect to its predecessor.
    Terms are stored within a page in sorted (memcmp) order.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点上存储的第一个术语（上图中的"Term 1"）都是原样存储的。每个后续术语都相对于前一个进行了前缀压缩。术语按照排序（memcmp）顺序存储在页面内。
- en: 9.3.2\. Segment B-Tree Interior Nodes
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.2\. 段B树内部节点
- en: The following diagram depicts the format of a segment b-tree interior (non-leaf)
    node.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了段B树内部（非叶子）节点的格式。
- en: '![](../Images/b1ff44614c88bafdffa674afdb56fed0.png)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b1ff44614c88bafdffa674afdb56fed0.png)'
- en: Segment B-Tree Interior Node Format
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 段B树内部节点格式
- en: 9.4\. Doclist Format
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4\. 文档列表格式
- en: 'A doclist consists of an array of 64-bit signed integers, serialized using
    the FTS varint format. Each doclist entry is made up of a series of two or more
    integers, as follows:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 文档列表由使用FTS varint格式序列化的64位有符号整数数组组成。每个文档列表条目由两个或更多整数组成，如下：
- en: The docid value. The first entry in a doclist contains the literal docid value.
    The first field of each subsequent doclist entry contains the difference between
    the new docid and the previous one (always a positive number).
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: docid值。文档列表中的第一个条目包含字面的docid值。每个后续文档列表条目的第一个字段包含新docid与前一个的差值（始终为正数）。
- en: 'Zero or more term-offset lists. A term-offset list is present for each column
    of the FTS virtual table that contains the term. A term-offset list consists of
    the following:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 零个或多个术语偏移列表。每个FTS虚拟表的列包含术语的术语偏移列表。术语偏移列表包含以下内容：
- en: Constant value 1\. This field is omitted for any term-offset list associated
    with column 0.
  id: totrans-399
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 常量值1。对于与列0关联的任何术语偏移列表，此字段被省略。
- en: The column number (1 for the second leftmost column, etc.). This field is omitted
    for any term-offset list associated with column 0.
  id: totrans-400
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列号（第二个最左列为1，依此类推）。对于与列0关联的任何术语偏移列表，此字段被省略。
- en: A list of term-offsets, sorted from smallest to largest. Instead of storing
    the term-offset value literally, each integer stored is the difference between
    the current term-offset and the previous one (or zero if the current term-offset
    is the first), plus 2.
  id: totrans-401
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一列术语偏移列表，从最小到最大排序。每个存储的整数不是直接存储术语偏移值，而是当前术语偏移与前一个的差（如果当前术语偏移是第一个则为零），再加上2。
- en: Constant value 0.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 常量值0。
- en: '![](../Images/8bb73ce4f82564c8acfe7a618932bae0.png)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8bb73ce4f82564c8acfe7a618932bae0.png)'
- en: FTS3 Doclist Format
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: FTS3文档列表格式
- en: '![](../Images/8939947ade48c28fa4744a6e5363ee12.png)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8939947ade48c28fa4744a6e5363ee12.png)'
- en: FTS Doclist Entry Format
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: FTS文档列表条目格式
- en: For doclists for which the term appears in more than one column of the FTS virtual
    table, term-offset lists within the doclist are stored in column number order.
    This ensures that the term-offset list associated with column 0 (if any) is always
    first, allowing the first two fields of the term-offset list to be omitted in
    this case.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在FTS虚拟表的多个列中出现术语的文档列表，文档列表中的术语偏移列表按照列号顺序存储。这确保了与列0关联的术语偏移列表（如果有）始终位于第一位，允许在这种情况下省略术语偏移列表的前两个字段。
- en: 10\. Limitations
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10\. 限制
- en: 10.1\. UTF-16 byte-order-mark problem
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1\. UTF-16字节顺序标记问题
- en: 'For UTF-16 databases, when using the "simple" tokenizer, it is possible to
    use malformed unicode strings to cause the [integrity-check special command](#integcheck)
    to falsely report corruption, or for [auxiliary functions](#snippet) to return
    incorrect results. More specifically, the bug can be triggered by any of the following:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 对于UTF-16数据库，在使用"simple"分词器时，可能会使用格式不正确的Unicode字符串来导致[integrity-check特殊命令](#integcheck)错误地报告损坏，或者使[辅助函数](#snippet)返回不正确的结果。具体来说，这个漏洞可能由以下任何一种触发：
- en: 'A UTF-16 byte-order-mark (BOM) is embedded at the beginning of an SQL string
    literal value inserted into an FTS3 table. For example:'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UTF-16字节顺序标记（BOM）嵌入在插入到FTS3表的SQL字符串字面值的开头。例如：
- en: '[PRE65]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Malformed UTF-8 that SQLite converts to a UTF-16 byte-order-mark is embedded
    at the beginning of an SQL string literal value inserted into an FTS3 table.
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite转换为UTF-16字节顺序标记的格式不正确的UTF-8嵌入在插入到FTS3表中的SQL字符串字面值的开头。
- en: 'A text value created by casting a blob that begins with the two bytes 0xFF
    and 0xFE, in either possible order, is inserted into an FTS3 table. For example:'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过以任意顺序开始的以0xFF和0xFE两字节开头的blob进行转换而创建的文本值插入到FTS3表中。例如：
- en: '[PRE66]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Everything works correctly if any of the following are true:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 如果满足以下任一条件，则一切都能正常工作：
- en: The [database encoding](pragma.html#pragma_encoding) is UTF-8.
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数据库编码](pragma.html#pragma_encoding)为UTF-8。'
- en: All text strings are insert using one of the [sqlite3_bind_text()](c3ref/bind_blob.html)
    family of functions.
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有文本字符串均使用[sqlite3_bind_text()](c3ref/bind_blob.html)函数族中的一个进行插入。
- en: Literal strings contain no byte-order-marks.
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本字符串中不含有字节顺序标记。
- en: A tokenizer is used that recognizes byte-order-marks as whitespace. (The default
    "simple" tokenizer for FTS3/4 does not think that BOMs are whitespace, but the
    unicode tokenizer does.)
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用能识别字节顺序标记（BOM）作为空白的分词器（FTS3/4的默认“simple”分词器认为BOM不是空白，但Unicode分词器是这么认为的）。
- en: All of the above conditions must be false in order for problems to occur. And
    even if all of the conditiona above are false, most things will still operator
    correctly. Only the [integrity-check](#integcheck) command and the [auxiliary
    functions](#snippet) might given unexpected results.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 要发生问题，以上所有条件都必须为假。即使以上所有条件都为假，大多数事物仍将正确运行。只有[integrity-check](#integcheck)命令和[辅助函数](#snippet)可能会产生意外结果。
- en: 'Appendix A: Search Application Tips'
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录A：搜索应用技巧
- en: FTS is primarily designed to support Boolean full-text queries - queries to
    find the set of documents that match a specified criteria. However, many (most?)
    search applications require that results are somehow ranked in order of "relevance",
    where "relevance" is defined as the likelihood that the user who performed the
    search is interested in a specific element of the returned set of documents. When
    using a search engine to find documents on the world wide web, the user expects
    that the most useful, or "relevant", documents will be returned as the first page
    of results, and that each subsequent page contains progressively less relevant
    results. Exactly how a machine can determine document relevance based on a users
    query is a complicated problem and the subject of much ongoing research.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: FTS主要设计用于支持布尔全文查询 - 查询以查找满足指定条件的文档集。然而，许多（大多数？）搜索应用程序要求结果以某种方式按“相关性”排序，其中“相关性”定义为执行搜索的用户对返回的文档集中特定元素感兴趣的可能性。在使用搜索引擎在全球网络上查找文档时，用户期望最有用或“相关”的文档作为第一页的结果返回，每个后续页面包含的结果越来越不相关。如何基于用户的查询确定文档相关性是一个复杂的问题，也是当前许多研究的主题。
- en: 'One very simple scheme might be to count the number of instances of the users
    search terms in each result document. Those documents that contain many instances
    of the terms are considered more relevant than those with a small number of instances
    of each term. In an FTS application, the number of term instances in each result
    could be determined by counting the number of integers in the return value of
    the [offsets](fts3.html#offsets) function. The following example shows a query
    that could be used to obtain the ten most relevant results for a query entered
    by the user:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常简单的方案可能是计算每个结果文档中用户搜索词项的实例数量。包含许多词项实例的文档被认为比每个词项实例较少的文档更相关。在FTS应用中，可以通过计算[offsets](fts3.html#offsets)函数返回值中整数的数量来确定每个结果中的词项实例数量。以下示例显示了可用于获取用户输入查询的十个最相关结果的查询：
- en: '[PRE67]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The query above could be made to run faster by using the FTS [matchinfo](fts3.html#matchinfo)
    function to determine the number of query term instances that appear in each result.
    The matchinfo function is much more efficient than the offsets function. Furthermore,
    the matchinfo function provides extra information regarding the overall number
    of occurrences of each query term in the entire document set (not just the current
    row) and the number of documents in which each query term appears. This may be
    used (for example) to attach a higher weight to less common terms which may increase
    the overall computed relevancy of those results the user considers more interesting.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询可以通过使用FTS [matchinfo](fts3.html#matchinfo)函数来加速运行，以确定每个结果中出现的查询词项实例的数量。Matchinfo函数比offsets函数更高效。此外，matchinfo函数还提供了额外的信息，包括每个查询词项在整个文档集合中（而不仅仅是当前行）中出现的总次数以及出现每个查询词项的文档数。这可以（例如）用于给较少常见的词项附加更高的权重，从而增加用户认为更有趣的结果的整体计算相关性。
- en: '[PRE68]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The SQL query in the example above uses less CPU than the first example in this
    section, but still has a non-obvious performance problem. SQLite satisfies this
    query by retrieving the value of the "title" column and matchinfo data from the
    FTS module for every row matched by the users query before it sorts and limits
    the results. Because of the way SQLite's virtual table interface works, retrieving
    the value of the "title" column requires loading the entire row from disk (including
    the "content" field, which may be quite large). This means that if the users query
    matches several thousand documents, many megabytes of "title" and "content" data
    may be loaded from disk into memory even though they will never be used for any
    purpose.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中的 SQL 查询比本节开头的第一个示例使用的 CPU 较少，但仍然存在一个不明显的性能问题。SQLite 在排序和限制结果之前，为每个与用户查询匹配的行从
    FTS 模块中检索“title”列的值和 matchinfo 数据。由于 SQLite 虚拟表接口的工作方式，从磁盘加载“title”列的值需要加载整个行（包括可能非常大的“content”字段）。这意味着，如果用户的查询匹配了数千个文档，可能会从磁盘加载许多兆字节的“title”和“content”数据到内存中，尽管它们将永远不会被用于任何目的。
- en: The SQL query in the following example block is one solution to this problem.
    In SQLite, when a [sub-query used in a join contains a LIMIT clause](optoverview.html#flattening),
    the results of the sub-query are calculated and stored in temporary table before
    the main query is executed. This means that SQLite will load only the docid and
    matchinfo data for each row matching the users query into memory, determine the
    docid values corresponding to the ten most relevant documents, then load only
    the title and content information for those 10 documents only. Because both the
    matchinfo and docid values are gleaned entirely from the full-text index, this
    results in dramatically less data being loaded from the database into memory.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 下面示例块中的 SQL 查询是此问题的一种解决方案。在 SQLite 中，当联接中的子查询包含 LIMIT 子句时，子查询的结果会被计算并存储在临时表中，然后执行主查询。这意味着
    SQLite 只会将与用户查询匹配的每行的 docid 和 matchinfo 数据加载到内存中，确定与十个最相关文档对应的 docid 值，然后仅加载这十个文档的
    title 和 content 信息。由于 matchinfo 和 docid 值完全来自全文索引，因此从数据库加载到内存中的数据显著减少。
- en: '[PRE69]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The next block of SQL enhances the query with solutions to two other problems
    that may arise in developing search applications using FTS:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 下一块 SQL 代码增强了查询，在开发使用 FTS 的搜索应用程序时解决了其他两个可能出现的问题：
- en: The [snippet](fts3.html#snippet) function cannot be used with the above query.
    Because the outer query does not include a "WHERE ... MATCH" clause, the snippet
    function may not be used with it. One solution is to duplicate the WHERE clause
    used by the sub-query in the outer query. The overhead associated with this is
    usually negligible.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不能与上述查询一起使用 [snippet](fts3.html#snippet) 函数。因为外部查询不包括“WHERE ... MATCH”子句，所以不能使用
    snippet 函数。一个解决方案是在外部查询中复制子查询使用的 WHERE 子句。与此相关的开销通常是可以忽略不计的。
- en: The relevancy of a document may depend on something other than just the data
    available in the return value of matchinfo. For example each document in the database
    may be assigned a static weight based on factors unrelated to its content (origin,
    author, age, number of references etc.). These values can be stored by the application
    in a separate table that can be joined against the documents table in the sub-query
    so that the rank function may access them.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文档的相关性可能不仅仅取决于 matchinfo 返回值中可用的数据。例如，数据库中的每个文档可能会根据与其内容无关的因素（来源、作者、年龄、引用次数等）分配静态权重。这些值可以由应用程序存储在一个单独的表中，并在子查询中与文档表进行联接，以便排名函数可以访问它们。
- en: This version of the query is very similar to that used by the [sqlite.org documentation
    search](https://www.sqlite.org/search?q=fts3) application.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询版本与 [sqlite.org 文档搜索](https://www.sqlite.org/search?q=fts3) 应用程序使用的查询非常相似。
- en: '[PRE70]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: All the example queries above return the ten most relevant query results. By
    modifying the values used with the OFFSET and LIMIT clauses, a query to return
    (say) the next ten most relevant results is easy to construct. This may be used
    to obtain the data required for a search applications second and subsequent pages
    of results.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 所有上面的示例查询返回十个最相关的查询结果。通过修改与 OFFSET 和 LIMIT 子句一起使用的值，可以轻松构建一个查询来返回（例如）下一个十个最相关的结果。这可以用于获取搜索应用程序第二页及后续页面所需的数据。
- en: The next block contains an example rank function that uses matchinfo data implemented
    in C. Instead of a single weight, it allows a weight to be externally assigned
    to each column of each document. It may be registered with SQLite like any other
    user function using [sqlite3_create_function](c3ref/create_function.html).
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 下一块内容包含一个示例 rank 函数，它使用了在 C 中实现的 matchinfo 数据。与单一权重不同的是，它允许将权重外部分配给每个文档的每一列。它可以像任何其他用户函数一样使用
    [sqlite3_create_function](c3ref/create_function.html) 在 SQLite 中注册。
- en: '**Security Warning:** Because it is just an ordinary SQL function, rank() may
    be invoked as part of any SQL query in any context. This means that the first
    argument passed may not be a valid matchinfo blob. Implementors should take care
    to handle this case without causing buffer overruns or other potential security
    problems.'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全警告：** 因为它只是一个普通的 SQL 函数，rank() 可以作为任何上下文中任何 SQL 查询的一部分被调用。这意味着传递的第一个参数可能不是有效的
    matchinfo blob。实现者应当小心处理这种情况，以避免造成缓冲区溢出或其他潜在的安全问题。'
- en: '[PRE71]</integer></language-id>'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE71]</integer></language-id>'
