- en: 'A.5 MySQL 8.0 FAQ: Triggers'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'A.5 MySQL 8.0 FAQ: Triggers'
- en: 原文：[https://dev.mysql.com/doc/refman/8.0/en/faqs-triggers.html](https://dev.mysql.com/doc/refman/8.0/en/faqs-triggers.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://dev.mysql.com/doc/refman/8.0/en/faqs-triggers.html](https://dev.mysql.com/doc/refman/8.0/en/faqs-triggers.html)
- en: A.5.1\. [Where can I find the documentation for MySQL 8.0 triggers?](faqs-triggers.html#faq-mysql-where-triggers-docs)
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: A.5.1\. [我在哪里可以找到 MySQL 8.0 触发器的文档？](faqs-triggers.html#faq-mysql-where-triggers-docs)
- en: A.5.2\. [Is there a discussion forum for MySQL Triggers?](faqs-triggers.html#faq-mysql-where-triggers-forum)
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: A.5.2\. [是否有关于 MySQL 触发器的讨论论坛？](faqs-triggers.html#faq-mysql-where-triggers-forum)
- en: A.5.3\. [Does MySQL 8.0 have statement-level or row-level triggers?](faqs-triggers.html#faq-mysql-have-trigger-levels)
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: A.5.3\. [MySQL 8.0 是否具有语句级触发器还是行级触发器？](faqs-triggers.html#faq-mysql-have-trigger-levels)
- en: A.5.4\. [Are there any default triggers?](faqs-triggers.html#faq-mysql-have-trigger-defaults)
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: A.5.4\. [是否有任何默认触发器？](faqs-triggers.html#faq-mysql-have-trigger-defaults)
- en: A.5.5\. [How are triggers managed in MySQL?](faqs-triggers.html#faq-mysql-how-triggers-managed)
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: A.5.5\. [MySQL 中的触发器是如何管理的？](faqs-triggers.html#faq-mysql-how-triggers-managed)
- en: A.5.6\. [Is there a way to view all triggers in a given database?](faqs-triggers.html#faq-mysql-can-view-all-triggers)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: A.5.6\. [是否有一种方法可以查看给定数据库中的所有触发器？](faqs-triggers.html#faq-mysql-can-view-all-triggers)
- en: A.5.7\. [Where are triggers stored?](faqs-triggers.html#faq-mysql-how-triggers-stored)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: A.5.7\. [触发器存储在哪里？](faqs-triggers.html#faq-mysql-how-triggers-stored)
- en: A.5.8\. [Can a trigger call a stored procedure?](faqs-triggers.html#faq-mysql-can-trigger-procedure)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: A.5.8\. [触发器是否可以调用存储过程？](faqs-triggers.html#faq-mysql-can-trigger-procedure)
- en: A.5.9\. [Can triggers access tables?](faqs-triggers.html#faq-mysql-can-triggers-tables)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: A.5.9\. [触发器是否可以访问表？](faqs-triggers.html#faq-mysql-can-triggers-tables)
- en: A.5.10\. [Can a table have multiple triggers with the same trigger event and
    action time?](faqs-triggers.html#faq-mysql-can-triggers-same-events)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: A.5.10\. [一个表是否可以有多个具有相同触发器事件和操作时间的触发器？](faqs-triggers.html#faq-mysql-can-triggers-same-events)
- en: A.5.11\. [Is it possible for a trigger to update tables on a remote server?](faqs-triggers.html#faq-mysql-can-triggers-remote)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: A.5.11\. [触发器是否可以更新远程服务器上的表？](faqs-triggers.html#faq-mysql-can-triggers-remote)
- en: A.5.12\. [Do triggers work with replication?](faqs-triggers.html#faq-mysql-can-triggers-replication)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: A.5.12\. [触发器是否与复制一起工作？](faqs-triggers.html#faq-mysql-can-triggers-replication)
- en: A.5.13\. [How are actions carried out through triggers on a source replicated
    to a replica?](faqs-triggers.html#faq-mysql-how-triggers-source-replica)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: A.5.13\. [如何通过触发器在源上执行的操作传递到副本上？](faqs-triggers.html#faq-mysql-how-triggers-source-replica)
- en: '| **A.5.1.** | Where can I find the documentation for MySQL 8.0 triggers? |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| **A.5.1.** | 我在哪里可以找到 MySQL 8.0 触发器的文档？ |'
- en: '|  | See [Section 27.3, “Using Triggers”](triggers.html "27.3 Using Triggers").
    |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '|  | 参见 [Section 27.3, “Using Triggers”](triggers.html "27.3 Using Triggers")。
    |'
- en: '| **A.5.2.** | Is there a discussion forum for MySQL Triggers? |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| **A.5.2.** | 是否有关于 MySQL 触发器的讨论论坛？ |'
- en: '|  | Yes. It is available at [https://forums.mysql.com/list.php?99](https://forums.mysql.com/list.php?99).
    |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '|  | 是的。可在 [https://forums.mysql.com/list.php?99](https://forums.mysql.com/list.php?99)
    找到。 |'
- en: '| **A.5.3.** | Does MySQL 8.0 have statement-level or row-level triggers? |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| **A.5.3.** | MySQL 8.0 是否具有语句级触发器还是行级触发器？ |'
- en: '|  | In MySQL 8.0, all triggers are `FOR EACH ROW`; that is, the trigger is
    activated for each row that is inserted, updated, or deleted. MySQL 8.0 does not
    support triggers using `FOR EACH STATEMENT`. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '|  | 在 MySQL 8.0 中，所有触发器都是`FOR EACH ROW`；也就是说，触发器会在每插入、更新或删除的行上被激活。MySQL 8.0
    不支持使用`FOR EACH STATEMENT`的触发器。 |'
- en: '| **A.5.4.** | Are there any default triggers? |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| **A.5.4.** | 是否有任何默认触发器？ |'
- en: '|  | Not explicitly. MySQL does have specific special behavior for some [`TIMESTAMP`](datetime.html
    "13.2.2 The DATE, DATETIME, and TIMESTAMP Types") columns, as well as for columns
    which are defined using `AUTO_INCREMENT`. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|  | 并非明确。MySQL 对于一些特定的[`TIMESTAMP`](datetime.html "13.2.2 The DATE, DATETIME,
    and TIMESTAMP Types")列，以及使用`AUTO_INCREMENT`定义的列有特殊行为。 |'
- en: '| **A.5.5.** | How are triggers managed in MySQL? |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| **A.5.5.** | MySQL 中的触发器是如何管理的？ |'
- en: '|  | In MySQL 8.0, triggers can be created using the [`CREATE TRIGGER`](create-trigger.html
    "15.1.22 CREATE TRIGGER Statement") statement, and dropped using [`DROP TRIGGER`](drop-trigger.html
    "15.1.34 DROP TRIGGER Statement"). See [Section 15.1.22, “CREATE TRIGGER Statement”](create-trigger.html
    "15.1.22 CREATE TRIGGER Statement"), and [Section 15.1.34, “DROP TRIGGER Statement”](drop-trigger.html
    "15.1.34 DROP TRIGGER Statement"), for more about these statements.Information
    about triggers can be obtained by querying the [`INFORMATION_SCHEMA.TRIGGERS`](information-schema-triggers-table.html
    "28.3.45 The INFORMATION_SCHEMA TRIGGERS Table") table. See [Section 28.3.45,
    “The INFORMATION_SCHEMA TRIGGERS Table”](information-schema-triggers-table.html
    "28.3.45 The INFORMATION_SCHEMA TRIGGERS Table"). |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '|  | 在 MySQL 8.0 中，可以使用[`CREATE TRIGGER`](create-trigger.html "15.1.22 CREATE
    TRIGGER Statement")语句创建触发器，并使用[`DROP TRIGGER`](drop-trigger.html "15.1.34 DROP
    TRIGGER Statement")删除触发器。有关这些语句的更多信息，请参见[第 15.1.22 节，“CREATE TRIGGER Statement”](create-trigger.html
    "15.1.22 CREATE TRIGGER Statement")和[第 15.1.34 节，“DROP TRIGGER Statement”](drop-trigger.html
    "15.1.34 DROP TRIGGER Statement")。可以通过查询[`INFORMATION_SCHEMA.TRIGGERS`](information-schema-triggers-table.html
    "28.3.45 INFORMATION_SCHEMA TRIGGERS Table")表来获取有关触发器的信息。请参见[第 28.3.45 节，“INFORMATION_SCHEMA
    TRIGGERS Table”](information-schema-triggers-table.html "28.3.45 INFORMATION_SCHEMA
    TRIGGERS Table")。 |'
- en: '| **A.5.6.** | Is there a way to view all triggers in a given database? |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| **A.5.6.** | 有没有办法查看给定数据库中的所有触发器？ |'
- en: '|  | Yes. You can obtain a listing of all triggers defined on database `dbname`
    using a query on the [`INFORMATION_SCHEMA.TRIGGERS`](information-schema-triggers-table.html
    "28.3.45 The INFORMATION_SCHEMA TRIGGERS Table") table such as the one shown here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '|  | 是的。您可以使用对[`INFORMATION_SCHEMA.TRIGGERS`](information-schema-triggers-table.html
    "28.3.45 INFORMATION_SCHEMA TRIGGERS Table")表的查询来获取在数据库`dbname`上定义的所有触发器的列表，例如下面显示的查询：'
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For more information about this table, see [Section 28.3.45, “The INFORMATION_SCHEMA
    TRIGGERS Table”](information-schema-triggers-table.html "28.3.45 The INFORMATION_SCHEMA
    TRIGGERS Table").You can also use the [`SHOW TRIGGERS`](show-triggers.html "15.7.7.40 SHOW
    TRIGGERS Statement") statement, which is specific to MySQL. See [Section 15.7.7.40,
    “SHOW TRIGGERS Statement”](show-triggers.html "15.7.7.40 SHOW TRIGGERS Statement").
    |
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此表格的更多信息，请参见[第 28.3.45 节，“INFORMATION_SCHEMA TRIGGERS Table”](information-schema-triggers-table.html
    "28.3.45 INFORMATION_SCHEMA TRIGGERS Table")。您还可以使用[`SHOW TRIGGERS`](show-triggers.html
    "15.7.7.40 SHOW TRIGGERS Statement")语句，该语句专用于 MySQL。请参见[第 15.7.7.40 节，“SHOW TRIGGERS
    Statement”](show-triggers.html "15.7.7.40 SHOW TRIGGERS Statement")。 |
- en: '| **A.5.7.** | Where are triggers stored? |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| **A.5.7.** | 触发器存储在哪里？ |'
- en: '|  | Triggers are stored in the `mysql.triggers` system table, which is part
    of the data dictionary. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '|  | 触发器存储在`mysql.triggers`系统表中，该表是数据字典的一部分。 |'
- en: '| **A.5.8.** | Can a trigger call a stored procedure? |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| **A.5.8.** | 触发器可以调用存储过程吗��� |'
- en: '|  | Yes. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '|  | 是的。 |'
- en: '| **A.5.9.** | Can triggers access tables? |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| **A.5.9.** | 触发器可以访问表吗？ |'
- en: '|  | A trigger can access both old and new data in its own table. A trigger
    can also affect other tables, but it is not permitted to modify a table that is
    already being used (for reading or writing) by the statement that invoked the
    function or trigger. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '|  | 触发器可以访问其自己表中的旧数据和新数据。触发器还可以影响其他表，但不允许修改已被调用函数或触发器的语句正在使用（读取或写入）的表。 |'
- en: '| **A.5.10.** | Can a table have multiple triggers with the same trigger event
    and action time? |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| **A.5.10.** | 表格可以具有具有相同触发事件和操作时间的多个触发器吗？ |'
- en: '|  | In MySQL 8.0, it is possible to define multiple triggers for a given table
    that have the same trigger event and action time. For example, you can have two
    `BEFORE UPDATE` triggers for a table. By default, triggers that have the same
    trigger event and action time activate in the order they were created. To affect
    trigger order, specify a clause after `FOR EACH ROW` that indicates `FOLLOWS`
    or `PRECEDES` and the name of an existing trigger that also has the same trigger
    event and action time. With `FOLLOWS`, the new trigger activates after the existing
    trigger. With `PRECEDES`, the new trigger activates before the existing trigger.
    |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '|  | 在 MySQL 8.0 中，可以为给定表定义具有相同触发事件和操作时间的多个触发器。例如，您可以为表定义两个`BEFORE UPDATE`触发器。默认情况下，具有相同触发事件和操作时间的触发器按创建顺序激活。要影响触发器顺序，请在`FOR
    EACH ROW`之后指定一个子句，指示`FOLLOWS`或`PRECEDES`以及具有相同触发事件和操作时间的现有触发器的名称。使用`FOLLOWS`，新触发器在现有触发器之后激活。使用`PRECEDES`，新触发器在现有触发器之前激活。
    |'
- en: '| **A.5.11.** | Is it possible for a trigger to update tables on a remote server?
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| **A.5.11.** | 触发器是否可以更新远程服务器上的表？ |'
- en: '|  | Yes. A table on a remote server could be updated using the `FEDERATED`
    storage engine. (See [Section 18.8, “The FEDERATED Storage Engine”](federated-storage-engine.html
    "18.8 The FEDERATED Storage Engine")). |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '|  | 是的。可以使用 `FEDERATED` 存储引擎更新远程服务器上的表（参见 [第 18.8 节，“FEDERATED 存储引擎”](federated-storage-engine.html
    "18.8 The FEDERATED Storage Engine")）。 |'
- en: '| **A.5.12.** | Do triggers work with replication? |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **A.5.12.** | 触发器与复制一起工作吗？ |'
- en: '|  | Yes. However, the way in which they work depends whether you are using
    MySQL''s “classic” statement-based or row-based replication format.When using
    statement-based replication, triggers on the replica are executed by statements
    that are executed on the source (and replicated to the replica).When using row-based
    replication, triggers are not executed on the replica due to statements that were
    run on the source and then replicated to the replica. Instead, when using row-based
    replication, the changes caused by executing the trigger on the source are applied
    on the replica.For more information, see [Section 19.5.1.36, “Replication and
    Triggers”](replication-features-triggers.html "19.5.1.36 Replication and Triggers").
    |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '|  | 是的。然而，它们的工作方式取决于您是使用 MySQL 的“经典”基于语句还是基于行的复制格式。当使用基于语句的复制时，在复制品上执行触发器是由在源上执行的语句执行的（并复制到复制品）。当使用基于行的复制时，由于在源上运行然后复制到复制品的语句，触发器不会在复制品上执行。相反，当使用基于行的复制时，源上执行触发器引起的更改会应用于复制品。有关更多信息，请参见
    [第 19.5.1.36 节，“复制和触发器”](replication-features-triggers.html "19.5.1.36 Replication
    and Triggers")。 |'
- en: '| **A.5.13.** | How are actions carried out through triggers on a source replicated
    to a replica? |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| **A.5.13.** | 通过源上的触发器执行的操作如何复制到复制品？ |'
- en: '|  | Again, this depends on whether you are using statement-based or row-based
    replication.**Statement-based replication. ** First, the triggers that exist on
    a source must be re-created on the replica server. Once this is done, the replication
    flow works as any other standard DML statement that participates in replication.
    For example, consider a table `EMP` that has an `AFTER` insert trigger, which
    exists on a replication source server. The same `EMP` table and `AFTER` insert
    trigger exist on the replica server as well. The replication flow would be:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '|  | 再次，这取决于您是使用基于语句还是基于行的复制。**基于语句的复制。** 首先，源上存在的触发器必须在复制品服务器上重新创建。完成此操作后，复制流程就像参与复制的任何其他标准
    DML 语句一样工作。例如，考虑一个具有在复制源服务器上存在的 `AFTER` 插入触发器的 `EMP` 表。在复制品服务器上也存在相同的 `EMP` 表和
    `AFTER` 插入触发器。复制流程将是：'
- en: An [`INSERT`](insert.html "15.2.7 INSERT Statement") statement is made to `EMP`.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `EMP` 进行了 [`INSERT`](insert.html "15.2.7 INSERT Statement") 语句。
- en: The `AFTER` trigger on `EMP` activates.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`EMP` 上的 `AFTER` 触发器被激活。'
- en: The [`INSERT`](insert.html "15.2.7 INSERT Statement") statement is written to
    the binary log.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[`INSERT`](insert.html "15.2.7 INSERT Statement") 语句被写入二进制日志。'
- en: The replica picks up the [`INSERT`](insert.html "15.2.7 INSERT Statement") statement
    to `EMP` and executes it.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制品捡起 [`INSERT`](insert.html "15.2.7 INSERT Statement") 语句到 `EMP` 并执行它。
- en: The `AFTER` trigger on `EMP` that exists on the replica activates.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制品上存在的 `EMP` 上的 `AFTER` 触发器被激活。
- en: '**Row-based replication. ** When you use row-based replication, the changes
    caused by executing the trigger on the source are applied on the replica. However,
    the triggers themselves are not actually executed on the replica under row-based
    replication. This is because, if both the source and the replica applied the changes
    from the source and, in addition, the trigger causing these changes were applied
    on the replica, the changes would in effect be applied twice on the replica, leading
    to different data on the source and the replica.In most cases, the outcome is
    the same for both row-based and statement-based replication. However, if you use
    different triggers on the source and replica, you cannot use row-based replication.
    (This is because the row-based format replicates the changes made by triggers
    executing on the source to the replicas, rather than the statements that caused
    the triggers to execute, and the corresponding triggers on the replica are not
    executed.) Instead, any statements causing such triggers to be executed must be
    replicated using statement-based replication.For more information, see [Section 19.5.1.36,
    “Replication and Triggers”](replication-features-triggers.html "19.5.1.36 Replication
    and Triggers"). |'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于行的复制。** 当您使用基于行的复制时，源上执行触发器引起的更改会应用到副本上。然而，在基于行的复制下，触发器本身实际上不会在副本上执行。这是因为，如果源和副本都应用了源上的更改，并且触发这些更改的触发器在副本上也被应用，那么这些更改实际上会在副本上应用两次，导致源和副本上的数据不同。在大多数情况下，基于行和基于语句的复制的结果是相同的。然而，如果您在源和副本上使用不同的触发器，则无法使用基于行的复制。（这是因为基于行的格式将在源上执行的触发器引起的更改复制到副本上，而不是导致触发器执行的语句，副本上对应的触发器也不会被执行。）相反，导致这些触发器被执行的任何语句必须使用基于语句的复制进行复制。有关更多信息，请参见[Section 19.5.1.36,
    “Replication and Triggers”](replication-features-triggers.html "19.5.1.36 Replication
    and Triggers"). |'
