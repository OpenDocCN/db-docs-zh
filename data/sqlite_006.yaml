- en: 1\. Introduction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1\. 引言
- en: 原文：[https://sqlite.com/testing.html](https://sqlite.com/testing.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://sqlite.com/testing.html](https://sqlite.com/testing.html)
- en: The reliability and robustness of SQLite is achieved in part by thorough and
    careful testing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 的可靠性和健壮性部分得益于彻底和谨慎的测试。
- en: As of [version 3.42.0](releaselog/3_42_0.html) (2023-05-16), the SQLite library
    consists of approximately 155.8 KSLOC of C code. (KSLOC means thousands of "Source
    Lines Of Code" or, in other words, lines of code excluding blank lines and comments.)
    By comparison, the project has 590 times as much test code and test scripts -
    92053.1 KSLOC.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 [版本 3.42.0](releaselog/3_42_0.html)（2023-05-16），SQLite 库大约由155.8 KSLOC的 C
    代码组成。（KSLOC 意为千行源代码，即不包括空白行和注释的代码行数。）相比之下，项目的测试代码和测试脚本有590倍之多 - 92053.1 KSLOC。
- en: 1.1\. Executive Summary
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1\. 执行摘要
- en: Four independently developed test harnesses
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四个独立开发的测试工具
- en: 100% branch test coverage in an as-deployed configuration
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署配置下分支测试覆盖率达到100%
- en: Millions and millions of test cases
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数以百万计的测试用例
- en: Out-of-memory tests
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存不足测试
- en: I/O error tests
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I/O 错误测试
- en: Crash and power loss tests
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 崩溃和断电测试
- en: Fuzz tests
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模糊测试
- en: Boundary value tests
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边界值测试
- en: Disabled optimization tests
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁用优化测试
- en: Regression tests
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回归测试
- en: Malformed database tests
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库格式错误测试
- en: Extensive use of assert() and run-time checks
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广泛使用 assert() 和运行时检查
- en: Valgrind analysis
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Valgrind 分析
- en: Undefined behavior checks
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未定义行为检查
- en: Checklists
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查清单
- en: 2\. Test Harnesses
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2\. 测试工具
- en: There are four independent test harnesses used for testing the core SQLite library.
    Each test harness is designed, maintained, and managed separately from the others.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 用于测试核心 SQLite 库的四个独立测试工具。每个测试工具都是设计、维护和管理分开的。
- en: The **TCL Tests** are the original tests for SQLite. They are contained in the
    same source tree as the SQLite core and like the SQLite core are in the public
    domain. The TCL tests are the primary tests used during development. The TCL tests
    are written using the [TCL scripting language](http://www.tcl-lang.org/). The
    TCL test harness itself consists of 27.2 KSLOC of C code used to create the TCL
    interface. The test scripts are contained in 1390 files totaling 23.2MB in size.
    There are 51445 distinct test cases, but many of the test cases are parameterized
    and run multiple times (with different parameters) so that on a full test run
    millions of separate tests are performed.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**TCL 测试** 是 SQLite 的原始测试。它们包含在与 SQLite 核心相同的源树中，并且像 SQLite 核心一样属于公共领域。TCL
    测试是开发过程中主要使用的测试。TCL 测试使用[TCL 脚本语言](http://www.tcl-lang.org/)编写。TCL 测试工具本身由27.2
    KSLOC的 C 代码组成，用于创建 TCL 接口。测试脚本包含在1390个文件中，总大小为23.2MB。有51445个独立的测试用例，但许多测试用例是参数化的，并且以不同的参数多次运行，因此在完整测试运行中执行了数百万个单独的测试。'
- en: The **[TH3](th3.html)** test harness is a set of proprietary tests, written
    in C that provide 100% branch test coverage (and [100% MC/DC test coverage](testing.html#mcdc))
    to the core SQLite library. The TH3 tests are designed to run on embedded and
    specialized platforms that would not easily support TCL or other workstation services.
    TH3 tests use only the published SQLite interfaces. TH3 consists of about 76.9
    MB or 1055.4 KSLOC of C code implementing 50362 distinct test cases. TH3 tests
    are heavily parameterized, though, so a full-coverage test runs about 2.4 million
    different test instances. The cases that provide 100% branch test coverage constitute
    a subset of the total TH3 test suite. A soak test prior to release does about
    248.5 million tests. Additional information on TH3 is [available separately](th3.html).
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**[TH3](th3.html)** 测试工具是一组专有测试，用 C 语言编写，为核心 SQLite 库提供了100%的分支测试覆盖率（以及[100%的MC/DC测试覆盖率](testing.html#mcdc)）。TH3
    测试旨在运行于嵌入式和专用平台，这些平台不易支持 TCL 或其他工作站服务。TH3 测试仅使用公开的 SQLite 接口。TH3 包含约76.9 MB或1055.4
    KSLOC的 C 代码，实现了50362个独立的测试用例。尽管 TH3 测试具有很强的参数化特性，但完整覆盖测试约会运行大约240万个不同的测试实例。提供100%分支测试覆盖的案例是总
    TH3 测试套件的一个子集。发布前的浸泡测试大约执行了2.485亿次测试。关于 TH3 的更多信息[可单独获取](th3.html)。'
- en: The [**SQL Logic Test**](https://www.sqlite.org/sqllogictest) or SLT test harness
    is used to run huge numbers of SQL statements against both SQLite and several
    other SQL database engines and verify that they all get the same answers. SLT
    currently compares SQLite against PostgreSQL, MySQL, Microsoft SQL Server, and
    Oracle 10g. SLT runs 7.2 million queries comprising 1.12GB of test data.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[**SQL逻辑测试**](https://www.sqlite.org/sqllogictest)或SLT测试框架用于针对SQLite和其他几个SQL数据库引擎运行大量SQL语句，并验证它们是否得到相同的答案。SLT目前将SQLite与PostgreSQL、MySQL、Microsoft
    SQL Server和Oracle 10g进行比较。SLT运行720万个查询，包括1.12GB的测试数据。'
- en: The [**dbsqlfuzz**](#dbsqlfuzz) engine is a proprietary fuzz tester. Other [fuzzers
    for SQLite](testing.html#fuzztesting) mutate either the SQL inputs or the database
    file. Dbsqlfuzz mutates both the SQL and the database file at the same time, and
    is thus able to reach new error states. Dbsqlfuzz is built using the [libFuzzer](http://llvm.org/docs/LibFuzzer.html)
    framework of LLVM with a custom mutator. There are 336 seed files. The dbsqlfuzz
    fuzzer runs about one billion test mutations per day. Dbsqlfuzz helps ensure that
    SQLite is robust against attack via malicious SQL or database inputs.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[**dbsqlfuzz**](#dbsqlfuzz)引擎是专有的模糊测试工具。其他SQLite的[fuzzers](testing.html#fuzztesting)会改变SQL输入或数据库文件。Dbsqlfuzz同时改变SQL和数据库文件，因此能够达到新的错误状态。Dbsqlfuzz使用LLVM的[libFuzzer](http://llvm.org/docs/LibFuzzer.html)框架并带有自定义变异器。共有336个种子文件。dbsqlfuzz每天运行大约10亿次测试变异。Dbsqlfuzz有助于确保SQLite对通过恶意SQL或数据库输入进行的攻击具有鲁棒性。'
- en: 'In addition to the four main test harnesses, there many other small programs
    that implement specialized tests. Here are a few examples:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了四个主要的测试框架外，还有许多实现专门测试的小程序。以下是一些示例：
- en: The "speedtest1.c" program estimates the performance of SQLite under a typical
    workload.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '"speedtest1.c"程序估计了SQLite在典型工作负载下的性能。'
- en: The "mptester.c" program is a stress test for multiple processes concurrently
    reading and writing a single database.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '"mptester.c"程序是用于多进程并发读写单个数据库的压力测试。'
- en: The "threadtest3.c" program is a stress test for multiple threads using SQLite
    simultaneously.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '"threadtest3.c"程序是用于测试多线程同时使用SQLite的压力测试。'
- en: The "fuzzershell.c" program is used to run some [fuzz tests](#fuzztesting).
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '"fuzzershell.c"程序用于运行一些[fuzz tests](#fuzztesting)。'
- en: The "jfuzz" program is a libfuzzer-based fuzzer for [JSONB](json1.html#jsonbx)
    inputs to the [JSON SQL functions](json1.html).
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '"jfuzz"程序是基于libfuzzer的模糊器，用于[JSONB](json1.html#jsonbx)输入到[JSON SQL函数](json1.html)。'
- en: All of the tests above must run successfully, on multiple platforms and under
    multiple compile-time configurations, before each release of SQLite.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 所有上述测试在每次SQLite发布前，必须在多个平台和多个编译时配置下成功运行。
- en: Prior to each check-in to the SQLite source tree, developers typically run a
    subset (called "veryquick") of the Tcl tests consisting of about 304.7 thousand
    test cases. The veryquick tests include most tests other than the anomaly, fuzz,
    and soak tests. The idea behind the veryquick tests are that they are sufficient
    to catch most errors, but also run in only a few minutes instead of a few hours.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次提交到SQLite源代码树之前，开发人员通常运行Tcl测试的子集（称为"veryquick"），包括约304.7万个测试用例。veryquick测试包括大多数测试，但不包括异常、模糊和浸泡测试。veryquick测试的想法是，它们足以捕捉大多数错误，但运行时间仅为几分钟，而不是几小时。
- en: 3\. Anomaly Testing
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3\. 异常测试
- en: Anomaly tests are tests designed to verify the correct behavior of SQLite when
    something goes wrong. It is (relatively) easy to build an SQL database engine
    that behaves correctly on well-formed inputs on a fully functional computer. It
    is more difficult to build a system that responds sanely to invalid inputs and
    continues to function following system malfunctions. The anomaly tests are designed
    to verify the latter behavior.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 异常测试是用于验证SQLite在发生问题时的正确行为的测试。构建一个在功能完好的计算机上对良好形式输入表现正确的SQL数据库引擎相对较容易。构建一个在遇到无效输入和系统故障后继续正常运行的系统则更具挑战性。异常测试旨在验证后者的行为。
- en: 3.1\. Out-Of-Memory Testing
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1\. 内存耗尽测试
- en: SQLite, like all SQL database engines, makes extensive use of malloc() (See
    the separate report on [dynamic memory allocation in SQLite](malloc.html) for
    additional detail.) On servers and workstations, malloc() never fails in practice
    and so correct handling of out-of-memory (OOM) errors is not particularly important.
    But on embedded devices, OOM errors are frighteningly common and since SQLite
    is frequently used on embedded devices, it is important that SQLite be able to
    gracefully handle OOM errors.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite，像所有 SQL 数据库引擎一样，广泛使用 malloc() 函数（详见关于 [SQLite 中动态内存分配](malloc.html) 的单独报告）。在服务器和工作站上，malloc()
    函数实际上不会失败，因此正确处理内存耗尽（OOM）错误并不是特别重要。但是在嵌入式设备上，OOM 错误非常常见，并且由于 SQLite 经常用于嵌入式设备，因此
    SQLite 能够优雅地处理这些错误非常重要。
- en: OOM testing is accomplished by simulating OOM errors. SQLite allows an application
    to substitute an alternative malloc() implementation using the [sqlite3_config](c3ref/config.html)([SQLITE_CONFIG_MALLOC](c3ref/c_config_covering_index_scan.html#sqliteconfigmalloc),...)
    interface. The TCL and TH3 test harnesses are both capable of inserting a modified
    version of malloc() that can be rigged to fail after a certain number of allocations.
    These instrumented mallocs can be set to fail only once and then start working
    again, or to continue failing after the first failure. OOM tests are done in a
    loop. On the first iteration of the loop, the instrumented malloc is rigged to
    fail on the first allocation. Then some SQLite operation is carried out and checks
    are done to make sure SQLite handled the OOM error correctly. Then the time-to-failure
    counter on the instrumented malloc is increased by one and the test is repeated.
    The loop continues until the entire operation runs to completion without ever
    encountering a simulated OOM failure. Tests like this are run twice, once with
    the instrumented malloc set to fail only once, and again with the instrumented
    malloc set to fail continuously after the first failure.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: OOM 测试通过模拟 OOM 错误来实现。SQLite 允许应用程序使用 [sqlite3_config](c3ref/config.html)([SQLITE_CONFIG_MALLOC](c3ref/c_config_covering_index_scan.html#sqliteconfigmalloc),...)
    接口替换替代的 malloc() 实现。TCL 和 TH3 测试工具都能够插入一个修改版的 malloc()，可以设置在一定数量的分配后失败。这些有仪器的
    malloc 可以设置为仅在第一次分配失败后才继续工作，或者在第一次失败后继续持续失败。OOM 测试是在一个循环中进行的。在循环的第一次迭代中，有仪器的 malloc
    被设置为在第一次分配时失败。然后执行一些 SQLite 操作，并检查确保 SQLite 正确处理了 OOM 错误。然后增加有仪器的 malloc 的失败计数器，并重复测试。直到整个操作在没有遇到模拟的
    OOM 失败的情况下完成。这样的测试会运行两次，一次将有仪器的 malloc 设置为仅在失败一次后才继续工作，另一次则设置为在第一次失败后持续失败。
- en: 3.2\. I/O Error Testing
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2\. I/O 错误测试
- en: I/O error testing seeks to verify that SQLite responds sanely to failed I/O
    operations. I/O errors might result from a full disk drive, malfunctioning disk
    hardware, network outages when using a network file system, system configuration
    or permission changes that occur in the middle of an SQL operation, or other hardware
    or operating system malfunctions. Whatever the cause, it is important that SQLite
    be able to respond correctly to these errors and I/O error testing seeks to verify
    that it does.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: I/O 错误测试旨在验证 SQLite 对于失败的 I/O 操作能够做出合理响应。I/O 错误可能由于磁盘已满、磁盘硬件故障、使用网络文件系统时的网络中断、在
    SQL 操作中途发生的系统配置或权限更改，或其他硬件或操作系统故障引起。无论造成错误的原因是什么，都很重要的是 SQLite 能够正确响应这些错误，而 I/O
    错误测试就是为了验证它是否能够做到。
- en: I/O error testing is similar in concept to OOM testing; I/O errors are simulated
    and checks are made to verify that SQLite responds correctly to the simulated
    errors. I/O errors are simulated in both the TCL and TH3 test harnesses by inserting
    a new [Virtual File System object](c3ref/vfs.html) that is specially rigged to
    simulate an I/O error after a set number of I/O operations. As with OOM error
    testing, the I/O error simulators can be set to fail just once, or to fail continuously
    after the first failure. Tests are run in a loop, slowly increasing the point
    of failure until the test case runs to completion without error. The loop is run
    twice, once with the I/O error simulator set to simulate only a single failure
    and a second time with it set to fail all I/O operations after the first failure.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: I/O错误测试在概念上类似于OOM测试；模拟I/O错误并检查SQLite是否正确响应模拟的错误。在TCL和TH3测试工具中，通过插入一个特殊设置为在一定数量的I/O操作后模拟I/O错误的新[虚拟文件系统对象](c3ref/vfs.html)来模拟I/O错误。与OOM错误测试类似，I/O错误模拟器可以设置为仅失败一次，或者在第一次失败后持续失败。测试循环运行，逐渐增加失败点，直到测试用例在没有错误的情况下完成。循环运行两次，一次将I/O错误模拟器设置为仅模拟单次失败，另一次将其设置为在第一次失败后连续失败所有I/O操作。
- en: In I/O error tests, after the I/O error simulation failure mechanism is disabled,
    the database is examined using [PRAGMA integrity_check](pragma.html#pragma_integrity_check)
    to make sure that the I/O error has not introduced database corruption.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在I/O错误测试中，禁用I/O错误模拟失败机制后，使用[PRAGMA integrity_check](pragma.html#pragma_integrity_check)检查数据库，确保I/O错误未引入数据库损坏。
- en: 3.3\. Crash Testing
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3\. 崩溃测试
- en: Crash testing seeks to demonstrate that an SQLite database will not go corrupt
    if the application or operating system crashes or if there is a power failure
    in the middle of a database update. A separate white-paper titled [Atomic Commit
    in SQLite](atomiccommit.html) describes the defensive measure SQLite takes to
    prevent database corruption following a crash. Crash tests strive to verify that
    those defensive measures are working correctly.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 崩溃测试旨在证明SQLite数据库在应用程序或操作系统崩溃或数据库更新过程中发生电力故障时不会损坏。名为[SQLite中的原子提交](atomiccommit.html)的独立白皮书描述了SQLite为防止崩溃后数据库损坏所采取的防御措施。崩溃测试旨在验证这些防御措施是否正常工作。
- en: It is impractical to do crash testing using real power failures, of course,
    and so crash testing is done in simulation. An alternative [Virtual File System](c3ref/vfs.html)
    is inserted that allows the test harness to simulate the state of the database
    file following a crash.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，使用真实的电力故障进行崩溃测试是不现实的，因此崩溃测试是在模拟中进行的。插入一个替代的[虚拟文件系统](c3ref/vfs.html)，允许测试工具模拟数据库文件在崩溃后的状态。
- en: In the TCL test harness, the crash simulation is done in a separate process.
    The main testing process spawns a child process which runs some SQLite operation
    and randomly crashes somewhere in the middle of a write operation. A special [VFS](vfs.html)
    randomly reorders and corrupts the unsynchronized write operations to simulate
    the effect of buffered filesystems. After the child dies, the original test process
    opens and reads the test database and verifies that the changes attempted by the
    child either completed successfully or else were completely rolled back. The [integrity_check](pragma.html#pragma_integrity_check)
    [PRAGMA](pragma.html#syntax) is used to make sure no database corruption occurs.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在TCL测试工具中，崩溃模拟在一个单独的进程中进行。主测试进程生成一个子进程，在写操作的中途随机崩溃。一个特殊的[VFS](vfs.html)随机重新排序和损坏未同步的写操作，模拟缓冲文件系统的效果。子进程终止后，原始测试进程打开并读取测试数据库，并验证子进程尝试的更改是成功完成还是完全回滚。使用[integrity_check](pragma.html#pragma_integrity_check)
    PRAGMA确保没有数据库损坏发生。
- en: The TH3 test harness needs to run on embedded systems that do not necessarily
    have the ability to spawn child processes, so it uses an in-memory [VFS](vfs.html)
    to simulate crashes. The in-memory [VFS](vfs.html) can be rigged to make a snapshot
    of the entire filesystem after a set number of I/O operations. Crash tests run
    in a loop. On each iteration of the loop, the point at which a snapshot is made
    is advanced until the SQLite operations being tested run to completion without
    ever hitting a snapshot. Within the loop, after the SQLite operation under test
    has completed, the filesystem is reverted to the snapshot and random file damage
    is introduced that is characteristic of the kinds of damage one expects to see
    following a power loss. Then the database is opened and checks are made to ensure
    that it is well-formed and that the transaction either ran to completion or was
    completely rolled back. The interior of the loop is repeated multiple times for
    each snapshot with different random damage each time.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: TH3测试套件需要运行在不一定具备生成子进程能力的嵌入式系统上，因此使用内存中的[VFS](vfs.html)来模拟崩溃。内存中的[VFS](vfs.html)可以被操纵，在一定I/O操作次数后进行整个文件系统的快照。崩溃测试在循环中运行。在每次循环迭代中，快照的生成点会被推进，直到正在测试的SQLite操作完全运行而不触发快照。在循环内部，完成SQLite操作后，文件系统被还原到快照状态，并引入随机文件损坏，这些损坏特征上电后可能见到的损坏。然后打开数据库并检查确保其形式良好，且事务完成或完全回滚。在每个快照中的循环内部，会多次重复，每次引入不同的随机损坏。
- en: 3.4\. Compound failure tests
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4\. 复合失败测试
- en: The test suites for SQLite also explore the result of stacking multiple failures.
    For example, tests are run to ensure correct behavior when an I/O error or OOM
    fault occurs while trying to recover from a prior crash.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite的测试套件还探索了多重失败叠加的结果。例如，运行测试以确保在尝试从先前的崩溃中恢复时发生I/O错误或OOM故障时的正确行为。
- en: 4\. Fuzz Testing
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4\. 模糊测试
- en: '[Fuzz testing](http://en.wikipedia.org/wiki/Fuzz_testing) seeks to establish
    that SQLite responds correctly to invalid, out-of-range, or malformed inputs.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[模糊测试](http://en.wikipedia.org/wiki/Fuzz_testing)旨在验证SQLite对于无效、超出范围或格式错误的输入能够正确响应。'
- en: 4.1\. SQL Fuzz
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1\. SQL模糊测试
- en: SQL fuzz testing consists of creating syntactically correct yet wildly nonsensical
    SQL statements and feeding them to SQLite to see what it will do with them. Usually
    some kind of error is returned (such as "no such table"). Sometimes, purely by
    chance, the SQL statement also happens to be semantically correct. In that case,
    the resulting prepared statement is run to make sure it gives a reasonable result.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: SQL模糊测试包括创建语法正确但极不合理的SQL语句，并将其输入SQLite以查看其反应。通常会返回某种错误（例如“表不存在”）。有时，纯粹偶然间，SQL语句也可能在语义上是正确的。在这种情况下，运行生成的准备语句以确保其给出合理结果。
- en: 4.1.1\. SQL Fuzz Using The American Fuzzy Lop Fuzzer
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1\. 使用American Fuzzy Lop模糊测试器的SQL模糊测试
- en: The concept of fuzz testing has been around for decades, but fuzz testing was
    not an effective way to find bugs until 2014 when Michal Zalewski invented the
    first practical profile-guided fuzzer, [American Fuzzy Lop](http://lcamtuf.coredump.cx/afl/)
    or "AFL". Unlike prior fuzzers that blindly generate random inputs, AFL instruments
    the program being tested (by modifying the assembly-language output from the C
    compiler) and uses that instrumentation to detect when an input causes the program
    to do something different - to follow a new control path or loop a different number
    of times. Inputs that provoke new behavior are retained and further mutated. In
    this way, AFL is able to "discover" new behaviors of the program under test, including
    behaviors that were never envisioned by the designers.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 出现几十年的模糊测试概念，但直到2014年Michal Zalewski发明了第一个实用的基于配置文件引导的模糊测试工具[American Fuzzy
    Lop](http://lcamtuf.coredump.cx/afl/)或简称“AFL”，模糊测试才成为发现错误的有效方法。与以往盲目生成随机输入的模糊测试工具不同，AFL通过修改C编译器生成的汇编语言输出来对被测试程序进行插桩，并利用这些插桩来检测输入何时导致程序执行不同行为，如跟踪新的控制路径或循环次数。触发新行为的输入将被保留并进一步变异。通过这种方式，AFL能够“发现”测试中程序的新行为，甚至是设计者未曾预料到的行为。
- en: AFL proved adept at finding arcane bugs in SQLite. Most of the findings have
    been assert() statements where the conditional was false under obscure circumstances.
    But AFL has also found a fair number of crash bugs in SQLite, and even a few cases
    where SQLite computed incorrect results.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: AFL在SQLite中发现了许多奥秘bug。大多数发现都是在assert()语句中，条件在奇怪的情况下为假。但AFL也发现了一些导致SQLite崩溃的bug，甚至还有一些SQLite计算错误结果的情况。
- en: Because of its past success, AFL became a standard part of the testing strategy
    for SQLite beginning with [version 3.8.10](releaselog/3_8_10.html) (2015-05-07)
    until it was superseded by better fuzzers in [version 3.29.0](releaselog/3_29_0.html)
    (2019-07-10).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其过去的成功，AFL从[版本3.8.10](releaselog/3_8_10.html)（2015-05-07）开始成为SQLite测试策略的标准部分，直到在[版本3.29.0](releaselog/3_29_0.html)（2019-07-10）中被更好的模糊器取代。
- en: 4.1.2\. Google OSS Fuzz
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.2\. Google OSS Fuzz
- en: Beginning in 2016, a team of engineers at Google started the [OSS Fuzz](https://github.com/google/oss-fuzz)
    project. OSS Fuzz uses a AFL-style guided fuzzer running on Google's infrastructure.
    The Fuzzer automatically downloads the latest check-ins for participating projects,
    fuzzes them, and sends email to the developers reporting any problems. When a
    fix is checked in, the fuzzer automatically detects this and emails a confirmation
    to the developers.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 2016年，谷歌的一支工程师团队启动了[OSS Fuzz](https://github.com/google/oss-fuzz)项目。OSS Fuzz使用谷歌基础设施上运行的AFL风格引导的模糊器。该模糊器会自动下载参与项目的最新提交，对其进行模糊测试，并向开发人员发送电子邮件报告任何问题。当有修复提交时，模糊器会自动检测到并向开发人员发送确认邮件。
- en: SQLite is one of many open-source projects that OSS Fuzz tests. The [test/ossfuzz.c](https://www.sqlite.org/src/file/test/ossfuzz.c)
    source file in the SQLite repository is SQLite's interface to OSS fuzz.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite是许多开源项目中由OSS Fuzz测试的项目之一。SQLite存储库中的[test/ossfuzz.c](https://www.sqlite.org/src/file/test/ossfuzz.c)源文件是SQLite与OSS
    fuzz的接口。
- en: 'OSS Fuzz no longer finds historical bugs in SQLite. But it is still running
    and does occasionally find issues in new development check-ins. Examples: [[1]](https://www.sqlite.org/src/timeline?y=ci&c=c422afb507dc8757)
    [[2]](https://www.sqlite.org/src/timeline?y=ci&c=0a2eb949f8a759e5) [[3]](https://www.sqlite.org/src/timeline?y=ci&c=62f2235adf796c72).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: OSS Fuzz在SQLite中不再发现历史性bug。但它仍在运行，并偶尔在新的开发提交中发现问题。例如：[[1]](https://www.sqlite.org/src/timeline?y=ci&c=c422afb507dc8757)
    [[2]](https://www.sqlite.org/src/timeline?y=ci&c=0a2eb949f8a759e5) [[3]](https://www.sqlite.org/src/timeline?y=ci&c=62f2235adf796c72)。
- en: 4.1.3\. The dbsqlfuzz and jfuzz fuzzers
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.3\. dbsqlfuzz和jfuzz模糊器
- en: Beginning in late 2018, SQLite has been fuzzed using a proprietary fuzzer called
    "dbsqlfuzz". Dbsqlfuzz is built using the [libFuzzer](http://llvm.org/docs/LibFuzzer.html)
    framework of LLVM.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 自2018年末开始，SQLite开始使用名为“dbsqlfuzz”的专有模糊器进行模糊测试。Dbsqlfuzz是使用LLVM的[libFuzzer](http://llvm.org/docs/LibFuzzer.html)框架构建的。
- en: The dbsqlfuzz fuzzer mutates both the SQL input and the database file at the
    same time. Dbsqlfuzz uses a custom [Structure-Aware Mutator](https://github.com/google/fuzzing/blob/master/docs/structure-aware-fuzzing.md)
    on a specialized input file that defines both an input database and SQL text to
    be run against that database. Because it mutates both the input database and the
    input SQL at the same time, dbsqlfuzz has been able to find some obscure faults
    in SQLite that were missed by prior fuzzers that mutated only SQL inputs or only
    the database file. The SQLite developers keep dbsqlfuzz running against trunk
    in about 16 cores at all times. Each instance of dbsqlfuzz program is able to
    evalutes about 400 test cases per second, meaning that about 500 million cases
    are checked every day.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: dbsqlfuzz模糊器同时变异SQL输入和数据库文件。Dbsqlfuzz在专门的输入文件上使用自定义的[结构感知变异器](https://github.com/google/fuzzing/blob/master/docs/structure-aware-fuzzing.md)，该文件定义了输入数据库和要对其运行的SQL文本。因为它同时变异输入数据库和输入SQL，dbsqlfuzz能够发现一些先前的模糊器错过的SQLite中的隐蔽故障。SQLite开发人员始终保持dbsqlfuzz针对主干的运行，使用大约16个核心。每个dbsqlfuzz程序能够每秒评估约400个测试用例，这意味着每天检查大约5亿个案例。
- en: The dbsqlfuzz fuzzer has been very successful at hardening the SQLite code base
    against malicious attack. Since dbsqlfuzz has been added to the SQLite internal
    test suite, bug reports from external fuzzers such as OSSFuzz have all but stopped.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: dbsqlfuzz模糊器在加固SQLite代码库防御恶意攻击方面非常成功。自从将dbsqlfuzz添加到SQLite内部测试套件以来，来自OSSFuzz等外部模糊器的bug报告几乎停止了。
- en: Note that dbsqlfuzz is *not* the Protobuf-based structure-aware fuzzer for SQLite
    that is used by Chromium and described in the [Structure-Aware Mutator article](https://github.com/google/fuzzing/blob/master/docs/structure-aware-fuzzing.md#user-content-example-sqlite).
    There is no connection between these two fuzzers, other than the fact that they
    are both based on [libFuzzer](http://llvm.org/docs/LibFuzzer.html) The Protobuf
    fuzzer for SQLite is written and maintained by the Chromium team at Google, whereas
    dbsqlfuzz is written and maintained by the original SQLite developers. Having
    multiple independently-developed fuzzers for SQLite is good, as it means that
    obscure issues are more likely to be uncovered.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，dbsqlfuzz *不是*基于Protobuf的SQLite结构感知模糊测试工具，该工具被Chromium使用，并在[结构感知变异器文章](https://github.com/google/fuzzing/blob/master/docs/structure-aware-fuzzing.md#user-content-example-sqlite)中描述。这两个模糊测试工具之间没有任何联系，除了它们都基于[libFuzzer](http://llvm.org/docs/LibFuzzer.html)。SQLite的Protobuf模糊器由Google的Chromium团队编写和维护，而dbsqlfuzz由原始SQLite开发人员编写和维护。对SQLite进行多个独立开发的模糊测试工具是件好事，因为这意味着更容易发现一些隐晦的问题。
- en: Near the end of January 2024, a second libFuzzer-based tool called "jfuzz" came
    into use. Jfuzz generates corrupt [JSONB](json1.html#jsonbx) blobs and feeds them
    into the [JSON SQL functions](json1.html) to verify that the JSON functions are
    able to safely and efficiently deal with corrupt binary inputs.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在2024年1月底，第二个基于libFuzzer的工具"jfuzz"开始使用。Jfuzz生成损坏的[JSONB](json1.html#jsonbx)二进制大对象，并将它们馈送到[JSON
    SQL函数](json1.html)中，以验证JSON函数能够安全高效地处理损坏的二进制输入。
- en: 4.1.4\. Other third-party fuzzers
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.4\. 其他第三方模糊测试工具
- en: 'SQLite seems to be a popular target for third-parties to fuzz. The developers
    hear about many attempts to fuzz SQLite and they do occasionally get bug reports
    found by independent fuzzers. All such reports are promptly fixed, so the product
    is improved and that the entire SQLite user community benefits. This mechanism
    of having many independent testers is similar to [Linus''s law](https://en.wikipedia.org/wiki/Linus%27s_law):
    "given enough eyeballs, all bugs are shallow".'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite似乎是第三方模糊测试的一个受欢迎目标。开发人员听说有许多人尝试对SQLite进行模糊测试，并偶尔收到独立模糊测试工具发现的bug报告。所有这些报告都会及时修复，因此产品得以改进，整个SQLite用户社区也因此受益。这种具有多个独立测试者的机制类似于[Linus定律](https://en.wikipedia.org/wiki/Linus%27s_law)："足够多的眼睛，所有的bug都很浅显"。
- en: One fuzzing researcher of particular note is [Manuel Rigger](https://www.manuelrigger.at/).
    Most fuzzers only look for assertion faults, crashes, undefined behavior (UB),
    or other easily detected anomalies. Dr. Rigger's fuzzers, on the other hand, are
    able to find cases where SQLite computes an incorrect answer. Rigger has found
    [many such cases](https://www.sqlite.org/src/timeline?y=t&u=mrigger&n=all). Most
    of these finds are obscure corner cases involving type conversions and affinity
    transformations, and a good number of the finds are against unreleased features.
    Nevertheless, his finds are still important as they are real bugs, and the SQLite
    developers are grateful to be able to identify and fix the underlying problems.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 特别值得一提的一个模糊测试研究人员是[Manuel Rigger](https://www.manuelrigger.at/)。大多数模糊测试工具只寻找断言错误、崩溃、未定义行为（UB）或其他易于检测的异常情况。另一方面，Rigger博士的模糊测试工具能够找到SQLite计算出错误答案的情况。Rigger发现了[许多这样的案例](https://www.sqlite.org/src/timeline?y=t&u=mrigger&n=all)。这些发现大多数是涉及类型转换和亲和性转换的角落案例，很多发现是针对未发布功能的。然而，他的发现仍然很重要，因为它们是真实的bug，SQLite开发人员很感激能够识别并修复潜在问题。
- en: 4.1.5\. The fuzzcheck test harness
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.5\. fuzzcheck测试工具
- en: Historical test cases from [AFL](testing.html#aflfuzz), [OSS Fuzz](testing.html#ossfuzz),
    and [dbsqlfuzz](testing.html#dbsqlfuzz) are collected in a set of database files
    in the main SQLite source tree and then rerun by the "fuzzcheck" utility program
    whenever one runs "make test". Fuzzcheck only runs a few thousand "interesting"
    cases out of the billions of cases that the various fuzzers have examined over
    the years. "Interesting" cases are cases that exhibit previously unseen behavior.
    Actual bugs found by fuzzers are always included among the interesting test cases,
    but most of the cases run by fuzzcheck were never actual bugs.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 历史测试用例来自[AFL](testing.html#aflfuzz)、[OSS Fuzz](testing.html#ossfuzz)和[dbsqlfuzz](testing.html#dbsqlfuzz)，它们被收集在主SQLite源树中的一组数据库文件中，并由"fuzzcheck"实用程序重新运行，每当运行"make
    test"时。Fuzzcheck只运行了数千个"有趣"的案例，而各种模糊测试工具多年来检查的案例数量则达到了数十亿。"有趣"的案例是表现出先前未见行为的案例。由模糊测试工具找到的实际错误始终包含在有趣的测试用例中，但大多数由fuzzcheck运行的案例实际上并非错误。
- en: 4.1.6\. Tension Between Fuzz Testing And 100% MC/DC Testing
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.6\. 模糊测试与 100% MC/DC 测试之间的紧张关系
- en: Fuzz testing and [100% MC/DC testing](testing.html#mcdc) are in tension with
    one another. That is to say, code tested to 100% MC/DC will tend to be more vulnerable
    to problems found by fuzzing and code that performs well during fuzz testing will
    tend to have (much) less than 100% MC/DC. This is because MC/DC testing discourages
    [defensive code](testing.html#defcode) with unreachable branches, but without
    defensive code, a fuzzer is more likely to find a path that causes problems. MC/DC
    testing seems to work well for building code that is robust during normal use,
    whereas fuzz testing is good for building code that is robust against malicious
    attack.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试和 [100% MC/DC 测试](testing.html#mcdc) 是相互对立的。也就是说，经过 100% MC/DC 测试的代码往往更容易受到模糊测试发现的问题的影响，而在模糊测试中表现良好的代码往往不会达到
    100% MC/DC。这是因为 MC/DC 测试会阻止包含不可达分支的防御性代码，但是没有防御性代码，模糊器更可能找到导致问题的路径。MC/DC 测试似乎非常适合构建在正常使用时健壮的代码，而模糊测试则有助于构建能够抵御恶意攻击的代码。
- en: Of course, users would prefer code that is both robust in normal use and resistant
    to malicious attack. The SQLite developers are dedicated to providing that. The
    purpose of this section is merely to point out that doing both at the same time
    is difficult.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，用户希望的是在正常使用中既健壮又能抵御恶意攻击的代码。SQLite 的开发人员致力于提供这样的代码。本节的目的仅仅是指出同时做到这两点是困难的。
- en: For much of its history SQLite has been focused on 100% MC/DC testing. Resistance
    to fuzzing attacks only became a concern with the introduction of AFL in 2014\.
    For a while there, fuzzers were finding many problems in SQLite. In more recent
    years, the testing strategy of SQLite has evolved to place more emphasis on fuzz
    testing. We still maintain 100% MC/DC of the core SQLite code, but most testing
    CPU cycles are now devoted to fuzzing.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在其历史的大部分时间里，SQLite 一直专注于 100% 的 MC/DC 测试。对模糊测试攻击的抗拒力直到 2014 年 AFL 的引入才成为一个关注点。有一段时间，模糊测试器在
    SQLite 中发现了许多问题。近年来，SQLite 的测试策略已经演变，更加强调模糊测试。我们仍然保持对核心 SQLite 代码的 100% MC/DC
    覆盖率，但现在大多数的测试 CPU 周期都用于模糊测试。
- en: While fuzz testing and 100% MC/DC testing are in tension, they are not completely
    at cross-purposes. The fact that the SQlite test suite does test to 100% MC/DC
    means that when fuzzers do find problems, those problems can be fixed quickly
    and with little risk of introducing new errors.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管模糊测试和 100% MC/DC 测试存在紧张关系，但它们并不完全相互对立。SQLite 测试套件确实进行了 100% MC/DC 测试，这意味着当模糊测试器发现问题时，这些问题可以迅速修复，而且几乎没有引入新错误的风险。
- en: 4.2\. Malformed Database Files
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2\. 格式不正确的数据库文件
- en: There are numerous test cases that verify that SQLite is able to deal with malformed
    database files. These tests first build a well-formed database file, then add
    corruption by changing one or more bytes in the file by some means other than
    SQLite. Then SQLite is used to read the database. In some cases, the bytes changes
    are in the middle of data. This causes the content of the database to change while
    keeping the database well-formed. In other cases, unused bytes of the file are
    modified, which has no effect on the integrity of the database. The interesting
    cases are when bytes of the file that define database structure get changed. The
    malformed database tests verify that SQLite finds the file format errors and reports
    them using the [SQLITE_CORRUPT](rescode.html#corrupt) return code without overflowing
    buffers, dereferencing NULL pointers, or performing other unwholesome actions.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多测试用例验证了 SQLite 能够处理格式不正确的数据库文件。这些测试首先构建一个格式良好的数据库文件，然后通过某种方式改变文件中一个或多个字节来引入破坏。然后使用
    SQLite 来读取数据库。在某些情况下，字节的更改发生在数据的中间。这会导致数据库内容改变，同时保持数据库的格式正确。在其他情况下，修改文件未使用的字节，这不会影响数据库的完整性。有趣的情况是当文件中定义数据库结构的字节发生改变时。格式不正确的数据库测试验证了
    SQLite 能够发现文件格式错误，并使用 [SQLITE_CORRUPT](rescode.html#corrupt) 返回代码报告这些错误，而不会溢出缓冲区、取消引用空指针或执行其他不良操作。
- en: The [dbsqlfuzz](testing.html#dbsqlfuzz) fuzzer also does an excellent job of
    verifying that SQLite responds sanely to malformed database files.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[dbsqlfuzz](testing.html#dbsqlfuzz) 模糊器也非常出色地验证了 SQLite 对格式不正确的数据库文件的响应是否合理。'
- en: 4.3\. Boundary Value Tests
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3\. 边界值测试
- en: SQLite defines certain [limits](limits.html) on its operation, such as the maximum
    number of columns in a table, the maximum length of an SQL statement, or the maximum
    value of an integer. The TCL and TH3 test suites both contains numerous tests
    that push SQLite right to the edge of its defined limits and verify that it performs
    correctly for all allowed values. Additional tests go beyond the defined limits
    and verify that SQLite correctly returns errors. The source code contains [testcase
    macros](testing.html#testcase) to verify that both sides of each boundary have
    been tested.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite定义了其操作的若干[限制](limits.html)，如表中列的最大数量、SQL语句的最大长度或整数的最大值。TCL和TH3测试套件都包含大量测试用例，将SQLite推到其定义的极限并验证其对所有允许值的正确执行。额外的测试超出了定义的限制，并验证SQLite正确返回错误。源代码包含[测试用例宏](testing.html#testcase)，以验证每个边界的两侧是否都已经过测试。
- en: 5\. Regression Testing
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5\. 回归测试
- en: Whenever a bug is reported against SQLite, that bug is not considered fixed
    until new test cases that would exhibit the bug have been added to either the
    TCL or TH3 test suites. Over the years, this has resulted in thousands and thousands
    of new tests. These regression tests ensure that bugs that have been fixed in
    the past are not reintroduced into future versions of SQLite.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 每当有关SQLite的错误报告时，只有在向TCL或TH3测试套件添加了能够显示错误的新测试用例后，该错误才被认为已修复。多年来，这已导致数千个新的测试用例。这些回归测试确保过去修复的错误不会重新引入到SQLite的未来版本中。
- en: 6\. Automatic Resource Leak Detection
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6\. 自动资源泄漏检测
- en: 'Resource leak occurs when system resources are allocated and never freed. The
    most troublesome resource leaks in many applications are memory leaks - when memory
    is allocated using malloc() but never released using free(). But other kinds of
    resources can also be leaked: file descriptors, threads, mutexes, etc.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 资源泄漏是指系统资源被分配但从未被释放。许多应用程序中最棘手的资源泄漏是内存泄漏 - 使用malloc()分配内存但未使用free()释放。但其他类型的资源也可能泄漏：文件描述符、线程、互斥锁等。
- en: Both the TCL and TH3 test harnesses automatically track system resources and
    report resource leaks on every test run. No special configuration or setup is
    required. The test harnesses are especially vigilant with regard to memory leaks.
    If a change causes a memory leak, the test harnesses will recognize this quickly.
    SQLite is designed to never leak memory, even after an exception such as an OOM
    error or disk I/O error. The test harnesses are zealous to enforce this.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: TCL和TH3测试框架自动跟踪系统资源，并在每次测试运行时报告资源泄漏。无需特殊配置或设置。测试框架特别关注内存泄漏。如果更改导致内存泄漏，测试框架将迅速识别出来。SQLite设计为永不泄漏内存，即使发生诸如OOM错误或磁盘I/O错误等异常情况。测试框架积极地执行此操作。
- en: 7\. Test Coverage
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7\. 测试覆盖
- en: The SQLite core, including the unix [VFS](vfs.html), has 100% branch test coverage
    under [TH3](th3.html) in its default configuration as measured by [gcov](http://gcc.gnu.org/onlinedocs/gcc/Gcov.html).
    Extensions such as FTS3 and RTree are excluded from this analysis.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite核心，包括unix [VFS](vfs.html)，在其默认配置下在[TH3](th3.html)下具有100%的分支测试覆盖率，由[gcov](http://gcc.gnu.org/onlinedocs/gcc/Gcov.html)测量。例如FTS3和RTree等扩展被排除在此分析之外。
- en: 7.1\. Statement versus branch coverage
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1\. 语句与分支覆盖
- en: There are many ways to measure test coverage. The most popular metric is "statement
    coverage". When you hear someone say that their program as "XX% test coverage"
    without further explanation, they usually mean statement coverage. Statement coverage
    measures what percentage of lines of code are executed at least once by the test
    suite.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以衡量测试覆盖率。最流行的度量标准是“语句覆盖率”。当你听到有人说他们的程序具有“XX%的测试覆盖率”而没有进一步解释时，他们通常指的是语句覆盖率。语句覆盖率衡量了测试套件至少一次执行的代码行的百分比。
- en: Branch coverage is more rigorous than statement coverage. Branch coverage measures
    the number of machine-code branch instructions that are evaluated at least once
    on both directions.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 分支覆盖率比语句覆盖率更严格。分支覆盖率衡量了在两个方向上至少评估一次的机器码分支指令的数量。
- en: 'To illustrate the difference between statement coverage and branch coverage,
    consider the following hypothetical line of C code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要说明语句覆盖率与分支覆盖率的区别，请考虑以下假设的C代码行：
- en: '[PRE0]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Such a line of C code might generate a dozen separate machine code instructions.
    If any one of those instructions is ever evaluated, then we say that the statement
    has been tested. So, for example, it might be the case that the conditional expression
    is always false and the "d" variable is never incremented. Even so, statement
    coverage counts this line of code as having been tested.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一行 C 代码可能会生成十几条单独的机器码指令。如果这些指令中的任何一条被评估，我们就说该语句已经被测试过了。例如，可能条件表达式总是假，而“d”变量从未递增。即便如此，语句覆盖率也会将这行代码视为已经被测试过。
- en: 'Branch coverage is more strict. With branch coverage, each test and each subblock
    within the statement is considered separately. In order to achieve 100% branch
    coverage in the example above, there must be at least three test cases:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 分支覆盖率更为严格。在分支覆盖率下，每个测试和语句中的每个子块都被单独考虑。为了在上述例子中实现 100% 分支覆盖率，至少需要三个测试用例：
- en: a<=b
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: a<=b
- en: a>b && c==25
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: a>b && c==25
- en: a>b && c!=25
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: a>b && c!=25
- en: Any one of the above test cases would provide 100% statement coverage but all
    three are required for 100% branch coverage. Generally speaking, 100% branch coverage
    implies 100% statement coverage, but the converse is not true. To reemphasize,
    the [TH3](th3.html) test harness for SQLite provides the stronger form of test
    coverage - 100% branch test coverage.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 上述任何一个测试用例都可以提供 100% 语句覆盖率，但需要所有三个用例才能实现 100% 分支覆盖率。一般来说，100% 分支覆盖率意味着 100%
    语句覆盖率，但反之则不成立。再次强调，SQLite 的 [TH3](th3.html) 测试工具提供了更强的测试覆盖形式 - 100% 分支测试覆盖率。
- en: 7.2\. Coverage testing of defensive code
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2\. 防御性代码的覆盖测试
- en: 'A well-written C program will typically contain some defensive conditionals
    which in practice are always true or always false. This leads to a programming
    dilemma: Does one remove defensive code in order to obtain 100% branch coverage?'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一个良好编写的 C 程序通常会包含一些防御性条件，这些条件在实践中总是真或总是假。这导致了一个编程困境：是删除防御性代码以获得 100% 分支覆盖率呢？
- en: 'In SQLite, the answer to the previous question is "no". For testing purposes,
    the SQLite source code defines macros called ALWAYS() and NEVER(). The ALWAYS()
    macro surrounds conditions which are expected to always evaluate as true and NEVER()
    surrounds conditions that are always evaluated to false. These macros serve as
    comments to indicate that the conditions are defensive code. In release builds,
    these macros are pass-throughs:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLite 中，对于前面的问题答案是“否”。为了测试目的，SQLite 源代码定义了名为 ALWAYS() 和 NEVER() 的宏。ALWAYS()
    宏用于包围预期总是评估为真的条件，而 NEVER() 用于包围总是评估为假的条件。这些宏作为注释，表明这些条件是防御性代码。在发布构建中，这些宏是直通的：
- en: '[PRE1]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: During most testing, however, these macros will throw an assertion fault if
    their argument does not have the expected truth value. This alerts the developers
    quickly to incorrect design assumptions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数测试中，如果这些宏的参数未具有预期的真值，它们将抛出一个断言故障。这能迅速提醒开发者发现设计上的错误假设。
- en: '[PRE2]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When measuring test coverage, these macros are defined to be constant truth
    values so that they do not generate assembly language branch instructions, and
    hence do not come into play when calculating the branch coverage:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在测量测试覆盖率时，这些宏被定义为常量真值，以便它们不生成汇编语言分支指令，因此在计算分支覆盖率时不起作用：
- en: '[PRE3]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The test suite is designed to be run three times, once for each of the ALWAYS()
    and NEVER() definitions shown above. All three test runs should yield exactly
    the same result. There is a run-time test using the [sqlite3_test_control](c3ref/test_control.html)([SQLITE_TESTCTRL_ALWAYS](c3ref/c_testctrl_always.html),
    ...) interface that can be used to verify that the macros are correctly set to
    the first form (the pass-through form) for deployment.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 测试套件设计为运行三次，每次分别对应上述的 ALWAYS() 和 NEVER() 定义。所有三次测试运行应该得到完全相同的结果。有一个运行时测试使用 [sqlite3_test_control](c3ref/test_control.html)([SQLITE_TESTCTRL_ALWAYS](c3ref/c_testctrl_always.html),
    ...) 接口，用于验证这些宏是否正确设置为第一种形式（直通形式）以供部署使用。
- en: 7.3\. Forcing coverage of boundary values and boolean vector tests
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3\. 强制覆盖边界值和布尔向量测试
- en: 'Another macro used in conjunction with test coverage measurement is the `testcase()`
    macro. The argument is a condition for which we want test cases that evaluate
    to both true and false. In non-coverage builds (that is to say, in release builds)
    the `testcase()` macro is a no-op:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个与测试覆盖率测量一起使用的宏是 `testcase()` 宏。其参数是我们希望有测试用例能评估为真和为假的条件。在非覆盖率构建中（即发布构建中），`testcase()`
    宏是一个空操作：
- en: '[PRE4]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'But in a coverage measuring build, the `testcase()` macro generates code that
    evaluates the conditional expression in its argument. Then during analysis, a
    check is made to ensure tests exist that evaluate the conditional to both true
    and false. `Testcase()` macros are used, for example, to help verify that boundary
    values are tested. For example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 但在覆盖率测量构建中，`testcase()`宏生成评估其参数中的条件表达式的代码。然后在分析期间，会检查以确保存在测试评估条件既为真又为假。例如，`testcase()`宏用于帮助验证边界值是否被测试。例如：
- en: '[PRE5]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Testcase macros are also used when two or more cases of a switch statement
    go to the same block of code, to make sure that the code was reached for all cases:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例宏在`switch`语句的两个或多个情况进入同一段代码块时也会使用，以确保代码对所有情况都被执行：
- en: '[PRE6]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For bitmask tests, `testcase()` macros are used to verify that every bit of
    the bitmask affects the outcome. For example, in the following block of code,
    the condition is true if the mask contains either of two bits indicating either
    a MAIN_DB or a TEMP_DB is being opened. The `testcase()` macros that precede the
    if statement verify that both cases are tested:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于位掩码测试，`testcase()`宏用于验证位掩码的每一位对结果的影响。例如，在以下代码块中，如果掩码包含表示打开`MAIN_DB`或`TEMP_DB`的两个位之一，则条件为真。在`if`语句之前的`testcase()`宏验证了两种情况都被测试：
- en: '[PRE7]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The SQLite source code contains 1184 uses of the `testcase()` macro.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite源代码包含1184个`testcase()`宏的使用。
- en: 7.4\. Branch coverage versus MC/DC
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4\. 分支覆盖与MC/DC
- en: 'Two methods of measuring test coverage were described above: "statement" and
    "branch" coverage. There are many other test coverage metrics besides these two.
    Another popular metric is "Modified Condition/Decision Coverage" or MC/DC. [Wikipedia](http://en.wikipedia.org/wiki/Modified_Condition/Decision_Coverage)
    defines MC/DC as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 上述介绍了两种测量测试覆盖率的方法：“语句”和“分支”覆盖率。除了这两种之外，还有许多其他的测试覆盖率指标。另一个流行的指标是“修改条件/决策覆盖”（MC/DC）。[维基百科](http://en.wikipedia.org/wiki/Modified_Condition/Decision_Coverage)对MC/DC的定义如下：
- en: Each decision tries every possible outcome.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个决策尝试每种可能的结果。
- en: Each condition in a decision takes on every possible outcome.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个决策中的每个条件都采用每种可能的结果。
- en: Each entry and exit point is invoked.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个进入和退出点都被调用。
- en: Each condition in a decision is shown to independently affect the outcome of
    the decision.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决策中的每个条件都独立影响决策的结果。
- en: In the C programming language where **`&&`** and **`||`** are "short-circuit"
    operators, MC/DC and branch coverage are very nearly the same thing. The primary
    difference is in boolean vector tests. One can test for any of several bits in
    bit-vector and still obtain 100% branch test coverage even though the second element
    of MC/DC - the requirement that each condition in a decision take on every possible
    outcome - might not be satisfied.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在C编程语言中，`&&`和`||`是“短路”操作符，MC/DC和分支覆盖几乎是一样的。主要区别在于布尔向量测试。可以测试位向量中的多个位中的任意一位，并且即使MC/DC的第二个元素——每个决策中的每个条件都采用每种可能的结果的要求可能未被满足，也可以获得100%的分支测试覆盖。
- en: SQLite uses `testcase()` macros as described in the previous subsection to make
    sure that every condition in a bit-vector decision takes on every possible outcome.
    In this way, SQLite also achieves 100% MC/DC in addition to 100% branch coverage.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite还使用如前节所述的`testcase()`宏来确保位向量决策中的每个条件都采用每种可能的结果。通过这种方式，SQLite不仅实现了100%的分支覆盖，还实现了100%的MC/DC。
- en: 7.5\. Measuring branch coverage
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5\. 测量分支覆盖率
- en: Branch coverage in SQLite is currently measured using [gcov](https://gcc.gnu.org/onlinedocs/gcc/Gcov.html)
    with the "-b" option. First the test program is compiled using options "-g -fprofile-arcs
    -ftest-coverage" and then the test program is run. Then "gcov -b" is run to generate
    a coverage report. The coverage report is verbose and inconvenient to read, so
    the gcov-generated report is processed using some simple scripts to put it into
    a more human-friendly format. This entire process is automated using scripts,
    of course.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite当前使用[gcov](https://gcc.gnu.org/onlinedocs/gcc/Gcov.html)测量分支覆盖率，使用“-b”选项。首先，使用选项“-g
    -fprofile-arcs -ftest-coverage”编译测试程序，然后运行测试程序。然后运行“gcov -b”生成覆盖率报告。覆盖率报告很冗长且不便于阅读，因此使用一些简单的脚本处理gcov生成的报告，使其更符合人类阅读习惯。当然，整个过程都是使用脚本自动化的。
- en: Note that running SQLite with gcov is not a test of SQLite — it is a test of
    the test suite. The gcov run does not test SQLite because the -fprofile-args and
    -ftest-coverage options cause the compiler to generate different code. The gcov
    run merely verifies that the test suite provides 100% branch test coverage. The
    gcov run is a test of the test - a meta-test.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用 gcov 运行 SQLite 并不是对 SQLite 的测试 —— 它是对测试套件的测试。 gcov 运行不测试 SQLite，因为 -fprofile-args
    和 -ftest-coverage 选项会导致编译器生成不同的代码。 gcov 运行仅仅验证测试套件是否提供了 100% 的分支测试覆盖率。 gcov 运行是测试测试的测试
    - 一个元测试。
- en: After gcov has been run to verify 100% branch test coverage, then the test program
    is recompiled using delivery compiler options (without the special -fprofile-arcs
    and -ftest-coverage options) and the test program is rerun. This second run is
    the actual test of SQLite.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 gcov 验证了 100% 的分支测试覆盖率之后，然后使用交付编译器选项（而不是特殊的 -fprofile-arcs 和 -ftest-coverage
    选项）重新编译测试程序，并重新运行测试程序。 这第二次运行才是 SQLite 的实际测试。
- en: It is important to verify that the gcov test run and the second real test run
    both give the same output. Any differences in output indicate either the use of
    undefined or indeterminate behavior in the SQLite code (and hence a bug), or a
    bug in the compiler. Note that SQLite has, over the previous decade, encountered
    bugs in each of GCC, Clang, and MSVC. Compiler bugs, while rare, do happen, which
    is why it is so important to test the code in an as-delivered configuration.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 验证 gcov 测试运行和第二次真实测试运行的输出相同非常重要。 任何输出上的差异都表明 SQLite 代码中使用了未定义或不确定的行为（从而是一个 bug），或者编译器存在
    bug。 请注意，SQLite 在过去的十年中遇到了 GCC、Clang 和 MSVC 中的每个编译器的 bug。 编译器 bug 虽然罕见，但确实会发生，这就是为什么在交付配置下测试代码如此重要的原因。
- en: 7.6\. Mutation testing
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.6\. 突变测试
- en: Using gcov (or similar) to show that every branch instruction is taken at least
    once in both directions is good measure of test suite quality. But even better
    is showing that every branch instruction makes a difference in the output. In
    other words, we want to show not only that every branch instruction both jumps
    and falls through but also that every branch is doing useful work and that the
    test suite is able to detect and verify that work. When a branch is found that
    does not make a difference in the output, that suggests that code associated with
    the branch can be removed (reducing the size of the library and perhaps making
    it run faster) or that the test suite is inadequately testing the feature that
    the branch implements.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 gcov（或类似工具）显示每个分支指令在两个方向上都至少执行一次是测试套件质量的一个良好衡量标准。 但更好的是要显示每个分支指令对输出都产生影响。
    换句话说，我们希望不仅显示每个分支指令既跳转又顺序执行，还要显示每个分支正在执行有用的工作，并且测试套件能够检测和验证这些工作。 当发现一个不影响输出的分支时，这表明可以删除与该分支相关联的代码（减少库的大小，或许使其运行更快），或者测试套件不足以测试该分支实现的功能。
- en: SQLite strives to verify that every branch instruction makes a difference using
    [mutation testing](https://en.wikipedia.org/wiki/Mutation_testing). [A script](th3.html#muttest)
    first compiles the SQLite source code into assembly language (using, for example,
    the -S option to gcc). Then the script steps through the generated assembly language
    and, one by one, changes each branch instruction into either an unconditional
    jump or a no-op, compiles the result, and verifies that the test suite catches
    the mutation.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 通过 [突变测试](https://zh.wikipedia.org/wiki/%E7%AA%81%E5%8F%98%E6%B5%8B%E8%AF%95)
    力求验证每个分支指令的差异性。 [一个脚本](th3.html#muttest) 首先将 SQLite 源代码编译成汇编语言（例如使用 gcc 的 -S 选项）。
    然后，该脚本逐步遍历生成的汇编语言，并逐个将每个分支指令更改为无条件跳转或空操作，编译结果，并验证测试套件是否捕获到了这种变异。
- en: 'Unfortunately, SQLite contains many branch instructions that help the code
    run faster without changing the output. Such branches generate false-positives
    during mutation testing. As an example, consider the following [hash function](https://www.sqlite.org/src/artifact/55b5fb474?ln=55-62)
    used to accelerate table-name lookup:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，SQLite 包含许多分支指令，这些指令帮助代码运行得更快，但并不改变输出。 这样的分支在突变测试中会产生假阳性。 例如，考虑以下用于加速表名查找的
    [哈希函数](https://www.sqlite.org/src/artifact/55b5fb474?ln=55-62)：
- en: '[PRE8]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If the branch instruction that implements the "c!=0" test on line 58 is changed
    into a no-op, then the while-loop will loop forever and the test suite will fail
    with a time-out. But if that branch is changed into an unconditional jump, then
    the hash function will always return 0. The problem is that 0 is a valid hash.
    A hash function that always returns 0 still works in the sense that SQLite still
    always gets the correct answer. The table-name hash table degenerates into a linked-list
    and so the table-name lookups that occur while parsing SQL statements might be
    a little slower, but the end result will be the same.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果58行实现“c!=0”测试的分支指令被改为空操作，那么while循环将永远循环下去，并且测试套件将因超时而失败。但如果该分支改为无条件跳转，则哈希函数将始终返回0。问题在于0是有效的哈希值。即使哈希函数始终返回0，在某种意义上SQLite仍然可以得到正确的答案。表名哈希表退化为链表，因此在解析SQL语句时进行的表名查找可能会慢一些，但最终结果将是一样的。
- en: To work around this problem, comments of the form "`/*OPTIMIZATION-IF-TRUE*/`"
    and "`/*OPTIMIZATION-IF-FALSE*/`" are inserted into the SQLite source code to
    tell the mutation testing script to ignore some branch instructions.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，在SQLite源代码中插入形如"`/*OPTIMIZATION-IF-TRUE*/`"和"`/*OPTIMIZATION-IF-FALSE*/`"的注释，告诉变异测试脚本忽略一些分支指令。
- en: 7.7\. Experience with full test coverage
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7\. 全覆盖测试的经验
- en: The developers of SQLite have found that full coverage testing is an extremely
    effective method for locating and preventing bugs. Because every single branch
    instruction in SQLite core code is covered by test cases, the developers can be
    confident that changes made in one part of the code do not have unintended consequences
    in other parts of the code. The many new features and performance improvements
    that have been added to SQLite in recent years would not have been possible without
    the availability of full-coverage testing.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite的开发人员发现全覆盖测试是一种非常有效的方法，用于定位和预防错误。因为SQLite核心代码中的每个分支指令都由测试用例覆盖，开发人员可以确信在代码的某个部分进行的更改不会在代码的其他部分产生意外后果。近年来为SQLite添加的许多新功能和性能改进如果没有全覆盖测试的支持是不可能的。
- en: Maintaining 100% MC/DC is laborious and time-consuming. The level of effort
    needed to maintain full-coverage testing is probably not cost effective for a
    typical application. However, we think that full-coverage testing is justified
    for a [very widely deployed](mostdeployed.html) infrastructure library like SQLite,
    and especially for a database library which by its very nature "remembers" past
    mistakes.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 维护100%的MC/DC测试工作繁琐且耗时。对于典型应用程序来说，维护全覆盖测试的努力程度可能不划算。然而，我们认为像SQLite这样的[非常广泛部署的](mostdeployed.html)基础设施库，特别是对于数据库库而言，完全覆盖测试是合理的，因为其本质上“记住”了过去的错误。
- en: 8\. Dynamic Analysis
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8\. 动态分析
- en: Dynamic analysis refers to internal and external checks on the SQLite code which
    are performed while the code is live and running. Dynamic analysis has proven
    to be a great help in maintaining the quality of SQLite.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分析指的是在SQLite代码运行时进行的内部和外部检查。动态分析已被证明在维护SQLite代码质量方面非常有帮助。
- en: 8.1\. Assert
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1\. Assert
- en: The SQLite core contains 6754 `assert()` statements that verify function preconditions
    and postconditions and loop invariants. Assert() is a macro which is a standard
    part of ANSI-C. The argument is a boolean value that is assumed to always be true.
    If the assertion is false, the program prints an error message and halts.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite核心包含6754个`assert()`语句，用于验证函数前置条件、后置条件和循环不变式。Assert()是ANSI-C的标准部分的宏。参数是一个布尔值，假定始终为真。如果断言为假，程序将打印错误消息并停止。
- en: Assert() macros are disabled by compiling with the NDEBUG macro defined. In
    most systems, asserts are enabled by default. But in SQLite, the asserts are so
    numerous and are in such performance critical places, that the database engine
    runs about three times slower when asserts are enabled. Hence, the default (production)
    build of SQLite disables asserts. Assert statements are only enabled when SQLite
    is compiled with the SQLITE_DEBUG preprocessor macro defined.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Assert()宏在编译时通过定义NDEBUG宏来禁用。在大多数系统中，assert语句默认启用。但在SQLite中，assert语句非常多，并且位于性能关键的位置，因此当启用assert时，数据库引擎的运行速度会慢大约三倍。因此，SQLite的默认（生产）构建禁用assert语句。只有在定义了SQLITE_DEBUG预处理宏的情况下，assert语句才会启用。
- en: See the [Use Of assert in SQLite](assert.html) document for additional information
    about how SQLite uses assert().
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[SQLite中assert的使用](assert.html)文档以获取有关SQLite如何使用assert()的其他信息。
- en: 8.2\. Valgrind
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2\. Valgrind
- en: '[Valgrind](http://valgrind.org/) is perhaps the most amazing and useful developer
    tool in the world. Valgrind is a simulator - it simulates an x86 running a Linux
    binary. (Ports of Valgrind for platforms other than Linux are in development,
    but as of this writing, Valgrind only works reliably on Linux, which in the opinion
    of the SQLite developers means that Linux should be the preferred platform for
    all software development.) As Valgrind runs a Linux binary, it looks for all kinds
    of interesting errors such as array overruns, reading from uninitialized memory,
    stack overflows, memory leaks, and so forth. Valgrind finds problems that can
    easily slip through all of the other tests run against SQLite. And, when Valgrind
    does find an error, it can dump the developer directly into a symbolic debugger
    at the exact point where the error occur, to facilitate a quick fix.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[Valgrind](http://valgrind.org/)也许是世界上最令人惊奇和有用的开发者工具。 Valgrind是一个模拟器 - 它模拟运行Linux二进制文件的x86架构。
    （除Linux之外的平台上的Valgrind端口正在开发中，但截至本文撰写时，Valgrind仅在Linux上可靠运行，SQLite开发者认为Linux应该是所有软件开发的首选平台。）当Valgrind运行Linux二进制文件时，它寻找各种有趣的错误，例如数组溢出，从未初始化的内存读取，堆栈溢出，内存泄漏等等。
    Valgrind找到的问题往往可以轻易地溜过所有其他针对SQLite运行的测试。 而且，当Valgrind找到错误时，它可以将开发人员直接转到符号调试器，准确地定位错误发生的地方，以便快速修复。'
- en: Because it is a simulator, running a binary in Valgrind is slower than running
    it on native hardware. (To a first approximation, an application running in Valgrind
    on a workstation will perform about the same as it would running natively on a
    smartphone.) So it is impractical to run the full SQLite test suite through Valgrind.
    However, the veryquick tests and the coverage of the TH3 tests are run through
    Valgrind prior to every release.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它是一个模拟器，运行在Valgrind上的二进制比在本地硬件上运行要慢。 （从第一次近似来看，一个在工作站上通过Valgrind运行的应用程序将表现得与在智能手机上本地运行相似。）因此，通过Valgrind运行完整的SQLite测试套件是不切实际的。
    然而，非常快速的测试和TH3测试的覆盖范围在每次发布之前都会通过Valgrind运行。
- en: 8.3\. Memsys2
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3\. Memsys2
- en: SQLite contains a pluggable [memory allocation subsystem](malloc.html). The
    default implementation uses system malloc() and free(). However, if SQLite is
    compiled with [SQLITE_MEMDEBUG](compile.html#memdebug), an alternative memory
    allocation wrapper ([memsys2](malloc.html#memdebug)) is inserted that looks for
    memory allocation errors at run-time. The memsys2 wrapper checks for memory leaks,
    of course, but also looks for buffer overruns, uses of uninitialized memory, and
    attempts to use memory after it has been freed. These same checks are also done
    by valgrind (and, indeed, Valgrind does them better) but memsys2 has the advantage
    of being much faster than Valgrind, which means the checks can be done more often
    and for longer tests.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite包含一个可插拔的[内存分配子系统](malloc.html)。 默认实现使用系统malloc（）和free（）。 但是，如果使用[SQLITE_MEMDEBUG](compile.html#memdebug)编译SQLite，则会插入一个替代的内存分配包装器（[memsys2](malloc.html#memdebug)），该包装器在运行时查找内存分配错误。
    memsys2包装器当然检查内存泄漏，但也查找缓冲区溢出，未初始化内存的使用以及尝试在释放后使用内存。 Valgrind也执行这些相同的检查（实际上，Valgrind执行得更好），但memsys2的优势在于比Valgrind快得多，这意味着可以更频繁地进行检查，并进行更长时间的测试。
- en: 8.4\. Mutex Asserts
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4\. 互斥断言
- en: SQLite contains a pluggable mutex subsystem. Depending on compile-time options,
    the default mutex system contains interfaces [sqlite3_mutex_held()](c3ref/mutex_held.html)
    and [sqlite3_mutex_notheld()](c3ref/mutex_held.html) that detect whether or not
    a particular mutex is held by the calling thread. These two interfaces are used
    extensively within assert() statements in SQLite to verify mutexes are held and
    released at all the right moments, in order to double-check that SQLite does work
    correctly in multi-threaded applications.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite包含一个可插拔的互斥子系统。 根据编译时选项，默认的互斥系统包含接口[sqlite3_mutex_held（）](c3ref/mutex_held.html)和[sqlite3_mutex_notheld（）](c3ref/mutex_held.html)，用于检测调用线程是否持有特定的互斥体。
    在SQLite的assert（）语句中广泛使用这两个接口，以验证互斥体在所有正确的时刻被持有和释放，以便仔细检查SQLite在多线程应用程序中是否正确工作。
- en: 8.5\. Journal Tests
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.5\. 日志测试
- en: One of the things that SQLite does to ensure that transactions are atomic across
    system crashes and power failures is to write all changes into the rollback journal
    file prior to changing the database. The TCL test harness contains an alternative
    [OS backend](vfs.html) implementation that helps to verify this is occurring correctly.
    The "journal-test VFS" monitors all disk I/O traffic between the database file
    and rollback journal, checking to make sure that nothing is written into the database
    file which has not first been written and synced to the rollback journal. If any
    discrepancies are found, an assertion fault is raised.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite为确保事务在系统崩溃和断电时是原子的而做的一项工作是，在修改数据库之前将所有更改写入回滚日志文件。TCL测试工具包含一个备用的[OS后端](vfs.html)实现，帮助验证这一操作是否正确进行。"journal-test
    VFS"监视数据库文件与回滚日志之间的所有磁盘I/O流量，检查确保没有任何写入数据库文件的内容未先写入并同步到回滚日志。如果发现任何不一致，将引发断言错误。
- en: The journal tests are an additional double-check over and above the crash tests
    to make sure that SQLite transactions will be atomic across system crashes and
    power failures.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 日志测试是在崩溃测试之上的一种额外的双重检查，确保SQLite事务在系统崩溃和断电时是原子的。
- en: 8.6\. Undefined Behavior Checks
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.6. 未定义行为检查
- en: 'In the C programming language, it is very easy to write code that has "undefined"
    or "implementation defined" behavior. That means that the code might work during
    development, but then give a different answer on a different system, or when recompiled
    using different compiler options. Examples of undefined and implementation-defined
    behavior in ANSI C include:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在C编程语言中，编写具有"未定义"或"实现定义"行为的代码非常容易。这意味着代码在开发过程中可能有效，但在不同系统或使用不同编译器选项重新编译时可能会得到不同的答案。ANSI
    C中未定义和实现定义行为的例子包括：
- en: Signed integer overflow. (Signed integer overflow does not necessarily wrap
    around, as most people expect.)
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有符号整数溢出。（有符号整数溢出不一定会环绕，正如大多数人所期望的那样。）
- en: Shifting an N-bit integer by more than N bits.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将N位整数向左或向右移动超过N位。
- en: Shifting by a negative amount.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动一个负数量。
- en: Shifting a negative number.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动一个负数。
- en: Using the memcpy() function on overlapping buffers.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在重叠缓冲区上使用memcpy()函数。
- en: The order of evaluation of function arguments.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数参数的求值顺序。
- en: Whether or not "char" variables are signed or unsigned.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"char"变量是有符号还是无符号。'
- en: And so forth....
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等等……
- en: Since undefined and implementation-defined behavior is non-portable and can
    easily lead to incorrect answers, SQLite works very hard to avoid it. For example,
    when adding two integer column values together as part of an SQL statement, SQLite
    does not simply add them together using the C-language "+" operator. Instead,
    it first checks to make sure the addition will not overflow, and if it will, it
    does the addition using floating point instead.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于未定义和实现定义的行为是不可移植的，并且很容易导致错误答案，SQLite非常努力避免它。例如，在SQL语句中将两个整数列值相加时，SQLite不仅仅使用C语言的"+"运算符将它们简单相加。相反，它首先检查确保加法不会溢出，如果会溢出，则使用浮点数进行加法运算。
- en: 'To help ensure that SQLite does not make use of undefined or implementation
    defined behavior, the test suites are rerun using instrumented builds that try
    to detect undefined behavior. For example, test suites are run using the "-ftrapv"
    option of GCC. And they are run again using the "-fsanitize=undefined" option
    on Clang. And again using the "/RTC1" option in MSVC. Then the test suites are
    rerun using options like "-funsigned-char" and "-fsigned-char" to make sure that
    implementation differences do not matter either. Tests are then repeated on 32-bit
    and 64-bit systems and on big-endian and little-endian systems, using a variety
    of CPU architectures. Furthermore, the test suites are augmented with many test
    cases that are deliberately designed to provoke undefined behavior. For example:
    "**SELECT -1*(-9223372036854775808);**".'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保SQLite不使用未定义或实现定义的行为，测试套件会使用带有检测未定义行为的仪器化构建重新运行。例如，测试套件使用GCC的"-ftrapv"选项运行。然后再次使用Clang的"-fsanitize=undefined"选项运行。然后再使用MSVC的"/RTC1"选项运行。然后使用"-funsigned-char"和"-fsigned-char"选项再次运行测试套件，以确保实现差异也无关紧要。测试还会在32位和64位系统上以及大端和小端系统上，使用各种CPU架构进行重复。此外，测试套件还增加了许多故意设计来引发未定义行为的测试用例。例如："**SELECT
    -1*(-9223372036854775808);**"。
- en: 9\. Disabled Optimization Tests
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9. 禁用优化测试
- en: The [sqlite3_test_control](c3ref/test_control.html)([SQLITE_TESTCTRL_OPTIMIZATIONS](c3ref/c_testctrl_always.html),
    ...) interface allows selected SQL statement optimizations to be disabled at run-time.
    SQLite should always generate exactly the same answer with optimizations enabled
    and with optimizations disabled; the answer simply arrives quicker with the optimizations
    turned on. So in a production environment, one always leaves the optimizations
    turned on (the default setting).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[sqlite3_test_control](c3ref/test_control.html)([SQLITE_TESTCTRL_OPTIMIZATIONS](c3ref/c_testctrl_always.html),
    ...) 接口允许在运行时禁用选定的 SQL 语句优化。SQLite 应该在启用和禁用优化时始终生成完全相同的答案；只是在启用优化时答案会更快到达。因此，在生产环境中，通常保持优化开启（默认设置）。'
- en: One verification technique used on SQLite is to run an entire test suite twice,
    once with optimizations left on and a second time with optimizations turned off,
    and verify that the same output is obtained both times. This shows that the optimizations
    do not introduce errors.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对 SQLite 使用的一种验证技术是运行整个测试套件两次，一次保持优化开启，另一次关闭优化，并验证两次都获得相同的输出。这表明优化不会引入错误。
- en: Not all test cases can be handled this way. Some test cases check to verify
    that the optimizations really are reducing the amount of computation by counting
    the number of disk accesses, sort operations, full-scan steps, or other processing
    steps that occur during queries. Those test cases will appear to fail when optimizations
    are disabled. But the majority of test cases simply check that the correct answer
    was obtained, and all of those cases can be run successfully with and without
    the optimizations, in order to show that the optimizations do not cause malfunctions.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有测试用例都可以通过这种方式处理。某些测试用例检查优化是否确实通过计算磁盘访问次数、排序操作、全扫描步骤或其他处理步骤来减少计算量。当禁用优化时，这些测试用例会出现失败。但大多数测试用例只是检查是否获得了正确答案，所有这些情况都可以在启用和禁用优化时成功运行，以表明优化不会导致故障。
- en: 10\. Checklists
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10\. Checklists
- en: The SQLite developers use an on-line checklist to coordinate testing activity
    and to verify that all tests pass prior each SQLite release. [Past checklists](https://www.sqlite.org/checklists/index.html)
    are retained for historical reference. (The checklists are read-only for anonymous
    internet viewers, but developers can log in and update checklist items in their
    web browsers.) The use of checklists for SQLite testing and other development
    activities is inspired by *[The Checklist Manifesto](http://atulgawande.com/book/the-checklist-manifesto/)*
    .
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 开发人员使用在线清单来协调测试活动，并在每次 SQLite 发布之前验证所有测试是否通过。[过去的检查清单](https://www.sqlite.org/checklists/index.html)被保留作为历史参考。（对于匿名互联网查看者，检查清单是只读的，但开发人员可以登录并在其网页浏览器中更新清单项。）SQLite
    测试和其他开发活动中使用清单的灵感来自于 *[《清单宣言》](http://atulgawande.com/book/the-checklist-manifesto/)*
    。
- en: The latest checklists contain approximately 200 items that are individually
    verified for each release. Some checklist items only take a few seconds to verify
    and mark off. Others involve test suites that run for many hours.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最新的检查清单包含大约 200 项，每个发布版本都会逐项进行验证。有些检查项只需几秒钟即可完成并标记。其他涉及运行数小时的测试套件。
- en: 'The release checklist is not automated: developers run each item on the checklist
    manually. We find that it is important to keep a human in the loop. Sometimes
    problems are found while running a checklist item even though the test itself
    passed. It is important to have a human reviewing the test output at the highest
    level, and constantly asking "Is this really right?"'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 发布清单并非自动化：开发人员手动运行清单中的每一项。我们发现保持人为参与很重要。有时即使测试本身通过，运行清单项时仍可能发现问题。在最高层级审查测试输出并持续询问“这真的正确吗？”是很重要的。
- en: The release checklist is continuously evolving. As new problems or potential
    problems are discovered, new checklist items are added to make sure those problems
    do not appear in subsequent releases. The release checklist has proven to be an
    invaluable tool in helping to ensure that nothing is overlooked during the release
    process.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 发布清单在不断发展。随着发现新问题或潜在问题，会添加新的清单项，以确保这些问题不会出现在后续发布中。发布清单已被证明是确保在发布过程中没有遗漏任何事项的宝贵工具。
- en: 11\. Static Analysis
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11\. 静态分析
- en: Static analysis means analyzing source code at compile-time to check for correctness.
    Static analysis includes compiler warning messages and more in-depth analysis
    engines such as the [Clang Static Analyzer](http://clang-analyzer.llvm.org/).
    SQLite compiles without warnings on GCC and Clang using the -Wall and -Wextra
    flags on Linux and Mac and on MSVC on Windows. No valid warnings are generated
    by the Clang Static Analyzer tool "scan-build" either (though recent versions
    of clang seem to generate many false-positives.) Nevertheless, some warnings might
    be generated by other static analyzers. Users are encouraged not to stress over
    these warnings and to instead take solace in the intense testing of SQLite described
    above.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析意味着在编译时分析源代码以检查正确性。静态分析包括编译器的警告信息以及更深入的分析引擎，如[Clang Static Analyzer](http://clang-analyzer.llvm.org/)。在
    Linux 和 Mac 上，SQLite 在 GCC 和 Clang 使用 -Wall 和 -Wextra 标志编译时没有警告，在 Windows 上使用
    MSVC 也是如此。Clang Static Analyzer 工具 "scan-build" 也没有生成有效警告（尽管最近的 clang 版本似乎生成了很多误报）。尽管如此，其他静态分析器可能会生成一些警告。建议用户不要过于担心这些警告，而是放心于上述
    SQLite 的强大测试工作。
- en: Static analysis has not been helpful in finding bugs in SQLite. Static analysis
    has found a few bugs in SQLite, but those are the exceptions. More bugs have been
    introduced into SQLite while trying to get it to compile without warnings than
    have been found by static analysis.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析在发现 SQLite 中的错误方面并不那么有帮助。静态分析确实在 SQLite 中发现了一些错误，但那些属于例外。与通过静态分析找到的错误相比，更多的错误是在尝试消除警告以使
    SQLite 编译通过时引入的。
- en: 12\. Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12\. 总结
- en: SQLite is open source. This gives many people the idea that it is not well tested
    as commercial software and is perhaps unreliable. But that impression is false.
    SQLite has exhibited very high reliability in the field and a very low defect
    rate, especially considering how rapidly it is evolving. The quality of SQLite
    is achieved in part by careful code design and implementation. But extensive testing
    also plays a vital role in maintaining and improving the quality of SQLite. This
    document has summarized the testing procedures that every release of SQLite undergoes
    with the hope of inspiring confidence that SQLite is suitable for use in mission-critical
    applications.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 是开源的。这让很多人误以为它没有商业软件那样经过充分测试，可能不可靠。但这种印象是错误的。SQLite 在实际应用中展现出非常高的可靠性和极低的缺陷率，尤其是考虑到它的快速发展速度。SQLite
    的质量部分得益于精心设计和实现的代码，但广泛的测试也在维护和提升 SQLite 的质量中发挥着至关重要的作用。本文总结了每个 SQLite 发布版本都经历的测试流程，希望能够增强
    SQLite 在关键任务应用中的可信度。
