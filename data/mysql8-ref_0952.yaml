- en: 15.2.13 SELECT Statement
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.2.13 SELECT Statement
- en: 原文：[https://dev.mysql.com/doc/refman/8.0/en/select.html](https://dev.mysql.com/doc/refman/8.0/en/select.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://dev.mysql.com/doc/refman/8.0/en/select.html](https://dev.mysql.com/doc/refman/8.0/en/select.html)
- en: '[15.2.13.1 SELECT ... INTO Statement](select-into.html)'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[15.2.13.1 SELECT ... INTO Statement](select-into.html)'
- en: '[15.2.13.2 JOIN Clause](join.html)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[15.2.13.2 JOIN Clause](join.html)'
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[`SELECT`](select.html "15.2.13 SELECT Statement") is used to retrieve rows
    selected from one or more tables, and can include [`UNION`](union.html "15.2.18 UNION
    Clause") operations and subqueries. Beginning with MySQL 8.0.31, [`INTERSECT`](intersect.html
    "15.2.8 INTERSECT Clause") and [`EXCEPT`](except.html "15.2.4 EXCEPT Clause")
    operations are also supported. The `UNION`, `INTERSECT`, and `EXCEPT` operators
    are described in more detail later in this section. See also [Section 15.2.15,
    “Subqueries”](subqueries.html "15.2.15 Subqueries").'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[`SELECT`](select.html "15.2.13 SELECT Statement") 用于检索从一个或多个表中选择的行，并且可以包括
    [`UNION`](union.html "15.2.18 UNION Clause") 操作和子查询。从 MySQL 8.0.31 开始，还支持 [`INTERSECT`](intersect.html
    "15.2.8 INTERSECT Clause") 和 [`EXCEPT`](except.html "15.2.4 EXCEPT Clause") 操作。`UNION`、`INTERSECT`
    和 `EXCEPT` 运算符将在本节后面更详细地描述。另请参阅 [Section 15.2.15, “Subqueries”](subqueries.html
    "15.2.15 Subqueries")。'
- en: A [`SELECT`](select.html "15.2.13 SELECT Statement") statement can start with
    a [`WITH`](with.html "15.2.20 WITH (Common Table Expressions)") clause to define
    common table expressions accessible within the [`SELECT`](select.html "15.2.13 SELECT
    Statement"). See [Section 15.2.20, “WITH (Common Table Expressions)”](with.html
    "15.2.20 WITH (Common Table Expressions)").
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '[`SELECT`](select.html "15.2.13 SELECT Statement") 语句可以以 [`WITH`](with.html
    "15.2.20 WITH (Common Table Expressions)") 子句开头，以定义在 [`SELECT`](select.html "15.2.13 SELECT
    Statement") 中可访问的常用表达式。请参阅 [Section 15.2.20, “WITH (Common Table Expressions)”](with.html
    "15.2.20 WITH (Common Table Expressions)")。'
- en: 'The most commonly used clauses of [`SELECT`](select.html "15.2.13 SELECT Statement")
    statements are these:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[`SELECT`](select.html "15.2.13 SELECT Statement") 语句最常用的子句包括：'
- en: Each *`select_expr`* indicates a column that you want to retrieve. There must
    be at least one *`select_expr`*.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个 *`select_expr`* 表示要检索的列。必须至少有一个 *`select_expr`*。
- en: '*`table_references`* indicates the table or tables from which to retrieve rows.
    Its syntax is described in [Section 15.2.13.2, “JOIN Clause”](join.html "15.2.13.2 JOIN
    Clause").'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*`table_references`* 指示要检索行的表或表。其语法在 [Section 15.2.13.2, “JOIN Clause”](join.html
    "15.2.13.2 JOIN Clause") 中描述。'
- en: '`SELECT` supports explicit partition selection using the `PARTITION` clause
    with a list of partitions or subpartitions (or both) following the name of the
    table in a *`table_reference`* (see [Section 15.2.13.2, “JOIN Clause”](join.html
    "15.2.13.2 JOIN Clause")). In this case, rows are selected only from the partitions
    listed, and any other partitions of the table are ignored. For more information
    and examples, see [Section 26.5, “Partition Selection”](partitioning-selection.html
    "26.5 Partition Selection").'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SELECT` 支持使用 `PARTITION` 子句显式选择分区，后跟表名中的分区或子分区列表（或两者都有）在 *`table_reference`*
    中（参见 [Section 15.2.13.2, “JOIN Clause”](join.html "15.2.13.2 JOIN Clause")）。在这种情况下，仅从列出的分区中选择行，忽略表的任何其他分区。有关更多信息和示例，请参阅
    [Section 26.5, “Partition Selection”](partitioning-selection.html "26.5 Partition
    Selection")。'
- en: The `WHERE` clause, if given, indicates the condition or conditions that rows
    must satisfy to be selected. *`where_condition`* is an expression that evaluates
    to true for each row to be selected. The statement selects all rows if there is
    no `WHERE` clause.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果给出 `WHERE` 子句，则指示行必须满足的条件或条件。*`where_condition`* 是一个表达式，对于要选择的每一行都会计算为 true。如果没有
    `WHERE` 子句，则该语句选择所有行。
- en: In the `WHERE` expression, you can use any of the functions and operators that
    MySQL supports, except for aggregate (group) functions. See [Section 11.5, “Expressions”](expressions.html
    "11.5 Expressions"), and [Chapter 14, *Functions and Operators*](functions.html
    "Chapter 14 Functions and Operators").
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `WHERE` 表达式中，您可以使用 MySQL 支持的任何函数和运算符，但不能使用聚合（组）函数。请参阅 [Section 11.5, “Expressions”](expressions.html
    "11.5 Expressions")，以及 [Chapter 14, *Functions and Operators*](functions.html
    "Chapter 14 Functions and Operators")。
- en: '[`SELECT`](select.html "15.2.13 SELECT Statement") can also be used to retrieve
    rows computed without reference to any table.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[`SELECT`](select.html "15.2.13 SELECT Statement") 也可用于检索计算而不参考任何表的行。'
- en: 'For example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You are permitted to specify `DUAL` as a dummy table name in situations where
    no tables are referenced:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有引用任何表的情况下，您可以指定 `DUAL` 作为虚拟表名：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`DUAL` is purely for the convenience of people who require that all [`SELECT`](select.html
    "15.2.13 SELECT Statement") statements should have `FROM` and possibly other clauses.
    MySQL may ignore the clauses. MySQL does not require `FROM DUAL` if no tables
    are referenced.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`DUAL`纯粹是为那些要求所有[`SELECT`](select.html "15.2.13 SELECT Statement")语句应具有`FROM`和可能其他子句的人方便而设计的。MySQL可能会忽略这些子句。如果没有引用表，则MySQL不需要`FROM
    DUAL`。'
- en: In general, clauses used must be given in exactly the order shown in the syntax
    description. For example, a `HAVING` clause must come after any `GROUP BY` clause
    and before any `ORDER BY` clause. The `INTO` clause, if present, can appear in
    any position indicated by the syntax description, but within a given statement
    can appear only once, not in multiple positions. For more information about `INTO`,
    see [Section 15.2.13.1, “SELECT ... INTO Statement”](select-into.html "15.2.13.1 SELECT
    ... INTO Statement").
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，必须按照语法描述中显示的顺序给出使用的子句。例如，`HAVING`子句必须在任何`GROUP BY`子句之后和任何`ORDER BY`子句之前。如果存在`INTO`子句，则可以出现在语法描述指示的任何位置，但在给定语句中只能出现一次，而不是在多个位置。有关`INTO`的更多信息，请参见[第15.2.13.1节，“SELECT
    ... INTO语句”](select-into.html "15.2.13.1 SELECT ... INTO Statement")。
- en: 'The list of *`select_expr`* terms comprises the select list that indicates
    which columns to retrieve. Terms specify a column or expression or can use `*`-shorthand:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*`select_expr`*项列表包括指示要检索哪些列的选择列表。项指定列或表达式，或可以使用`*`-简写：'
- en: 'A select list consisting only of a single unqualified `*` can be used as shorthand
    to select all columns from all tables:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅由单个未限定的`*`组成的选择列表可以用作从所有表中选择所有列的简写：
- en: '[PRE3]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`*`tbl_name`*.*` can be used as a qualified shorthand to select all columns
    from the named table:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`tbl_name`*.*` 可以用作从命名表中选择所有列的限定简写：'
- en: '[PRE4]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If a table has invisible columns, `*` and `*`tbl_name`*.*` do not include them.
    To be included, invisible columns must be referenced explicitly.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果表具有不可见列，则`*`和`*`tbl_name`*.*` 不包括它们。要包括不可见列，必须明确引用它们。
- en: 'Use of an unqualified `*` with other items in the select list may produce a
    parse error. For example:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在选择列表中与其他项目一起使用未限定的`*`可能会产生解析错误。例如：
- en: '[PRE5]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To avoid this problem, use a qualified `*`tbl_name`*.*` reference:'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为避免此问题，请使用限定的`*`tbl_name`*.*` 引用：
- en: '[PRE6]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Use qualified `*`tbl_name`*.*` references for each table in the select list:'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在选择列表中为每个表使用限定的`*`tbl_name`*.*` 引用：
- en: '[PRE7]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following list provides additional information about other `SELECT` clauses:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表提供了有关其他`SELECT`子句的其他信息：
- en: 'A *`select_expr`* can be given an alias using `AS *`alias_name`*`. The alias
    is used as the expression''s column name and can be used in `GROUP BY`, `ORDER
    BY`, or `HAVING` clauses. For example:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`AS *`alias_name`*`为*`select_expr`*指定别名。别名用作表达式的列名，并且可以在`GROUP BY`、`ORDER
    BY`或`HAVING`子句中使用。例如：
- en: '[PRE8]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `AS` keyword is optional when aliasing a *`select_expr`* with an identifier.
    The preceding example could have been written like this:'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在使用标识符为*`select_expr`*指定别名时，`AS`关键字是可选的。前面的示例可以这样写：
- en: '[PRE9]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'However, because the `AS` is optional, a subtle problem can occur if you forget
    the comma between two *`select_expr`* expressions: MySQL interprets the second
    as an alias name. For example, in the following statement, `columnb` is treated
    as an alias name:'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但是，由于`AS`是可选的，如果忘记在两个*`select_expr`*表达式之间加逗号，可能会出现一个微妙的问题：MySQL将第二个解释为别名。例如，在以下语句中，`columnb`被视为别名：
- en: '[PRE10]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For this reason, it is good practice to be in the habit of using `AS` explicitly
    when specifying column aliases.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，养成在指定列别名时明确使用`AS`的习惯是一个好习惯。
- en: It is not permissible to refer to a column alias in a `WHERE` clause, because
    the column value might not yet be determined when the `WHERE` clause is executed.
    See [Section B.3.4.4, “Problems with Column Aliases”](problems-with-alias.html
    "B.3.4.4 Problems with Column Aliases").
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`WHERE`子句中不允许引用列别名，因为在执行`WHERE`子句时可能尚未确定列值。请参见[第B.3.4.4节，“列别名问题”](problems-with-alias.html
    "B.3.4.4 Problems with Column Aliases")。
- en: The `FROM *`table_references`*` clause indicates the table or tables from which
    to retrieve rows. If you name more than one table, you are performing a join.
    For information on join syntax, see [Section 15.2.13.2, “JOIN Clause”](join.html
    "15.2.13.2 JOIN Clause"). For each table specified, you can optionally specify
    an alias.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROM *`table_references`*` 子句表示要检索行的表或表。如果命名多个表，则正在执行连接。有关连接语法的信息，请参见[第15.2.13.2节，“JOIN子句”](join.html
    "15.2.13.2 JOIN Clause")。对于每个指定的表，您可以选择指定别名。'
- en: '[PRE11]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The use of index hints provides the optimizer with information about how to
    choose indexes during query processing. For a description of the syntax for specifying
    these hints, see [Section 10.9.4, “Index Hints”](index-hints.html "10.9.4 Index
    Hints").
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用索引提示可以为优化器提供有关在查询处理期间如何选择索引的信息。有关指定这些提示的语法的描述，请参见[第10.9.4节，“索引提示”](index-hints.html
    "10.9.4 索引提示")。
- en: You can use `SET max_seeks_for_key=*`value`*` as an alternative way to force
    MySQL to prefer key scans instead of table scans. See [Section 7.1.8, “Server
    System Variables”](server-system-variables.html "7.1.8 Server System Variables").
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以使用`SET max_seeks_for_key=*`value`*`作为一种替代方法，强制 MySQL 优先选择键扫描而不是表扫描。参见[第7.1.8节，“服务器系统变量”](server-system-variables.html
    "7.1.8 服务器系统变量")。
- en: You can refer to a table within the default database as *`tbl_name`*, or as
    *`db_name`*.*`tbl_name`* to specify a database explicitly. You can refer to a
    column as *`col_name`*, *`tbl_name`*.*`col_name`*, or *`db_name`*.*`tbl_name`*.*`col_name`*.
    You need not specify a *`tbl_name`* or *`db_name`*.*`tbl_name`* prefix for a column
    reference unless the reference would be ambiguous. See [Section 11.2.2, “Identifier
    Qualifiers”](identifier-qualifiers.html "11.2.2 Identifier Qualifiers"), for examples
    of ambiguity that require the more explicit column reference forms.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将默认数据库中的表称为*`tbl_name`*，或者作为*`db_name`*.*`tbl_name`*来明确指定数据库。你可以将列称为*`col_name`*，*`tbl_name`*.*`col_name`*，或*`db_name`*.*`tbl_name`*.*`col_name`*。除非引用会产生歧义，否则不需要为列引用指定*`tbl_name`*或*`db_name`*.*`tbl_name`*前缀。参见[第11.2.2节，“标识符限定符”](identifier-qualifiers.html
    "11.2.2 标识符限定符")，了解需要更明确的列引用形式的歧义示例。
- en: 'A table reference can be aliased using `*`tbl_name`* AS *`alias_name`*` or
    *`tbl_name alias_name`*. These statements are equivalent:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`*`tbl_name`* AS *`alias_name`*`或*`tbl_name alias_name`*对表引用进行别名。以下语句是等效的：
- en: '[PRE12]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Columns selected for output can be referred to in `ORDER BY` and `GROUP BY`
    clauses using column names, column aliases, or column positions. Column positions
    are integers and begin with 1:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择输出的列可以在`ORDER BY`和`GROUP BY`子句中使用列名、列别名或列位置进行引用。列位置是整数，从1开始：
- en: '[PRE13]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To sort in reverse order, add the `DESC` (descending) keyword to the name of
    the column in the `ORDER BY` clause that you are sorting by. The default is ascending
    order; this can be specified explicitly using the `ASC` keyword.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要按照倒序排序，将`DESC`（降序）关键字添加到`ORDER BY`子句中你要排序的列的名称中。默认是升序；可以使用`ASC`关键字明确指定。
- en: If `ORDER BY` occurs within a parenthesized query expression and also is applied
    in the outer query, the results are undefined and may change in a future version
    of MySQL.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果`ORDER BY`出现在带括号的查询表达式中，并且也应用在外部查询中，结果是未定义的，并且可能在 MySQL 的将来版本中发生变化。
- en: Use of column positions is deprecated because the syntax has been removed from
    the SQL standard.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用列位置已被弃用，因为该语法已从 SQL 标准中删除。
- en: 'Prior to MySQL 8.0.13, MySQL supported a nonstandard syntax extension that
    permitted explicit `ASC` or `DESC` designators for `GROUP BY` columns. MySQL 8.0.12
    and later supports `ORDER BY` with grouping functions so that use of this extension
    is no longer necessary. (Bug #86312, Bug #26073525) This also means you can sort
    on an arbitrary column or columns when using `GROUP BY`, like this:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 MySQL 8.0.13 之前，MySQL 支持了一个非标准语法扩展，允许为`GROUP BY`列使用显式的`ASC`或`DESC`标识符。MySQL
    8.0.12 及更高版本支持带有分组函数的`ORDER BY`，因此不再需要使用此扩展。这也意味着在使用`GROUP BY`时可以对任意列进行排序，就像这样：
- en: '[PRE14]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As of MySQL 8.0.13, the `GROUP BY` extension is no longer supported: `ASC`
    or `DESC` designators for `GROUP BY` columns are not permitted.'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 截至 MySQL 8.0.13，不再支持`GROUP BY`扩展：不允许为`GROUP BY`列使用`ASC`或`DESC`标识符。
- en: When you use `ORDER BY` or `GROUP BY` to sort a column in a [`SELECT`](select.html
    "15.2.13 SELECT Statement"), the server sorts values using only the initial number
    of bytes indicated by the [`max_sort_length`](server-system-variables.html#sysvar_max_sort_length)
    system variable.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你使用`ORDER BY`或`GROUP BY`对[`SELECT`](select.html "15.2.13 SELECT语句")中的列进行排序时，服务器仅使用由[`max_sort_length`](server-system-variables.html#sysvar_max_sort_length)系统变量指示的初始字节数对值进行排序。
- en: MySQL extends the use of `GROUP BY` to permit selecting fields that are not
    mentioned in the `GROUP BY` clause. If you are not getting the results that you
    expect from your query, please read the description of `GROUP BY` found in [Section 14.19,
    “Aggregate Functions”](aggregate-functions-and-modifiers.html "14.19 Aggregate
    Functions").
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL扩展了对`GROUP BY`的使用，允许选择未在`GROUP BY`子句中提及的字段。如果您的查询未获得预期结果，请阅读[Section 14.19，“Aggregate
    Functions”](aggregate-functions-and-modifiers.html "14.19 Aggregate Functions")中关于`GROUP
    BY`的描述。
- en: '`GROUP BY` permits a `WITH ROLLUP` modifier. See [Section 14.19.2, “GROUP BY
    Modifiers”](group-by-modifiers.html "14.19.2 GROUP BY Modifiers").'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GROUP BY`允许使用`WITH ROLLUP`修饰符。请参见[Section 14.19.2，“GROUP BY Modifiers”](group-by-modifiers.html
    "14.19.2 GROUP BY Modifiers")。'
- en: Previously, it was not permitted to use `ORDER BY` in a query having a `WITH
    ROLLUP` modifier. This restriction is lifted as of MySQL 8.0.12\. See [Section 14.19.2,
    “GROUP BY Modifiers”](group-by-modifiers.html "14.19.2 GROUP BY Modifiers").
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以前，在具有`WITH ROLLUP`修饰符的查询中不允许使用`ORDER BY`。从MySQL 8.0.12开始取消了此限制。请参见[Section 14.19.2，“GROUP
    BY Modifiers”](group-by-modifiers.html "14.19.2 GROUP BY Modifiers")。
- en: The `HAVING` clause, like the `WHERE` clause, specifies selection conditions.
    The `WHERE` clause specifies conditions on columns in the select list, but cannot
    refer to aggregate functions. The `HAVING` clause specifies conditions on groups,
    typically formed by the `GROUP BY` clause. The query result includes only groups
    satisfying the `HAVING` conditions. (If no `GROUP BY` is present, all rows implicitly
    form a single aggregate group.)
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HAVING`子句与`WHERE`子句一样，指定选择条件。`WHERE`子句指定选择列表中的列的条件，但不能引用聚合函数。`HAVING`子句指定对由`GROUP
    BY`子句形成的组的条件。查询结果仅包括满足`HAVING`条件的组。（如果没有`GROUP BY`存在，则所有行隐式形成单个聚合组。）'
- en: The `HAVING` clause is applied nearly last, just before items are sent to the
    client, with no optimization. (`LIMIT` is applied after `HAVING`.)
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`HAVING`子句几乎是在最后应用的，就在项目发送到客户端之前，没有优化。（`LIMIT`在`HAVING`之后应用。）'
- en: The SQL standard requires that `HAVING` must reference only columns in the `GROUP
    BY` clause or columns used in aggregate functions. However, MySQL supports an
    extension to this behavior, and permits `HAVING` to refer to columns in the [`SELECT`](select.html
    "15.2.13 SELECT Statement") list and columns in outer subqueries as well.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: SQL标准要求`HAVING`只能引用`GROUP BY`子句中的列或聚合函数中使用的列。然而，MySQL支持对此行为的扩展，并允许`HAVING`引用[`SELECT`](select.html
    "15.2.13 SELECT Statement")列表中的列以及外部子查询中的列。
- en: 'If the `HAVING` clause refers to a column that is ambiguous, a warning occurs.
    In the following statement, `col2` is ambiguous because it is used as both an
    alias and a column name:'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果`HAVING`子句引用的列存在歧义，将发出警告。在以下语句中，`col2`存在歧义，因为它既用作别名又用作列名：
- en: '[PRE15]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Preference is given to standard SQL behavior, so if a `HAVING` column name is
    used both in `GROUP BY` and as an aliased column in the select column list, preference
    is given to the column in the `GROUP BY` column.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 标准SQL行为优先，因此如果`HAVING`列名既在`GROUP BY`中使用，又作为选择列列表中的别名列，则优先使用`GROUP BY`列。
- en: 'Do not use `HAVING` for items that should be in the `WHERE` clause. For example,
    do not write the following:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要将应该在`WHERE`子句中的项目放在`HAVING`中。例如，不要写如下内容：
- en: '[PRE16]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Write this instead:'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 改为写成：
- en: '[PRE17]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `HAVING` clause can refer to aggregate functions, which the `WHERE` clause
    cannot:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HAVING`子句可以引用聚合函数，而`WHERE`子句不能：'
- en: '[PRE18]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: (This did not work in some older versions of MySQL.)
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （在某些较旧版本的MySQL中不起作用。）
- en: 'MySQL permits duplicate column names. That is, there can be more than one *`select_expr`*
    with the same name. This is an extension to standard SQL. Because MySQL also permits
    `GROUP BY` and `HAVING` to refer to *`select_expr`* values, this can result in
    an ambiguity:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL允许重复列名。也就是说，可以有多个具有相同名称的*`select_expr`*。这是对标准SQL的扩展。因为MySQL还允许`GROUP BY`和`HAVING`引用*`select_expr`*值，这可能导致歧义：
- en: '[PRE19]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In that statement, both columns have the name `a`. To ensure that the correct
    column is used for grouping, use different names for each *`select_expr`*.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在该语句中，两列都具有名称`a`。为确保正确使用列进行分组，请为每个*`select_expr`*使用不同的名称。
- en: The `WINDOW` clause, if present, defines named windows that can be referred
    to by window functions. For details, see [Section 14.20.4, “Named Windows”](window-functions-named-windows.html
    "14.20.4 Named Windows").
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在`WINDOW`子句，则定义了可以被窗口函数引用的命名窗口。详情请参见[Section 14.20.4，“Named Windows”](window-functions-named-windows.html
    "14.20.4 Named Windows")。
- en: MySQL resolves unqualified column or alias references in `ORDER BY` clauses
    by searching in the *`select_expr`* values, then in the columns of the tables
    in the `FROM` clause. For `GROUP BY` or `HAVING` clauses, it searches the `FROM`
    clause before searching in the *`select_expr`* values. (For `GROUP BY` and `HAVING`,
    this differs from the pre-MySQL 5.0 behavior that used the same rules as for `ORDER
    BY`.)
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL通过在`ORDER BY`子句中搜索*`select_expr`*值，然后在`FROM`子句中的表列中搜索来解析未限定的列或别名引用。对于`GROUP
    BY`或`HAVING`子句，它会先在`FROM`子句中搜索，然后再在*`select_expr`*值中搜索。（对于`GROUP BY`和`HAVING`，这与MySQL
    5.0之前的行为不同，该行为使用与`ORDER BY`相同的规则。）
- en: 'The `LIMIT` clause can be used to constrain the number of rows returned by
    the [`SELECT`](select.html "15.2.13 SELECT Statement") statement. `LIMIT` takes
    one or two numeric arguments, which must both be nonnegative integer constants,
    with these exceptions:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LIMIT`子句可用于限制[`SELECT`](select.html "15.2.13 SELECT Statement")语句返回的行数。`LIMIT`接受一个或两个数字参数，这两个参数必须都是非负整数常量，但有以下例外：'
- en: Within prepared statements, `LIMIT` parameters can be specified using `?` placeholder
    markers.
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在准备好的语句中，可以使用`?`占位符标记指定`LIMIT`参数。
- en: Within stored programs, `LIMIT` parameters can be specified using integer-valued
    routine parameters or local variables.
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在存储程序中，可以使用整数值例程参数或本地变量指定`LIMIT`参数。
- en: 'With two arguments, the first argument specifies the offset of the first row
    to return, and the second specifies the maximum number of rows to return. The
    offset of the initial row is 0 (not 1):'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用两个参数时，第一个参数指定要返回的第一行的偏移量，第二个参数指定要返回的最大行数。初始行的偏移量为0（而不是1）：
- en: '[PRE20]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To retrieve all rows from a certain offset up to the end of the result set,
    you can use some large number for the second parameter. This statement retrieves
    all rows from the 96th row to the last:'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要检索从某个偏移量到结果集末尾的所有行，可以使用一个很大的数字作为第二个参数。以下语句检索从第96行到最后的所有行：
- en: '[PRE21]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'With one argument, the value specifies the number of rows to return from the
    beginning of the result set:'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用一个参数时，该值指定从结果集开头返回的行数：
- en: '[PRE22]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In other words, `LIMIT *`row_count`*` is equivalent to `LIMIT 0, *`row_count`*`.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 换句话说，`LIMIT *`row_count`*`等同于`LIMIT 0, *`row_count`*`。
- en: 'For prepared statements, you can use placeholders. The following statements
    return one row from the `tbl` table:'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于准备好的语句，可以使用占位符。以下语句从`tbl`表中返回一行：
- en: '[PRE23]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following statements return the second to sixth rows from the `tbl` table:'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下语句从`tbl`表中返回第二到第六行：
- en: '[PRE24]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: For compatibility with PostgreSQL, MySQL also supports the `LIMIT *`row_count`*
    OFFSET *`offset`*` syntax.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了与PostgreSQL兼容，MySQL还支持`LIMIT *`row_count`* OFFSET *`offset`*`语法。
- en: If `LIMIT` occurs within a parenthesized query expression and also is applied
    in the outer query, the results are undefined and may change in a future version
    of MySQL.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果`LIMIT`出现在括号查询表达式中，并且也应用于外部查询，则结果是未定义的，并且可能在MySQL的将来版本中更改。
- en: The [`SELECT ... INTO`](select-into.html "15.2.13.1 SELECT ... INTO Statement")
    form of [`SELECT`](select.html "15.2.13 SELECT Statement") enables the query result
    to be written to a file or stored in variables. For more information, see [Section 15.2.13.1,
    “SELECT ... INTO Statement”](select-into.html "15.2.13.1 SELECT ... INTO Statement").
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`SELECT ... INTO`](select-into.html "15.2.13.1 SELECT ... INTO Statement")形式的[`SELECT`](select.html
    "15.2.13 SELECT Statement")允许将查询结果写入文件或存储在变量中。更多信息，请参见[Section 15.2.13.1, “SELECT
    ... INTO Statement”](select-into.html "15.2.13.1 SELECT ... INTO Statement")。'
- en: If you use `FOR UPDATE` with a storage engine that uses page or row locks, rows
    examined by the query are write-locked until the end of the current transaction.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在使用页面或行锁的存储引擎中使用`FOR UPDATE`，则查询检查的行将被写锁定，直到当前事务结束。
- en: You cannot use `FOR UPDATE` as part of the [`SELECT`](select.html "15.2.13 SELECT
    Statement") in a statement such as [`CREATE TABLE *`new_table`* SELECT ... FROM
    *`old_table`* ...`](create-table-select.html "15.1.20.4 CREATE TABLE ... SELECT
    Statement"). (If you attempt to do so, the statement is rejected with the error
    Can't update table '*`old_table`*' while '*`new_table`*' is being created.)
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你不能在[`CREATE TABLE *`new_table`* SELECT ... FROM *`old_table`* ...`](create-table-select.html
    "15.1.20.4 CREATE TABLE ... SELECT Statement")等语句中将`FOR UPDATE`作为[`SELECT`](select.html
    "15.2.13 SELECT Statement")的一部分。（如果尝试这样做，将会收到错误消息“在创建'*`new_table`*'时无法更新表'*`old_table`*'。”）
- en: '`FOR SHARE` and `LOCK IN SHARE MODE` set shared locks that permit other transactions
    to read the examined rows but not to update or delete them. `FOR SHARE` and `LOCK
    IN SHARE MODE` are equivalent. However, `FOR SHARE`, like `FOR UPDATE`, supports
    `NOWAIT`, `SKIP LOCKED`, and `OF *`tbl_name`*` options. `FOR SHARE` is a replacement
    for `LOCK IN SHARE MODE`, but `LOCK IN SHARE MODE` remains available for backward
    compatibility.'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`FOR SHARE` 和 `LOCK IN SHARE MODE` 设置共享锁，允许其他事务读取检查的行，但不允许更新或删除它们。 `FOR SHARE`
    和 `LOCK IN SHARE MODE` 是等效的。但是，`FOR SHARE`，像 `FOR UPDATE` 一样，支持 `NOWAIT`，`SKIP
    LOCKED` 和 `OF *`tbl_name`*` 选项。 `FOR SHARE` 是 `LOCK IN SHARE MODE` 的替代，但 `LOCK
    IN SHARE MODE` 仍可用于向后兼容。'
- en: '`NOWAIT` causes a `FOR UPDATE` or `FOR SHARE` query to execute immediately,
    returning an error if a row lock cannot be obtained due to a lock held by another
    transaction.'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`NOWAIT` 会导致 `FOR UPDATE` 或 `FOR SHARE` 查询立即执行，如果由于另一个事务持有的锁而无法获得行锁，则返回错误。'
- en: '`SKIP LOCKED` causes a `FOR UPDATE` or `FOR SHARE` query to execute immediately,
    excluding rows from the result set that are locked by another transaction.'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`SKIP LOCKED` 会导致 `FOR UPDATE` 或 `FOR SHARE` 查询立即执行，从结果集中排除被另一个事务锁定的行。'
- en: '`NOWAIT` and `SKIP LOCKED` options are unsafe for statement-based replication.'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`NOWAIT` 和 `SKIP LOCKED` 选项对基于语句的复制不安全。'
- en: Note
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Queries that skip locked rows return an inconsistent view of the data. `SKIP
    LOCKED` is therefore not suitable for general transactional work. However, it
    may be used to avoid lock contention when multiple sessions access the same queue-like
    table.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 跳过被锁定行的查询会返回数据的不一致视图。因此，`SKIP LOCKED` 不适用于一般的事务工作。但是，当多个会话访问相同的类似队列的表时，可以使用它来避免锁争用。
- en: '`OF *`tbl_name`*` applies `FOR UPDATE` and `FOR SHARE` queries to named tables.
    For example:'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`OF *`tbl_name`*` 适用于对指定表执行 `FOR UPDATE` 和 `FOR SHARE` 查询。例如：'
- en: '[PRE25]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: All tables referenced by the query block are locked when `OF *`tbl_name`*` is
    omitted. Consequently, using a locking clause without `OF *`tbl_name`*` in combination
    with another locking clause returns an error. Specifying the same table in multiple
    locking clauses returns an error. If an alias is specified as the table name in
    the `SELECT` statement, a locking clause may only use the alias. If the `SELECT`
    statement does not specify an alias explicitly, the locking clause may only specify
    the actual table name.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当省略 `OF *`tbl_name`*` 时，查询块引用的所有表都会被锁定。因此，在不与另一个锁定子句结合使用 `OF *`tbl_name`*` 的情况下使用锁定子句会返回错误。在多个锁定子句中指定相同的表会返回错误。如果在
    `SELECT` 语句中指定了别名作为表名，则锁定子句只能使用该别名。如果 `SELECT` 语句没有明确指定别名，则锁定子句只能指定实际表名。
- en: For more information about `FOR UPDATE` and `FOR SHARE`, see [Section 17.7.2.4,
    “Locking Reads”](innodb-locking-reads.html "17.7.2.4 Locking Reads"). For additional
    information about `NOWAIT` and `SKIP LOCKED` options, see [Locking Read Concurrency
    with NOWAIT and SKIP LOCKED](innodb-locking-reads.html#innodb-locking-reads-nowait-skip-locked
    "Locking Read Concurrency with NOWAIT and SKIP LOCKED").
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有关 `FOR UPDATE` 和 `FOR SHARE` 的更多信息，请参见 [Section 17.7.2.4, “Locking Reads”](innodb-locking-reads.html
    "17.7.2.4 Locking Reads")。有关 `NOWAIT` 和 `SKIP LOCKED` 选项的更多信息，请参见 [Locking Read
    Concurrency with NOWAIT and SKIP LOCKED](innodb-locking-reads.html#innodb-locking-reads-nowait-skip-locked
    "Locking Read Concurrency with NOWAIT and SKIP LOCKED")。
- en: Following the [`SELECT`](select.html "15.2.13 SELECT Statement") keyword, you
    can use a number of modifiers that affect the operation of the statement. `HIGH_PRIORITY`,
    `STRAIGHT_JOIN`, and modifiers beginning with `SQL_` are MySQL extensions to standard
    SQL.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [`SELECT`](select.html "15.2.13 SELECT Statement") 关键字之后，您可以使用许多修饰符来影响语句的操作。
    `HIGH_PRIORITY`，`STRAIGHT_JOIN` 和以 `SQL_` 开头的修饰符是 MySQL 对标准 SQL 的扩展。
- en: The `ALL` and `DISTINCT` modifiers specify whether duplicate rows should be
    returned. `ALL` (the default) specifies that all matching rows should be returned,
    including duplicates. `DISTINCT` specifies removal of duplicate rows from the
    result set. It is an error to specify both modifiers. `DISTINCTROW` is a synonym
    for `DISTINCT`.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ALL` 和 `DISTINCT` 修饰符指定是否应返回重复行。 `ALL`（默认）指定应返回所有匹配行，包括重复行。 `DISTINCT` 指定从结果集中删除重复行。指定两个修饰符是错误的。
    `DISTINCTROW` 是 `DISTINCT` 的同义词。'
- en: 'In MySQL 8.0.12 and later, `DISTINCT` can be used with a query that also uses
    `WITH ROLLUP`. (Bug #87450, Bug #26640100)'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '在 MySQL 8.0.12 及更高版本中，`DISTINCT` 可以与使用 `WITH ROLLUP` 的查询一起使用。 (Bug #87450,
    Bug #26640100)'
- en: '`HIGH_PRIORITY` gives the [`SELECT`](select.html "15.2.13 SELECT Statement")
    higher priority than a statement that updates a table. You should use this only
    for queries that are very fast and must be done at once. A `SELECT HIGH_PRIORITY`
    query that is issued while the table is locked for reading runs even if there
    is an update statement waiting for the table to be free. This affects only storage
    engines that use only table-level locking (such as `MyISAM`, `MEMORY`, and `MERGE`).'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HIGH_PRIORITY` 给予[`SELECT`](select.html "15.2.13 SELECT Statement")比更新表的语句更高的优先级。你应该只对非常快速且必须一次完成的查询使用这个选项。在表被锁定以供读取时发出的`SELECT
    HIGH_PRIORITY`查询即使有一个更新语句在等待表空闲也会运行。这只影响只使用表级锁定的存储引擎（如`MyISAM`、`MEMORY`和`MERGE`）。'
- en: '`HIGH_PRIORITY` cannot be used with [`SELECT`](select.html "15.2.13 SELECT
    Statement") statements that are part of a [`UNION`](union.html "15.2.18 UNION
    Clause").'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`HIGH_PRIORITY` 不能与 [`SELECT`](select.html "15.2.13 SELECT Statement") 语句一起使用，这些语句是
    [`UNION`](union.html "15.2.18 UNION Clause") 的一部分。'
- en: '`STRAIGHT_JOIN` forces the optimizer to join the tables in the order in which
    they are listed in the `FROM` clause. You can use this to speed up a query if
    the optimizer joins the tables in nonoptimal order. `STRAIGHT_JOIN` also can be
    used in the *`table_references`* list. See [Section 15.2.13.2, “JOIN Clause”](join.html
    "15.2.13.2 JOIN Clause").'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STRAIGHT_JOIN` 强制优化器按照 `FROM` 子句中列出的顺序连接表。如果优化器以非最佳顺序连接表，可以使用这个选项加快查询速度。`STRAIGHT_JOIN`
    也可以在 *`table_references`* 列表中使用。参见[第 15.2.13.2 节，“JOIN 子句”](join.html "15.2.13.2 JOIN
    Clause")。'
- en: '`STRAIGHT_JOIN` does not apply to any table that the optimizer treats as a
    [`const`](explain-output.html#jointype_const) or [`system`](explain-output.html#jointype_system)
    table. Such a table produces a single row, is read during the optimization phase
    of query execution, and references to its columns are replaced with the appropriate
    column values before query execution proceeds. These tables appear first in the
    query plan displayed by [`EXPLAIN`](explain.html "15.8.2 EXPLAIN Statement").
    See [Section 10.8.1, “Optimizing Queries with EXPLAIN”](using-explain.html "10.8.1 Optimizing
    Queries with EXPLAIN"). This exception may not apply to [`const`](explain-output.html#jointype_const)
    or [`system`](explain-output.html#jointype_system) tables that are used on the
    `NULL`-complemented side of an outer join (that is, the right-side table of a
    `LEFT JOIN` or the left-side table of a `RIGHT JOIN`.'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`STRAIGHT_JOIN` 不适用于优化器将其视为[`const`](explain-output.html#jointype_const)或[`system`](explain-output.html#jointype_system)表的任何表。这样的表产生一行，是在查询执行的优化阶段读取的，并且在查询执行继续之前，其列的引用被替换为适当的列值。这些表在[`EXPLAIN`](explain.html
    "15.8.2 EXPLAIN Statement")显示的查询计划中首先出现。参见[第 10.8.1 节，“使用 EXPLAIN 优化查询”](using-explain.html
    "10.8.1 Optimizing Queries with EXPLAIN")。这个例外可能不适用于在外连接的`NULL`补充侧使用的[`const`](explain-output.html#jointype_const)或[`system`](explain-output.html#jointype_system)表（即`LEFT
    JOIN`的右侧表或`RIGHT JOIN`的左侧表）。'
- en: '`SQL_BIG_RESULT` or `SQL_SMALL_RESULT` can be used with `GROUP BY` or `DISTINCT`
    to tell the optimizer that the result set has many rows or is small, respectively.
    For `SQL_BIG_RESULT`, MySQL directly uses disk-based temporary tables if they
    are created, and prefers sorting to using a temporary table with a key on the
    `GROUP BY` elements. For `SQL_SMALL_RESULT`, MySQL uses in-memory temporary tables
    to store the resulting table instead of using sorting. This should not normally
    be needed.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SQL_BIG_RESULT` 或 `SQL_SMALL_RESULT` 可以与 `GROUP BY` 或 `DISTINCT` 一起使用，告诉优化器结果集有很多行或很小，分别。对于
    `SQL_BIG_RESULT`，如果创建了磁盘临时表，MySQL 直接使用它们，并倾向于对 `GROUP BY` 元素使用排序而不是使用带有键的临时表。对于
    `SQL_SMALL_RESULT`，MySQL 使用内存临时表来存储结果表，而不是使用排序。这通常不需要。'
- en: '`SQL_BUFFER_RESULT` forces the result to be put into a temporary table. This
    helps MySQL free the table locks early and helps in cases where it takes a long
    time to send the result set to the client. This modifier can be used only for
    top-level [`SELECT`](select.html "15.2.13 SELECT Statement") statements, not for
    subqueries or following [`UNION`](union.html "15.2.18 UNION Clause").'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SQL_BUFFER_RESULT` 强制结果放入临时表中。这有助于 MySQL 提前释放表锁，并在向客户端发送结果集需要很长时间的情况下提供帮助。这个修饰符只能用于顶层[`SELECT`](select.html
    "15.2.13 SELECT Statement")语句，不能用于子查询或后续的[`UNION`](union.html "15.2.18 UNION Clause")。'
- en: '`SQL_CALC_FOUND_ROWS` tells MySQL to calculate how many rows there would be
    in the result set, disregarding any `LIMIT` clause. The number of rows can then
    be retrieved with `SELECT FOUND_ROWS()`. See [Section 14.15, “Information Functions”](information-functions.html
    "14.15 Information Functions").'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SQL_CALC_FOUND_ROWS` 告诉 MySQL 计算结果集中会有多少行，忽略任何 `LIMIT` 子句。然后可以使用 `SELECT FOUND_ROWS()`
    检索行数。参见[第 14.15 节，“信息函数”](information-functions.html "14.15 信息函数")。'
- en: Note
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The `SQL_CALC_FOUND_ROWS` query modifier and accompanying [`FOUND_ROWS()`](information-functions.html#function_found-rows)
    function are deprecated as of MySQL 8.0.17; expect them to be removed in a future
    version of MySQL. See the [`FOUND_ROWS()`](information-functions.html#function_found-rows)
    description for information about an alternative strategy.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`SQL_CALC_FOUND_ROWS` 查询修饰符和配套的[`FOUND_ROWS()`](information-functions.html#function_found-rows)函数在
    MySQL 8.0.17 中已被弃用；预计它们将在未来的 MySQL 版本中被移除。请查看[`FOUND_ROWS()`](information-functions.html#function_found-rows)的描述以获取有关替代策略的信息。'
- en: The `SQL_CACHE` and `SQL_NO_CACHE` modifiers were used with the query cache
    prior to MySQL 8.0\. The query cache was removed in MySQL 8.0\. The `SQL_CACHE`
    modifier was removed as well. `SQL_NO_CACHE` is deprecated, and has no effect;
    expect it to be removed in a future MySQL release.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 MySQL 8.0 之前，`SQL_CACHE` 和 `SQL_NO_CACHE` 修饰符与查询缓存一起使用。查询缓存在 MySQL 8.0 中被移除。`SQL_CACHE`
    修饰符也被移除。`SQL_NO_CACHE` 已被弃用，并且没有效果；预计它将在未来的 MySQL 版本中被移除。
