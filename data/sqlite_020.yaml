- en: 1\. Overview
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1\. 概述
- en: 原文：[https://sqlite.com/lang_datefunc.html](https://sqlite.com/lang_datefunc.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://sqlite.com/lang_datefunc.html](https://sqlite.com/lang_datefunc.html)
- en: 'SQLite supports seven [scalar](lang_corefunc.html) date and time functions
    as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite支持七种[标量](lang_corefunc.html)日期和时间函数，如下所示：
- en: '**date(***time-value, modifier, modifier, ...***)**'
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**date(***time-value, modifier, modifier, ...***)**'
- en: '**time(***time-value, modifier, modifier, ...***)**'
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**time(***time-value, modifier, modifier, ...***)**'
- en: '**datetime(***time-value, modifier, modifier, ...***)**'
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**datetime(***time-value, modifier, modifier, ...***)**'
- en: '**julianday(***time-value, modifier, modifier, ...***)**'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**julianday(***time-value, modifier, modifier, ...***)**'
- en: '**unixepoch(***time-value, modifier, modifier, ...***)**'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**unixepoch(***time-value, modifier, modifier, ...***)**'
- en: '**strftime(***format, time-value, modifier, modifier, ...***)**'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**strftime(***format, time-value, modifier, modifier, ...***)**'
- en: '**timediff(***time-value, time-value***)**'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**timediff(***time-value, time-value***)**'
- en: The first six date and time functions take an optional [time-value](lang_datefunc.html#tmval)
    as an argument, followed by zero or more [modifiers](lang_datefunc.html#dtmods).
    The strftime() function also takes a format string as its first argument. The
    timediff() function takes exactly two arguments which are both [time-values](lang_datefunc.html#tmval).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 前六个日期和时间函数以可选的[time-value](lang_datefunc.html#tmval)作为参数，后面跟零个或多个[modifiers](lang_datefunc.html#dtmods)。strftime()函数的第一个参数也是格式字符串。timediff()函数接受两个参数，这两个参数都是[time-values](lang_datefunc.html#tmval)。
- en: 'SQLite does not have a dedicated date/time datatype. Instead, date and time
    values can stored as any of the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite没有专门的日期/时间数据类型。相反，日期和时间值可以存储为以下任一格式之一：
- en: '| [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) | A text string that is
    an ISO 8601 date/time value. Example: `''2025-05-29 14:16:00''` |'
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [ISO-8601](http://zh.wikipedia.org/wiki/ISO_8601) | 一个文本字符串，表示ISO 8601日期/时间值。例如：`''2025-05-29
    14:16:00''` |'
- en: '| [Julian day number](http://en.wikipedia.org/wiki/Julian_day) | The number
    of days including fractional days since -4713-11-24 12:00:00 Example: `2460825.09444444`
    |'
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [朱利安日数](http://zh.wikipedia.org/wiki/朱利安日) | 自公元前4713年11月24日12:00:00以来的天数，包括小数天数。例如：`2460825.09444444`
    |'
- en: '| [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time) | The number of
    seconds including fractional seconds since 1970-01-01 00:00:00 Example: `1748528160`
    |'
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [Unix时间戳](https://zh.wikipedia.org/wiki/Unix时间) | 自1970-01-01 00:00:00以来的秒数，包括小数秒数。例如：`1748528160`
    |'
- en: These three formats are collectively known as [time-values](lang_datefunc.html#tmval).
    All of the date time functions accept time-values as either ISO-8601 text or as
    Julian day numbers. They can also be made to accept unix timestamps by adding
    optional modifiers arguments ['auto'](lang_datefunc.html#automod) or ['unixepoch'](lang_datefunc.html#jdmod).
    Since the timediff() function does not accept modifiers, it can only use ISO-8601
    and julian day number time-values.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种格式统称为[time-values](lang_datefunc.html#tmval)。所有日期时间函数都接受ISO-8601文本或朱利安日数作为time-values。它们也可以通过添加可选的modifiers参数['auto'](lang_datefunc.html#automod)或['unixepoch'](lang_datefunc.html#jdmod)来接受Unix时间戳。由于timediff()函数不接受modifiers，因此它只能使用ISO-8601和朱利安日数的time-values。
- en: 'The **date()** function returns the date as text in this format: YYYY-MM-DD.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**date()** 函数以YYYY-MM-DD格式返回文本形式的日期。'
- en: The **time()** function returns the time as text in formatted as HH:MM:SS or
    as HH:MM:SS.SSS if the [subsec modifier](lang_datefunc.html#subsec) is used.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**time()** 函数以HH:MM:SS或如果使用[subsec modifier](lang_datefunc.html#subsec)，则以HH:MM:SS.SSS格式返回文本形式的时间。'
- en: The **datetime()** function returns the date and time formatted as YYYY-MM-DD
    HH:MM:SS or as YYYY-MM-DD HH:MM:SS.SSS if the [subsec modifier](lang_datefunc.html#subsec)
    is used.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**datetime()** 函数以YYYY-MM-DD HH:MM:SS或如果使用[subsec modifier](lang_datefunc.html#subsec)，则以YYYY-MM-DD
    HH:MM:SS.SSS格式返回日期和时间。'
- en: The **julianday()** function returns the [Julian day](http://en.wikipedia.org/wiki/Julian_day)
    - the fractional number of days since noon in Greenwich on November 24, 4714 B.C.
    ([Proleptic Gregorian calendar](http://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar)).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**julianday()** 函数返回[朱利安日](http://zh.wikipedia.org/wiki/朱利安日) - 自公元前4714年11月24日格林威治的中午起的天数，采用[普罗莱普特·格里高利历](http://zh.wikipedia.org/wiki/普罗莱普特·格里高利历)。'
- en: The **unixepoch()** function returns a unix timestamp - the number of seconds
    since 1970-01-01 00:00:00 UTC. The unixepoch() function normally returns an integer
    number of seconds, but with the optional [subsec modifier](lang_datefunc.html#subsec)
    it will return a floating point number which is the fractional number of seconds.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**unixepoch()** 函数返回Unix时间戳 - 自1970-01-01 00:00:00 UTC以来的秒数。unixepoch()函数通常返回整数秒数，但使用可选的[subsec
    modifier](lang_datefunc.html#subsec)时，将返回浮点数，即秒的小数部分。'
- en: The **strftime()** function returns the date formatted according to the format
    string specified as the first argument. The format string supports the most common
    substitutions found in the [strftime() function](http://opengroup.org/onlinepubs/007908799/xsh/strftime.html)
    from the standard C library plus two new substitutions, %f and %J. The following
    is a complete list of valid strftime() substitutions as of version 3.46.0 (2024-05-23).
    Earlier versions of SQLite might not support all substitutions. If an undefined
    or unsupported substitution is seen, the result is NULL.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**strftime()**函数根据作为第一个参数指定的格式字符串返回格式化的日期。格式字符串支持标准C库中strftime()函数中找到的最常见的替换，加上两个新的替换，%f和%J。以下是截至版本3.46.0（2024-05-23）的有效strftime()替换的完整列表。SQLite的早期版本可能不支持所有替换。如果看到未定义或不支持的替换，则结果为NULL。'
- en: '|  |  |  |'
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  |  |  |'
- en: '| %d |  | day of month: 01-31 |'
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| %d |  | 月份中的日期：01-31 |'
- en: '| %e |  | day of month without leading zero: 1-31 |'
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| %e |  | 没有前导零的月份中的日期：1-31 |'
- en: '| %f |  | fractional seconds: SS.SSS |'
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| %f |  | 分数秒：SS.SSS |'
- en: '| %F |  | ISO 8601 date: YYYY-MM-DD |'
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| %F |  | ISO 8601日期：YYYY-MM-DD |'
- en: '| %G |  | ISO 8601 year corresponding to %V |'
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| %G |  | 对应于%V的ISO 8601年份 |'
- en: '| %g |  | 2-digit ISO 8601 year corresponding to %V |'
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| %g |  | 对应于%V的两位数ISO 8601年份 |'
- en: '| %H |  | hour: 00-24 |'
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| %H |  | 小时：00-24 |'
- en: '| %I |  | hour for 12-hour clock: 01-12 |'
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| %I |  | 12小时制小时：01-12 |'
- en: '| %j |  | day of year: 001-366 |'
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| %j |  | 年份中的天数：001-366 |'
- en: '| %J |  | Julian day number (fractional) |'
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| %J |  | 朱利安日数（小数） |'
- en: '| %k |  | hour without leading zero: 0-24 |'
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| %k |  | 没有前导零的小时：0-24 |'
- en: '| %l |  | %I without leading zero: 1-12 |'
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| %l |  | 没有前导零的%I：1-12 |'
- en: '| %m |  | month: 01-12 |'
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| %m |  | 月份：01-12 |'
- en: '| %M |  | minute: 00-59 |'
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| %M |  | 分钟：00-59 |'
- en: '| %p |  | "AM" or "PM" depending on the hour |'
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| %p |  | 根据小时为“AM”或“PM” |'
- en: '| %P |  | "am" or "pm" depending on the hour |'
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| %P |  | 根据小时为“am”或“pm” |'
- en: '| %R |  | ISO 8601 time: HH:MM |'
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| %R |  | ISO 8601时间：HH:MM |'
- en: '| %s |  | seconds since 1970-01-01 |'
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| %s |  | 自1970-01-01以来的秒数 |'
- en: '| %S |  | seconds: 00-59 |'
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| %S |  | 秒数：00-59 |'
- en: '| %T |  | ISO 8601 time: HH:MM:SS |'
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| %T |  | ISO 8601时间：HH:MM:SS |'
- en: '| %U |  | week of year (00-53) - week 01 starts on the first Sunday |'
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| %U |  | 年份中的周数（00-53）- 第一个星期从周日开始 |'
- en: '| %u |  | day of week 1-7 with Monday==1 |'
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| %u |  | 一周中的星期几，星期一为1 |'
- en: '| %V |  | ISO 8601 week of year |'
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| %V |  | ISO 8601年份中的周数 |'
- en: '| %w |  | day of week 0-6 with Sunday==0 |'
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| %w |  | 一周中的星期几，星期日为0 |'
- en: '| %W |  | week of year (00-53) - week 01 starts on the first Monday |'
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| %W |  | 年份中的周数（00-53）- 第一个星期从周一开始 |'
- en: '| %Y |  | year: 0000-9999 |'
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| %Y |  | 年份：0000-9999 |'
- en: '| %% |  | % |'
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| %% |  | % |'
- en: 'Other date and time functions can be expressed in terms of strftime():'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 其他日期和时间函数可以通过strftime()来表达：
- en: '| **Function** |  | **Equivalent strftime()** |'
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| **Function** |  | **Equivalent strftime()** |'
- en: '| date(...) |  | strftime(''%F'', ...) |'
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| date(...) |  | strftime(''%F'', ...) |'
- en: '| time(...) |  | strftime(''%T'', ...) |'
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| time(...) |  | strftime(''%T'', ...) |'
- en: '| datetime(...) |  | strftime(''%F %T'', ...) |'
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| datetime(...) |  | strftime(''%F %T'', ...) |'
- en: '| julianday(...) |  | <nobr>CAST(strftime(''%J'', ...) as REAL)</nobr> |'
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| julianday(...) |  | <nobr>CAST(strftime(''%J'', ...) as REAL)</nobr> |'
- en: '| unixepoch(...) |  | <nobr>CAST(strftime(''%s'', ...) as INT)</nobr> |'
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| unixepoch(...) |  | <nobr>CAST(strftime(''%s'', ...) as INT)</nobr> |'
- en: The date(), time(), and datetime() functions all return text, and so their strftime()
    equivalents are exact. However, the julianday() and unixepoch() functions return
    numeric values. Their strftime() equivalents return a string that is the text
    representation of the corresponding number.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: date(), time()和datetime()函数都返回文本，因此它们的strftime()等效值是准确的。然而，julianday()和unixepoch()函数返回数值。它们的strftime()等效值返回的是相应数字的文本表示。
- en: The main reasons for providing functions other than strftime() are for convenience
    and for efficiency. The julianday() and unixepoch() functions return real and
    integer values respectively, and do not incur the format conversion costs or inexactitude
    resulting from use of the '%J' or '%s' format specifiers with the strftime() function.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便和效率考虑，提供了除了strftime()之外的函数。julianday()和unixepoch()函数分别返回实数和整数值，并且不会产生与使用'%J'或'%s'格式说明符时strftime()函数所产生的格式转换成本或不精确性相关的开销。
- en: 'The **timediff(A,B)** function returns a string that describes the amount of
    time that must be added to B in order to reach time A. The format of the timediff()
    result is designed to be human-readable. The format is:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**timediff(A,B)**函数返回描述必须添加到B以达到时间A的时间量的字符串。timediff()结果的格式设计为人类可读。格式如下：'
- en: (+|-)YYYY-MM-DD HH:MM:SS.SSS
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (+|-)YYYY-MM-DD HH:MM:SS.SSS
- en: 'This time difference string is also an allowed modifier for the other date/time
    functions. The following invariant holds for time-values A and B:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个时间差字符串也是其他日期/时间函数的允许修饰符。时间值 A 和 B 的以下不变性成立：
- en: datetime(A) = datetime(B, timediff(A,B))
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: datetime(A) = datetime(B, timediff(A,B))
- en: 'The length of months and years vary. February is shorter than March. Leap years
    are longer than non-leap years. The output from timediff() takes this all into
    account. The timediff() function is intended to provide a human-friendly description
    of the time span. If you want to know the number of days or seconds between two
    dates, A and B, then you can always do one of these:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 月份和年份的长度各不相同。二月比三月短。闰年比非闰年长。timediff() 的输出考虑到了这一切。timediff() 函数旨在提供时间跨度的用户友好描述。如果你想知道两个日期
    A 和 B 之间的天数或秒数，则可以始终执行以下操作之一：
- en: SELECT julianday(B) - julianday(A);
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SELECT julianday(B) - julianday(A);
- en: SELECT unixepoch(B) - unixepoch(A);
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SELECT unixepoch(B) - unixepoch(A);
- en: 'The timediff(A,B) might return the same result even for values A and B that
    span a different number of days - depending on the starting date. For example,
    both of the following two timediff() calls return the same result ("-0000-01-00
    00:00:00.000") even though the first timespan is 28 days and the seconds is 31
    days:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 A 和 B 的值跨越不同天数，timediff(A,B) 可能会返回相同的结果 - 取决于起始日期。例如，以下两个 timediff() 调用返回相同的结果
    ("-0000-01-00 00:00:00.000")，尽管第一个时间跨度为 28 天，第二个为 31 天：
- en: SELECT timediff('2023-02-15','2023-03-15');
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SELECT timediff('2023-02-15','2023-03-15');
- en: SELECT timediff('2023-03-15','2023-04-15');
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SELECT timediff('2023-03-15','2023-04-15');
- en: 'Summary: If you want a human-friendly time span, use timediff(). If you what
    a precise time difference (in days or seconds) use the difference between two
    julianday() or unixepoch() calls.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要：如果你想要一个用户友好的时间跨度，请使用 timediff()。如果你需要精确的时间差（以天或秒计算），请使用 julianday() 或 unixepoch()
    调用的差异。
- en: 2\. Time Values
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2\. 时间值
- en: A time-value can be in any of the following formats shown below. The value is
    usually a string, though it can be an integer or floating point number in the
    case of format 12.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 时间值可以采用下面显示的任何格式。值通常是一个字符串，但在格式12的情况下可以是整数或浮点数。
- en: '*YYYY-MM-DD*'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*YYYY-MM-DD*'
- en: '*YYYY-MM-DD HH:MM*'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*YYYY-MM-DD HH:MM*'
- en: '*YYYY-MM-DD HH:MM:SS*'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*YYYY-MM-DD HH:MM:SS*'
- en: '*YYYY-MM-DD HH:MM:SS.SSS*'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*YYYY-MM-DD HH:MM:SS.SSS*'
- en: '*YYYY-MM-DD***T***HH:MM*'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*YYYY-MM-DD***T***HH:MM*'
- en: '*YYYY-MM-DD***T***HH:MM:SS*'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*YYYY-MM-DD***T***HH:MM:SS*'
- en: '*YYYY-MM-DD***T***HH:MM:SS.SSS*'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*YYYY-MM-DD***T***HH:MM:SS.SSS*'
- en: '*HH:MM*'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*HH:MM*'
- en: '*HH:MM:SS*'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*HH:MM:SS*'
- en: '*HH:MM:SS.SSS*'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*HH:MM:SS.SSS*'
- en: '**now**'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**now**'
- en: '*DDDDDDDDDD*'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*DDDDDDDDDD*'
- en: In formats 5 through 7, the "T" is a literal character separating the date and
    the time, as required by [ISO-8601](http://www.w3c.org/TR/NOTE-datetime). Formats
    8 through 10 that specify only a time assume a date of 2000-01-01\. Format 11,
    the string 'now', is converted into the current date and time as obtained from
    the xCurrentTime method of the [sqlite3_vfs](c3ref/vfs.html) object in use. The
    'now' argument to date and time functions always returns exactly the same value
    for multiple invocations within the same [sqlite3_step()](c3ref/step.html) call.
    [Universal Coordinated Time (UTC)](http://en.wikipedia.org/wiki/Coordinated_Universal_Time)
    is used. Format 12 is the [Julian day number](http://en.wikipedia.org/wiki/Julian_day)
    expressed as an integer or floating point value. Format 12 might also be interpreted
    as a unix timestamp if it is immediately followed either the ['auto'](lang_datefunc.html#automod)
    or ['unixepoch'](lang_datefunc.html#jdmod) modifier.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在格式 5 到 7 中，“T” 是一个文字字符，用于分隔日期和时间，符合 [ISO-8601](http://www.w3c.org/TR/NOTE-datetime)
    的要求。格式 8 到 10 只指定时间，假定日期为 2000-01-01。格式 11 的字符串 'now' 被转换为从当前正在使用的 [sqlite3_vfs](c3ref/vfs.html)
    对象的 xCurrentTime 方法获得的当前日期和时间。在同一个 [sqlite3_step()](c3ref/step.html) 调用中，对日期和时间函数的
    'now' 参数总是返回完全相同的值。使用 [协调世界时（UTC）](http://en.wikipedia.org/wiki/Coordinated_Universal_Time)。格式
    12 是 [朱利安日期](http://en.wikipedia.org/wiki/Julian_day) 表示为整数或浮点值。如果紧随其后的是 ['auto'](lang_datefunc.html#automod)
    或 ['unixepoch'](lang_datefunc.html#jdmod) 修饰符，格式 12 也可以解释为 Unix 时间戳。
- en: 'Formats 2 through 10 may be optionally followed by a timezone indicator of
    the form "*[+-]HH:MM*" or just "*Z*". The date and time functions use UTC or "zulu"
    time internally, and so the "Z" suffix is a no-op. Any non-zero "HH:MM" suffix
    is subtracted from the indicated date and time in order to compute zulu time.
    For example, all of the following time-values are equivalent:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 格式 2 到 10 可能后跟形如 "*[+-]HH:MM*" 或只是 "*Z*" 的时区指示器。日期和时间函数内部使用 UTC 或 "zulu" 时间，因此
    "Z" 后缀是一个空操作。任何非零的 "HH:MM" 后缀都会从指定的日期和时间中减去，以计算 zulu 时间。例如，以下所有时间值都是等效的：
- en: '2013-10-07 08:23:19.120'
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '2013-10-07 08:23:19.120  '
- en: '2013-10-07T08:23:19.120Z'
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '2013-10-07T08:23:19.120Z  '
- en: '2013-10-07 04:23:19.120-04:00'
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '2013-10-07 04:23:19.120-04:00  '
- en: '2456572.84952685'
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '2456572.84952685  '
- en: In formats 4, 7, and 10, the fractional seconds value SS.SSS can have one or
    more digits following the decimal point. Exactly three digits are shown in the
    examples because only the first three digits are significant to the result, but
    the input string can have fewer or more than three digits and the date/time functions
    will still operate correctly. Similarly, format 12 is shown with 10 significant
    digits, but the date/time functions will really accept as many or as few digits
    as are necessary to represent the Julian day number.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '在格式 4、7 和 10 中，小数秒值 SS.SSS 可以有一个或多个小数点后的数字。示例中只显示三位数字，因为只有前三位数字对结果有意义，但输入字符串可以有少于或多于三位数的小数位数，日期/时间函数仍然可以正确操作。类似地，格式
    12 显示为 10 位有效数字，但日期/时间函数实际上接受表示朱利安日期号的任意多或少位数的数字。  '
- en: In all functions other than timediff(), the time-value (and all modifiers) may
    be omitted, in which case a time value of 'now' is assumed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '在除 timediff() 外的所有函数中，时间值（及所有修饰符）可以省略，此时假定时间值为 ''now''。  '
- en: 3\. Modifiers
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3\. 修饰符  '
- en: For all date/time functions other than timediff(), the time-value argument can
    be followed by zero or more modifiers that alter date and/or time. Each modifier
    is a transformation that is applied to the time-value to its left. Modifiers are
    applied from left to right; order is important. The available modifiers are as
    follows.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '对于除 timediff() 外的所有日期/时间函数，时间值参数可以跟随零个或多个修改器，这些修改器改变日期和/或时间。每个修改器是应用于其左侧时间值的转换。修改器从左到右应用；顺序很重要。可用的修改器如下。  '
- en: NNN days
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'NNN 天  '
- en: NNN hours
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'NNN 小时  '
- en: NNN minutes
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'NNN 分钟  '
- en: NNN seconds
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'NNN 秒  '
- en: NNN months
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'NNN 月  '
- en: NNN years
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'NNN 年  '
- en: ±HH:MM
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '±HH:MM  '
- en: ±HH:MM:SS
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '±HH:MM:SS  '
- en: ±HH:MM:SS.SSS
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '±HH:MM:SS.SSS  '
- en: ±YYYY-MM-DD
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ±YYYY-MM-DD
- en: ±YYYY-MM-DD HH:MM
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '±YYYY-MM-DD HH:MM  '
- en: ±YYYY-MM-DD HH:MM:SS
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '±YYYY-MM-DD HH:MM:SS  '
- en: ±YYYY-MM-DD HH:MM:SS.SSS
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '±YYYY-MM-DD HH:MM:SS.SSS  '
- en: ceiling
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**ceiling**  '
- en: floor
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**floor**  '
- en: start of month
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'start of month  '
- en: start of year
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'start of year  '
- en: start of day
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'start of day  '
- en: weekday N
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '周几 N  '
- en: unixepoch
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'unixepoch  '
- en: julianday
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'julianday  '
- en: auto
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'auto  '
- en: localtime
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'localtime  '
- en: utc
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'utc  '
- en: subsec
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'subsec  '
- en: subsecond
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'subsecond  '
- en: The first thirteen modifiers (1 through 13) add the specified amount of time
    to the date and time specified by the arguments to its left. The 's' character
    at the end of the modifier names in 1 through 6 is optional. The NNN value can
    be any floating point number, with an optional '+' or '-' prefix.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '前十三个修饰符（1 到 13）将指定的时间添加到左侧参数指定的日期和时间中。修饰符名字的结尾 ''s'' 字符在修饰符 1 到 6 中是可选的。NNN
    值可以是任意浮点数，带有可选的 ''+'' 或 ''-'' 前缀。  '
- en: The **time shift modifiers** (7 through 13) move the time-value by the number
    of years, months, days, hours, minutes, and/or seconds specified. An initial "+"
    or "-" is required for formats 10 through 13 but is optional for formats 7, 8,
    and 9\. The changes are applies from left to right. First the year is shifted
    by YYYY, then the month by MM, and then day by DD, and so forth. The timediff(A,B)
    function returns a time shift in format 13 that shifts the time-value B into A.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**时间偏移修饰符**（7 到 13）通过指定的年、月、日、小时、分钟和/或秒数移动时间值。格式 10 到 13 需要初始的 ''+'' 或 ''-''
    符号，但格式 7、8 和 9 则是可选的。更改从左到右应用。首先按 YYYY 移动年份，然后按 MM 移动月份，接着按 DD 移动日期，依此类推。函数 timediff(A,B)
    返回格式 13 中的时间偏移，将时间值 B 调整到 A。  '
- en: Because the length of a month or year changes from one month or year to the
    next, ambiguities can arise when shifting a date by months and/or years. For example,
    what is the date one year after 2024-02-29? Is it 2025-02-28 or 2025-03-01? Or
    what is the date that is two months after 2023-12-31? Is it 2024-02-29 or 2024-03-02?
    There is no consensus on how to resolve this ambiguity, so the "**ceiling**" and
    "**floor**" modifiers (14 and 15) are available to let the programmer decide.
    If the next modifier after a time shift is "ceiling", then any ambiguity in the
    date is resolved by choosing the later date. The "floor" modifier resolves ambiguities
    by resolving to the last day of the previous month. The default behavior is "ceiling".
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '由于每个月或年的长度从一个月或年变化到下一个月或年，通过月份和/或年份移动日期时可能会出现歧义。例如，2024-02-29 之后一年的日期是什么？是
    2025-02-28 还是 2025-03-01？或者是 2023-12-31 之后两个月的日期是什么？是 2024-02-29 还是 2024-03-02？如何解决这种歧义还没有共识，因此提供了
    "**ceiling**" 和 "**floor**" 修饰符（14 和 15）供程序员选择。如果时间偏移后的下一个修饰符是 "ceiling"，则通过选择较晚的日期来解决任何日期的歧义。
    "floor" 修饰符通过将日期解析为上个月的最后一天来解决歧义。默认行为是 "ceiling"。  '
- en: The "**start of**" modifiers (16 through 18) shift the date backwards to the
    beginning of the subject month, year or day.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '"**start of**" 修饰符（16 到 18）将日期向前移动到所在月份、年份或日的开头。'
- en: The "**weekday**" modifier advances the date forward, if necessary, to the next
    date where the weekday number is N. Sunday is 0, Monday is 1, and so forth. If
    the date is already on the desired weekday, the "weekday" modifier leaves the
    date unchanged.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '"**weekday**" 修饰符会将日期前进到下一个周几为 N 的日期，如果有必要的话。星期日为 0，星期一为 1，以此类推。如果日期已经是所需的周几，则
    "weekday" 修饰符不会改变日期。'
- en: The "**unixepoch**" modifier (20) only works if it immediately follows a time-value
    in the DDDDDDDDDD format. This modifier causes the DDDDDDDDDD to be interpreted
    not as a Julian day number as it normally would be, but as [Unix Time](http://en.wikipedia.org/wiki/Unix_time)
    - the number of seconds since 1970\. If the "unixepoch" modifier does not follow
    a time-value of the form DDDDDDDDDD which expresses the number of seconds since
    1970 or if other modifiers separate the "unixepoch" modifier from prior DDDDDDDDDD
    then the behavior is undefined.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '"**unixepoch**"（20）修饰符仅在紧跟格式为 DDDDDDDDDD 的时间值后面时起作用。此修饰符使 DDDDDDDDDD 被解释为 [Unix
    时间](http://en.wikipedia.org/wiki/Unix_time) - 自 1970 年以来的秒数。如果 "unixepoch" 修饰符未紧跟形如表示自
    1970 年以来秒数的 DDDDDDDDDD 的时间值，或者其他修饰符分隔 "unixepoch" 修饰符与前述 DDDDDDDDDD，则行为未定义。'
- en: The "**julianday**" modifier must immediately follow the initial time-value
    which must be of the form DDDDDDDDD. Any other use of the 'julianday' modifier
    is an error and causes the function to return NULL. The 'julianday' modifier forces
    the time-value number to be interpreted as a julian-day number. As this is the
    default behavior, the 'julianday' modifier is scarcely more than a no-op. The
    only difference is that adding 'julianday' forces the DDDDDDDDD time-value format,
    and causes a NULL to be returned if any other time-value format is used.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '"**julianday**" 修饰符必须紧跟格式为 DDDDDDDDD 的初始时间值后面。对 ''julianday'' 修饰符的任何其他使用都是错误的，并导致函数返回
    NULL。''julianday'' 修饰符强制将时间值数字解释为儒略日数。由于这是默认行为，''julianday'' 修饰符几乎只是一个空操作。唯一的区别在于添加
    ''julianday'' 强制使用 DDDDDDDDD 时间值格式，并在使用任何其他时间值格式时返回 NULL。'
- en: The "**auto**" modifier must immediately follow the initial time-value. If the
    time-value is numeric (the DDDDDDDDDD format) then the 'auto' modifier causes
    the time-value to interpreted as either a julian day number or a unix timestamp,
    depending on its magnitude. If the value is between 0.0 and 5373484.499999, then
    it is interpreted as a julian day number (corresponding to dates between -4713-11-24
    12:00:00 and 9999-12-31 23:59:59, inclusive). For numeric values outside of the
    range of valid julian day numbers, but within the range of -210866760000 to 253402300799,
    the 'auto' modifier causes the value to be interpreted as a unix timestamp. Other
    numeric values are out of range and cause a NULL return. The 'auto' modifier is
    a no-op for ISO 8601 text time-values. The "auto" modifier is designed to work
    with time-values even in cases where it is not known which time-value format is
    stored in the database file, or in cases where the same column stores time-values
    in different formats on different rows. The 'auto' modifier will automatically
    select the appropriate format. However, there is some ambiguity. Unix timestamps
    for the first 63 days of 1970 will be interpreted as julian day numbers. The 'auto'
    modifier is very useful when the dataset is guaranteed to contain no dates within
    that range, but should be avoided for applications that might make use of dates
    in the opening months of 1970.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '"**auto**" 修饰符必须紧跟在初始时间值后面。如果时间值是数字（格式为 DDDDDDDDDD），则 ''auto'' 修饰符会根据其大小将时间值解释为儒略日数或
    Unix 时间戳。如果值在 0.0 到 5373484.499999 之间，则被解释为儒略日数（对应日期范围为 -4713-11-24 12:00:00 到
    9999-12-31 23:59:59，包括边界）。对于超出有效儒略日数范围但在 -210866760000 到 253402300799 范围内的数值，''auto''
    修饰符会将其解释为 Unix 时间戳。其他数值超出范围且会导致 NULL 返回。对于 ISO 8601 文本时间值，''auto'' 修饰符不起作用。"auto"
    修饰符设计用于处理即使在数据库文件中未知存储哪种时间值格式，或者同一列在不同行中存储不同格式的时间值的情况下。''auto'' 修饰符会自动选择适当的格式。然而，存在一些歧义。1970
    年的前 63 天的 Unix 时间戳将被解释为儒略日数。当数据集保证不包含该范围内的日期时，''auto'' 修饰符非常有用，但在可能使用 1970 年开头几个月日期的应用中应避免使用。'
- en: The "**localtime**" modifier assumes the time-value to its left is in Universal
    Coordinated Time (UTC) and adjusts that time value so that it is in localtime.
    If "localtime" follows a time that is not UTC, then the behavior is undefined.
    The "**utc**" modifier is the opposite of "localtime". "utc" assumes that the
    time-value to its left is in the local timezone and adjusts that time-value to
    be in UTC. If the time to the left is not in localtime, then the result of "utc"
    is undefined.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '"**localtime**"修饰符假定其左侧的时间值为协调世界时（UTC），并调整该时间值以使其为本地时间。如果"localtime"跟在非UTC时间之后，则行为是未定义的。"utc"修饰符是"localtime"的反义。"utc"假定其左侧的时间值为本地时区，并调整该时间值为UTC。如果左侧的时间不在本地时间，则"utc"的结果是未定义的。'
- en: 'The "**subsecond**" modifier (which may be abbreviated as just "**subsec**")
    increases the resolution of the output for [datetime()](lang_datefunc.html#dttm),
    [time()](lang_datefunc.html#dttm), and [unixepoch()](lang_datefunc.html#uepch),
    and for the "%s" format string in [strftime()](lang_datefunc.html#strftm). The
    "subsecond" modifier has no effect on other date/time functions. The current implemention
    increases the resolution from seconds to milliseconds, but this might increase
    to a higher resolution in future releases of SQLite. When "subsec" is used with
    [datetime()](lang_datefunc.html#dttm) or [time()](lang_datefunc.html#dttm), the
    seconds field at the end is followed by a decimal point and one or more digits
    to show fractional seconds. When "subsec" is used with [unixepoch()](lang_datefunc.html#uepch),
    the result is a floating point value which is the number of seconds and fractional
    seconds since 1970-01-01. The "subsecond" and "subsec" modifiers have the special
    property that they can occur as the first argument to date/time functions (or
    as the first argument after the format string for strftime()). When this happens,
    the time-value that is normally in the first argument is understood to be "now".
    For example, a short cut to get the current time in seconds since 1970 with millisecond
    precision is to say:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '"**subsecond**"修饰符（也可以简写为"**subsec**"）可以增加[datetime()](lang_datefunc.html#dttm)、[time()](lang_datefunc.html#dttm)和[unixepoch()](lang_datefunc.html#uepch)的输出分辨率，以及[strftime()](lang_datefunc.html#strftm)中"%s"格式字符串的精度。该修饰符对其他日期/时间函数没有影响。当前的实现将分辨率从秒增加到毫秒，但是未来SQLite版本可能会进一步增加分辨率。当使用"subsec"修饰符与[datetime()](lang_datefunc.html#dttm)或[time()](lang_datefunc.html#dttm)时，末尾的秒字段后面跟有小数点和一个或多个数字，以显示分数秒。当使用"subsec"修饰符与[unixepoch()](lang_datefunc.html#uepch)时，结果是一个浮点值，表示自1970-01-01以来的秒数和分数秒。"subsecond"和"subsec"修饰符具有特殊属性，它们可以作为日期/时间函数的第一个参数（或作为strftime()的格式字符串后的第一个参数）。当这种情况发生时，通常在第一个参数中的时间值被理解为"now"。例如，获取具有毫秒精度的当前时间戳的快捷方法是：'
- en: SELECT unixepoch('subsec');
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SELECT unixepoch('subsec');
- en: 4\. Examples
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4\. 示例
- en: Compute the current date.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 计算当前日期。
- en: SELECT date();
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SELECT date();
- en: Compute the last day of the current month.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 计算当前月份的最后一天。
- en: SELECT date('now','start of month','+1 month','-1 day');
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SELECT date('now','start of month','+1 month','-1 day');
- en: Compute the date and time given a unix timestamp 1092941466.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 计算给定Unix时间戳1092941466的日期和时间。
- en: SELECT datetime(1092941466, 'unixepoch');
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SELECT datetime(1092941466, 'unixepoch');
- en: SELECT datetime(1092941466, 'auto'); -- Does not work for early 1970!
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SELECT datetime(1092941466, 'auto'); -- 早期1970年不起作用！
- en: Compute the date and time given a unix timestamp 1092941466, and compensate
    for your local timezone.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 计算给定Unix时间戳1092941466的日期和时间，并补偿您的本地时区。
- en: SELECT datetime(1092941466, 'unixepoch', 'localtime');
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SELECT datetime(1092941466, 'unixepoch', 'localtime');
- en: Compute the current unix timestamp.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 计算当前Unix时间戳。
- en: SELECT unixepoch();
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SELECT unixepoch();
- en: SELECT strftime('%s');
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SELECT strftime('%s');
- en: Compute the number of days since the signing of the US Declaration of Independence.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 计算自签署美国独立宣言以来的天数。
- en: SELECT julianday('now') - julianday('1776-07-04');
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SELECT julianday('now') - julianday('1776-07-04');
- en: 'Compute the number of seconds since a particular moment in 2004:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 计算自2004年特定时刻以来的秒数：
- en: SELECT unixepoch() - unixepoch('2004-01-01 02:34:56');
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SELECT unixepoch() - unixepoch('2004-01-01 02:34:56');
- en: Compute the date of the first Tuesday in October for the current year.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 计算当年10月第一个星期二的日期。
- en: SELECT date('now','start of year','+9 months','weekday 2');
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SELECT date('now','start of year','+9 months','weekday 2');
- en: 'Compute the time since the unix epoch in seconds with millisecond precision:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 计算自Unix纪元以来以毫秒为精度的秒数：
- en: SELECT (julianday('now') - 2440587.5)*86400.0;
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SELECT (julianday('now') - 2440587.5)*86400.0;
- en: SELECT unixepoch('now','subsec');
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SELECT unixepoch('now','subsec');
- en: 'Compute how old Abraham Lincoln would be if he were still alive today:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 计算亚伯拉罕·林肯如果今天还活着会多大年纪：
- en: SELECT timediff('now','1809-02-12');
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SELECT timediff('now','1809-02-12');
- en: 5\. Caveats And Bugs
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5\. 警告与错误
- en: The computation of local time depends heavily on the whim of politicians and
    is thus difficult to get correct for all locales. In this implementation, the
    standard C library function localtime_r() is used to assist in the calculation
    of local time. The localtime_r() C function normally only works for years between
    1970 and 2037\. For dates outside this range, SQLite attempts to map the year
    into an equivalent year within this range, do the calculation, then map the year
    back.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本地时间的计算严重依赖于政治家的心情，因此很难确保所有地区的正确性。在这个实现中，使用标准的C库函数localtime_r()来辅助计算本地时间。localtime_r()
    C函数通常只适用于1970年到2037年之间的年份。对于超出此范围的日期，SQLite尝试将年份映射到此范围内的等效年份，进行计算，然后再映射回原来的年份。
- en: These functions only work for dates between 0000-01-01 00:00:00 and 9999-12-31
    23:59:59 (julian day numbers 1721059.5 through 5373484.5). For dates outside that
    range, the results of these functions are undefined.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数仅适用于0000-01-01 00:00:00到9999-12-31 23:59:59之间的日期（儒略日号1721059.5到5373484.5）。超出此范围的日期，这些函数的结果是未定义的。
- en: Non-Vista Windows platforms only support one set of DST rules. Vista only supports
    two. Therefore, on these platforms, historical DST calculations will be incorrect.
    For example, in the US, in 2007 the DST rules changed. Non-Vista Windows platforms
    apply the new 2007 DST rules to all previous years as well. Vista does somewhat
    better getting results correct back to 1986, when the rules were also changed.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 非Vista版本的Windows平台仅支持一组夏令时规则。Vista仅支持两组。因此，在这些平台上，历史夏令时计算将不正确。例如，在美国，2007年夏令时规则发生了变化。非Vista版本的Windows平台将新的2007年夏令时规则应用到所有以前的年份。Vista在回溯到1986年时做得比较好，当时规则也发生了变化。
- en: All internal computations assume the [Gregorian calendar](http://en.wikipedia.org/wiki/Gregorian_calendar)
    system. They also assume that every day is exactly 86400 seconds in duration;
    no leap seconds are incorporated.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 所有内部计算都假设是[格里高利历](http://en.wikipedia.org/wiki/Gregorian_calendar)系统。它们还假设每天确切地是86400秒长，不考虑闰秒。
